<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kernel CFI failure实例分析</title>
      <link href="/kernel-cfi-failure-analysis.html"/>
      <url>/kernel-cfi-failure-analysis.html</url>
      
        <content type="html"><![CDATA[<p>最近压测碰到一例内核死机, 提示CFI failure.</p><p>先了解下CFI:</p><blockquote><p>Control-flow integrity (CFI) is a technique used to reduce the ability to redirect the execution of a program’s code in attacker-specified ways. </p></blockquote><p>字面直译CFI就是控制流完整性，用来减少通过修改代码流程来进行攻击的风险。</p><blockquote><p>The goal behind CFI is to try to ensure that indirect calls go to the expected addresses and that the return addresses are not changed.</p></blockquote><p>具体说就是用来保护indirect (function) call这种code flow的.</p><blockquote><p>Function pointers are used for indirect function calls, which are different than direct function calls because the address of the call site is not stored in the (non-writable) kernel text. Instead, the address for the call site is fetched from memory, placed into a register, and the call is made via that value. If an attacker can change the memory, they can control where the call actually ends up going. That is the “forward edge” of an indirect call, while the return address on the stack is the “backward edge” of the call. Either can be used by an attacker to redirect the code flow.</p></blockquote><p>这个indirect call就是函数指针了，有两个可攻击的点：一个是forward edge(goto expected address)，一个是backward edge(return address)。</p><blockquote><p>The writable function pointers can only exist in the kernel’s heap and stack due to the earlier tightening of the access to the rest of memory. Function pointers can be stored in the heap or on the stack. It turns out that making the stack read-only “makes it very hard to use”, Cook said with a chuckle.</p></blockquote><p>函数指针在kernel heap or stack上, 这些区域都可写，不像direct call那样都在只读区。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>kernel 5.x, crash stack:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 7322.456761] Kernel panic - not syncing: CFI failure (target: 0x1ffffffff):</span><br><span class="line">[...]</span><br><span class="line">[ 7322.485335] Call trace:</span><br><span class="line">[ 7322.488711]  dump_backtrace.cfi_jt+0x0/0x8</span><br><span class="line">[ 7322.493730]  show_stack+0x28/0x38</span><br><span class="line">[ 7322.497969]  dump_stack_lvl+0x84/0xcc</span><br><span class="line">[ 7322.502560]  panic+0x180/0x444</span><br><span class="line">[ 7322.506537]  __cfi_slowpath_diag+0x1e4/0x230</span><br><span class="line">[ 7322.511733]  dma_buf_unmap_attachment+0x108/0x144</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>objdump定位到<code>dma_buf_unmap_attachment+0x108</code>如下882行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; drivers/dma-buf/dma-buf.c:882</span><br><span class="line">ffffffc008b973ac: 97df944b      bl      0xffffffc00837c4d8 &lt;__cfi_slowpath_diag&gt;</span><br><span class="line">ffffffc008b973b0: f94003e8      ldr     x8, [sp]</span><br><span class="line">ffffffc008b973b4: f9400fa1      ldr     x1, [x29, #24]</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">875</span> <span class="type">static</span> <span class="type">void</span> __unmap_dma_buf(<span class="keyword">struct</span> dma_buf_attachment *attach,</span><br><span class="line"><span class="number">876</span>                             <span class="keyword">struct</span> sg_table *sg_table,</span><br><span class="line"><span class="number">877</span>                             <span class="keyword">enum</span> dma_data_direction direction)</span><br><span class="line"><span class="number">878</span> &#123;</span><br><span class="line"><span class="number">879</span>         <span class="comment">/* uses XOR, hence this unmangles */</span></span><br><span class="line"><span class="number">880</span>         mangle_sg_table(sg_table);</span><br><span class="line"><span class="number">881</span></span><br><span class="line"><span class="number">882</span>         attach-&gt;dmabuf-&gt;ops-&gt;unmap_dma_buf(attach, sg_table, direction); <span class="comment">//tj: here</span></span><br><span class="line"><span class="number">883</span> &#125;</span><br></pre></td></tr></table></figure><p>啊，这是一个indirect function call。这为啥挂了，看下kernel cfi code:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">26</span> <span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">handle_cfi_failure</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">27 &#123;</span><br><span class="line"><span class="number">28</span>         <span class="keyword">if</span> (IS_ENABLED(CONFIG_CFI_PERMISSIVE))</span><br><span class="line"><span class="number">29</span>                 WARN_RATELIMIT(<span class="number">1</span>, <span class="string">&quot;CFI failure (target: %pS):\n&quot;</span>, ptr);</span><br><span class="line"><span class="number">30</span>         <span class="keyword">else</span></span><br><span class="line"><span class="number">31</span>                 panic(<span class="string">&quot;CFI failure (target: %pS)\n&quot;</span>, ptr); <span class="comment">//tj: here</span></span><br><span class="line"><span class="number">32</span> &#125;</span><br></pre></td></tr></table></figure><p>这个target 0x1ffffffff是啥？简单跟下：</p><p>我们配了MODULES：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __cfi_slowpath_diag(<span class="type">uint64_t</span> id, <span class="type">void</span> *ptr, <span class="type">void</span> *diag)</span><br><span class="line">&#123;</span><br><span class="line">        ___cfi_slowpath_diag(id, ptr, diag);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__cfi_slowpath_diag);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* !CONFIG_MODULES */</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __nocfi ___cfi_slowpath_diag(<span class="type">uint64_t</span> id, <span class="type">void</span> *ptr, <span class="type">void</span> *diag)</span><br><span class="line">&#123;</span><br><span class="line">        cfi_check_fn fn = find_check_fn((<span class="type">unsigned</span> <span class="type">long</span>)ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (likely(fn))</span><br><span class="line">                fn(id, ptr, diag);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* Don&#x27;t allow unchecked modules */</span></span><br><span class="line">                handle_cfi_failure(ptr); <span class="comment">//tj: here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去这个<code>ptr</code>(&#x3D;0x1ffffffff)不是一个function, so走到了unchecked modules分支，rt? 内存出问题了？ 不应该。。。看栈是通过ioctl下来的，所以可能是用户态触发了一个非法请求，暂不论，我们看看如何在内核态规避这个问题。</p><blockquote><p>To assist in debugging CFI failures, enable CONFIG_CFI_PERMISSIVE, which prints out a warning instead of causing a kernel panic. Permissive mode must not be used in production.</p></blockquote><p>使能内核配置<code>CONFIG_CFI_PERMISSIVE</code>，不过我试了下竟然起不来。。。什么鬼，没跟了，而且一开全开似乎不妥，有没有单一文件跳过CFI的？答案是有的，CFI提交日志写道：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit cf68fffb66d60d96209446bfc4a15291dc5a5d41</span><br><span class="line">Author: Sami Tolvanen &lt;samitolvanen@google.com&gt;</span><br><span class="line">Date:   Thu Apr 8 11:28:26 2021 -0700</span><br><span class="line"></span><br><span class="line">    add support for Clang CFI</span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    CFI checking can be disabled in a function with the __nocfi attribute.</span><br><span class="line">    Additionally, CFI can be disabled for an entire compilation unit by</span><br><span class="line">    filtering out CC_FLAGS_CFI.</span><br></pre></td></tr></table></figure><p>这个帅啊，可以函数禁用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/include/linux/compiler-clang.h b/include/linux/compiler-clang.h</span><br><span class="line">index d217c382b02d.<span class="number">.6</span>de9d0c9377e <span class="number">100644</span></span><br><span class="line">--- a/include/linux/compiler-clang.h</span><br><span class="line">+++ b/include/linux/compiler-clang.h</span><br><span class="line">@@ <span class="number">-61</span>,<span class="number">3</span> +<span class="number">61</span>,<span class="number">5</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> __has_feature(shadow_call_stack)</span></span><br><span class="line"> <span class="meta"># <span class="keyword">define</span> __noscs       __attribute__((__no_sanitize__(<span class="string">&quot;shadow-call-stack&quot;</span>)))</span></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> __nocfi                __attribute__((__no_sanitize__(<span class="string">&quot;cfi&quot;</span>)))</span></span><br></pre></td></tr></table></figure><p>注意到没，<code>___cfi_slowpath_diag()</code>就有这个属性。</p><p>加上即可：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">875 static void __nocfi __unmap_dma_buf(struct dma_buf_attachment *attach,</span><br></pre></td></tr></table></figure><p>反汇编看了下，确是没了，完美。不过上层的问题不能老让kernel修吧。。。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://en.wikipedia.org/wiki/Control-flow_integrity">https://en.wikipedia.org/wiki/Control-flow_integrity</a></li><li><a href="https://lwn.net/Articles/810077/">https://lwn.net/Articles/810077/</a></li><li><a href="https://outflux.net/slides/2020/lca/cfi.pdf">https://outflux.net/slides/2020/lca/cfi.pdf</a></li><li><a href="https://source.android.com/docs/security/test/cfi">https://source.android.com/docs/security/test/cfi</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cfi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux kernel DRM overview</title>
      <link href="/linux-kernel-drm-overview.html"/>
      <url>/linux-kernel-drm-overview.html</url>
      
        <content type="html"><![CDATA[<p>I have not touched Linux DRM before, although I’m very familiar with BSP. Now I need to fix display-related issues due to OpenHarmony porting, so let me provide an overview of this.</p><p>DRM(Direct Rendering Manager) was initially designed for accessing GPU hardware, but it has expanded to cover more functions previously handled by userpace, such as GEM(Graphics Execution Manager) and KMS(kernel mode-setting).</p><p>The software architecture is as follows:</p><p><img src="/images/2024/05/drm-arch.png"></p><p>There are two parts: DRM core and DRM driver(GEM + KMS). Access the DRM via userspace libdrm to avoid duplicate code.</p><p>GEM is the memory managerment in DRM. For example, userspace can use GEM to request memory to store a framebuffer or data required by GPU.</p><p>KMS mode includes screen resolution, color depth and refresh rate.</p><p>The display output pipeline is as follows:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fb -&gt;plane</span><br><span class="line">      \</span><br><span class="line">     crtc -&gt; encoder -&gt; bridge (optional) -&gt; connector -&gt; display device (monitor, laptop panel...)</span><br><span class="line">      /</span><br><span class="line">fb -&gt;plane</span><br></pre></td></tr></table></figure><ul><li>Framebuffer(fb): Includes pixel data for a single frame or image to be displayed on the screen.</li><li>Plane: Image source, framebuffer feed.</li><li>CRTC: Read pixel data from different planes and blends them together.</li><li>Connector: Phyical connector, like VGA, HDMI, DisplayPort(DP).</li><li>Encoder: Encodes the signal from CRTC for the connector.</li><li>Panel: The actual screen that diplays the image. Panel types include LCD(IPS, VA, TN) and OLED.</li><li>Monitor: Panel plus other components(power supply, connect port, etc.).</li><li>Bridge: Convert signals, such as MIPI DSI to eDP.</li></ul><p>We can use libdrm&#x2F;modetest to test KMS. The DRM device is <code>/dev/dri/cardX</code>, the code is in <code>drivers/gpu/drm</code>.</p><p>OK, that’s all. No need to read kernel documents about DRM now, the wiki is enough.</p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager">https://en.wikipedia.org/wiki/Direct_Rendering_Manager</a></li><li>Rockchip Linux SDK</li></ul>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> drm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的PC组装升级记</title>
      <link href="/upgrade-my-custom-build-server-amd-based.html"/>
      <url>/upgrade-my-custom-build-server-amd-based.html</url>
      
        <content type="html"><![CDATA[<p>18年左右为了编译Android组装了一台PC，AMD AM4，2K，主要配置如下：</p><ul><li>主板：技嘉 GA-A320M-S2H (rev. 1.x)</li><li>CPU ：AMD Ryzen 3 2200G (盒装)   1100 (+mb)</li><li>内存：威刚 DDR4 2400MHz 8G        439</li><li>硬盘：金泰克 SSD 480G             400</li><li>主机：大水牛&#x2F;300W                 200</li></ul><p>最近试试编译OH4.0花了6h40m：</p><p><img src="/images/2024/05/old-oh-build-cost-time.png"></p><p>这速度，能急死，升级下了，一开始只是想升级下CPU，到后面越升越多：）</p><p>先看了下主板CPU support列表, 好家伙AM4支持的是真多，2200G:</p><blockquote><p>AMD Ryzen 3 2200G 4C&#x2F;4T 3.5GHz &#x2F; 3.7GHz 2MB 4MB 1100 MHz Raven Ridge 14nm B0 45-65W F10</p></blockquote><p>R3 2200G只有4个核，选个6个的吧，太高了怕带不动。</p><p>最后看了BIOS版本大多到F55支持的比较多。因为用来编译做server用，集显就不是必选了，而且比非集显相对也较贵, 而且这主板版本供电貌似稍弱，最后看上了R5 5500：</p><blockquote><p>AMD Ryzen 5 5500 6C&#x2F;12T 3.6GHz &#x2F; 4.2GHz 3MB 16MB N&#x2F;A Cezanne 7nm A0 65W F55</p></blockquote><p>7nm工艺，jd自yin盒装559，jdcard还有100，449拿下，后面在xianyu把旧的还卖了220, 也就是花了200+升级了CPU，哈～双。</p><p>下来就是买个显卡，能点亮就行了, 也就装机or偶尔用下，tao个二手便宜的吧, 不需要额外供电那种，一开始买的昂达R5 220 1GB，100，但是大晚上的能听到zizi声音, 强迫症，受不了退了，换了个七彩虹GT710 1G, 这个帅，静音，110。</p><p>内存看OH官方推荐16GB+：</p><blockquote><p>Ubuntu环境要求</p><p>   Ubuntu18.04及以上版本，X86_64架构，内存推荐16 GB及以上。</p><p>   Ubuntu系统的用户名不能包含中文字符。</p></blockquote><p>我这8G也升下吧，而且是2400的频，看了看这个主板内存说明:</p><blockquote><p>   1.2个DDR4 DIMM插槽，可支持高达32 GB<br>   2.支持双通道内存技术<br>   3.支持 DDR4 3200(O.C.)&#x2F;2933(O.C.)&#x2F;2667*&#x2F;2400&#x2F;2133 MHz<br>     * 是否支持此规格依CPU而定。<br>   4.支持ECC Un-buffered DIMM 1Rx8&#x2F;2Rx8内存(non-ECC模式运行)<br>   5.支持non-ECC Un-buffered DIMM 1Rx8&#x2F;2Rx8&#x2F;1Rx16内存<br>   6.支持Extreme Memory Profile (XMP)内存</p></blockquote><p>最大支持3200, 不过要O.C.(OverClocking), 看了看主流条子说要主板BIOS开启XMP，我这主板支持阿，大不了退到2400，搞一个试试，考虑到兼容性还是买了威刚，万紫千红版，晒单返现249 - 10 &#x3D; 239拿下，回来插上去直接上了3200，哈～，都不用动BIOS, <code>sudo dmidecode --type 17</code>如：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Speed: 3200 MT/s</span><br><span class="line">Manufacturer: A-DATA Technology</span><br><span class="line">Part Number:                     </span><br><span class="line">Rank: 2</span><br><span class="line">Configured Memory Speed: 3200 MT/s</span><br></pre></td></tr></table></figure><p>这个大水牛机箱外观还凑合，电源上置。偶尔搜到一个帖子，发现Tt启航者A1颇具美感（尤其是外露下置电源 BT 500W），侧拉钢化玻璃，199，不过F1亚克力侧版149更具性价比，据说钢化玻璃侧板固定要像A1这样才安全些，所以类似平头哥的款式就没选了，而且启航者这名字听上去感觉也更好点，哈哈。 </p><p>原来的电源外观是真不行，搭这个机箱不太配，BT 500W官方已经不生产了。。。不过，竟给我发现一个官方好物：Tt Smart G 550W 金牌&#x2F;全模组在售，优惠价只要249，赚了哈感觉。 </p><p>这个主板还支持M.2 SSD:</p><blockquote><p>1个M.2插座 (支持Socket 3，M key，type 2242&#x2F;2260&#x2F;2280&#x2F;22110 SATA 及 PCIe x4&#x2F;x2* SSD)</p></blockquote><p>5.1 闲着没事干，看中了七彩虹 CN600 PRO M.2(NVMe)，就装个Ubuntu，code放原来固态上，挂到&#x2F;home，256G够了 149，不错。颗粒好像是国产，不过七彩虹也算是个品牌了，图个便宜，坏了再换个就是了，就不需要swap分区了。</p><p>算下来花了大概1000的样子。</p><p>一开始只换的CPU，起不来，后来把显卡接上，提示如下：</p><p><img src="/images/2024/05/bios-hint-when-new-cpu-installed.png"></p><p>原来是检测到new cpu，让我选Y or N，先N不过，后Y pass了。</p><p>系统Ubuntu 18.04原先一直装不上，最后装的是18.08，现在官方OH也支持20.04，就试了一把，我去，20.04可以装拉，好好。</p><p>最后只需要2h30m，速度提升60%，哈～</p><p><img src="/images/2024/05/new-oh-build-cost-time.png"></p><p>最后来张美图：</p><p><img src="/images/2024/05/tj-pc.jpeg"></p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://docs.openharmony.cn/pages/v4.0/zh-cn/device-dev/quick-start/quickstart-pkg-prepare.md">https://docs.openharmony.cn/pages/v4.0/zh-cn/device-dev/quick-start/quickstart-pkg-prepare.md</a></li><li><a href="https://www.gigabyte.cn/Motherboard/GA-A320M-S2H-rev-1x/sp#sp">https://www.gigabyte.cn/Motherboard/GA-A320M-S2H-rev-1x/sp#sp</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I am back!</title>
      <link href="/convert-typecho-to-hexo.html"/>
      <url>/convert-typecho-to-hexo.html</url>
      
        <content type="html"><![CDATA[<p>你没看错，我回来了，哈～</p><p>3月就收到了某云续费通知，好家伙，直接一年500人民币，啥优惠都没有，原来也就200左右的样子。有点入坑的赶脚，不过对我别想。。。不用了，直接静态。</p><p>其实之前就做过功课, typecho可以转hexo，github有脚本直接转，评论啥的不care，刚好Maupassant主题也有，风格基本没变。直接放github了，国内的其他都试过不好使，要不有坑。</p><p>一直没搞是因为最近工作变故，一直在瞎忙，回来后不想搞了，LP也不让：）</p><p>最近PRJ基本收尾了，轻松阿，正好LP不在jia，来搞一把，没啥坑。</p><p>hexo d用ssh方式，https要啥token，没试了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">114 deploy:</span><br><span class="line">115   type: git</span><br><span class="line">116   repo: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">117   branch: master</span><br></pre></td></tr></table></figure><p>域名解析用CNAME即可，不需要用IP。</p><p>About页面直接hexo new page即可。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/verifying-your-custom-domain-for-github-pages">https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/verifying-your-custom-domain-for-github-pages</a></li><li><a href="https://hexo.io/zh-cn/docs/writing.html">https://hexo.io/zh-cn/docs/writing.html</a></li><li><a href="https://github.com/tufu9441/maupassant-hexo">https://github.com/tufu9441/maupassant-hexo</a></li><li><a href="https://cloud.tencent.com/developer/article/1158747">https://cloud.tencent.com/developer/article/1158747</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenHarmony适配后图标拖拽卡屏问题回顾</title>
      <link href="/review-freezing-issue-when-drag-icon-after-ohos-adaption.html"/>
      <url>/review-freezing-issue-when-drag-icon-after-ohos-adaption.html</url>
      
        <content type="html"><![CDATA[<p>在展讯T606上完成基础OpenHarmony V3.2.2适配后，发现桌面拖拽图标竟然不行，屏幕会卡住，我去，这又是什么坑。</p><p>从产品搭建开始已经搞了快3月了，坑是真多，也有点累，加上这个现象看上去像是上层的问题，顶多到框架，不是我的菜，我也不想跟了，就交给一个框架侧同事帮忙看看。</p><p>随后提到udid获取不到，其实我是想把这个问题丢出去的。。。好吧，还是要我来，那就跟吧，都等着出版本。</p><p>这个问题其实是因为适配时没配置<code>ohos.boot.sn</code>导致的，刚刚适配谁会去配置序列号？主要原因就是拖拽图标这个行为会触发粘贴板服务(PasteboardService)，而这个服务正常working依赖一个叫deviceprofile的sa(system ability)，id是6001，而这个sa赖上sn了。</p><p>大致调用流程如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">_________________________________________________________________</span><br><span class="line">| PasteboardService (GetClipPlugin) -&gt; GetDeviceProfileService  |</span><br><span class="line">|_______________________________________________________________|</span><br><span class="line">__________________|_____________</span><br><span class="line">| SystemAbilityManagerProxy    |</span><br><span class="line">|______________________________|</span><br><span class="line">__________________|___________________________________</span><br><span class="line">| SystemAbilityManager: CheckSystemAbility(6001)     |</span><br><span class="line">|____________________________________________________|</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细分析可以参考微信公众号原文：<a href="https://mp.weixin.qq.com/s?__biz=MzkwNjI5MjAxNg==&mid=2247484709&idx=1&sn=7ac4ee708bf0a5f24186ad0b6ac734d1&chksm=c14213fc9f66b41f5d66b93f14051a47615dcd1af1233e5852b10c9c1140fedb3934e76517f8&scene=126&sessionid=1704849209#rd">OHOS适配实战 | 图标拖拽卡屏分析与解决</a></p>]]></content>
      
      
      <categories>
          
          <category> ohos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Source Insight 自定义解析</title>
      <link href="/how-to-fix-parse-too-complex-in-source-insight.html"/>
      <url>/how-to-fix-parse-too-complex-in-source-insight.html</url>
      
        <content type="html"><![CDATA[<p>si就不用介绍了吧，左手vi右手si，你都得有，想用啥用啥:)</p><p>话说在看erofs-utils时，偶尔发现一个问题，就是<code>struct erofs_inode</code>解析不到，找不到这个定义：</p><p><img src="https://tjtech.me/usr/uploads/2023/11/3128121757.png#center" alt="si-sym-not-found-for-erofs_inode.png"></p><p>好吧，先问了问手上能用的鸡皮踢:</p><p><img src="https://tjtech.me/usr/uploads/2023/11/2939323841.png#center" alt="openai-answer-si-cannot-parse-struct.png"></p><p>感觉没啥用，或许是prompt不对？不聊了，次数受限，直接bing搜了：</p><p><img src="https://tjtech.me/usr/uploads/2023/11/130286877.png#center" alt="search-si-cannot-parse-struct-using-bing.png"></p><p>第一栏就看到了Fixing “Parse-Too-Complex”又是官方doc，感觉很香啊，打开看看：</p><blockquote><p>If Source Insight encounters too many problems trying to parse a file, the symbol window at the left side of the source window will say “Parse Too Complex” instead of listing the symbols in the file.</p></blockquote><p>我是没碰到这个情况。</p><blockquote><p>The Parse-too-complex can often be handled by using the Edit Condition dialog, or defining Source Insight preprocessor macros (token macros).</p></blockquote><p>有两个修复方法，一个是Edit Condition，是给<code>#ifdef</code>用的，我这儿应该不是，另一个是添加定义token macros：</p><blockquote><p>defining a token macro in the c.tom file located in your Documents\Source Insight 4.0</p></blockquote><p>这是for 4.0，我是3.5:</p><p><img src="https://tjtech.me/usr/uploads/2023/11/794098412.png#center" alt="si-version.png"></p><p>直接site根目录浏览了一把没找到对应入口，好吧，先看看怎么用：</p><blockquote><p><strong>Token Macro Syntax</strong><br>A token macro file consists of token macros, one per line. The format of a token macro is:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">macroname    &lt;no text here means macro is a no-op&gt;</span><br><span class="line">macroname    substituted text here</span><br><span class="line">macroname(parameter list)    substituted text with parameter names</span><br><span class="line">macroname(parameter)    text##parameter // concatenates text </span><br><span class="line">; comments begin with a semicolon</span><br></pre></td></tr></table></figure><p>Some examples of token macros:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">MyStructure(sname)    struct sname</span><br><span class="line">NoOperation</span><br><span class="line">BuildName(name1, name2)    name1##name2</span><br></pre></td></tr></table></figure></blockquote><p>再来看internal.h，留意si符号窗口按行排序时是这样的：</p><p><img src="https://tjtech.me/usr/uploads/2023/11/1668261980.png#center" alt="si-parse-erofs-internal-h.png"></p><p>啊，貌似宏<code>EROFS_FEATURE_FUNCS</code>有嫌疑，红框处也就是它后面的<code>EROFS_I_EA_INITED/EROFS_I_Z_INITED</code>也找不到定义。</p><p>那就照样子改句子，我的文档下也有个C.tom文件哈：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\tj\Documents\Source Insight\C.tom</span><br></pre></td></tr></table></figure><p>直接打开看看，里面还有内容，尾巴添加：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; erofs-utils</span><br><span class="line">EROFS_FEATURE_FUNCS</span><br></pre></td></tr></table></figure><p>重新打开si，进入Project-&gt;Synchronize Files，勾选<code>Force all files to be re-parsed</code>，点击OK，哇，I’m back, 符号窗口和颜色都有了，哈皮:)</p><p><img src="https://tjtech.me/usr/uploads/2023/11/1932076558.png#center" alt="si-parsed-struct-erofs-inode.png"></p><p>Done。</p><p>[参考文档]</p><ul><li><p><a href="https://www.sourceinsight.com/doc/v4/userguide/Manual/Concepts/Fixing_Parse-Too-Complex.htm">https://www.sourceinsight.com/doc/v4/userguide/Manual/Concepts/Fixing_Parse-Too-Complex.htm</a></p></li><li><p><a href="https://www.sourceinsight.com/doc/v4/userguide/Manual/Concepts/Preprocessor_Token_Macros.htm#XREF_62419_Preprocessor_Token">https://www.sourceinsight.com/doc/v4/userguide/Manual/Concepts/Preprocessor_Token_Macros.htm#XREF_62419_Preprocessor_Token</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sourceinsight </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转：拥抱鸿蒙 - 在展讯T606平台上的探索与实践</title>
      <link href="/adapt-ohos-for-mali-g57-on-sprd-t606.html"/>
      <url>/adapt-ohos-for-mali-g57-on-sprd-t606.html</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://mp.weixin.qq.com/s/yi863YqPkFq7VsA0S1j8VA">https://mp.weixin.qq.com/s/yi863YqPkFq7VsA0S1j8VA</a></p><p>公众号内容主要是关于GPU(Mali-G57)的开源方案(mesa)适配, OpenHarmony版本是3.2.2，包括了用户层的mesa库和内核层的驱动(panfrost)。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">       ____________</span><br><span class="line">       |___app____|</span><br><span class="line">   _________|______________</span><br><span class="line">   |__oh opengl_wrapper__|</span><br><span class="line">   ________|______________</span><br><span class="line">   |_____mesa library____|</span><br><span class="line">           |</span><br><span class="line">-----------|----------------</span><br><span class="line">   ________|______________</span><br><span class="line">   |___mesa GPU driver___|</span><br><span class="line">   ________|____________</span><br><span class="line">   |____GPU Hardware___|</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>btw，图形这块之前基本没怎么搞过，这是第一次，也算是一个积累吧。</p>]]></content>
      
      
      <categories>
          
          <category> ohos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mesa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>展讯平台 OpenHarmony 3.2.2 适配基础盘点</title>
      <link href="/essential-inventory-of-adaption-for-unisoc-platform-androidt-based.html"/>
      <url>/essential-inventory-of-adaption-for-unisoc-platform-androidt-based.html</url>
      
        <content type="html"><![CDATA[<p>花了三个月，从零开始搭建产品，终于在展讯平台上适配了 OH 3.2.2, 是基于 Android 13&#x2F;Kernel 5.4 的版本做适配。前期当然是亮屏，显示和 GPU 适配最费事，还有 hdc 调试功能，不然 hilog 都抓不到，还搞啥，虽然 Kernel 有 USB 转串的特性。</p><p>这里简单韶韶有哪些事情，先聊聊 Android 13：首先是动态分区，OH 就不支持。对于 A&#x2F;B 分区 OH 是支持的，还有个 vbmeta，如何适配比较合适？另外，我们用的是 Kernel 5.4，不是官方的 5.10。还有 GKI，一堆 ko，Android 专门为此写了个 modprobe，OH 压根就不支持这个命令，只支持 insmod, 而在线 sh 几乎没法调。</p><p>对于刚接触 OH 的同学（比如我），要熟悉它的方方面面，比如如何编译，如何写编译脚本，如何抓log，反正 Android 那一套基本都要会，不然怎么调试，让你整个模块，你都不知道从哪入手。好在 OH 和 Android 多少还是有些相似的，所以不会有那种完全陌生的赶脚。但是，我只想说一句，任何东西都是说起来容易!</p><p>适配的重点除了 modem 侧的东东(我不懂，我也不想懂，除非。。。)，那就是显示了，需要 debug drm driver 和 OH render_service。</p><p>GPU 我们是 mali-g57, 是一种新架构，5.4 内核不支持，官方的 5.10 也不支持，自带的 mesa3d 库也不支持。理论上 mesa3d 编译出来应该就能用，可我们偏偏遇到了bug，我想说 mesa3d 真的不好调, 一堆 so 和中间文件，谁调谁知道，和 Kernel 不是一个风格。</p><p>相对困难一点的我觉得就是 HDI gfx 图形加速适配了，这玩意要下点功夫。</p><p>最后，吐槽下 OH 那些提交日志，和 Linux 内核比起来，都不能入眼，不知道是不是有意的，这都给新平台适配带来一些麻烦，当然能力强的人除外！</p>]]></content>
      
      
      <categories>
          
          <category> ohos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sprd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速移植 OpenHarmony Linux 内核到三方 ARM64 平台</title>
      <link href="/porting-openharmony-linux-kernel-to-3rd-party-chip.html"/>
      <url>/porting-openharmony-linux-kernel-to-3rd-party-chip.html</url>
      
        <content type="html"><![CDATA[<p>官方的文档我觉得是最终的产品形态，一个新品在开发移植过程中不太可能一步到位，尤其是非官方支持版本，所以多少还是要拆分下。</p><h2 id="准备整体构建环境"><a href="#准备整体构建环境" class="headerlink" title="准备整体构建环境"></a>准备整体构建环境</h2><p>1 准备代码</p><p>理论上path不是问题，只要找到就好。这里就把要用的三方内核，比如我的是Linux-5.4就放到Linux目录下。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tj@ubuntu:~/code/oh-3.2.2/kernel/linux$ ls</span><br><span class="line">build  config  linux-5.10  linux-5.4  patches  third_party  vendor</span><br></pre></td></tr></table></figure><p>2 配置ARM64编译环境</p><p>check build&#x2F;kernel.mk:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">31 CLANG_HOST_TOOLCHAIN := <span class="variable">$(OHOS_BUILD_HOME)</span>/prebuilts/clang/ohos/linux-x86_64/llvm/bin</span><br><span class="line">32 KERNEL_HOSTCC := <span class="variable">$(CLANG_HOST_TOOLCHAIN)</span>/clang</span><br><span class="line">33 KERNEL_PREBUILT_MAKE := make</span><br><span class="line">34 CLANG_CC := <span class="variable">$(CLANG_HOST_TOOLCHAIN)</span>/clang</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">39 <span class="keyword">else</span> <span class="keyword">ifeq</span> (<span class="variable">$(KERNEL_ARCH)</span>, arm64)</span><br><span class="line">40     KERNEL_TARGET_TOOLCHAIN := <span class="variable">$(PREBUILTS_GCC_DIR)</span>/linux-x86/aarch64/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin</span><br><span class="line">41     KERNEL_TARGET_TOOLCHAIN_PREFIX := <span class="variable">$(KERNEL_TARGET_TOOLCHAIN)</span>/aarch64-linux-gnu-</span><br></pre></td></tr></table></figure><p>进入Linux-5.4:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=./../../prebuilts/clang/ohos/linux-x86_64/llvm/bin:./../../prebuilts/gcc/linux-x86/aarch64/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> MAKE_OPTIONS=<span class="string">&quot;ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- CC=clang HOSTCC=clang&quot;</span></span><br></pre></td></tr></table></figure><p>3 编译Image和模块</p><p>移植前先编译一次三方内核，确保无误。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make <span class="variable">$MAKE_OPTIONS</span> O=out/ -j4</span><br><span class="line">make <span class="variable">$MAKE_OPTIONS</span> O=out/ -j4 modules</span><br></pre></td></tr></table></figure><h2 id="移植内核态基础代码"><a href="#移植内核态基础代码" class="headerlink" title="移植内核态基础代码"></a>移植内核态基础代码</h2><p>官方文档提到的hilog&#x2F;hievent:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">drivers/staging/hilog</span><br><span class="line">drivers/staging/hievent</span><br></pre></td></tr></table></figure><p>还有这几个特性：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">drivers/staging/hisysevent</span><br><span class="line">drivers/staging/hungtask</span><br><span class="line">drivers/staging/zerohung</span><br><span class="line">drivers/staging/blackbox</span><br></pre></td></tr></table></figure><p>对应的头文件：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">include/dfx/hiview_hisysevent.h               |   67 ++</span><br><span class="line">include/dfx/hung_wp_screen.h                  |   24 +</span><br><span class="line">include/dfx/hungtask_base.h                   |  111 ++</span><br><span class="line">include/dfx/zrhung.h                          |   11 +</span><br><span class="line">include/linux/blackbox.h                      |   84 ++</span><br><span class="line">include/linux/blackbox_common.h               |   44 +</span><br><span class="line">include/linux/blackbox_storage.h              |   22 +</span><br></pre></td></tr></table></figure><p>drivers下还有个accesstokenid特性，改的地方还不只一处：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tj@ubuntu:~/ohos-3.2.2/kernel/linux/linux-5.10$ grep -R ACCESS_TOKENID --exclude-dir=accesstokenid</span><br><span class="line">include/linux/sched.h:#ifdef CONFIG_ACCESS_TOKENID</span><br><span class="line">drivers/Makefile:obj-$(CONFIG_ACCESS_TOKENID)   += accesstokenid/</span><br><span class="line">drivers/android/binder.c:#ifdef CONFIG_ACCESS_TOKENID</span><br><span class="line">drivers/android/binder.c:#define ENABLE_ACCESS_TOKENID 1</span><br><span class="line">drivers/android/binder.c:#define ENABLE_ACCESS_TOKENID 0</span><br><span class="line">drivers/android/binder.c:#endif /* CONFIG_ACCESS_TOKENID */</span><br><span class="line">drivers/android/binder.c:#define ACCESS_TOKENID_FEATURE_VALUE (ENABLE_ACCESS_TOKENID &lt;&lt; 0)</span><br><span class="line">drivers/android/binder.c:#define BINDER_CURRENT_FEATURE_SET ACCESS_TOKENID_FEATURE_VALUE</span><br><span class="line">drivers/android/binder.c:#ifdef CONFIG_ACCESS_TOKENID</span><br><span class="line">drivers/android/binder.c:#endif /* CONFIG_ACCESS_TOKENID */</span><br><span class="line">drivers/android/binder.c:#ifdef CONFIG_ACCESS_TOKENID</span><br><span class="line">drivers/android/binder.c:#endif /* CONFIG_ACCESS_TOKENID */</span><br><span class="line">drivers/android/binder.c:#ifdef CONFIG_ACCESS_TOKENID</span><br><span class="line">drivers/android/binder.c:#endif /* CONFIG_ACCESS_TOKENID */</span><br><span class="line">drivers/android/binder.c:#ifdef CONFIG_ACCESS_TOKENID</span><br><span class="line">drivers/android/binder.c:#endif /* CONFIG_ACCESS_TOKENID */</span><br><span class="line">drivers/android/binder.c:#ifdef CONFIG_ACCESS_TOKENID</span><br><span class="line">drivers/android/binder.c:#endif /* CONFIG_ACCESS_TOKENID */</span><br><span class="line">fs/proc/base.c:#ifdef CONFIG_ACCESS_TOKENID</span><br><span class="line">fs/proc/base.c:#endif /* CONFIG_ACCESS_TOKENID */</span><br><span class="line">fs/proc/base.c:#ifdef CONFIG_ACCESS_TOKENID</span><br><span class="line">fs/proc/base.c:#ifdef CONFIG_ACCESS_TOKENID</span><br><span class="line">kernel/fork.c:#ifdef CONFIG_ACCESS_TOKENID</span><br></pre></td></tr></table></figure><p>看了下 caller path:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">base/security/access_token</span><br></pre></td></tr></table></figure><p>所以说，要拿一个非官方支持的内核版本落地产品，不是说不能做，还是要考虑清楚。</p><h2 id="移植内核态必选特性HDF"><a href="#移植内核态必选特性HDF" class="headerlink" title="移植内核态必选特性HDF"></a>移植内核态必选特性HDF</h2><p>官方的打hdf patch方法, 看kernel.mk:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">83         <span class="variable">$(hide)</span> <span class="variable">$(OHOS_BUILD_HOME)</span>/drivers/hdf_core/adapter/khdf/linux/patch_hdf.sh <span class="variable">$(OHOS_BUILD_HOME)</span> <span class="variable">$(KERNEL_SRC_TMP_PATH)</span> <span class="variable">$(KERNEL_PATCH_PATH)</span> <span class="variable">$(DEVICE_NAME)</span></span><br></pre></td></tr></table></figure><p>patch_hdf.sh:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">65 function main()</span><br><span class="line">66 &#123;</span><br><span class="line">67     cd $KERNEL_BUILD_ROOT</span><br><span class="line">68     put_hdf_patch</span><br><span class="line">69     ln_hdf_repos</span><br><span class="line">70     copy_external_compents</span><br><span class="line">71     cd -</span><br><span class="line">72 &#125;</span><br></pre></td></tr></table></figure><p><code>put_hdf_patch</code>:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">55 function put_hdf_patch()</span><br><span class="line">56 &#123;</span><br><span class="line">57     HDF_PATCH_FILE=$&#123;KERNEL_PATCH_PATH&#125;/$&#123;DEVICE_NAME&#125;_patch/hdf.patch</span><br><span class="line">58     if [ ! -e &quot;$&#123;HDF_PATCH_FILE&#125;&quot; ]</span><br><span class="line">59     then</span><br><span class="line">60             HDF_PATCH_FILE=$&#123;KERNEL_PATCH_PATH&#125;/$&#123;HDF_COMMON_PATCH&#125;_patch/hdf.patch</span><br><span class="line">61     fi</span><br><span class="line">62     patch -p1 &lt; $HDF_PATCH_FILE</span><br><span class="line">63 &#125;</span><br></pre></td></tr></table></figure><p>我们这里用的是60行通用的hdf.patch:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">kernel/linux/patches/linux-5.10/common_patch/hdf.patch</span><br></pre></td></tr></table></figure><p>这个patch是给5.10用，我们是5.4，直接打多少应该是有问题的，还好只有300多行，手动改改即可。</p><p>然后，注掉这个<code>put_hdf_patch</code>, 跑下patch_hdf.sh即可, 多了个<code>PRODUCT_PATH</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PRODUCT_PATH=vendor/<span class="variable">$your_product</span></span><br></pre></td></tr></table></figure><p>使能几个，最大的问题就是有很多下面这类错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">../drivers/hdf/khdf/manager/../../../..//framework/core/host/src/hdf_device_node.c:156:27: error: ISO C90 forbids mixing declarations and code [-Werror,-Wdeclaration-after-statement]</span><br><span class="line">    struct HdfServiceInfo servInfo;</span><br></pre></td></tr></table></figure><p>code是这样写的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">149</span> <span class="type">int</span> <span class="title function_">HdfDeviceNodePublishPublicService</span><span class="params">(<span class="keyword">struct</span> HdfDeviceNode *devNode)</span></span><br><span class="line">150 &#123;</span><br><span class="line"><span class="number">151</span>     <span class="type">int</span> ret;</span><br><span class="line"><span class="number">152</span>     <span class="keyword">if</span> (devNode == <span class="literal">NULL</span> || devNode-&gt;deviceObject.service == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">153</span>         HDF_LOGE(<span class="string">&quot;failed to publish public service, devNode is NULL&quot;</span>);</span><br><span class="line"><span class="number">154</span>         <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line"><span class="number">155</span>     &#125;</span><br><span class="line"><span class="number">156</span>     <span class="class"><span class="keyword">struct</span> <span class="title">HdfServiceInfo</span> <span class="title">servInfo</span>;</span></span><br><span class="line"><span class="number">157</span>     HdfServiceInfoInit(&amp;servInfo, devNode);</span><br><span class="line"><span class="number">158</span>     ret = DevSvcManagerClntAddService(&amp;devNode-&gt;deviceObject, &amp;servInfo);</span><br><span class="line"><span class="number">159</span>     <span class="keyword">if</span> (ret == HDF_SUCCESS) &#123;</span><br><span class="line"><span class="number">160</span>         devNode-&gt;servStatus = <span class="literal">true</span>;</span><br><span class="line"><span class="number">161</span>     &#125;</span><br><span class="line"><span class="number">162</span> </span><br></pre></td></tr></table></figure><p>C90不允许<code>declaration-after-statement</code>，看了下5.4&#x2F;5.10还是gnu89, 上游已经更新到gnu11了，照样改过来fix即可。</p><p>整个移植下来的感觉就是你可以把它当成个黑盒，不需要有太多的Linux Kernel背景。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.openharmony.cn/pages/v3.2/zh-cn/device-dev/porting/porting-linux-kernel.md/">https://docs.openharmony.cn/pages/v3.2/zh-cn/device-dev/porting/porting-linux-kernel.md/</a></li><li><a href="https://ost.51cto.com/posts/20918">https://ost.51cto.com/posts/20918</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ohos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> porting-oh-linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识 OpenHarmony Linux Kernel</title>
      <link href="/openharmony-linux-kernel-overview.html"/>
      <url>/openharmony-linux-kernel-overview.html</url>
      
        <content type="html"><![CDATA[<p>先看技术架构：</p><p><img src="https://tjtech.me/usr/uploads/2023/07/2415536131.png" alt="ohos-arch.png"></p><p>既然 OH 是多内核设计，那必然会有个抽象层（KAL）统一接口供上层使用，还多了个 HDF 驱动框架，官方的引入考虑：</p><blockquote><p>How to smoothly adapt device drivers to different kernels on the same hardware and minimize the workloads on driver code porting and maintenance is an important issue to address in the OpenHarmony driver subsystem.</p></blockquote><p>就是同一份 driver code 可以多个系统跑，有点那个 BPF CO-RE (compile once-run everywhere) 的味道。</p><p>此外，针对 Linux，OH 还添加了一些增强内核特性，比如 ESwap (内存融合相关)、任务调度。</p><blockquote><p>OpenHarmony provides the enhanced swap (ESwap), related thread group (RTG), and lightweight CPU isolation features for the Linux kernel</p></blockquote><p>还有一些基本特性，比如 hilog, hievent。</p><blockquote><p>Currently, the basic kernel-mode code of OpenHarmony is related to the log service. The lightweight kernel log service code includes the following:</p></blockquote><p>还有的藏的比较深,比如 accesstokenid：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@ubuntu:~/ohos-3.2.2/kernel/linux/linux-5.10/drivers/accesstokenid$ <span class="built_in">ls</span></span><br><span class="line">Kconfig  Makefile  access_tokenid.c  access_tokenid.h</span><br></pre></td></tr></table></figure><p>干啥用的？Kconfig:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config ACCESS_TOKENID</span><br><span class="line">        bool &quot;Access task&#x27;s token&quot;</span><br><span class="line">        default n</span><br></pre></td></tr></table></figure><p>这描述。。。貌似和 APP 权限有关。</p><p>当前 OH Linux 内核版本只有 4.19 和 5.10：</p><blockquote><p>OpenHarmony uses Linux LTS versions as its base kernel. Currently, it supports Linux-4.19 and Linux-5.10.</p></blockquote><p>既然用 Linux LTS 版本，为啥不用 5.4？I think it might not be related to technology… rt?</p><p>3.2.2 里只有 linux-5.10:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@ubuntu:~/ohos-3.2.2/kernel/linux$ <span class="built_in">ls</span></span><br><span class="line">build  config  linux-5.10  patches</span><br></pre></td></tr></table></figure><p>这种情况，如果 Vendor&#x2F;SoC 不支持 5.10，那三方有的干了。</p><p>我们来看下内核提交日志，好家伙，下面这种 log 对我没有任何用处, I can’t learn anything from this, what about you? </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit b840cb60753e1118e9d0e1eb4d2bfd353ec0e032 (grafted, HEAD, tag: OpenHarmony-v3.2.2-Release, m/refs/tags/OpenHarmony-v3.2.2-Release)</span><br><span class="line">Author: openharmony_ci &lt;120357966@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 9 08:32:06 2023 +0000</span><br><span class="line"></span><br><span class="line">    !896 master 分支CVE同步</span><br><span class="line">    Merge pull request !896 from Ywenrui44091/OpenHarmony-3.2-Release</span><br></pre></td></tr></table></figure><p>附带过下代码目录。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@ubuntu:~/ohos-3.2.2$ <span class="built_in">ls</span></span><br><span class="line">applications  base   build.py  commonlibrary  device  drivers     ide        kernel          productdefine  <span class="built_in">test</span>         vendor</span><br><span class="line">arkcompiler   build  build.sh  developtools   docs    foundation  interface  napi_generator  qemu-run       third_party</span><br></pre></td></tr></table></figure><p>有个 base 和 foundation 不太明白，其他目录看 name 还好。</p><p>官方解释：</p><blockquote><p>base | Basic software service subsystem set and hardware service subsystem set.|<br>foundation | Basic system capability subsystem set.|</p></blockquote><p>啊，就是架构图画到的。</p><blockquote><p>Basic software service subsystem set: Provides OpenHarmony with common universal software services, including common event and notification, telephony, multimedia, and Design For X (DFX).</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@ubuntu:~/ohos-3.2.2$ <span class="built_in">ls</span> base</span><br><span class="line">account        global     inputmethod  location  notification  request   sensors  telephony  time    usb      web</span><br><span class="line">customization  hiviewdfx  iothardware  msdp      powermgr      security  startup  theme      update  useriam</span><br></pre></td></tr></table></figure><blockquote><p>Basic system capability subsystem set: Implements distributed application running, scheduling, and migration across OpenHarmony devices. This subsystem set provides the following basic capabilities: Distributed Soft Bus (DSoftBus), distributed data management, Distributed Scheduler, Utils, multimodal input, graphics, security, and AI.</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@ubuntu:~/ohos-3.2.2$ <span class="built_in">ls</span> foundation/</span><br><span class="line">ability  arkui        bundlemanager  deviceprofile       distributedhardware  graphic     multimodalinput   systemabilitymgr</span><br><span class="line">ai       barrierfree  communication  distributeddatamgr  filemanagement       multimedia  resourceschedule  window</span><br></pre></td></tr></table></figure><p>都能对号入座，就这么多，done。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><p><a href="https://docs.openharmony.cn/pages/v3.2/en/OpenHarmony-Overview.md/">https://docs.openharmony.cn/pages/v3.2/en/OpenHarmony-Overview.md/</a></p></li><li><p><a href="https://gitee.com/openharmony/docs/blob/master/en/device-dev/get-code/sourcecode-acquire.md">https://gitee.com/openharmony/docs/blob/master/en/device-dev/get-code/sourcecode-acquire.md</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> ohos </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>What Android GKI Brings to OEMs</title>
      <link href="/what-android-gki-brings-to-oems.html"/>
      <url>/what-android-gki-brings-to-oems.html</url>
      
        <content type="html"><![CDATA[<p>After reading the Android documentation on General Kernel Image (GKI), i have gained an understanding of what it means for OEMs.</p><p>We know every OEM could modify the Linux kernel in earlier kernel versions (before 5.4) of Android. Some were just customizing the device driver. However, Android realized that this process could block the ecosystem, so the GKI project was developed.</p><p>For OEMs, I think the key priority should be to differentiate the Linux kernel under GKI. However, most OEMs prefer not to submit their modifications to the Linux upstream as it is their proprietary and gives them a competitive edge (or show them may lead to a loss since they may not be solid enough). To address this, GKI offers a vendor hook method, which requires OEMs to create a separate kernel module for their modifications and add a hook in GKI that will call the functions defined in the kernel module. The hook uses kernel trace point rather trace event. By using this method, OEMs can differentiate their kernel while still maintaining their competitive advantage.</p><p>Please keep in mind that the OEM&#x2F;vendor must submit any hooks to the Android Common Kernel (ACK) upstream, which will then be reviewed. If the hook is reasonable, it will be accepted, but if it’s not, it will be rejected. It’s crucial to consider this when adding a hook to your feature since it could potentially be rejected.</p><p>Additionally, I’d like to point out that before the GKI was introduced, there were people who liked to make random modifications to the kernel. We weren’t sure whether these changes were good or bad because we weren’t familiar with the areas they were modifying. They simply had more exposure to those areas than we did. The emergence of GKI allows us to identify whether something is a mule or a horse.</p><p>Returning to the topic, are there any other ways to customize the kernel? I believe there are, and one example is eBPF. And i think we still need to submit something upstream rather than completely closed development.</p><p>Currently there are 2 GKI stages: GKI 1.0 and GKI 2.0.</p><blockquote><p>In GKI 1.0, devices launching with kernel version 5.4 must pass GKI testing (Android 11 and later platform releases).</p></blockquote><blockquote><p>In GKI 2.0, devices launching with kernel version 5.10 or higher must ship with the GKI kernel (beginning with Android 12). Signed boot images are available and updated regularly with LTS and critical bug fixes.</p></blockquote><p>Based on my undertanding, OEMs can still modify the core kernel for kernel 5.4 only if their devices pass the GKI testing and&#x2F;or CTS&#x2F;VTS testing. Remember, i think it’s best to avoid breaking the upgrade process which includes any core changes as well except this testing. If you’re not confident, don’t touch it. For kernel version 5.10 or above, it is mandatory that OEMs cannot modify the core kernel.</p><p>So, to summarize the methods that OEMs need to take towards the right direction:</p><ol><li>Develop a kernel module with a vendor hook.</li><li>Utilize eBPF technology.</li><li>Explore additional methods for customization.</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h2><ul><li><a href="https://source.android.google.cn/docs/core/architecture/kernel/kernel-code">https://source.android.google.cn/docs/core/architecture/kernel/kernel-code</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> GKI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转：EROFS pcluster 模式分析</title>
      <link href="/analyze-erofs-pcluster-mode.html"/>
      <url>/analyze-erofs-pcluster-mode.html</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://mp.weixin.qq.com/s/PQb_PwgxzyeeFZyz3FsO6w">https://mp.weixin.qq.com/s/PQb_PwgxzyeeFZyz3FsO6w</a></p><p>EROFS pluster 模式的用处：</p><blockquote><p>It’s used to judge whether inplace I&#x2F;O can be used due to the current status of pclusters in the chain.</p></blockquote><p>有四种：INFLIGHT, HOOKED, FOLLOWED, FOLLOWED_NOINPLACE，本文源码参考 Linux kernel 6.x.</p><h2 id="FOLLOWED-模式"><a href="#FOLLOWED-模式" class="headerlink" title="FOLLOWED 模式"></a>FOLLOWED 模式</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The current collection has been linked with the owned chain, and</span></span><br><span class="line"><span class="comment"> * could also be linked with the remaining collections, which means</span></span><br><span class="line"><span class="comment"> * if the processing page is the tail page of the collection, thus</span></span><br><span class="line"><span class="comment"> * the current collection can safely use the whole page (since</span></span><br><span class="line"><span class="comment"> * the previous collection is under control) for in-place I/O, as</span></span><br><span class="line"><span class="comment"> * illustrated below:</span></span><br><span class="line"><span class="comment"> *  ________________________________________________________________</span></span><br><span class="line"><span class="comment"> * |  tail (partial) page |          head (partial) page           |</span></span><br><span class="line"><span class="comment"> * |  (of the current cl) |      (of the previous collection)      |</span></span><br><span class="line"><span class="comment"> * | PCLUSTER_FOLLOWED or |                                        |</span></span><br><span class="line"><span class="comment"> * |_____PCLUSTER_HOOKED__|___________PCLUSTER_FOLLOWED____________|</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [  (*) the above page can be used as inplace I/O.               ]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Z_EROFS_PCLUSTER_FOLLOWED,</span><br></pre></td></tr></table></figure><p>注释写到这个模式表示当前收集的 pcluster 是被 link 到这个 <code>owned chain</code>，而且也可以和 <code>remaining collections</code>连在一起，怎么理解？我们直接看代码。</p><p>如果当前收集的 pcluster 已经存在，走<code>z_erofs_try_to_claim_pcluster</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">z_erofs_try_to_claim_pcluster</span><span class="params">(<span class="keyword">struct</span> z_erofs_decompress_frontend *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">z_erofs_pcluster</span> *<span class="title">pcl</span> =</span> f-&gt;pcl;</span><br><span class="line">    <span class="type">z_erofs_next_pcluster_t</span> *owned_head = &amp;f-&gt;owned_head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* type 1, nil pcluster (this pcluster doesn&#x27;t belong to any chain.) */</span></span><br><span class="line">    <span class="keyword">if</span> (cmpxchg(&amp;pcl-&gt;next, Z_EROFS_PCLUSTER_NIL,</span><br><span class="line">            *owned_head) == Z_EROFS_PCLUSTER_NIL) &#123;</span><br><span class="line">        *owned_head = &amp;pcl-&gt;next;</span><br><span class="line">        <span class="comment">/* so we can attach this pcluster to our submission chain. */</span></span><br><span class="line">        f-&gt;mode = Z_EROFS_PCLUSTER_FOLLOWED;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而这个 pcluster 已经解压过了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="type">static</span> <span class="type">int</span> <span class="title function_">z_erofs_decompress_pcluster</span><span class="params">(<span class="keyword">struct</span> z_erofs_decompress_backend *be,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> err)</span></span><br><span class="line">&#123;</span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">/* pcluster lock MUST be taken before the following line */</span></span><br><span class="line">        WRITE_ONCE(pcl-&gt;next, Z_EROFS_PCLUSTER_NIL);</span><br><span class="line">        mutex_unlock(&amp;pcl-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是<code>pcl-&gt;next == Z_EROFS_PCLUSTER_NIL</code>，那就放到这个链里，跟在<code>owned_head</code>后面。</p><p>当收集到新的 pcluster 时，直接增加到这个 chain 里:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">z_erofs_register_pcluster</span><span class="params">(<span class="keyword">struct</span> z_erofs_decompress_frontend *fe)</span></span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">    pcl-&gt;next = fe-&gt;owned_head;</span><br><span class="line">    pcl-&gt;pageofs_out = <span class="built_in">map</span>-&gt;m_la &amp; ~PAGE_MASK;</span><br><span class="line">    fe-&gt;mode = Z_EROFS_PCLUSTER_FOLLOWED;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, 如果当前访问的 page 是整个收集的 tail page, 那这个 page 就可以用作 in-place I&#x2F;O.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">z_erofs_attach_page</span><span class="params">(<span class="keyword">struct</span> z_erofs_decompress_frontend *fe,</span></span><br><span class="line"><span class="params">                   <span class="keyword">struct</span> z_erofs_bvec *bvec, <span class="type">bool</span> exclusive)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exclusive) &#123;</span><br><span class="line">        <span class="comment">/* give priority for inplaceio to use file pages first */</span></span><br><span class="line">        <span class="keyword">if</span> (z_erofs_try_inplace_io(fe, bvec))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如上，在 attach page 时如果<code>exclusive</code>为真，就会尝试 inplace I&#x2F;O。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">exclusive = (!cur &amp;&amp; (!spiltted || tight));</span><br></pre></td></tr></table></figure><p>当访问完 tail page 部分(从 page end 处开始)，<code>cur</code>为0, 依赖<code>tight</code>, 这个<code>tight</code>就根据 pcluster 模式来定：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ensure the current partial page belongs to this submit chain rather</span></span><br><span class="line"><span class="comment"> * than other concurrent submit chains or the noio(bypass) chain since</span></span><br><span class="line"><span class="comment"> * those chains are handled asynchronously thus the page cannot be used</span></span><br><span class="line"><span class="comment"> * for inplace I/O or bvpage (should be processed in a strict order.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">tight &amp;= (fe-&gt;mode &gt;= Z_EROFS_PCLUSTER_HOOKED &amp;&amp;</span><br><span class="line">      fe-&gt;mode != Z_EROFS_PCLUSTER_FOLLOWED_NOINPLACE);</span><br></pre></td></tr></table></figure><p>也就是 tail page 所属的 pcluster 模式只有 HOOKED 或 FOLLOWED 才会把这个 page 用作 inplace I&#x2F;O。</p><h2 id="HOOKED-模式"><a href="#HOOKED-模式" class="headerlink" title="HOOKED 模式"></a>HOOKED 模式</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The current pclusters was the tail of an exist chain, in addition</span></span><br><span class="line"><span class="comment"> * that the previous processed chained pclusters are all decided to</span></span><br><span class="line"><span class="comment"> * be hooked up to it.</span></span><br><span class="line"><span class="comment"> * A new chain will be created for the remaining pclusters which are</span></span><br><span class="line"><span class="comment"> * not processed yet, so different from Z_EROFS_PCLUSTER_FOLLOWED,</span></span><br><span class="line"><span class="comment"> * the next pcluster cannot reuse the whole page safely for inplace I/O</span></span><br><span class="line"><span class="comment"> * in the following scenario:</span></span><br><span class="line"><span class="comment"> *  ________________________________________________________________</span></span><br><span class="line"><span class="comment"> * |      tail (partial) page     |       head (partial) page       |</span></span><br><span class="line"><span class="comment"> * |   (belongs to the next pcl)  |   (belongs to the current pcl)  |</span></span><br><span class="line"><span class="comment"> * |_______PCLUSTER_FOLLOWED______|________PCLUSTER_HOOKED__________|</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Z_EROFS_PCLUSTER_HOOKED,</span><br></pre></td></tr></table></figure><p>当前的 pcluster 处在一个已经存在的 chain 的尾部，也就是 <code>pcl-&gt;next == Z_EROFS_PCLUSTER_TAIL</code>，那么就新建一个 chain 给接下来的收集好了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">z_erofs_try_to_claim_pcluster</span><span class="params">(<span class="keyword">struct</span> z_erofs_decompress_frontend *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * type 2, link to the end of an existing open chain, be careful</span></span><br><span class="line"><span class="comment">     * that its submission is controlled by the original attached chain.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (*owned_head != &amp;pcl-&gt;next &amp;&amp; pcl != f-&gt;tailpcl &amp;&amp;</span><br><span class="line">        cmpxchg(&amp;pcl-&gt;next, Z_EROFS_PCLUSTER_TAIL,</span><br><span class="line">            *owned_head) == Z_EROFS_PCLUSTER_TAIL) &#123;</span><br><span class="line">        *owned_head = Z_EROFS_PCLUSTER_TAIL;</span><br><span class="line">        f-&gt;mode = Z_EROFS_PCLUSTER_HOOKED;</span><br><span class="line">        f-&gt;tailpcl = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么这个 <code>tight</code> 就是 false 了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur)</span><br><span class="line">        tight &amp;= (fe-&gt;mode &gt;= Z_EROFS_PCLUSTER_FOLLOWED);</span><br></pre></td></tr></table></figure><p>当访问 head page 时，<code>cur</code>还未变成 0，显然不是<code>exclusive</code>，也就不能走 inplace I&#x2F;O了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cur = end - <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>, offset + end - <span class="built_in">map</span>-&gt;m_la, end);</span><br></pre></td></tr></table></figure><h2 id="INFLIGHT-模式"><a href="#INFLIGHT-模式" class="headerlink" title="INFLIGHT 模式"></a>INFLIGHT 模式</h2><p>对一个已经存在的 pcluster，除了 nil 的情况，要么它是一个 chain 的 end (上面的 HOOKED)，要么它不是一个 chain 的 end.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">z_erofs_try_to_claim_pcluster</span><span class="params">(<span class="keyword">struct</span> z_erofs_decompress_frontend *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">/* type 3, it belongs to a chain, but it isn&#x27;t the end of the chain */</span></span><br><span class="line">    f-&gt;mode = Z_EROFS_PCLUSTER_INFLIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FOLLOWED-NOINPLACE-模式"><a href="#FOLLOWED-NOINPLACE-模式" class="headerlink" title="FOLLOWED_NOINPLACE 模式"></a>FOLLOWED_NOINPLACE 模式</h2><p>看命名就大概知道了，这个模式不需要 inplace I&#x2F;O。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * a weak form of Z_EROFS_PCLUSTER_FOLLOWED, the difference is that it</span></span><br><span class="line"><span class="comment">     * could be dispatched into bypass queue later due to uptodated managed</span></span><br><span class="line"><span class="comment">     * pages. All related online pages cannot be reused for inplace I/O (or</span></span><br><span class="line"><span class="comment">     * bvpage) since it can be directly decoded without I/O submission.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Z_EROFS_PCLUSTER_FOLLOWED_NOINPLACE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>z_erofs_bind_cache()</code>如果<code>find_get_page()</code>都找到了 pcluster 的所有 pages，那就不用 I&#x2F;O 了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">z_erofs_bind_cache</span><span class="params">(<span class="keyword">struct</span> z_erofs_decompress_frontend *fe,</span></span><br><span class="line"><span class="params">                   <span class="keyword">struct</span> page **pagepool)</span></span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pcl-&gt;pclusterpages; ++i) &#123;</span><br><span class="line">        [...]</span><br><span class="line">        page = find_get_page(mc, pcl-&gt;obj.index + i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (page) &#123;</span><br><span class="line">            t = (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">long</span>)page | <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* I/O is needed, no possible to decompress directly */</span></span><br><span class="line">            standalone = <span class="literal">false</span>;</span><br><span class="line">        [...]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * don&#x27;t do inplace I/O if all compressed pages are available in</span></span><br><span class="line"><span class="comment">     * managed cache since it can be moved to the bypass queue instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (standalone)</span><br><span class="line">        fe-&gt;mode = Z_EROFS_PCLUSTER_FOLLOWED_NOINPLACE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，inline 的情况也不需要 inplace I&#x2F;O:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">z_erofs_do_read_page</span><span class="params">(<span class="keyword">struct</span> z_erofs_decompress_frontend *fe,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> page *page, <span class="keyword">struct</span> page **pagepool)</span></span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="keyword">if</span> (z_erofs_is_inline_pcluster(fe-&gt;pcl)) &#123;</span><br><span class="line">        [...]</span><br><span class="line">        fe-&gt;mode = Z_EROFS_PCLUSTER_FOLLOWED_NOINPLACE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure><p>BTW: 最新的版本已经去掉了HOOK模式。</p>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erofs </tag>
            
            <tag> pclustermode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么 WQ_CPU_INTENSIVE 对 unbound 工作队列没有意义</title>
      <link href="/why-cpu-intensive-work-is-meaningless-for-unbound-wq.html"/>
      <url>/why-cpu-intensive-work-is-meaningless-for-unbound-wq.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如题，Linux workqueue 文档在描述 <code>WQ_CPU_INSTENSIVE</code> 时提到:</p><blockquote><p>This flag is meaningless for unbound wq.</p></blockquote><p>为什么这样说？本文尝试去解读这个标记。</p><p>unbound wq 就是 <code>WQ_UNBOUND</code>:</p><blockquote><p><code>WQ_UNBOUND</code><br>  Work items queued to an unbound wq are served by the special<br>  worker-pools which host workers which are not bound to any<br>  specific CPU.  This makes the wq behave as a simple execution<br>  context provider without concurrency management.  The unbound<br>  worker-pools try to start execution of work items as soon as<br>  possible.\  Unbound wq sacrifices locality but is useful for<br>  the following cases.</p><p>  * Wide fluctuation in the concurrency level requirement is<br> \   expected and using bound wq may end up creating large number<br> \   of mostly unused workers across different CPUs as the issuer<br> \   hops through different CPUs.</p><p>  * Long running CPU intensive workloads which can be better<br> \   managed by the system scheduler.</p></blockquote><p>就是 worker 不绑 CPU，有用的场景一是并发级别波动比较大，一时任务多，一时任务少。另一个就是对长时间运行 CPU intensive 的工作。</p><p>什么是 <code>WQ_CPU_INTENSIVE</code>:</p><blockquote><p><code>WQ_CPU_INTENSIVE</code><br>  Work items of a CPU intensive wq do not contribute to the<br>  concurrency level.  In other words, runnable CPU intensive<br>  work items will not prevent other work items in the same<br>  worker-pool from starting execution.  This is useful for bound<br>  work items which are expected to hog CPU cycles so that their<br>  execution is regulated by the system scheduler.</p></blockquote><p>带这个标记的 wq 表示这个 wq 里面都是 CPU intensive work，这些 works都期望独占CPU，加了这个标记后它们的调度由系统完成。</p><p>这些 works <em>do not contribute to the concurrency level</em> 怎么理解？来看code, 参考6.x:</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>带有 CPU intensive 的 wq 源头处理只有 <code>process_one_work</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">process_one_work</span><span class="params">(<span class="keyword">struct</span> worker *worker, <span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">__<span class="title function_">releases</span><span class="params">(&amp;pool-&gt;lock)</span></span><br><span class="line">__<span class="title function_">acquires</span><span class="params">(&amp;pool-&gt;lock)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> =</span> get_work_pwq(work);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line">        <span class="type">bool</span> cpu_intensive = pwq-&gt;wq-&gt;flags &amp; WQ_CPU_INTENSIVE; <span class="comment">//tj: here</span></span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * CPU intensive works don&#x27;t participate in concurrency management.</span></span><br><span class="line"><span class="comment">         * They&#x27;re the scheduler&#x27;s responsibility.  This takes @worker out</span></span><br><span class="line"><span class="comment">         * of concurrency management and the next code block will chain</span></span><br><span class="line"><span class="comment">         * execution of the pending work items.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">                worker_set_flags(worker, WORKER_CPU_INTENSIVE);</span><br></pre></td></tr></table></figure><p>注释写到：CPU intensive works 的并发是由 scheduler 管而不归 workqueue 管。具体怎么做的了, 在<code>worker_set_flags()</code>里。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">worker_set_flags</span><span class="params">(<span class="keyword">struct</span> worker *worker, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line"></span><br><span class="line">        WARN_ON_ONCE(worker-&gt;task != current);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If transitioning into NOT_RUNNING, adjust nr_running. */</span></span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; WORKER_NOT_RUNNING) &amp;&amp;</span><br><span class="line">            !(worker-&gt;flags &amp; WORKER_NOT_RUNNING)) &#123;</span><br><span class="line">                pool-&gt;nr_running--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        worker-&gt;flags |= flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正有作用的只有两处：一个是 <code>nr_running--</code>，另一个就是把 <code>WORKER_CPU_INTENSIVE</code> 这个标记加到 worker 里。</p><p><code>nr_running</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The counter is incremented in a process context on the associated CPU</span></span><br><span class="line"><span class="comment"> * w/ preemption disabled, and decremented or reset in the same context</span></span><br><span class="line"><span class="comment"> * but w/ pool-&gt;lock held. The readers grab pool-&gt;lock and are</span></span><br><span class="line"><span class="comment"> * guaranteed to see if the counter reached zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>nr_running;</span><br></pre></td></tr></table></figure><p>怎么用的了？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wq_worker_running</span><span class="params">(<span class="keyword">struct</span> task_struct *task)</span></span><br><span class="line">&#123;</span><br><span class="line">[...]</span><br><span class="line">preempt_disable();</span><br><span class="line"><span class="keyword">if</span> (!(worker-&gt;flags &amp; WORKER_NOT_RUNNING))</span><br><span class="line">worker-&gt;pool-&gt;nr_running++;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wq_worker_sleeping</span><span class="params">(<span class="keyword">struct</span> task_struct *task)</span></span><br><span class="line">&#123;</span><br><span class="line">[...]</span><br><span class="line">pool-&gt;nr_running--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">worker_clr_flags</span><span class="params">(<span class="keyword">struct</span> worker *worker, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">[...]</span><br><span class="line"><span class="keyword">if</span> ((flags &amp; WORKER_NOT_RUNNING) &amp;&amp; (oflags &amp; WORKER_NOT_RUNNING))</span><br><span class="line"><span class="keyword">if</span> (!(worker-&gt;flags &amp; WORKER_NOT_RUNNING))</span><br><span class="line">pool-&gt;nr_running++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unbind_workers</span><span class="params">(<span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">[...]</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The handling of nr_running in sched callbacks are disabled</span></span><br><span class="line"><span class="comment"> * now.  Zap nr_running.  After this, nr_running stays zero and</span></span><br><span class="line"><span class="comment"> * need_more_worker() and keep_working() are always true as</span></span><br><span class="line"><span class="comment"> * long as the worklist is not empty.  This pool now behaves as</span></span><br><span class="line"><span class="comment"> * an unbound (in terms of concurrency management) pool which</span></span><br><span class="line"><span class="comment"> * are served by workers tied to the pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pool-&gt;nr_running = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> __need_more_worker(<span class="keyword">struct</span> worker_pool *pool)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !pool-&gt;nr_running;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上的使用可以看出来 <code>nr_running</code> 就关联着并发管理，如果没有<code>nr_running</code>，那就不再需要worker thread了。</p><p>回到上文，<code>cpu_intensive</code>时的<code>nr_running--</code>就是把这个 worker 从并发里面拿走，这也是 <code>WQ_CPU_INTENSIVE</code> 的意义所在，也正如文档描述的那样。</p><p>至于 worker 的 flags 有：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* worker flags */</span></span><br><span class="line">WORKER_DIE= <span class="number">1</span> &lt;&lt; <span class="number">1</span>,<span class="comment">/* die die die */</span></span><br><span class="line">WORKER_IDLE= <span class="number">1</span> &lt;&lt; <span class="number">2</span>,<span class="comment">/* is idle */</span></span><br><span class="line">WORKER_PREP= <span class="number">1</span> &lt;&lt; <span class="number">3</span>,<span class="comment">/* preparing to run works */</span></span><br><span class="line">WORKER_CPU_INTENSIVE= <span class="number">1</span> &lt;&lt; <span class="number">6</span>,<span class="comment">/* cpu intensive */</span></span><br><span class="line">WORKER_UNBOUND= <span class="number">1</span> &lt;&lt; <span class="number">7</span>,<span class="comment">/* worker is unbound */</span></span><br><span class="line">WORKER_REBOUND= <span class="number">1</span> &lt;&lt; <span class="number">8</span>,<span class="comment">/* worker was rebound */</span></span><br><span class="line"></span><br><span class="line">WORKER_NOT_RUNNING= WORKER_PREP | WORKER_CPU_INTENSIVE |</span><br><span class="line">  WORKER_UNBOUND | WORKER_REBOUND,</span><br></pre></td></tr></table></figure><p>而 <code>WORKER_CPU_INTENSIVE</code> 的 check 全部都是和 <code>WORKER_NOT_RUNNING</code> 有关。</p><p>那影响 <code>CPU_INTENSIVE</code> 行为的只有最开始的 <code>worker_set_flags</code>，rt? 也就是那个 <code>nr_running--</code> 的条件，也就是说如果 <code>worker-&gt;flags</code> 包含 <code>WORKER_NOT_RUNNING</code> 里的一种时，<code>WORKER_CPU_INTENSIVE</code> 这个标记就没意义了。</p><p>ok, 那带上 <code>WQ_UNBOUND</code> 来看下：</p><p><code>alloc_workqueue</code> -&gt; <code>alloc_and_link_pwqs</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_and_link_pwqs</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> highpri = wq-&gt;flags &amp; WQ_HIGHPRI;</span><br><span class="line"><span class="type">int</span> cpu, ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND)) &#123;</span><br><span class="line">[...]</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tj: 下面是for WQ_UNBOUND</span></span><br><span class="line"><span class="keyword">if</span> (wq-&gt;flags &amp; __WQ_ORDERED) &#123;</span><br><span class="line">ret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);</span><br><span class="line"><span class="comment">/* there should only be single pwq for ordering guarantee */</span></span><br><span class="line">WARN(!ret &amp;&amp; (wq-&gt;pwqs.next != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node ||</span><br><span class="line">      wq-&gt;pwqs.prev != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node),</span><br><span class="line">     <span class="string">&quot;ordering guarantee broken for workqueue %s\n&quot;</span>, wq-&gt;name);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret = apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">apply_workqueue_attrs() -&gt; apply_workqueue_attrs_locked() -&gt; apply_wqattrs_prepare() -&gt; alloc_unbound_pwq() -&gt; get_unbound_pool()</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">get_unbound_pool()</span><br><span class="line">        |-&gt;  init_worker_pool() -&gt; set POOL_DISASSOCIATED</span><br><span class="line">        |-&gt;  create_worker() -&gt; worker_attach_to_pool -&gt; set WORKER_UNBOUND if pool flags has POOL_DISASSOCIATED</span><br></pre></td></tr></table></figure><p><code>init_worker_pool</code> 会默认 set pool 为 <code>POOL_DISASSOCIATED</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * worker_pool flags</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A bound pool is either associated or disassociated with its CPU.</span></span><br><span class="line"><span class="comment"> * While associated (!DISASSOCIATED), all workers are bound to the</span></span><br><span class="line"><span class="comment"> * CPU and none has %WORKER_UNBOUND set and concurrency management</span></span><br><span class="line"><span class="comment"> * is in effect.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * While DISASSOCIATED, the cpu may be offline and all workers have</span></span><br><span class="line"><span class="comment"> * %WORKER_UNBOUND set and concurrency management disabled, and may</span></span><br><span class="line"><span class="comment"> * be executing on any CPU.  The pool behaves as an unbound one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">[...]</span></span><br><span class="line"><span class="comment">POOL_DISASSOCIATED= 1 &lt;&lt; 2,/* cpu can&#x27;t serve workers */</span></span><br></pre></td></tr></table></figure><p><code>POOL_DISASSOCIATED</code> 就是没有并发管理了，这个 worker pool 是 unbound pool，里面所有 worker 都是 unbound worker，可以在任意 cpu 上执行。</p><p><code>create_worker</code> 会创建一个 <code>worker_thread</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> worker *<span class="title function_">create_worker</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">[...]</span><br><span class="line">worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">      <span class="string">&quot;kworker/%s&quot;</span>, id_buf);</span><br></pre></td></tr></table></figure><p>在后面的 <code>worker_attach_to_pool</code> 时会设置 <code>WORKER_UNBOUND</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">worker_attach_to_pool</span><span class="params">(<span class="keyword">struct</span> worker *worker,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">mutex_lock(&amp;wq_pool_attach_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The wq_pool_attach_mutex ensures %POOL_DISASSOCIATED remains</span></span><br><span class="line"><span class="comment"> * stable across this function.  See the comments above the flag</span></span><br><span class="line"><span class="comment"> * definition for details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;flags &amp; POOL_DISASSOCIATED)</span><br><span class="line">worker-&gt;flags |= WORKER_UNBOUND; <span class="comment">//tj: here</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">kthread_set_per_cpu(worker-&gt;task, pool-&gt;cpu);</span><br></pre></td></tr></table></figure><p>ok, 当有 work item 进来时, worker 会被唤醒处理 work item:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">__queue_work -&gt;  insert_work -&gt; wake_up_worker</span><br><span class="line"></span><br><span class="line">worker_thread -&gt; process_one_work</span><br></pre></td></tr></table></figure><p>此时，worker 的 flags 是带有 <code>WORKER_UNBOUND</code> 的，也就是这个 worker 表示 <code>WORKER_NOT_RUNNING</code>，那 cpu intensive时 <code>nr_running</code> 如下就不会递减喽。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* If transitioning into NOT_RUNNING, adjust nr_running. */</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; WORKER_NOT_RUNNING) &amp;&amp;</span><br><span class="line">    !(worker-&gt;flags &amp; WORKER_NOT_RUNNING)) &#123;</span><br><span class="line">        pool-&gt;nr_running--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>so, 点个题：<code>alloc_workqueue()</code> 的 <code>flags</code> 被设置为 <code>WQ_UNBOUND</code> 并且同时是 <code>WQ_CPU_INTENSIVE</code> 时，<code>WQ_CPU_INTENSIVE</code> 是没有发挥作用滴。</p>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpu-intensive </tag>
            
            <tag> wq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使 bpftrace:runqlat.bt 按 workqueue name 统计延迟</title>
      <link href="/how-to-support-filter-workqueue-name-in-bpftrace-runqlat.html"/>
      <url>/how-to-support-filter-workqueue-name-in-bpftrace-runqlat.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当我们想利用 ebpf 统计 task&#x2F;kworker 的调度延迟，通常有两个前端选择，一是 bcc，另一个是 bpftrace。而如果要自定义，通常选择先上手 bpftrace，因为简单。</p><p>bpftrace&#x2F;tools 下的工具 runqlat.bt 就可以统计调度延迟，只不过输出是直方图，我们希望能够像 <code>perf sched</code> 那样输出 task&#x2F;kworker 的调度延迟时间。</p><h2 id="浏览-runqlat-bt"><a href="#浏览-runqlat-bt" class="headerlink" title="浏览 runqlat.bt"></a>浏览 runqlat.bt</h2><p>先浏览下代码，参考 v0.11.4:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1 #!/usr/bin/env bpftrace</span><br><span class="line"> 2 /*</span><br><span class="line"> 3  * runqlat.bt   CPU scheduler run queue latency as a histogram.</span><br><span class="line"> 4  *              For Linux, uses bpftrace, eBPF.</span><br><span class="line"> 5  *</span><br><span class="line"> 6  * This is a bpftrace version of the bcc tool of the same name.</span><br><span class="line"> 7  *</span><br><span class="line"> 8  * Copyright 2018 Netflix, Inc.</span><br><span class="line"> 9  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;)</span><br><span class="line">10  *</span><br><span class="line">11  * 17-Sep-2018  Brendan Gregg   Created this.</span><br><span class="line">12  */</span><br><span class="line">13</span><br><span class="line">14 #include &lt;linux/sched.h&gt;</span><br><span class="line">15</span><br><span class="line">16 BEGIN</span><br><span class="line">17 &#123;</span><br><span class="line">18         printf(&quot;Tracing CPU scheduler... Hit Ctrl-C to end.\n&quot;);</span><br><span class="line">19 &#125;</span><br><span class="line">20</span><br><span class="line">21 tracepoint:sched:sched_wakeup,</span><br><span class="line">22 tracepoint:sched:sched_wakeup_new</span><br><span class="line">23 &#123;</span><br><span class="line">24         @qtime[args-&gt;pid] = nsecs;</span><br><span class="line">25 &#125;</span><br><span class="line">26</span><br><span class="line">27 tracepoint:sched:sched_switch</span><br><span class="line">28 &#123;</span><br><span class="line">29         if (args-&gt;prev_state == TASK_RUNNING) &#123;</span><br><span class="line">30                 @qtime[args-&gt;prev_pid] = nsecs;</span><br><span class="line">31         &#125;</span><br><span class="line">32</span><br><span class="line">33         $ns = @qtime[args-&gt;next_pid];</span><br><span class="line">34         if ($ns) &#123;</span><br><span class="line">35                 @usecs = hist((nsecs - $ns) / 1000);</span><br><span class="line">36         &#125;</span><br><span class="line">37         delete(@qtime[args-&gt;next_pid]);</span><br><span class="line">38 &#125;</span><br><span class="line">39</span><br><span class="line">40 END</span><br><span class="line">41 &#123;</span><br><span class="line">42         clear(@qtime);</span><br><span class="line">43 &#125;</span><br></pre></td></tr></table></figure><p>行数不多，看上去也很简单，对于首次接触 bpftrace 的这段代码主要盲点: <code>args/@/$/nsecs/hist/delete/clear/BEGIN/END</code>。</p><p>先运行下看看：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@localhost:/bpftrace# bpftrace tools/runqlat.bt</span><br><span class="line">Attaching 5 probes...</span><br><span class="line">Tracing CPU scheduler... Hit Ctrl-C to end.</span><br><span class="line">^C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@usecs:</span><br><span class="line">[2, 4)               236 |@@@@@@@@@                                           |</span><br><span class="line">[4, 8)              1109 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      |</span><br><span class="line">[8, 16)             1246 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|</span><br><span class="line">[16, 32)             772 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    |</span><br><span class="line">[32, 64)             233 |@@@@@@@@@                                           |</span><br><span class="line">[64, 128)            318 |@@@@@@@@@@@@@                                       |</span><br><span class="line">[128, 256)           147 |@@@@@@                                              |</span><br><span class="line">[256, 512)            42 |@                                                   |</span><br><span class="line">[512, 1K)             52 |@@                                                  |</span><br><span class="line">[1K, 2K)              22 |                                                    |</span><br><span class="line">[2K, 4K)               7 |                                                    |</span><br></pre></td></tr></table></figure><p>这些输出是怎么产生的？带着这些疑问来认识 bpftrace。</p><h2 id="了解-bpftrace-语言"><a href="#了解-bpftrace-语言" class="headerlink" title="了解 bpftrace 语言"></a>了解 bpftrace 语言</h2><p>基本语法就是：<code>probe[,probe,...] /filter/ &#123; action &#125;</code></p><p>probe 可以有多种，比如这里的 traceponit，action 可以有多个，filter 是过滤条件，可写可不写，看情况。</p><ul><li>@, $</li></ul><p>代表变量类型，<code>@</code> 表示全局 (map variables)，而 <code>$</code> 表示 scratch variables(栈变量？)</p><p><code>@[]</code> 表示关联数组，它是 map variable 的变体，格式 <code>@array_name[key_name, key_name2, ...] = value</code>, 类似 hash or Python Dict：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Dict = &#123;1: <span class="string">&#x27;Geeks&#x27;</span>, 2: <span class="string">&#x27;For&#x27;</span>, 3: <span class="string">&#x27;Geeks&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt; Dict</span><br><span class="line">&#123;1: <span class="string">&#x27;Geeks&#x27;</span>, 2: <span class="string">&#x27;For&#x27;</span>, 3: <span class="string">&#x27;Geeks&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt; Dict[1]</span><br><span class="line"><span class="string">&#x27;Geeks&#x27;</span></span><br><span class="line">&gt;&gt;&gt; Dict[2]</span><br><span class="line"><span class="string">&#x27;For&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>args</li></ul><p>docs&#x2F;tutorial_one_liners.md:</p><blockquote><p><code>args</code> is a pointer to a struct containing all the tracepoint arguments. This<br>struct is automatically generated by bpftrace based tracepoint information.</p></blockquote><p><code>args</code> 是一个指针，指向该 tracepoint 的所有参数。这个结构是由 bpftrace 根据 tracepoint 信息自动生成。</p><p>可以用如下命令找出这个结构：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:/<span class="comment"># bpftrace -vl &#x27;tracepoint:sched:sched_wakeup&#x27;</span></span><br><span class="line">tracepoint:<span class="built_in">sched</span>:sched_wakeup</span><br><span class="line">    char <span class="built_in">comm</span>[16];</span><br><span class="line">    pid_t pid;</span><br><span class="line">    int prio;</span><br><span class="line">    int success;</span><br><span class="line">    int target_cpu;</span><br><span class="line">    long state;</span><br></pre></td></tr></table></figure><p>再看下 wakeup tracepoint code:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ttwu_do_wakeup</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> wake_flags,</span></span><br><span class="line"><span class="params">                           <span class="keyword">struct</span> rq_flags *rf)</span></span><br><span class="line">&#123;</span><br><span class="line">        check_preempt_curr(rq, p, wake_flags);</span><br><span class="line">        p-&gt;state = TASK_RUNNING;</span><br><span class="line">        trace_sched_wakeup(p);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_EVENT(sched_wakeup_template, sched_wakeup,</span><br><span class="line">             TP_PROTO(<span class="keyword">struct</span> task_struct *p),</span><br><span class="line">             TP_ARGS(p));</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_EVENT_CLASS(sched_wakeup_template,</span><br><span class="line"></span><br><span class="line">        TP_PROTO(<span class="keyword">struct</span> task_struct *p),</span><br><span class="line"></span><br><span class="line">        TP_ARGS(__perf_task(p)),</span><br><span class="line"></span><br><span class="line">        TP_STRUCT__entry(</span><br><span class="line">                __array(        <span class="type">char</span>,   comm,   TASK_COMM_LEN   )</span><br><span class="line">                __field(        <span class="type">pid_t</span>,  pid                     )</span><br><span class="line">                __field(        <span class="type">int</span>,    prio                    )</span><br><span class="line">                __field(        <span class="type">int</span>,    success                 )</span><br><span class="line">                __field(        <span class="type">int</span>,    target_cpu              )</span><br><span class="line">        ),</span><br></pre></td></tr></table></figure><p>到这里就清晰了，这个 <code>args</code> 就指向 <code>TP_STRUCT__entry</code>。</p><ul><li>nsecs</li></ul><p>内置变量，里面用的是 <code>&#123;bpf_&#125;ktime_get_ns()</code>。</p><ul><li>BEGIN, END</li></ul><blockquote><p>These are special built-in events provided by the bpftrace runtime. BEGIN is triggered before all other probes are attached. END is triggered after all other probes are detached.</p></blockquote><p>内置probe，管开头和结束。</p><ul><li>delete&#x2F;clear&#x2F;hist</li></ul><p>都是内置 map functions，map 是一种特殊的 data type，除了用作 variable 外，还可以用来存储直方图（调用hist） 等。</p><p><code>delete</code> 是从 map 里删除一个 key，所以要指定 key，比如上面的 <code>delete(@qtime[args-&gt;next_pid])</code>，</p><p>而 <code>clear</code> 是清除 map 里所有 keys&#x2F;values, 所以语法是 <code>clear(map m)</code>, 比如上面的 <code>clear(@qtime)</code>。</p><p>bpftrace 退出时所有的 maps 都会打印出来, 不想打就在 END block 里加上 <code>clear</code>。</p><p>ok, 在了解下这些基本语言规则后，我们来修改这个 bt 文件。</p><h2 id="修改-runqlat-bt"><a href="#修改-runqlat-bt" class="headerlink" title="修改 runqlat.bt"></a>修改 runqlat.bt</h2><p>调度延迟的时间就是从 wakeup 开始一直到 start running 这个时间点。</p><p>wakeup 时记录 wakeup time 到 <code>@qtimes[task_id]</code> 里，而在 switch 时，用 <code>nsecs</code> 减去这个 wakeup 的时间(前提要存在)就是这个 task 的调度延迟。</p><p>来看下 kernel <code>trace_sched_switch()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TRACE_EVENT(sched_switch,</span><br><span class="line"></span><br><span class="line">        TP_PROTO(<span class="type">bool</span> preempt,</span><br><span class="line">                 <span class="keyword">struct</span> task_struct *prev,</span><br><span class="line">                 <span class="keyword">struct</span> task_struct *next),</span><br><span class="line"></span><br><span class="line">        TP_ARGS(preempt, prev, next),</span><br><span class="line"></span><br><span class="line">        TP_STRUCT__entry(</span><br><span class="line">                __array(        <span class="type">char</span>,   prev_comm,      TASK_COMM_LEN   )</span><br><span class="line">                __field(        <span class="type">pid_t</span>,  prev_pid                        )</span><br><span class="line">                __field(        <span class="type">int</span>,    prev_prio                       )</span><br><span class="line">                __field(        <span class="type">long</span>,   prev_state                      )</span><br><span class="line">                __array(        <span class="type">char</span>,   next_comm,      TASK_COMM_LEN   )</span><br><span class="line">                __field(        <span class="type">pid_t</span>,  next_pid                        )</span><br><span class="line">                __field(        <span class="type">int</span>,    next_prio                       )</span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">        TP_fast_assign(</span><br><span class="line">                <span class="built_in">memcpy</span>(__entry-&gt;next_comm, next-&gt;comm, TASK_COMM_LEN);</span><br><span class="line">                __entry-&gt;prev_pid       = prev-&gt;pid;</span><br><span class="line">                __entry-&gt;prev_prio      = prev-&gt;prio;</span><br><span class="line">                __entry-&gt;prev_state     = __trace_sched_switch_state(preempt, prev);</span><br><span class="line">                <span class="built_in">memcpy</span>(__entry-&gt;prev_comm, prev-&gt;comm, TASK_COMM_LEN);</span><br><span class="line">                __entry-&gt;next_pid       = next-&gt;pid;</span><br><span class="line">                __entry-&gt;next_prio      = next-&gt;prio;</span><br></pre></td></tr></table></figure><p>我们关心的是 <code>prev_comm</code> 和 <code>next_comm</code>，<code>next</code> 是即将 running 的 task，所以 switch block 可以改成：</p><figure class="highlight patch"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        $ns = @qtime[args-&gt;next_pid];</span><br><span class="line">        if ($ns) &#123;</span><br><span class="line"><span class="deletion">-               @usecs = hist((nsecs - $ns) / 1000);</span></span><br><span class="line"><span class="addition">+               @uesc[args-&gt;next_comm] = ((nsecs - $ns) / 1000);</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这样就输出所有 tasks 的调度延迟了，效果如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Attaching 5 probes...</span><br><span class="line">Tracing CPU scheduler... Hit Ctrl-C to end.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@usecs[ksoftirqd/6]: 14</span><br><span class="line">@usecs[swapper/2]: 14</span><br><span class="line">@usecs[swapper/1]: 17</span><br><span class="line">@usecs[swapper/0]: 17</span><br><span class="line">@usecs[kworker/7:1]: 32</span><br><span class="line">@usecs[swapper/6]: 42</span><br><span class="line">@usecs[kworker/6:1]: 50</span><br><span class="line">@usecs[kworker/3:2]: 57</span><br></pre></td></tr></table></figure><p>因为要 Ctrl-c 才终止，把 <code>bpftrace tools/runqlat.bt</code> 输出重定向到文本，<code>grep kworker</code> 搜索这个文本即可完成 kworker 统计。</p><p>那代码要支持过滤 kworker 怎么写了？高版本有字符串包含，这个版本只有 <code>strncmp</code>，修改如下:</p><figure class="highlight patch"><table><tr><td class="code"><pre><span class="line"> tracepoint:sched:sched_wakeup_new</span><br><span class="line"> &#123;</span><br><span class="line"><span class="deletion">-       @qtime[args-&gt;pid] = nsecs;</span></span><br><span class="line"><span class="addition">+       if (!strncmp(args-&gt;comm, &quot;kworker&quot;, 7)) &#123;</span></span><br><span class="line"><span class="addition">+               @qtime[args-&gt;pid] = nsecs;</span></span><br><span class="line"><span class="addition">+       &#125;</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> tracepoint:sched:sched_switch</span><br><span class="line"> &#123;</span><br><span class="line">        if (args-&gt;prev_state == TASK_RUNNING) &#123;</span><br><span class="line"><span class="deletion">-               @qtime[args-&gt;prev_pid] = nsecs;</span></span><br><span class="line"><span class="addition">+               if (!strncmp(args-&gt;prev_comm, &quot;kworker&quot;, 7)) &#123;</span></span><br><span class="line"><span class="addition">+                       @qtime[args-&gt;prev_pid] = nsecs;</span></span><br><span class="line"><span class="addition">+               &#125;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这样一次性统计所有 kworker 的调度延迟，我们跑下看看：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Attaching 5 probes...</span><br><span class="line">Tracing CPU scheduler... Hit Ctrl-C to end.</span><br><span class="line">^C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@usecs[kworker/3:2]: 40</span><br><span class="line">@usecs[kworker/u17:2]: 44</span><br><span class="line">@usecs[kworker/7:1]: 64</span><br><span class="line">@usecs[kworker/u16:14]: 81</span><br><span class="line">@usecs[kworker/6:1]: 92</span><br><span class="line">@usecs[kworker/u16:5]: 120</span><br><span class="line">@usecs[kworker/u16:7]: 121</span><br><span class="line">@usecs[kworker/u16:1]: 124</span><br></pre></td></tr></table></figure><p>怎么没有 workqueue name? 方括号里的显示来自 <code>args-&gt;next_comm</code>，也就是入参 <code>next</code> 的 <code>comm</code>，来看 kernel 部分(大概还有一半-)。</p><p>btw: 看了下最新的 Linux 6.3rc 也不支持。</p>]]></content>
      
      
      <categories>
          
          <category> ebpf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bpftrace </tag>
            
            <tag> runqlat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使 perf sched 支持 workqueue name</title>
      <link href="/how-to-support-workqueue-name-for-perf-sched.html"/>
      <url>/how-to-support-workqueue-name-for-perf-sched.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>workqueue name 就是 <code>alloc_workqueue</code> 的第一个参数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * alloc_workqueue - allocate a workqueue</span></span><br><span class="line"><span class="comment"> * @fmt: printf format for the name of the workqueue</span></span><br><span class="line"><span class="comment">[...]</span></span><br><span class="line"><span class="comment">#define alloc_workqueue(fmt, flags, max_active, args...)                \</span></span><br></pre></td></tr></table></figure><p>前文已经说过如何使用 <code>perf sched</code> 来统计 task 调度延迟，但是如下图 workqueue name 被剪掉了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-----------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Task                  |   Runtime ms  | Switches | Average delay ms | Maximum delay ms | Maximum delay at       |</span><br><span class="line">-----------------------------------------------------------------------------------------------------------------</span><br><span class="line"> kworker/4:2-eve:404   |     88.386 ms |      207 | avg:    0.248 ms | max:   12.380 ms | max at:    271.002611 s</span><br><span class="line"> kworker/u16:18-:1499  |     36.641 ms |      681 | avg:    0.081 ms | max:    4.086 ms | max at:    269.173878 s</span><br><span class="line"> kworker/u16:17-:1498  |     21.918 ms |      511 | avg:    0.080 ms | max:    2.706 ms | max at:    272.811798 s</span><br><span class="line"> kworker/u16:19-:1500  |     41.742 ms |      713 | avg:    0.077 ms | max:    4.098 ms | max at:    272.342235 s</span><br></pre></td></tr></table></figure><p>那如何显示完整name了？我们直接看 perf 源码(kernel 4.19)。</p><h2 id="perf-源码分析"><a href="#perf-源码分析" class="headerlink" title="perf 源码分析"></a>perf 源码分析</h2><p>打印入口：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">perf_sched__lat</span><span class="params">(<span class="keyword">struct</span> perf_sched *sched)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">        setup_pager();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (perf_sched__read_events(sched))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        perf_sched__merge_lat(sched);</span><br><span class="line">        perf_sched__sort_lat(sched);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n -----------------------------------------------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  Task                  |   Runtime ms  | Switches | Average delay ms | Maximum delay ms | Maximum delay at       |\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; -----------------------------------------------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        next = rb_first(&amp;sched-&gt;sorted_atom_root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (next) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">work_atoms</span> *<span class="title">work_list</span>;</span></span><br><span class="line"></span><br><span class="line">                work_list = rb_entry(next, <span class="keyword">struct</span> work_atoms, node);</span><br><span class="line">                output_lat_thread(sched, work_list);</span><br><span class="line">                next = rb_next(next);</span><br><span class="line">                thread__zput(work_list-&gt;thread);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>应该是 <code>output_lat_thread()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">output_lat_thread</span><span class="params">(<span class="keyword">struct</span> perf_sched *sched, <span class="keyword">struct</span> work_atoms *work_list)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        u64 avg;</span><br><span class="line">        <span class="type">char</span> max_lat_at[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!work_list-&gt;nb_atoms)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ignore idle threads:</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(thread__comm_str(work_list-&gt;thread), <span class="string">&quot;swapper&quot;</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        sched-&gt;all_runtime += work_list-&gt;total_runtime;</span><br><span class="line">        sched-&gt;all_count   += work_list-&gt;nb_atoms;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (work_list-&gt;num_merged &gt; <span class="number">1</span>)</span><br><span class="line">                ret = <span class="built_in">printf</span>(<span class="string">&quot;  %s:(%d) &quot;</span>, thread__comm_str(work_list-&gt;thread), work_list-&gt;num_merged);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                ret = <span class="built_in">printf</span>(<span class="string">&quot;  %s:%d &quot;</span>, thread__comm_str(work_list-&gt;thread), work_list-&gt;thread-&gt;tid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">24</span> - ret; i++)</span><br></pre></td></tr></table></figure><p>所以，那个 workqueue name 应该是来自 <code>thread__comm_str(work_list-&gt;thread)</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">thread__comm_str</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> thread *thread)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *str;</span><br><span class="line"></span><br><span class="line">        down_read((<span class="keyword">struct</span> rw_semaphore *)&amp;thread-&gt;comm_lock);</span><br><span class="line">        str = __thread__comm_str(thread);</span><br><span class="line">        up_read((<span class="keyword">struct</span> rw_semaphore *)&amp;thread-&gt;comm_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *__thread__comm_str(<span class="type">const</span> <span class="keyword">struct</span> thread *thread)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">comm</span> *<span class="title">comm</span> =</span> thread__comm(thread);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!comm)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> comm__str(comm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> comm *<span class="title function_">thread__comm</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> thread *thread)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;thread-&gt;comm_list))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list_first_entry(&amp;thread-&gt;comm_list, <span class="keyword">struct</span> comm, <span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>啊，原来是<code>thread</code>里有个链表 <code>comm_list</code>，从这个表里取出<code>comm</code> -&gt; <code>comm__str(comm)</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">comm__str</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> comm *comm)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> comm-&gt;comm_str-&gt;str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概看下 <code>struct comm</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comm_str</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comm</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">comm_str</span> *<span class="title">comm_str</span>;</span></span><br><span class="line">        u64 start;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">        <span class="type">bool</span> exec;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span> <span class="comment">/* Tool specific area */</span></span><br><span class="line">                <span class="type">void</span>    *priv;</span><br><span class="line">                u64     db_id;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>util&#x2F;comm.c里：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comm_str</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> *str;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span></span><br><span class="line">        <span class="type">refcount_t</span> refcnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>能看到 <code>str</code> 是一个 char * 的指针，那啥时候分配的？分配里不是有大小吗？这个comm.c文件里就有分配实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> comm_str *<span class="title function_">comm_str__alloc</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">comm_str</span> *<span class="title">cs</span>;</span></span><br><span class="line"></span><br><span class="line">        cs = zalloc(<span class="keyword">sizeof</span>(*cs));</span><br><span class="line">        <span class="keyword">if</span> (!cs)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        cs-&gt;str = strdup(str); <span class="comment">//tj: here</span></span><br><span class="line">        <span class="keyword">if</span> (!cs-&gt;str) &#123;</span><br><span class="line">                <span class="built_in">free</span>(cs);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        refcount_set(&amp;cs-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是按照入参<code>str</code>的长度来分配的，继续跟。</p><p>有两个caller: <code>comm__new</code> 和 <code>comm__override</code>，看下 <code>comm__new</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> thread *<span class="title function_">thread__new</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> tid)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> *comm_str;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">comm</span> *<span class="title">comm</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">thread</span> =</span> zalloc(<span class="keyword">sizeof</span>(*thread));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                thread-&gt;pid_ = pid;</span><br><span class="line">                thread-&gt;tid = tid;</span><br><span class="line">                thread-&gt;ppid = <span class="number">-1</span>;</span><br><span class="line">                thread-&gt;cpu = <span class="number">-1</span>;</span><br><span class="line">                INIT_LIST_HEAD(&amp;thread-&gt;namespaces_list);</span><br><span class="line">                INIT_LIST_HEAD(&amp;thread-&gt;comm_list);</span><br><span class="line">                init_rwsem(&amp;thread-&gt;namespaces_lock);</span><br><span class="line">                init_rwsem(&amp;thread-&gt;comm_lock);</span><br><span class="line"></span><br><span class="line">                comm_str = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">                <span class="keyword">if</span> (!comm_str)</span><br><span class="line">                        <span class="keyword">goto</span> err_thread;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">snprintf</span>(comm_str, <span class="number">32</span>, <span class="string">&quot;:%d&quot;</span>, tid); <span class="comment">//tj: here</span></span><br><span class="line">                comm = comm__new(comm_str, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">                <span class="built_in">free</span>(comm_str);</span><br><span class="line">                <span class="keyword">if</span> (!comm)</span><br><span class="line">                        <span class="keyword">goto</span> err_thread;</span><br><span class="line"></span><br><span class="line">                list_add(&amp;comm-&gt;<span class="built_in">list</span>, &amp;thread-&gt;comm_list);</span><br></pre></td></tr></table></figure><p>分配了32个字节，应该够了，那实际用了多少？也就是这个 <code>str</code> 是如何被填入的，那就是 <code>sched record</code>喽。回头再看下相关code：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_atom</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">list</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">thread_state</span>       <span class="title">state</span>;</span></span><br><span class="line">        u64                     sched_out_time;</span><br><span class="line">        u64                     wake_up_time;</span><br><span class="line">        u64                     sched_in_time;</span><br><span class="line">        u64                     runtime;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_atoms</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">work_list</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thread</span>           *<span class="title">thread</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>          <span class="title">node</span>;</span></span><br><span class="line">        u64                     max_lat;</span><br><span class="line">        u64                     max_lat_at;</span><br><span class="line">        u64                     total_lat;</span><br><span class="line">        u64                     nb_atoms;</span><br><span class="line">        u64                     total_runtime;</span><br><span class="line">        <span class="type">int</span>                     num_merged;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每一个 <code>struct work_atom</code> 定义的work都有相应的行为成员，<code>work_atom</code>的<code>list</code>用来关联到<code>work_atoms</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_add_tail(&amp;atom-&gt;<span class="built_in">list</span>, &amp;atoms-&gt;work_list);</span><br></pre></td></tr></table></figure><p>看下<code>work_atoms</code>里的<code>thread</code>，这个 <code>thread</code> 里有个 <code>comm_list</code>，除了上文提到的<code>thread_new()</code>会add 一个comm到这个list以外，还有：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> ____thread__set_comm(<span class="keyword">struct</span> thread *thread, <span class="type">const</span> <span class="type">char</span> *str,</span><br><span class="line">                                u64 timestamp, <span class="type">bool</span> exec)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">comm</span> *<span class="title">new</span>, *<span class="title">curr</span> =</span> thread__comm(thread);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Override the default :tid entry */</span></span><br><span class="line">        <span class="keyword">if</span> (!thread-&gt;comm_set) &#123;</span><br><span class="line">                <span class="type">int</span> err = comm__override(curr, str, timestamp, exec);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                new = comm__new(str, timestamp, exec);</span><br><span class="line">                <span class="keyword">if</span> (!new)</span><br><span class="line">                        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">                list_add(&amp;new-&gt;<span class="built_in">list</span>, &amp;thread-&gt;comm_list); <span class="comment">//tj: here</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (exec)</span><br><span class="line">                        unwind__flush_access(thread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        thread-&gt;comm_set = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if <code>comm_set</code>过了，就new一个comm。read这个set code的分支有点多，我们借用<code>dump_stack()</code>看下运行时：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+++ b/tools/perf/util/thread.c</span><br><span class="line">@@ <span class="number">-218</span>,<span class="number">6</span> +<span class="number">218</span>,<span class="number">8</span> @@ <span class="type">static</span> <span class="type">int</span> ____thread__set_comm(<span class="keyword">struct</span> thread *thread, <span class="type">const</span> <span class="type">char</span> *str,</span><br><span class="line"> &#123;</span><br><span class="line">        <span class="keyword">struct</span> comm *new, *curr = thread__comm(thread);</span><br><span class="line"></span><br><span class="line">+       dump_stack();</span><br></pre></td></tr></table></figure><p>能追到：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cmd_record &gt; perf_session__process_events -&gt; perf_session__deliver_event -&gt;machines__deliver_event-&gt; machine__process_comm_event</span><br></pre></td></tr></table></figure><p>前面几个都ok，中间有个machines__deliver_event是怎么调到machine__process_comm_event的呢？来看下。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">machines__deliver_event</span><span class="params">(<span class="keyword">struct</span> machines *machines,</span></span><br><span class="line"><span class="params">                                   <span class="keyword">struct</span> perf_evlist *evlist,</span></span><br><span class="line"><span class="params">                                   <span class="keyword">union</span> perf_event *event,</span></span><br><span class="line"><span class="params">                                   <span class="keyword">struct</span> perf_sample *sample,</span></span><br><span class="line"><span class="params">                                   <span class="keyword">struct</span> perf_tool *tool, u64 file_offset)</span></span><br><span class="line">&#123;</span><br><span class="line">[...]</span><br><span class="line">        <span class="keyword">switch</span> (event-&gt;header.type) &#123;</span><br><span class="line">[...]</span><br><span class="line">        <span class="keyword">case</span> PERF_RECORD_COMM:</span><br><span class="line">                <span class="keyword">return</span> tool-&gt;comm(tool, event, sample, machine);</span><br></pre></td></tr></table></figure><p>应该是这里，用了一个callback，看下builtin-sched.c&#x2F;cmd sched:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmd_sched</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> default_sort_order[] = <span class="string">&quot;avg, max, switch, runtime&quot;</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">perf_sched</span> <span class="title">sched</span> =</span> &#123;</span><br><span class="line">                .tool = &#123;</span><br><span class="line">                        .sample          = perf_sched__process_tracepoint_sample,</span><br><span class="line">                        .comm            = perf_sched__process_comm, <span class="comment">//tj: here</span></span><br></pre></td></tr></table></figure><p>see? 这里有个tool的comm (<code>perf_sched__process_comm</code>)，直觉告诉我就是它:)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">perf_sched__process_comm</span><span class="params">(<span class="keyword">struct</span> perf_tool *tool __maybe_unused,</span></span><br><span class="line"><span class="params">                                    <span class="keyword">union</span> perf_event *event,</span></span><br><span class="line"><span class="params">                                    <span class="keyword">struct</span> perf_sample *sample,</span></span><br><span class="line"><span class="params">                                    <span class="keyword">struct</span> machine *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thread_runtime</span> *<span class="title">tr</span>;</span></span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">        err = perf_event__process_comm(tool, event, sample, machine);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">perf_event__process_comm</span><span class="params">(<span class="keyword">struct</span> perf_tool *tool __maybe_unused,</span></span><br><span class="line"><span class="params">                             <span class="keyword">union</span> perf_event *event,</span></span><br><span class="line"><span class="params">                             <span class="keyword">struct</span> perf_sample *sample,</span></span><br><span class="line"><span class="params">                             <span class="keyword">struct</span> machine *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> machine__process_comm_event(machine, event, sample);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rt? 到这里整个call stack就清楚了。现在应该知道怎么改了，如果还不知道，check below:</p>]]></content>
      
      
      <categories>
          
          <category> perf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> perf </tag>
            
            <tag> wq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 adeb 在 Android 上编译安装 bcc</title>
      <link href="/use-adeb-to-install-bcc-for-android.html"/>
      <url>/use-adeb-to-install-bcc-for-android.html</url>
      
        <content type="html"><![CDATA[<h2 id="先科普下-BCC"><a href="#先科普下-BCC" class="headerlink" title="先科普下 BCC"></a>先科普下 BCC</h2><p>BCC 官方：</p><blockquote><p>BCC is a toolkit for creating efficient kernel tracing and manipulation programs, and includes several useful tools and examples. It makes use of extended BPF (Berkeley Packet Filters), formally known as eBPF, a new feature that was first added to Linux 3.15. Much of what BCC uses requires Linux 4.1 and above.</p></blockquote><p>BCC 利用 eBPF 跟踪和操纵内核, 里面有很多工具。</p><p>Wiki eBPF:</p><blockquote><p>eBPF was built on top of the Berkeley Packet Filter (cBPF). At the lowest level, it introduced the use of ten 64-bit registers (instead of two 32-bit long registers for cBPF), different jump semantics, a call instruction and corresponding register passing convention, new instructions, and a different encoding for these instructions.[12] A number of additional features were subsequently added.</p></blockquote><p>eBPF 就是 BPF 的扩展版。</p><p>Wiki BPF 描述：</p><blockquote><p>BPF supports filtering packets, allowing a userspace process to supply a filter program that specifies which packets it wants to receive. For example, a tcpdump process may want to receive only packets that initiate a TCP connection. BPF returns only packets that pass the filter that the process supplies. This avoids copying unwanted packets from the operating system kernel to the process, greatly improving performance. The filter program is in the form of instructions for a virtual machine, which are interpreted, or compiled into machine code by a just-in-time (JIT) mechanism and executed, in the kernel.</p></blockquote><p>BPF 就是跑在内核里的虚拟机，使用 JIT 编译机制，最早用来过滤报文的。</p><p>Wiki JIT 编译解释：</p><blockquote><p>In computing, just-in-time (JIT) compilation (also dynamic translation or run-time compilations)<a href="https://tjtech.me/usr/uploads/2023/02/1630767984.png#center">1</a> is a way of executing computer code that involves compilation during execution of a program (at run time) rather than before execution</p></blockquote><p>JIT 是运行时编译。</p><blockquote><p>JIT compilation is a combination of the two traditional approaches to translation to machine code—ahead-of-time compilation (AOT), and interpretation—and combines some advantages and drawbacks of both.[2] </p></blockquote><p>Wiki AOT 编译：</p><blockquote><p>In computer science, ahead-of-time compilation (AOT compilation) is the act of compiling an (often) higher-level programming language into an (often) lower-level language before execution of a program, usually at build-time, to reduce the amount of work needed to be performed at run time.<br>AOT 编译是运行前编译 (like gcc)。</p></blockquote><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>在 Android 上运行 BCC 可以选择安装 adeb，参考 <a href="https://github.com/joelagnel/adeb/">https://github.com/joelagnel/adeb/</a> (不过现在不维护了，此为后话)</p><p>按官方文档 adeb prepare –build –bcc 带 BCC 编译安装时有如下错误，主机是 Ubuntu 18.04，板子安卓11, 内核 4.14。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">error: could not lock config file /home/tj/.gitconfig: No such file or directory</span><br><span class="line">CMake Warning at CMakeLists.txt:29 (message):</span><br><span class="line">  Failed to add root source directory to safe.directory</span><br></pre></td></tr></table></figure><p>这个半天没发现怎么 fix，转变思路，尝试直接从 BCC 源码编译，不过有如下错误：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/home/tj/code/bcc/src/cc/bpf_module.cc: In member function ‘virtual void ebpf::MyMemoryManager::notifyObjectLoaded(llvm::ExecutionEngine*, const llvm::object::ObjectFile&amp;)’:</span><br><span class="line">/home/tj/code/bcc/src/cc/bpf_module.cc:121:46: error: no matching function for call to ‘llvm::object::SectionRef::getName() const’</span><br></pre></td></tr></table></figure><p>是最新版本 BCC 不支持 llvm6 了，可以使用版本 v0.24.0，编译果然没问题（也没有上面那个不能lock的问题），那直接把 adeb build 脚本改成这样最直接：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">diff --git a/buildstrap b/buildstrap</span><br><span class="line">index bdbc554..a25e67c 100755</span><br><span class="line">--- a/buildstrap</span><br><span class="line">+++ b/buildstrap</span><br><span class="line">@@ -61,7 +61,7 @@ echo &quot;nameserver 4.2.2.2&quot; &gt; $OUT_TMP/etc/resolv.conf</span><br><span class="line"></span><br><span class="line"> # Clone BCC if needed</span><br><span class="line"> if [ $INSTALL_BCC -eq 1 ]; then</span><br><span class="line">-       git clone https://github.com/iovisor/bcc.git $TDIR/debian/bcc-master</span><br><span class="line">+       git clone -b v0.24.0 https://github.com/iovisor/bcc.git $TDIR/debian/bcc-master</span><br><span class="line">        cp $spath/bcc/build-bcc.sh $TDIR/debian/bcc-master/</span><br><span class="line">        chroot $OUT_TMP /bcc-master/build-bcc.sh</span><br></pre></td></tr></table></figure><p>或者自行 checkout，clean 下 if needed. 一路下来，没有问题，能看到 bcc tools 已经安装上了:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-- Installing: /usr/share/bcc/tools/javastat</span><br><span class="line">-- Installing: /usr/share/bcc/tools/javathreads</span><br><span class="line">-- Installing: /usr/share/bcc/tools/nodegc</span><br><span class="line">-- Installing: /usr/share/bcc/tools/nodestat</span><br><span class="line">-- Installing: /usr/share/bcc/tools/perlcalls</span><br><span class="line">-- Installing: /usr/share/bcc/tools/perlflow</span><br></pre></td></tr></table></figure><p>ok, 我们跑个工具看下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:/<span class="comment"># opensnoop</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/share/bcc/tools/opensnoop&quot;</span>, line 19, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from bcc import ArgString, BPF</span><br><span class="line">ImportError: No module named bcc</span><br></pre></td></tr></table></figure><p>少东西，默认安装的的 Debian buster，换个国内的源 (&#x2F;etc&#x2F;apt&#x2F;sources.list)，我用的 163:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.163.com/debian/ buster main non-free contrib</span><br><span class="line">deb http://mirrors.163.com/debian/ buster-updates main non-free contrib</span><br><span class="line">deb http://mirrors.163.com/debian/ buster-backports main non-free contrib</span><br><span class="line">deb http://mirrors.163.com/debian-security/ buster/updates main non-free contrib</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.163.com/debian/ buster main non-free contrib</span><br><span class="line">deb-src http://mirrors.163.com/debian/ buster-updates main non-free contrib</span><br><span class="line">deb-src http://mirrors.163.com/debian/ buster-backports main non-free contrib</span><br><span class="line">deb-src http://mirrors.163.com/debian-security/ buster/updates main non-free contrib</span><br></pre></td></tr></table></figure><p>Android 系统连上网络后 <code>apt-get update</code> 更新没错后安装:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install python-bpfcc</span><br></pre></td></tr></table></figure><p>不过这个竟然有错误：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Err:1 http://mirrors.163.com/debian buster/main arm64 libbpfcc arm64 0.8.0-4</span><br><span class="line">  Temporary failure resolving &#x27;mirrors.163.com&#x27;</span><br><span class="line">Get:2 http://mirrors.163.com/debian buster/main arm64 python-bpfcc all 0.8.0-4 [29.4 kB]</span><br><span class="line">Fetched 29.4 kB in 11s (2710 B/s)</span><br><span class="line">E: Failed to fetch http://mirrors.163.com/debian/pool/main/b/bpfcc/libbpfcc_0.8.0-4_arm64.deb  Temporary failure resolving &#x27;mirrors.163.com&#x27;</span><br><span class="line">E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?</span><br></pre></td></tr></table></figure><p>按提示用下面这个修复就好了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install python-bpfcc --fix-missing</span><br></pre></td></tr></table></figure><p>最近 chatgpt 比较火，我也问了下，相比 web search，还是比较高效的。</p><p><img src="https://tjtech.me/usr/uploads/2023/02/1630767984.png#center" alt="chat-no-module-bcc.png"></p><p>再次运行出错如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:/<span class="comment"># opensnoop</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/share/bcc/tools/opensnoop&quot;</span>, line 19, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from bcc import ArgString, BPF</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python2.7/dist-packages/bcc/__init__.py&quot;</span>, line 27, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from .libbcc import lib, bcc_symbol, bcc_symbol_option, _SYM_CB_TYPE</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python2.7/dist-packages/bcc/libbcc.py&quot;</span>, line 20, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    lib.bpf_module_create_b.restype = ct.c_void_p</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python2.7/ctypes/__init__.py&quot;</span>, line 379, <span class="keyword">in</span> __getattr__</span><br><span class="line">    func = self.__getitem__(name)</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python2.7/ctypes/__init__.py&quot;</span>, line 384, <span class="keyword">in</span> __getitem__</span><br><span class="line">    func = self._FuncPtr((name_or_ordinal, self))</span><br><span class="line">AttributeError: /usr/lib/aarch64-linux-gnu/libbcc.so.0: undefined symbol: bpf_module_create_b</span><br></pre></td></tr></table></figure><p>是 python 默认版本 2.x 导致，切到 3.x：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:/<span class="comment"># update-alternatives --install /usr/bin/python python /usr/bin/python2 1</span></span><br><span class="line">update-alternatives: using /usr/bin/python2 to provide /usr/bin/python (python) <span class="keyword">in</span> auto mode</span><br><span class="line">root@localhost:/<span class="comment"># update-alternatives --install /usr/bin/python python /usr/bin/python3 2</span></span><br><span class="line">update-alternatives: using /usr/bin/python3 to provide /usr/bin/python (python) <span class="keyword">in</span> auto mode</span><br><span class="line">root@localhost:/<span class="comment"># update-alternatives --config python</span></span><br><span class="line">There are 2 choices <span class="keyword">for</span> the alternative python (providing /usr/bin/python).</span><br><span class="line"></span><br><span class="line">  Selection    Path              Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">* 0            /usr/bin/python3   2         auto mode</span><br><span class="line">  1            /usr/bin/python2   1         manual mode</span><br><span class="line">  2            /usr/bin/python3   2         manual mode</span><br><span class="line"></span><br><span class="line">Press &lt;enter&gt; to keep the current choice[*], or <span class="built_in">type</span> selection number: 2</span><br><span class="line">root@localhost:/<span class="comment">#</span></span><br><span class="line">root@localhost:/<span class="comment"># python</span></span><br><span class="line">Python 3.7.3 (default, Jan 22 2021, 20:04:44)</span><br><span class="line">[GCC 8.3.0] on linux</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; quit()</span><br></pre></td></tr></table></figure><p>再运行还有错：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:/<span class="comment"># filetop</span></span><br><span class="line">sh: modprobe: <span class="built_in">command</span> not found</span><br><span class="line">Unable to find kernel headers. Try rebuilding kernel with CONFIG_IKHEADERS=m (module) or installing the kernel development package <span class="keyword">for</span> your running kernel version.</span><br><span class="line"><span class="built_in">chdir</span>(/lib/modules/4.14.xxx/build): No such file or directory</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/share/bcc/tools/filetop&quot;</span>, line 164, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    b = BPF(text=bpf_text)</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3/dist-packages/bcc/__init__.py&quot;</span>, line 475, <span class="keyword">in</span> __init__</span><br><span class="line">    raise Exception(<span class="string">&quot;Failed to compile BPF module %s&quot;</span> % (src_file or <span class="string">&quot;&lt;text&gt;&quot;</span>))</span><br><span class="line">Exception: Failed to compile BPF module &lt;text&gt;</span><br></pre></td></tr></table></figure><p>modeprobe 命令找不到，安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install kmod</span><br></pre></td></tr></table></figure><p>再跑出错：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:/<span class="comment"># opensnoop</span></span><br><span class="line">modprobe: ERROR: ../libkmod/libkmod.c:586 kmod_search_moddep() could not open moddep file <span class="string">&#x27;/lib/modules/4.14.xxx/modules.dep.bin&#x27;</span></span><br><span class="line">modprobe: FATAL: Module kheaders not found <span class="keyword">in</span> directory /lib/modules/4.14.xxx</span><br><span class="line">Unable to find kernel headers. Try rebuilding kernel with CONFIG_IKHEADERS=m (module) or installing the kernel development package <span class="keyword">for</span> your running kernel version.</span><br><span class="line"><span class="built_in">chdir</span>(/lib/modules/4.14.xxx/build): No such file or directory</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/share/bcc/tools/opensnoop&quot;</span>, line 261, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    b = BPF(text=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3/dist-packages/bcc/__init__.py&quot;</span>, line 475, <span class="keyword">in</span> __init__</span><br><span class="line">    raise Exception(<span class="string">&quot;Failed to compile BPF module %s&quot;</span> % (src_file or <span class="string">&quot;&lt;text&gt;&quot;</span>))</span><br><span class="line">Exception: Failed to compile BPF module &lt;text&gt;</span><br></pre></td></tr></table></figure><p>modprobe 找不到目录 &#x2F;lib&#x2F;modules&#x2F;4.14.xxx，看提示我的板子内核已经使能 CONFIG_IKHEADERS, 而且 linux header package 按下面命令搜索也没有匹配的包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-cache search linux-headers-</span><br></pre></td></tr></table></figure><p>我们先来了解下 kernel header 相关修改：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">commit f63868480dd3c52324d9bb8cdabb7c9950e5f751</span><br><span class="line">Author: Joel Fernandes &lt;joelaf@google.com&gt;</span><br><span class="line">Date:   Wed Jul 10 22:52:30 2019 -0400</span><br><span class="line"></span><br><span class="line">    Remove all code todo with kernel headers or sources</span><br><span class="line"></span><br><span class="line">    BCC now can use headers from CONFIG_IKHEADERS so no need for adeb to</span><br><span class="line">    package them.</span><br><span class="line"></span><br><span class="line">    Signed-off-by: Joel Fernandes &lt;joelaf@google.com&gt;</span><br></pre></td></tr></table></figure><p>adeb 的 –kernel-src 是在 BCC 支持 <code>CONFIG_IKHEADERS</code> 前使用的，当前情况：</p><p>host: adeb(no –kernel-src) + bcc 0.24.0 (支持CONFIG_IKHEADERS)<br>target: CONFIG_IKHEADERS 已经使能</p><p>bcc v0.24.0 使用 sysfs:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">commit 0797d4acbde025fbaa36e3c26257e74fb62645b2</span><br><span class="line">Author: Joel Fernandes (Google) &lt;joel@joelfernandes.org&gt;</span><br><span class="line">Date:   Wed Jun 12 15:54:14 2019 -0400</span><br><span class="line"></span><br><span class="line">    build: Rename kheaders location from proc to sys</span><br><span class="line"></span><br><span class="line">    In upstream kernel, the path has been renamed as the kheaders got moved</span><br><span class="line">    to sysfs. Let us update BCC with the new path.</span><br><span class="line"></span><br><span class="line">    Signed-off-by: Joel Fernandes (Google) &lt;joel@joelfernandes.org&gt;</span><br></pre></td></tr></table></figure><p>因为 CONFIG_IKHEADERS&#x3D;m 按模块编译，应该要加载这个模块，看看板子生成文件中确有 kheaders.ko，直接把这个 ko 推进板子上:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@u1804:~/adeb$ adeb push ~/kheaders.ko /data/</span><br><span class="line">|--------------|</span><br><span class="line">| adeb: v0.99h |</span><br><span class="line">|--------------|</span><br><span class="line">/home/tj/kheaders.ko: 1 file pushed. 26.1 MB/s (3279568 bytes <span class="keyword">in</span> 0.120s)</span><br></pre></td></tr></table></figure><p>然后 insmod 这个 ko:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:/<span class="comment"># insmod /data/kheaders.ko</span></span><br></pre></td></tr></table></figure><p>确认：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:/<span class="comment"># ls /sys/kernel/kheaders.tar.xz</span></span><br><span class="line">/sys/kernel/kheaders.tar.xz</span><br></pre></td></tr></table></figure><p>再运行出错：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:/<span class="comment"># opensnoop</span></span><br><span class="line">tar (child): xz: Cannot <span class="built_in">exec</span>: No such file or directory</span><br><span class="line">tar (child): Error is not recoverable: exiting now</span><br><span class="line">tar: Child returned status 2</span><br><span class="line">tar: Error is not recoverable: exiting now</span><br><span class="line">Unable to find kernel headers. Try rebuilding kernel with CONFIG_IKHEADERS=m (module) or installing the kernel development package <span class="keyword">for</span> your running kernel version.</span><br><span class="line"><span class="built_in">chdir</span>(/lib/modules/4.14.xxx/build): No such file or directory</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/share/bcc/tools/opensnoop&quot;</span>, line 261, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    b = BPF(text=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3/dist-packages/bcc/__init__.py&quot;</span>, line 475, <span class="keyword">in</span> __init__</span><br><span class="line">    raise Exception(<span class="string">&quot;Failed to compile BPF module %s&quot;</span> % (src_file or <span class="string">&quot;&lt;text&gt;&quot;</span>))</span><br><span class="line">Exception: Failed to compile BPF module &lt;text&gt;</span><br></pre></td></tr></table></figure><p>这个看起来比较明显，直接安装 xz 命令包:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install xz-utils</span><br></pre></td></tr></table></figure><p>now, it’s working.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:/<span class="comment"># opensnoop</span></span><br><span class="line">PID    COMM               FD ERR PATH</span><br><span class="line">792    vmstat              4   0</span><br><span class="line">792    vmstat              4   0</span><br><span class="line">792    vmstat              4   0</span><br><span class="line">792    vmstat              4   0</span><br><span class="line">792    vmstat              4   0</span><br><span class="line">792    vmstat              4   0</span><br><span class="line">792    vmstat              4   0</span><br><span class="line">792    vmstat              4   0</span><br></pre></td></tr></table></figure><p>btw: 同样的，可以安装bpftrace, build such as:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER=clang-7 -DCMAKE_CXX_COMPILER=clang++-7 -DBUILD_TESTING=OFF</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/joelagnel/adeb/blob/master/README.md">https://github.com/joelagnel/adeb/blob/master/README.md</a></li><li><a href="https://github.com/iovisor/bcc/issues/3881">https://github.com/iovisor/bcc/issues/3881</a></li><li><a href="https://github.com/iovisor/bcc/issues/4114">https://github.com/iovisor/bcc/issues/4114</a></li><li><a href="https://lwn.net/Articles/783581/">Provide in-kernel headers to make extending kernel easier</a></li><li><a href="https://lwn.net/ml/linux-kernel/20190320163116.39275-1-joel@joelfernandes.org/">https://lwn.net/ml/linux-kernel/20190320163116.39275-1-joel@joelfernandes.org/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ebpf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bcc </tag>
            
            <tag> adeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kworker 调度延迟性能测试和统计</title>
      <link href="/kworker-sched-la-stat.html"/>
      <url>/kworker-sched-la-stat.html</url>
      
        <content type="html"><![CDATA[<p>LPC2022 EROFS 提到一个解压调度延迟问题：</p><p><img src="https://tjtech.me/usr/uploads/2023/02/419606142.png#center" alt="sched-perf-in-lpc2022-erofs.png"></p><p>最近，Android 提了一笔优化 patch for this issue:</p><figure class="highlight patch"><table><tr><td class="code"><pre><span class="line">Author: Sandeep Dhavale &lt;dhavale@google.com&gt;</span><br><span class="line">Date:   Thu Dec 22 01:15:29 2022 +0000</span><br><span class="line"></span><br><span class="line">    EROFS: Replace erofs_unzipd workqueue with per-cpu threads</span><br><span class="line"></span><br><span class="line">    Using per-cpu thread pool we can reduce the scheduling latency compared</span><br><span class="line">    to workqueue implementation. With this patch scheduling latency and</span><br><span class="line">    variation is reduced as per-cpu threads are SCHED_FIFO kthread_workers.</span><br><span class="line"></span><br><span class="line">    The results were evaluated on arm64 Android devices running 5.10 kernel.</span><br><span class="line"></span><br><span class="line">    The table below shows resulting improvements of total scheduling latency</span><br><span class="line">    for the same app launch benchmark runs with 50 iterations. Scheduling</span><br><span class="line">    latency is the latency between when the task (workqueue kworker vs</span><br><span class="line">    kthread_worker) became eligible to run to when it actually started</span><br><span class="line">    running.</span><br><span class="line">    +-------------------------+-----------+----------------+---------+</span><br><span class="line">    |                         | workqueue | kthread_worker |  diff   |</span><br><span class="line">    +-------------------------+-----------+----------------+---------+</span><br><span class="line">    | Average (us)            |     15253 |           2914 | -80.89% |</span><br><span class="line">    | Median (us)             |     14001 |           2912 | -79.20% |</span><br><span class="line">    | Minimum (us)            |      3117 |           1027 | -67.05% |</span><br><span class="line">    | Maximum (us)            |     30170 |           3805 | -87.39% |</span><br><span class="line">    | Standard deviation (us) |      7166 |            359 |         |</span><br><span class="line">    +-------------------------+-----------+----------------+---------+</span><br><span class="line"></span><br><span class="line">    Background: Boot times and cold app launch benchmarks are very</span><br><span class="line">    important to android ecosystem as they directly translate to</span><br><span class="line">    responsiveness from user point of view. While erofs provides</span><br><span class="line">    lot of important features like space savings, we saw some</span><br><span class="line">    performance penalty in cold app launch benchmarks in few scenarios.</span><br><span class="line">    Analysis showed that the significant variance was coming from the</span><br><span class="line">    scheduling cost while decompression cost was more or less the same.</span><br></pre></td></tr></table></figure><p>ok, 我也来过一遍测试和统计，发现问题和验证问题，你懂的，主机 ubuntu，板子 arm64, 内核4.x。</p><h2 id="如何模拟-heavy-load"><a href="#如何模拟-heavy-load" class="headerlink" title="如何模拟 heavy load"></a>如何模拟 heavy load</h2><p>使用 fio 应该可以满足要求，配置如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">time_based</span><br><span class="line">runtime=120</span><br><span class="line"></span><br><span class="line">[randread]</span><br><span class="line">ioengine=sync</span><br><span class="line">filename=/data/testing</span><br><span class="line">rw=randread</span><br><span class="line">direct=1</span><br><span class="line">size=500m</span><br><span class="line"></span><br><span class="line">[burn_8x90%_qsort]</span><br><span class="line">ioengine=cpuio</span><br><span class="line">cpuload=90</span><br><span class="line">numjobs=8</span><br><span class="line">cpumode=qsort</span><br></pre></td></tr></table></figure><p>fio 源码按下面配置编译(for arm64)后，直接 push 到板子上运行。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --prefix=out --cc=aarch64-linux-gnu-gcc-7 --build-static</span><br></pre></td></tr></table></figure><p><code>aarch64-linux-gnu-gcc-7</code> 如果没有，直接 <code>apt install</code>。</p><p>另外，板子内核要使能 <code>CONFIG_SYSVIPC=y</code>，不然跑起来会有如下错误：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shmget: Function not implemented</span><br><span class="line">error: failed to setup shm segment</span><br></pre></td></tr></table></figure><p>跑起来效果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XXX:/ <span class="comment"># /data/fio /data/burn-cpu.fio</span></span><br><span class="line">randread: (g=0): rw=randread, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=<span class="built_in">sync</span>, iodepth=1</span><br><span class="line">...</span><br><span class="line">fio-3.30</span><br><span class="line">Starting 9 processes</span><br><span class="line">burn_8x90%_qsort (qsort): ioengine=cpuio, cpuload=90, cpucycle=50000</span><br><span class="line">burn_8x90%_qsort (qsort): ioengine=cpuio, cpuload=90, cpucycle=50000</span><br><span class="line">burn_8x90%_qsort (qsort): ioengine=cpuio, cpuload=90, cpucycle=50000</span><br><span class="line">burn_8x90%_qsort (qsort): ioengine=cpuio, cpuload=90, cpucycle=50000</span><br><span class="line">burn_8x90%_qsort (qsort): ioengine=cpuio, cpuload=90, cpucycle=50000</span><br><span class="line">burn_8x90%_qsort (qsort): ioengine=cpuio, cpuload=90, cpucycle=50000</span><br><span class="line">burn_8x90%_qsort (qsort): ioengine=cpuio, cpuload=90, cpucycle=50000</span><br><span class="line">burn_8x90%_qsort (qsort): ioengine=cpuio, cpuload=90, cpucycle=50000</span><br></pre></td></tr></table></figure><h2 id="复现-sched-latency-UI"><a href="#复现-sched-latency-UI" class="headerlink" title="复现 sched latency UI"></a>复现 sched latency UI</h2><p>看图估摸着应该是类似 systrace 的东西，看下 Android 官方说明：</p><blockquote><p>系统跟踪实用程序是一款用于将设备活动保存到跟踪文件的 Android 工具。在搭载 Android 10（API 级别 29）或更高版本的设备上，跟踪文件会以 Perfetto 格式保存，如本主题后面部分所示。在搭载较低版本 Android 系统的设备上，跟踪文件会以 Systrace 格式保存。</p></blockquote><p>当前环境是 11，使用 perfetto 格式。</p><ul><li>生成 trace 文件</li></ul><p>方法有命令行和 UI tools，具体可以看官方文档，这里使用 perfetto 命令(因为要连着 adb 敲 cmd)。</p><p>脚本参考 <a href="https://ui.perfetto.dev/">https://ui.perfetto.dev/</a> 下 Record new trace，只打开 CPU&#x2F;Scheduling details。</p><p>step1: 先把 fio 跑起来</p><p>step2: 开始录制，确保不要停下来</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell &quot;cat /data/config.pbtx | perfetto --txt -c - -o /data/misc/perfetto-traces/trace.perfetto-trace&quot;</span><br></pre></td></tr></table></figure><p>step3: 执行一个场景操作(这里就点击系统区一个 app，比如 setting 啥的)，完成后可以按配置自动退出 or ctrl-c 强行退出</p><p>step4: 取出 trace 到当前</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb pull /data/misc/perfetto-traces/trace.perfetto-trace .</span><br></pre></td></tr></table></figure><ul><li>浏览 trace</li></ul><p>直接用 <a href="https://ui.perfetto.dev/">https://ui.perfetto.dev/</a> 下 Open trace file 来 view，也就是一个 HTML report。</p><blockquote><p>Create an HTML report from the trace file using a web-based UI or from the command line.</p></blockquote><p>关于 cmdline 描述好像有点问题，对 perfetto trace 文件，cmdline 必须先 convert 到旧的 systrace 文件，然后再 –from-file 成 html，网络有问题的，连不上不能下载 convert工具，只能用在线。</p><ul><li>分析 trace</li></ul><p>perfetto doc&#x2F;CPU scheduling events 提到:</p><blockquote><p>On Android and Linux Perfetto can gather scheduler traces via the Linux Kernel ftrace infrastructure.</p><p>This allows to get fine grained scheduling events such as:</p><ul><li>Which threads were scheduled on which CPU core at any point in time, with nanosecond accuracy.</li><li>The reason why a running thread got descheduled (e.g. pre-emption, blocked on a mutex, blocking syscall or any other wait queue).</li><li>The point in time when a thread became eligible to be executed, even if it was not put immediately on any CPU run queue, together with the source thread that made it executable.</li></ul></blockquote><p>说明文档里抓了一个进程 897 的 cpu slice, 如下图：</p><p><img src="https://tjtech.me/usr/uploads/2023/02/984744057.png#center" alt="latency.png"></p><p>右下已经对 scheduling latency 做出描述：</p><blockquote><p>This is interval from when the task became eligible to run to when it started running.</p></blockquote><p>留意到 patch 的 commit message 最后也有这个描述，那基本就是这个了，rt?</p><p>图上的 Start time 就是真正 running 的时间点，而 wakeup 时间点就是 eligible to executed，但是因某些原因没有被放入 cpu 的 running queue，doc 也提到了几个因素：</p><blockquote><ul><li>All CPUs might be busy running some other thread, and Thread A needs to wait to get a run queue slot assigned (or the other threads have higher priority).</li><li>Some other CPUs other than the current one, but the scheduler load balancer might take some time to move the thread on another CPU.</li></ul></blockquote><p>ok, 那 897 的调度延迟就是从 wakeup 到 start time 的时间间隔，就是 10us 729ns。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  Start time: 6s 177ms 391us 761ns </span><br><span class="line">- Wakeup:     6s 177ms 381us  32ns</span><br><span class="line">  Scheduling latency =  10us 729ns</span><br></pre></td></tr></table></figure><p>查了下色块的定义，好像 Blue 是 Runnable (it could run, but the scheduler hasn’t picked it to run yet).</p><h2 id="内核支持-workqueue-name"><a href="#内核支持-workqueue-name" class="headerlink" title="内核支持 workqueue name"></a>内核支持 workqueue name</h2><p>我的内核只显示<code>kworker/u17:3</code>，需要一笔 patch:</p><figure class="highlight patch"><table><tr><td class="code"><pre><span class="line">commit 6b59808bfe482642287ddf3fe9d4cccb10756652</span><br><span class="line">Author: Tejun Heo &lt;tj@kernel.org&gt;</span><br><span class="line">Date:   Fri May 18 08:47:13 2018 -0700</span><br><span class="line"></span><br><span class="line">    workqueue: Show the latest workqueue name in /proc/PID/&#123;comm,stat,status&#125;</span><br></pre></td></tr></table></figure><p>还有关联的几笔，添加后的显示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XXX:/ <span class="comment"># ps -ef | grep kworker | grep erofs</span></span><br><span class="line">root            584      2 0 15:55:32 ?     00:00:00 [kworker/u17:4-erofs_unzipd]</span><br><span class="line">```bash</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">XXX:/ <span class="comment"># cat /proc/584/status</span></span><br><span class="line">Name:   kworker/u17:4-erofs_unzipd</span><br><span class="line">Umask:  0000</span><br><span class="line">State:  I (idle)</span><br><span class="line">Tgid:   584</span><br><span class="line">Ngid:   0</span><br><span class="line">Pid:    584</span><br></pre></td></tr></table></figure><p>ok, 再抓一次，如下图：</p><p><img src="https://tjtech.me/usr/uploads/2023/02/4247524523.png#center" alt="my-latency.png"></p><p>不过似乎 perfetto 不支持统计这个 latency，手动查还是累了。</p><h2 id="如何统计调度延迟"><a href="#如何统计调度延迟" class="headerlink" title="如何统计调度延迟"></a>如何统计调度延迟</h2><p>kernel 下 perf 工具，可以直接统计：</p><blockquote><p><code>perf sched latency</code> will summarize scheduler latencies by task, including average and maximum delay:</p></blockquote><p>查了下安卓自带的有 simpleperf, list 虽然有 sched，record 也录了，report 愣是没找到，编一个 perf 得了。</p><p>进 tools&#x2F;perf 下:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make CROSS_COMPILE=aarch64-linux-gnu- ARCH=arm64 LDFLAGS=-static O=out</span><br></pre></td></tr></table></figure><p>当前目录生成了 perf bin，推到板子上，先记录下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perf <span class="built_in">sched</span> record -- <span class="built_in">sleep</span> 5 // 记录5s</span><br></pre></td></tr></table></figure><p>完成后当前目录有个 perf.data，注意时长。</p><p>过滤下kworker by <code>perf sched latency | grep kworker</code>：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">kworker/4:2-eve:404   |     88.386 ms |      207 | avg:    0.248 ms | max:   12.380 ms | max at:    271.002611 s</span><br><span class="line">kworker/u16:18-:1499  |     36.641 ms |      681 | avg:    0.081 ms | max:    4.086 ms | max at:    269.173878 s</span><br><span class="line">kworker/u16:17-:1498  |     21.918 ms |      511 | avg:    0.080 ms | max:    2.706 ms | max at:    272.811798 s</span><br><span class="line">kworker/u16:19-:1500  |     41.742 ms |      713 | avg:    0.077 ms | max:    4.098 ms | max at:    272.342235 s</span><br></pre></td></tr></table></figure><p>好使好使，不过我的 kworker 在哪？待续。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><p><a href="https://source.android.com/docs/core/tests/debug/systrace">https://source.android.com/docs/core/tests/debug/systrace</a></p></li><li><p><a href="https://developer.android.com/topic/performance/tracing">https://developer.android.com/topic/performance/tracing</a></p></li><li><p><a href="https://perfetto.dev/docs/quickstart/android-tracing">https://perfetto.dev/docs/quickstart/android-tracing</a></p></li><li><p><a href="https://developer.android.com/topic/performance/tracing/on-device">https://developer.android.com/topic/performance/tracing/on-device</a></p></li><li><p><a href="https://perfetto.dev/docs/data-sources/cpu-scheduling">https://perfetto.dev/docs/data-sources/cpu-scheduling</a></p></li><li><p><a href="https://devblogs.microsoft.com/performance-diagnostics/perfetto-tooling-for-analyzing-android-linux-and-chromium-browser-performance-microsoft-performance-tools-linux-android/">https://devblogs.microsoft.com/performance-diagnostics/perfetto-tooling-for-analyzing-android-linux-and-chromium-browser-performance-microsoft-performance-tools-linux-android/</a></p></li><li><p>Documentation&#x2F;admin-guide&#x2F;kernel-per-CPU-kthreads.rst</p></li><li><p>Documentation&#x2F;core-api&#x2F;workqueue.rst</p></li><li><p><a href="https://lwn.net/ml/linux-kernel/20180517043448.3152269-1-tj@kernel.org/">https://lwn.net/ml/linux-kernel/20180517043448.3152269-1-tj@kernel.org/</a></p></li><li><p><a href="https://www.brendangregg.com/blog/2017-03-16/perf-sched.html">https://www.brendangregg.com/blog/2017-03-16/perf-sched.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> perf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> perf </tag>
            
            <tag> sched </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转：EROFS 碎片去重实践</title>
      <link href="/implement-erofs-fragment-dedupe.html"/>
      <url>/implement-erofs-fragment-dedupe.html</url>
      
        <content type="html"><![CDATA[<p>碎片去重已经实现了，参见 <a href="https://lore.kernel.org/all/20221208084859.24190-1-zbestahu@gmail.com/">[PATCH v7] erofs-utils: mkfs: support fragment deduplication</a>，其主要逻辑就是在压缩前去重以防把重复的部分写入 packed inode，去重成功后如果 pcluster 没压满，就再读碎片尝试修复。</p><p>主要围绕查找碎片、何时修复碎片、开始修复碎片、生成碎片extent、提交碎片这几块来说明。</p><p>详细可以参考原文链接：<a href="https://mp.weixin.qq.com/s/_xvOkPgYzHJivOpetyvbyg">https://mp.weixin.qq.com/s/_xvOkPgYzHJivOpetyvbyg</a></p><p>现在，dump.erofs 和 fsck.erofs 也加了支持。</p>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erofs </tag>
            
            <tag> fragments-dedupe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to enable KASAN in Ubuntu 18.04 for X86_64</title>
      <link href="/how-to-enable-kasan-in-ubuntu-18-04-for-x86_64.html"/>
      <url>/how-to-enable-kasan-in-ubuntu-18-04-for-x86_64.html</url>
      
        <content type="html"><![CDATA[<p>末日都过了，还在用 Ubuntu 18.04? 好吧，我觉得应该有很多人都在用。。。废话少说，上游 syzbot 天天查你，这不 KASAN bug 又来了，先来看看怎么使能 KASAN。</p><p>直接 menuconfig 按如下路径愣是找不到：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Kernel hacking -&gt; Memory Debugging</span><br></pre></td></tr></table></figure><p>来看下配置说明，在lib&#x2F;Kconfig.kasan 里：</p><blockquote><pre><code>    bool &quot;KASAN: dynamic memory safety error detector&quot;    depends on (((HAVE_ARCH_KASAN &amp;&amp; CC_HAS_KASAN_GENERIC) || \                 (HAVE_ARCH_KASAN_SW_TAGS &amp;&amp; CC_HAS_KASAN_SW_TAGS)) &amp;&amp; \                CC_HAS_WORKING_NOSANITIZE_ADDRESS) || \               HAVE_ARCH_KASAN_HW_TAGS    depends on (SLUB &amp;&amp; SYSFS) || (SLAB &amp;&amp; !DEBUG_SLAB)    select STACKDEPOT_ALWAYS_INIT    help</code></pre></blockquote><blockquote><pre><code>     KASAN has three modes:     1. Generic KASAN (supported by many architectures, enabled with        CONFIG_KASAN_GENERIC, similar to userspace ASan),     2. Software Tag-Based KASAN (arm64 only, based on software memory        tagging, enabled with CONFIG_KASAN_SW_TAGS, similar to userspace        HWASan), and     3. Hardware Tag-Based KASAN (arm64 only, based on hardware memory        tagging, enabled with CONFIG_KASAN_HW_TAGS).</code></pre></blockquote><p>ok, 我这是 x86_64，就看1就行了。也就是:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(HAVE_ARCH_KASAN &amp;&amp; CC_HAS_KASAN_GENERIC) &amp;&amp; CC_HAS_WORKING_NOSANITIZE_ADDRESS</span><br></pre></td></tr></table></figure><p>搜了下 .config 没有 <code>CC_HAS_WORKING_NOSANITIZE_ADDRESS</code> 这玩意啊，再看说明：</p><blockquote><pre><code>    bool &quot;Generic KASAN&quot;    depends on HAVE_ARCH_KASAN &amp;&amp; CC_HAS_KASAN_GENERIC    depends on CC_HAS_WORKING_NOSANITIZE_ADDRESS    select SLUB_DEBUG if SLUB    select CONSTRUCTORS    help      Enables Generic KASAN.      Requires GCC 8.3.0+ or Clang.</code></pre></blockquote><p>gcc 版本有要求？赶紧 check 下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@u1804:~/$ gcc --version</span><br><span class="line">gcc (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0</span><br><span class="line">Copyright (C) 2017 Free Software Foundation, Inc.</span><br></pre></td></tr></table></figure><p>还真是版本问题，可以不用编译安装，已经有打包好的了，具体安装步骤：</p><ul><li>add source</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install software-properties-common </span><br><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r/test</span><br></pre></td></tr></table></figure><ul><li>install</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc-8</span><br><span class="line">sudo apt install g++-8</span><br></pre></td></tr></table></figure><ul><li>enable</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@u1804:~/$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 80 --slave /usr/bin/g++ g++ /usr/bin/g++-8</span><br><span class="line">update-alternatives: using /usr/bin/gcc-8 to provide /usr/bin/gcc (gcc) <span class="keyword">in</span> auto mode</span><br></pre></td></tr></table></figure><ul><li>verfiy</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@u1804:~/$ gcc --version</span><br><span class="line">gcc (Ubuntu 8.4.0-1ubuntu1~18.04) 8.4.0</span><br></pre></td></tr></table></figure><ul><li>delete if needed</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --remove gcc /usr/bin/gcc-8</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">now, 我们再从头来一次看看。</span><br><span class="line"></span><br><span class="line">```config</span><br><span class="line">4814 CONFIG_HAVE_ARCH_KASAN=y</span><br><span class="line">4815 CONFIG_HAVE_ARCH_KASAN_VMALLOC=y</span><br><span class="line">4816 CONFIG_CC_HAS_KASAN_GENERIC=y</span><br><span class="line">4817 CONFIG_CC_HAS_WORKING_NOSANITIZE_ADDRESS=y</span><br><span class="line">4818 <span class="comment"># CONFIG_KASAN is not set</span></span><br></pre></td></tr></table></figure><p>menuconfig 看看，果然在那，just 打个*。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kasan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何分析 Linux user space&#39;s segmentation fault</title>
      <link href="/how-to-analyze-segmentation-fault-for-non-install-package-in-ubuntu.html"/>
      <url>/how-to-analyze-segmentation-fault-for-non-install-package-in-ubuntu.html</url>
      
        <content type="html"><![CDATA[<p>Linux 用户态码字有时会遇到如下错误：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Segmentation fault      (core dumped) ..</span><br></pre></td></tr></table></figure><p>当你没头绪时，或许可以借用工具来定位。这个错误中 <code>core dumped</code> 提示生成了一个 core 文件。那它在哪了？如何分析？ 具体来看，OS 是 Ubuntu 18.04。</p><ul><li>Step 1. check core 文件大小</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@u1804:~/code/erofs/erofs-utils$ <span class="built_in">ulimit</span> -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br></pre></td></tr></table></figure><p>ps: 这里是0不能生成core文件。</p><ul><li>Step 2. 设置 core 文件大小不受限制</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure><p>确认下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@u1804:~/code/erofs/erofs-utils$ <span class="built_in">ulimit</span> -a</span><br><span class="line">core file size          (blocks, -c) unlimited</span><br></pre></td></tr></table></figure><ul><li>Step 3. 设置 apport</li></ul><p>对于非安装包，ubuntu 下 apport 是拒绝写 core dump file 的。</p><p>先创建设置文件：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">~/.config/apport/settings</span><br></pre></td></tr></table></figure><p>然后添加如下配置：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[main]</span><br><span class="line">unpackaged=true</span><br></pre></td></tr></table></figure><ul><li>Step 4. 生成 core file</li></ul><p>此时再出现 crash 时，core dump 文件存在 &#x2F;var&#x2F;crash 目录，后缀类似是 .crash 文件，比如我的：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">_home_tj_code_erofs_erofs-utils_mkfs_mkfs.erofs.1000.crash</span><br></pre></td></tr></table></figure><p>btw: 此文件 gdb 不能直接读，需要用 apport 解下。</p><ul><li>Step 5. 用 apport 解包</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apport-unpack /var/crash/xxx.crash xxx_dir</span><br></pre></td></tr></table></figure><p>解完后生成如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-rw-rw-r-- 1 tj tj        5 Nov 15 15:35 Architecture</span><br><span class="line">-rw-rw-r-- 1 tj tj 13045760 Nov 15 15:35 CoreDump</span><br><span class="line">-rw-rw-r-- 1 tj tj       24 Nov 15 15:35 Date</span><br><span class="line">-rw-rw-r-- 1 tj tj       12 Nov 15 15:35 DistroRelease</span><br><span class="line">-rw-rw-r-- 1 tj tj       50 Nov 15 15:35 ExecutablePath</span><br><span class="line">-rw-rw-r-- 1 tj tj       10 Nov 15 15:35 ExecutableTimestamp</span><br><span class="line">-rw-rw-r-- 1 tj tj        4 Nov 15 15:35 _LogindSession</span><br><span class="line">-rw-rw-r-- 1 tj tj        5 Nov 15 15:35 ProblemType</span><br><span class="line">-rw-rw-r-- 1 tj tj      109 Nov 15 15:35 ProcCmdline</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>Step 6. 用 gdb 读</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb <span class="string">&quot;<span class="subst">$(cat ExecutablePath)</span>&quot;</span> CoreDump</span><br></pre></td></tr></table></figure><p>如果出现如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Program terminated with signal SIGSEGV, Segmentation fault.</span><br><span class="line"></span><br><span class="line">warning: Unexpected size of section `.reg-xstate/13869&#x27; in core file.</span><br><span class="line">#0  0x000055e46a7c0a29 in ?? ()</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>可能是 gdb 版本问题，换个版本之类 or have a break then just read your code…</p><p>Done.</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> segmentation fault </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EROFS 碎片去重准备</title>
      <link href="/prepare-fragment-dedupe-in-erofs.html"/>
      <url>/prepare-fragment-dedupe-in-erofs.html</url>
      
        <content type="html"><![CDATA[<p>因为 EROFS 就是奔着取代 SquashFS 去的(should be)，之前我们已经添加了碎片的支持，但是不支持去重。先大概看下 SquashFS 碎片去重是怎么做的。知己知彼，才能百战百胜。</p><h2 id="Check-SquashFS-碎片去重"><a href="#Check-SquashFS-碎片去重" class="headerlink" title="Check SquashFS 碎片去重"></a>Check SquashFS 碎片去重</h2><p>参考 squashfs-tools 4.5.1</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* hash tables used to do fast duplicate searches in duplicate check */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> **<span class="title">dupl_frag</span>;</span></span><br></pre></td></tr></table></figure><p>定义了一个 hash table 用来快速查找重复的碎片。这个 table 是怎么用的呢，能看到这样的使用：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Look for a possible duplicate fragment */</span></span><br><span class="line"><span class="keyword">if</span>(fragment_size) &#123;</span><br><span class="line">        <span class="keyword">for</span>(dupl_ptr = dupl_frag[fragment_size]; dupl_ptr; dupl_ptr = dupl_ptr-&gt;frag_next)</span><br><span class="line">                <span class="keyword">if</span>(dupl_ptr-&gt;fragment-&gt;size == fragment_size) &#123;</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是把 <code>fragment_size</code> 碎片大小用作 hash value。so，只有相同大小的碎片才能去重？继续看：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> file_info *<span class="title function_">frag_duplicate</span><span class="params">(<span class="keyword">struct</span> file_buffer *file_buffer, <span class="type">int</span> *duplicate)</span></span><br></pre></td></tr></table></figure><p><code>frag_duplicate()</code>这函数名起的，是要做去重 <code>dedupe</code>吗？看着落款 Phillip Lougher <a href="mailto:&#x70;&#104;&#x69;&#x6c;&#108;&#105;&#x70;&#64;&#x73;&#113;&#117;&#97;&#x73;&#104;&#102;&#x73;&#46;&#x6f;&#x72;&#103;&#46;&#x75;&#107;">&#x70;&#104;&#x69;&#x6c;&#108;&#105;&#x70;&#64;&#x73;&#113;&#117;&#97;&#x73;&#104;&#102;&#x73;&#46;&#x6f;&#x72;&#103;&#46;&#x75;&#107;</a> 应该是大英的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Look for a possible duplicate fragment */</span></span><br><span class="line"><span class="keyword">if</span>(frag_bytes) &#123;</span><br><span class="line">        <span class="keyword">for</span>(dupl_ptr = dupl_frag[frag_bytes]; dupl_ptr; dupl_ptr = dupl_ptr-&gt;frag_next) &#123;</span><br><span class="line">                <span class="keyword">if</span>(frag_bytes == dupl_ptr-&gt;fragment-&gt;size &amp;&amp; fragment_checksum == get_fragment_checksum(dupl_ptr)) &#123;</span><br><span class="line">                        <span class="comment">/* Checksums match, so now we need to do a byte by byte comparison */</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">file_buffer</span> *<span class="title">frag_buffer</span> =</span> get_fragment(dupl_ptr-&gt;fragment);</span><br><span class="line">                        <span class="type">int</span> res = <span class="built_in">memcmp</span>(file_buffer-&gt;data, frag_buffer-&gt;data + dupl_ptr-&gt;fragment-&gt;offset, frag_bytes);</span><br><span class="line"></span><br><span class="line">                        cache_block_put(frag_buffer);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(res == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">/* Yes, the fragment matches.  This file may have</span></span><br><span class="line"><span class="comment">                                 * a matching block list and fragment, in which case</span></span><br><span class="line"><span class="comment">                                 * we&#x27;re finished. */</span></span><br><span class="line">                                <span class="keyword">if</span>(block_dupl &amp;&amp; block_dupl-&gt;start == dupl_ptr-&gt;start) &#123;</span><br><span class="line">                                        *dupf = *block_dup = TRUE;</span><br><span class="line">                                        <span class="keyword">return</span> dupl_ptr;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ok, 看了上面这一段，基本逻辑就是 <code>fragment_size</code> 碎片大小相同而且 <code>fragment_checksum</code> 相同时然后再看内容是否一致。”Am i missing sth?” (mmm…留点退路不流破绽)</p><h2 id="简要回顾下哈希"><a href="#简要回顾下哈希" class="headerlink" title="简要回顾下哈希"></a>简要回顾下哈希</h2><blockquote><p>A hash function is any function that can be used to map data of arbitrary size to fixed-size values. The values returned by a hash function are called hash values, hash codes, digests, or simply hashes. The values are usually used to index a fixed-size table called a hash table. Use of a hash function to index a hash table is called hashing or scatter storage addressing.</p></blockquote><blockquote><p>A hash table is typically an array of linked lists.</p></blockquote><p>需要留意的是 hash table size 若过小 + link list 长度过长，效率低点, 就是 collision 的问题，不多说，知道这个即可。</p><h2 id="EROFS-碎片去重"><a href="#EROFS-碎片去重" class="headerlink" title="EROFS 碎片去重"></a>EROFS 碎片去重</h2><p>f哥，长度短点的不能去重么。可以使用 16bits checksum 作为 hash, table size 就 64KB。</p><p>我的想法比较简单也比较好写，就是顺着当前逻辑，在 packing fragment 分支时查表。但是有个问题，就是大碎片只有部分重复的怎么办？</p><p>Gao Xiang 建议在压缩前做去重，这样做的好处是避免把一部分重复的碎片写到 packed inode 里。不过改起来有点别扭，因为压缩 final 时要返回再读文件重新压缩。这种做法也解决了上面的疑问，rt?</p><p>Now, let’s do it.</p>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erofs-utils </tag>
            
            <tag> fragments-dedupe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优秀代码命名法</title>
      <link href="/good-naming-in-programming.html"/>
      <url>/good-naming-in-programming.html</url>
      
        <content type="html"><![CDATA[<p>有人说过写代码就像弹棉花(^_^)，不好意思，说错了，是弹piano。我觉得写代码就像写文章，文章写出来是要给人看的(不排除自lian型)，词不达意，肯定不是好文章。能做到信达雅，那都是高高手。“金山银山就是绿水青山”，抬头看看这高度!</p><p>只有好文章才能被收录(like upstream Linux kernel)，rt? 再看看老外金句：</p><blockquote><p>There are only two hard things in Computer Science: cache invalidation and naming things.</p><p><em>Phil Karlton</em></p></blockquote><blockquote><p>In the beginning was the Word, and the Word was with God, and the Word was God.</p><p><em>The Gospel According to John</em></p></blockquote><p>言论：</p><blockquote><p>A good name paints a picture in the mind of the reader.</p></blockquote><blockquote><p>Names are the structure we impose on the formless sea of bits that is computing.</p></blockquote><blockquote><p>When I’m designing software, I spend a lot of time thinking about names. For me, thinking about names is inseparable from the process of design. </p></blockquote><p>OK，指南开始：</p><p>一. 忽略那些变量类型词汇或参数类型词汇 (for static typeing)</p><blockquote><p>In Static Typing, type checking is performed during compile time. It means that the type of a variable is known at compile time. For some languages, the programmer must specify what type each variable is (e.g C, C++, Java)</p></blockquote><p>比如变量：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Bad */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">maprecorder</span> <span class="title">maprecoder</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Better */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">maprecorder</span> <span class="title">m</span>;</span></span><br></pre></td></tr></table></figure><p>对于收集类描述，可以用复数取代单数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Bad */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(fscache_volume_list)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Better */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(fscache_volumes)</span>;</span><br></pre></td></tr></table></figure><p>如果关心收集的内容，命名应该反映出来，e.g.：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">erofs: clean up `enum z_erofs_collectmode&#x27;</span><br><span class="line"></span><br><span class="line">`enum z_erofs_collectmode&#x27; is really ambiguous, but I&#x27;m not quite</span><br><span class="line">sure if there are better naming, basically it&#x27;s used to judge whether</span><br><span class="line">inplace I/O can be used due to the current status of pclusters in</span><br><span class="line">the chain.</span><br><span class="line"></span><br><span class="line">Rename it as `enum z_erofs_pclustermode&#x27; instead.</span><br></pre></td></tr></table></figure><p>函数的命名有提到：</p><blockquote><p> The method name doesn’t need to describe its parameters or their types—the parameter list does that for you.</p></blockquote><p>也要看情况，比如Kernel&#x2F;VFS:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*read_folio)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> folio *);</span><br></pre></td></tr></table></figure><p>二. 忽略那些无关或歧义词汇</p><blockquote><p>the name is an identifier: it points you to where it’s defined. It’s not an exhaustive catalog of everything the reader could want to know about the object.</p></blockquote><p>如果太短有冲突，可以增加qualifiers。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Bad */</span></span><br><span class="line"><span class="type">void</span>*aux_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Better */</span></span><br><span class="line"><span class="type">void</span>*aux; <span class="comment">/* auxiliary data */</span></span><br></pre></td></tr></table></figure><p>三. 忽略那些上下文已知词汇</p><ul><li><p>A method or field occurs in the context of a class</p></li><li><p>A variable occurs in the context of a method (or function)</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">load_cluster_from_disk</span><span class="params">(param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Bad */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cluster_type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Better */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line"><span class="keyword">case</span> CLUSTER_TYPE_1:</span><br><span class="line"><span class="keyword">case</span> CLUSTER_TYPE_2:</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四. 忽略那些没有意义的词汇</p><p>通常有嫌疑的：</p><blockquote><p>data, state, amount, value, manager, engine, object, entity, and instance</p></blockquote><p>多问问自己：</p><blockquote><p>“Would this identifier mean the same thing if I removed the word?”</p></blockquote><p>如果是的，那这个词就没意义。</p><p>五. 只有把业务想清楚了，才能说得简单准确</p><p>比如 <code>kmap_local()</code> 的出现，linus 的一段答复：</p><blockquote><p>On Sat, Sep 19, 2020 at 2:50 AM Thomas Gleixner <a href="mailto:&#x74;&#103;&#x6c;&#120;&#64;&#108;&#x69;&#x6e;&#117;&#116;&#x72;&#x6f;&#110;&#x69;&#120;&#x2e;&#x64;&#101;">&#x74;&#103;&#x6c;&#120;&#64;&#108;&#x69;&#x6e;&#117;&#116;&#x72;&#x6f;&#110;&#x69;&#120;&#x2e;&#x64;&#101;</a> wrote:<br>&gt;<br>&gt; this provides a preemptible variant of kmap_atomic &amp; related<br>&gt; interfaces. This is achieved by:</p><p>Ack. This looks really nice, even apart from the new capability.</p><p>The only thing I really reacted to is that the name doesn’t make sense<br>to me: “kmap_temporary()” seems a bit odd.</p><p>Particularly for an interface that really is basically meant as a<br>better replacement of “kmap_atomic()” (but is perhaps also a better<br>replacement for “kmap()”).</p><p>I think I understand how the name came about: I think the “temporary”<br>is there as a distinction from the “longterm” regular kmap(). So I<br>think it makes some sense from an internal implementation angle, but I<br>don’t think it makes a lot of sense from an interface name.</p><p>I don’t know what might be a better name, but if we want to emphasize<br>that it’s thread-private and a one-off, maybe “local” would be a<br>better naming, and make it distinct from the “global” nature of the<br>old kmap() interface?</p></blockquote><p>我们再加上英语不是母语。。。</p><p>BTW: 命名不够具体的，用象征(metaphor)代替，并保持一致。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* Bad */</span><br><span class="line">received_msg_queue</span><br><span class="line"></span><br><span class="line">/* Better */</span><br><span class="line">mailbox (use address instead of destination like)</span><br></pre></td></tr></table></figure><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ul><li><a href="https://www.geeksforgeeks.org/type-systemsdynamic-typing-static-typing-duck-typing/">https://www.geeksforgeeks.org/type-systemsdynamic-typing-static-typing-duck-typing/</a></li><li><a href="http://journal.stuffwithstuff.com/2009/06/05/naming-things-in-code/">http://journal.stuffwithstuff.com/2009/06/05/naming-things-in-code/</a></li><li><a href="http://journal.stuffwithstuff.com/2016/06/16/long-names-are-long/">http://journal.stuffwithstuff.com/2016/06/16/long-names-are-long/</a></li><li><a href="https://lore.kernel.org/linux-mm/20200919091751.011116649@linutronix.de/">https://lore.kernel.org/linux-mm/20200919091751.011116649@linutronix.de/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EROFS 压缩去重分析</title>
      <link href="/erofs-compressed-data-deduplication.html"/>
      <url>/erofs-compressed-data-deduplication.html</url>
      
        <content type="html"><![CDATA[<p>EROFS 文件系统刚提交了<a href="https://lore.kernel.org/linux-erofs/20220906114057.151445-4-ZiyangZhang@linux.alibaba.com/">压缩去重特性</a>提升压缩率，一起来看下。</p><h2 id="rolling-hash-基础"><a href="#rolling-hash-基础" class="headerlink" title="rolling hash 基础"></a>rolling hash 基础</h2><p>dedup 用到了 rolling hash，先了解下。</p><p><a href="https://en.wikipedia.org/wiki/Rolling_hash">wikipedia</a> 的定义是:</p><blockquote><p>A hash function is any function that can be used to map data of arbitrary size to fixed-size values.</p></blockquote><blockquote><p>A rolling hash (also known as recursive hashing or rolling checksum) is a hash function where the input is hashed in a window that moves through the input.</p></blockquote><p>举个例子理解下：</p><p>字串查找中使用 rolling hash，如查找字串 abcd 中长度为 3 个字符的子串 abc 和 bcd, base 是 10。</p><p>子串 abc 的 hash 值：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">H(abc) =&gt; a*(10^2) + b*(10^1) + c*(10^0)</span><br><span class="line">= 97*100 + 98*10 + 99*1 = 10779</span><br></pre></td></tr></table></figure><p>子串 bcd 的 hash 值：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">H(bcd) =&gt; b*(10^2) + c*(10^1) + d*(10^0)</span><br><span class="line">= 98*100 + 99*10 + 100*1 = 10890</span><br></pre></td></tr></table></figure><p>留意到 abc 和 bcd 有重复的 bc，可以利用之前的 H(abc) 推导出 H(bcd)，也就是：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">H(bcd) =&gt; (b*(10^1) + c*(10^0))*10 + d*(10^0)</span><br><span class="line">H(bcd) =&gt; (H(abc) - a*(10^2))*10 + d*(10^0)</span><br><span class="line">= (10779 - 97*100)*10 + 100*1 = 10890</span><br></pre></td></tr></table></figure><p>BTW: 为了避免 H() 值太大溢出，有个 mod 运算(by prime number)，这里忽略。</p><p>从 input(abc) 到 input(bcd) 的变化就是丢了 a 加了 d，可以把 input 看成一个 window (这里长度是3个字符)，从 abc 到 bcd 可以看作这个 window 在滚动，滚动步长是1个字符。rt?</p><p>所以，rolling hash 就是为了在计算字串 hash 值时避免 hashing 整个串, 因为利用之前算得的 old hash 值，所以 new hash 值算的很快。它是基于 hash 做的一种场景优化，rt?</p><p>来看 erofs-utils 的实现 rolling_hash.h。</p><p>因为 hash value 定义了 long long(8bytes) 型，所以为了防止溢出 <code>PRIME_NUMBER</code> 定义成了最大值。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRIME_NUMBER    4294967295LL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADIX           256</span></span><br></pre></td></tr></table></figure><p>RADIX 是 256(2^8)，为啥。。。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">erofs_rolling_hash_init</span><span class="params">(u8 *input,</span></span><br><span class="line"><span class="params">                                                <span class="type">int</span> len, <span class="type">bool</span> backwards)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> hash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!backwards) &#123;</span><br><span class="line">                <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">                        hash = (RADIX * hash + input[i]) % PRIME_NUMBER;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (len)</span><br><span class="line">                        hash = (RADIX * hash + input[--len]) % PRIME_NUMBER;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是 H() 的实现加个方向。</p><p>rolling hash 的计算：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">erofs_rolling_hash_advance</span><span class="params">(<span class="type">long</span> <span class="type">long</span> old_hash,</span></span><br><span class="line"><span class="params">                                                   <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> RM,</span></span><br><span class="line"><span class="params">                                                   u8 to_remove, u8 to_add)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> hash = old_hash;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> to_remove_val = (to_remove * RM) % PRIME_NUMBER;</span><br><span class="line"></span><br><span class="line">        hash = RADIX * (old_hash - to_remove_val) % PRIME_NUMBER;</span><br><span class="line">        hash = (hash + to_add) % PRIME_NUMBER;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We might get negative value of hash, converting it to positive */</span></span><br><span class="line">        <span class="keyword">if</span> (hash &lt; <span class="number">0</span>)</span><br><span class="line">                hash += PRIME_NUMBER;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是拿上面的例子来说，<code>old_hash</code> 就是 H(abc)，<code>to_remove</code> 和 <code>to_add</code> 相当于 a 和 d。</p><p><code>(old_hash - to_remove_val)</code> 就是 <code>H(abc) - a*(10^2)</code>, 所以这个 <code>RM</code> 就是 10^2，也就是针对 input window 的常量是多少，因为用作移除 (remove)，那就是 RM 喽。 所以，RM 的计算是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">erofs_rollinghash_calc_rm</span><span class="params">(<span class="type">int</span> window_size)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> RM = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; window_size - <span class="number">1</span>; ++i)</span><br><span class="line">                RM = (RM * RADIX) % PRIME_NUMBER;</span><br><span class="line">        <span class="keyword">return</span> RM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="red-black-tree-基础"><a href="#red-black-tree-基础" class="headerlink" title="red-black tree 基础"></a>red-black tree 基础</h2><p>除了用到 rolling hash, 压缩去重还用到了红黑树，let’s take a look.</p><p><a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">wikipedia</a> 相关定义：</p><blockquote><p>a red-black tree is a kind of self-balancing binary search tree. Each node stores an extra bit representing “color” (“red” or “black”), used to ensure that the tree remains balanced during insertions and deletions.</p></blockquote><p>红黑树是一种自平衡二叉查找树。</p><blockquote><p>a self-balancing binary search tree (BST) is any node-based binary search tree that automatically keeps its height (maximal number of levels below the root) small in the face of arbitrary item insertions and deletions.</p></blockquote><p>平衡二叉查找树就是为了深度(height)不要搞太深了。</p><blockquote><p>a binary search tree (BST), also called an ordered or sorted binary tree, is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node’s left subtree and less than the ones in its right subtree.</p></blockquote><p>二叉查找树就是排序的二叉树。</p><blockquote><p>a binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child.</p></blockquote><p>二叉树就是一代最多左右两娃。</p><p><a href="http://cslibrary.stanford.edu/110/BinaryTrees.html">stanford公开cs课</a>称 binary trees 有着 <em>优雅</em> 的递归指针结构。(mmm 艺术细胞有了…)</p><blockquote><p>Binary trees have an elegant recursive pointer structure</p></blockquote><p>erofs-utils 的实现在 dedupe.c + rb_tree.c里，just read…</p><ul><li>define the tree node</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>             red;     <span class="comment">// Color red (1), black (0)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">link</span>[2];</span> <span class="comment">// Link left [0] and right [1]</span></span><br><span class="line">    <span class="type">void</span>           *value;   <span class="comment">// User provided, used indirectly via rb_tree_node_cmp_f.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个 node 的值类型是一个 <code>void *</code>，使用者提供，用在下面 <code>-&gt;cmp</code> 这个 callback 函数里。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>    *<span class="title">root</span>;</span></span><br><span class="line">    rb_tree_node_cmp_f cmp;</span><br><span class="line">    <span class="type">size_t</span>             size;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>erofs dedup 的 <code>-&gt;cmp</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">z_erofs_dedupe_rbtree_cmp</span><span class="params">(<span class="keyword">struct</span> rb_tree *self,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> rb_node *node_a, <span class="keyword">struct</span> rb_node *node_b)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">z_erofs_dedupe_item</span> *<span class="title">e_a</span> =</span> node_a-&gt;value;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">z_erofs_dedupe_item</span> *<span class="title">e_b</span> =</span> node_b-&gt;value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (e_a-&gt;hash &gt; e_b-&gt;hash) - (e_a-&gt;hash &lt; e_b-&gt;hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-&gt;value</code> 是一个 dedup item，这个 item 的表征用 <code>hash</code> 来定，也就是前面的 rolling hash。</p><ul><li>insert the node</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">z_erofs_dedupe_insert</span><span class="params">(<span class="keyword">struct</span> z_erofs_inmem_extent *e,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> *original_data)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">z_erofs_dedupe_item</span> *<span class="title">di</span>;</span></span><br><span class="line">...</span><br><span class="line">        di-&gt;original_length = e-&gt;length;</span><br><span class="line">        erofs_sha256(original_data, window_size, di-&gt;prefix_sha256);</span><br><span class="line">        di-&gt;hash = erofs_rolling_hash_init(original_data,</span><br><span class="line">                        window_size, <span class="literal">true</span>); <span class="comment">//tj: here</span></span><br><span class="line">        <span class="built_in">memcpy</span>(di-&gt;extra_data, original_data + window_size,</span><br><span class="line">               e-&gt;length - window_size);</span><br><span class="line">        di-&gt;compressed_blkaddr = e-&gt;blkaddr;</span><br><span class="line">        di-&gt;compressed_blks = e-&gt;compressedblks;</span><br><span class="line">        di-&gt;partial = e-&gt;partial;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* with the same rolling hash */</span></span><br><span class="line">        <span class="keyword">if</span> (!rb_tree_insert(dedupe_subtree, di)) <span class="comment">//tj: here</span></span><br><span class="line">                <span class="built_in">free</span>(di);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>向 <code>dedupe_subtree</code> 这个 rb tree 里插入<code>di</code> 这个 node, <code>di-&gt;hash</code> 就是 rolling hash 的初始值。</p><ul><li>find the node</li></ul><p>call <code>-&gt;cmp</code> 这个 user 填入的 call back func。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">rb_tree_find</span><span class="params">(<span class="keyword">struct</span> rb_tree *self, <span class="type">void</span> *value)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (self) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">node</span> =</span> &#123; .value = value &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">it</span> =</span> self-&gt;root;</span><br><span class="line">        <span class="type">int</span> cmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (it) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((cmp = self-&gt;cmp(self, it, &amp;node))) &#123; <span class="comment">//tj: here</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// If the tree supports duplicates, they should be</span></span><br><span class="line">                <span class="comment">// chained to the right subtree for this to work</span></span><br><span class="line">                it = it-&gt;link[cmp &lt; <span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = it ? it-&gt;value : <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>erofs dedup 是在 match 里：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">z_erofs_dedupe_match</span><span class="params">(<span class="keyword">struct</span> z_erofs_dedupe_ctx *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">/* move backward byte-by-byte */</span></span><br><span class="line">        <span class="keyword">for</span> (; cur &gt;= ctx-&gt;start; --cur) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">z_erofs_dedupe_item</span> *<span class="title">e</span>;</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> extra;</span><br><span class="line">                u8 sha256[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (initial) &#123;</span><br><span class="line">                        <span class="comment">/* initial try */</span></span><br><span class="line">                        e_find.hash = erofs_rolling_hash_init(cur, window_size, <span class="literal">true</span>);</span><br><span class="line">                        initial = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        e_find.hash = erofs_rolling_hash_advance(e_find.hash,</span><br><span class="line">                                rollinghash_rm, cur[window_size], cur[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                e = rb_tree_find(dedupe_tree, &amp;e_find);</span><br><span class="line">                <span class="keyword">if</span> (!e) &#123;</span><br><span class="line">                        e = rb_tree_find(dedupe_subtree, &amp;e_find);</span><br><span class="line">                        <span class="keyword">if</span> (!e)</span><br><span class="line">                                <span class="keyword">continue</span>; <span class="comment">//tj: can not find</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>rolling 窗口区间在<code>cur</code> - <code>ctx-&gt;start</code>。第一次比较用 init 那个值(<code>initial try</code>)，后面的查找用了真正的 rolling hash 计算(<code>..._advance()</code>)。</p><p>ok，now 我们来看下 EROFS 是如何进行压缩去重(compressed data deduplication) 的。</p><h2 id="erofs-data-deduplication"><a href="#erofs-data-deduplication" class="headerlink" title="erofs data deduplication"></a>erofs data deduplication</h2><p>照例先了解下概念，<a href="https://en.wikipedia.org/wiki/Data_deduplication">wikipedia</a> 定义如下：</p><blockquote><p>data deduplication is a technique for eliminating duplicate copies of repeating data. Successful implementation of the technique can improve storage utilization, </p></blockquote><p>就是避免数据重复，减少存储占用。</p><p>erofs data dedup 大体的 flow:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vle_compress_one</span><br><span class="line">      |</span><br><span class="line">*z_erofs_compress_dedupe(,,len)* (-&gt; *z_erofs_dedupe_match*)</span><br><span class="line">      |</span><br><span class="line">      | &lt;no dupilcate&gt;</span><br><span class="line">erofs_compress_destsize</span><br><span class="line">      |</span><br><span class="line">   blk_write</span><br><span class="line">      |</span><br><span class="line">*z_erofs_dedupe_insert* (non-inline)</span><br></pre></td></tr></table></figure><p>对给定 <code>len</code> 长度源数据，压缩前先尝试 check 是否有重复的 data，如果有重复的(<code>z_erofs_dedupe_match</code>返回0表示match)，就不要写到磁盘了，直接 next round。如果没有重复，那就要写啊，同时记录下(via <code>z_erofs_dedupe_insert()</code>)让后来人比对。</p><p>在 match 到后，deduplication 的 data index 会回退到 noncompact，可能是简化逻辑。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (z_erofs_dedupe_match(&amp;dctx))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fall back to noncompact indexes for deduplication */</span></span><br><span class="line">inode-&gt;z_advise &amp;= ~Z_EROFS_ADVISE_COMPACTED_2B;</span><br><span class="line">inode-&gt;datalayout = EROFS_INODE_FLAT_COMPRESSION_LEGACY;</span><br></pre></td></tr></table></figure><p>那 rolling 是怎么找重复的了？滚动窗口 dedup 初始化时定义为 <code>EROFS_BLKSIZ</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err = z_erofs_dedupe_init(EROFS_BLKSIZ);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">z_erofs_dedupe_match</span><span class="params">(<span class="keyword">struct</span> z_erofs_dedupe_ctx *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">z_erofs_dedupe_item</span> <span class="title">e_find</span>;</span></span><br><span class="line">        u8 *cur;</span><br><span class="line">        <span class="type">bool</span> initial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!dedupe_tree)</span><br><span class="line">                <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;cur &gt; ctx-&gt;end - window_size)</span><br><span class="line">                cur = ctx-&gt;end - window_size;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                cur = ctx-&gt;cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* move backward byte-by-byte */</span></span><br><span class="line">        <span class="keyword">for</span> (; cur &gt;= ctx-&gt;start; --cur) &#123; <span class="comment">//tj: here</span></span><br></pre></td></tr></table></figure><p>从 <code>cur</code> 开始向后最小到 <code>ctx-&gt;start</code> 一个个字符滚动 check。<code>ctx-&gt;start</code> 就是接上次 rolling hash 的 end。rt?</p><p>如果 cur 往后退了，也就是 dedup 有个 <code>delta</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">delta = ctx-&gt;<span class="built_in">queue</span> + ctx-&gt;head - dctx.cur;</span><br><span class="line"><span class="keyword">if</span> (delta) &#123;</span><br><span class="line">        DBG_BUGON(delta &lt; <span class="number">0</span>);</span><br><span class="line">        DBG_BUGON(!ctx-&gt;e.length);</span><br><span class="line">        ctx-&gt;e.partial = <span class="literal">true</span>;</span><br><span class="line">        ctx-&gt;e.length -= delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时是部分 data dedup 的，有个 advise 申明这种 HEAD lcluster, 在 write index 里:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        type = ctx-&gt;e.raw ? Z_EROFS_VLE_CLUSTER_TYPE_PLAIN :</span><br><span class="line">                Z_EROFS_VLE_CLUSTER_TYPE_HEAD;</span><br><span class="line">        di.di_u.blkaddr = cpu_to_le32(ctx-&gt;e.blkaddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;e.partial) &#123;</span><br><span class="line">                DBG_BUGON(ctx-&gt;e.raw);</span><br><span class="line">                advise |= Z_EROFS_VLE_DI_PARTIAL_REF;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样 zmap 时可以准确找到它，也就是如下提交：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">erofs-utils: fuse: introduce partial-referenced pclusters</span><br><span class="line"></span><br><span class="line">Due to deduplication for compressed data, pclusters can be partially</span><br><span class="line">referenced with their prefixes.</span><br><span class="line"></span><br><span class="line">Decompression algorithms should know that in advance, otherwise they</span><br><span class="line">will fail out unexpectedly.</span><br></pre></td></tr></table></figure><h2 id="refer-doc"><a href="#refer-doc" class="headerlink" title="refer doc"></a>refer doc</h2><ul><li><a href="https://iq.opengenus.org/rolling-hash/">https://iq.opengenus.org/rolling-hash/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erofs-utils </tag>
            
            <tag> data-deduplication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转：浅析 Linux FS-Cache</title>
      <link href="/analyze-fscache-cookie-code.html"/>
      <url>/analyze-fscache-cookie-code.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzkwNjI5MjAxNg==&mid=2247484253&idx=1&sn=864faa036d84618153218e7b6d31a2bc&chksm=c0ebfd02f79c7414fc99821b001bd5bd7ed374547d34efdcd5326f9dddabe654e4ca064381a8&scene=178&cur_album_id=2360291497452929025#rd">FS-Cache 直译过来就是文件系统缓存，它旨在主要给网络文件系统提供一种本地缓存的能力，这里的本地缓存是指占用本地磁盘空间，从而提升慢速网络访问性能。当然，非网络文件系统也可以使用，比如最近 EROFS 就提交了一个基于 FS-Cache 的按需 (on-demand) 读特性。本文主要通过分析 cookie 相关源码来认识该模块，参考内核 5.17。</a></p>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fscache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rockpi4b Armbian Kodi 终于能使用蓝牙了</title>
      <link href="/how-to-let-bluetooth-work-under-armbian-kodi-for-rockpi4b-within-metal-case.html"/>
      <url>/how-to-let-bluetooth-work-under-armbian-kodi-for-rockpi4b-within-metal-case.html</url>
      
        <content type="html"><![CDATA[<p>这个板子以前我是这么用的：因眼馋搞了个官方指定的 NVMe (Acer那款，当时不到200块 128G) ，装了 Radxa 官方的 Debian stretch，不想落灰也想变美，就又搞了个铝外壳，不过 NVMe 装到壳子里，T卡就不能插拔了(貌似也不好装)，关键我T卡里装的是 LibreELEC，就这点精神食量，必须有，别问我为啥不用笔记本，这玩意小巧直接放到显示器旁，用时直接开关很方便，还减碳。那问题来了，难道要在这货上要装双系统？看了看有点复杂，不想弄了，所以只好将就把 NVMe 放到壳子下方，就可以插拔T卡了，不过总感觉有点别扭。</p><p>直到最近，发现一个叫 <a href="https://twisteros.com/">TwisterOS</a> 的发行版其中有个特性正是我想要的：</p><blockquote><ul><li>Kodi and MPV media players with built-in hardware acceleration support</li></ul></blockquote><p>但是， Download 要fan，好吧，其他bt工具都无果，xunlei竟然能下，不过是体验的会员速度，内心焦灼，不就是10块钱嘛，我tao，下下来 Checksum 没问题，先备份数据，T卡启动<code>dd</code>直接刷xz：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo xzcat *.img.xz | pv | <span class="built_in">dd</span> of=/dev/nvme0n1 bs=1M</span><br></pre></td></tr></table></figure><p>拔掉T卡接上电源，哈哈哈，蓝灯闪了，启动了。体验了一下，有点失望，Kodi 直接飙到57度，室内也就20左右，记得以前 LibreELEC 好像都不超过45，可能是盖子问题，另外只开浏览器，RAM 就用的好多，官方也推荐用 4G RAM，感觉没必要，再加上这个 OS 蓝牙不能用，打算放弃，看Application，确实装的多了，还是用 Armbian 算了。</p><p>既然决定用 Armbian 就搜了下竟然被我发现了，那就是 <a href="https://forum.armbian.com/topic/16516-rk3399-legacy-multimedia-framework/">RK3399 有个 legacy multimedia 包</a>，已经被集成到 Armbian 官方 Debian buster发行版了，这个 legacy 说的就是内核旧点(kernel-4.4)。赶紧到 <a href="https://imola.armbian.com/archive/rockpi-4b/archive/">Armbian download</a> 里下载 Armbian_21.08.1_Rockpi-4b_buster_legacy_4.4.213_xfce_desktop.img.xz (当前最新)，因 kernel 是 4.4，蓝牙应该正常，源更新时不需要 apt upgrade 防止挂掉费时折腾，我用的是<a href="http://mirrors.ustc.edu.cn/help/debian.html">ustc</a>。</p><h2 id="安装多媒体框架"><a href="#安装多媒体框架" class="headerlink" title="安装多媒体框架"></a>安装多媒体框架</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install media-buster-legacy-rk3399 --install-recommends</span><br></pre></td></tr></table></figure><p>安装完后不要 <code>systemctl disable lightdm</code> 禁用lightdm，恢复又要折腾，只需要logout，在登陆界面菜单选择Kodi-GBM就可以了。</p><h2 id="USB-移动硬盘不能自动-mount"><a href="#USB-移动硬盘不能自动-mount" class="headerlink" title="USB 移动硬盘不能自动 mount"></a>USB 移动硬盘不能自动 mount</h2><p>不想改fstab，LibreELEC 都是自动识别的，查了下是缺 usbmount 这个包，ubuntu有debian丢了，git clone then build 出一个deb，另我的移动硬盘是 NTFS 格式，只需要在&#x2F;etc&#x2F;usbmount&#x2F;usbmount.config里添加 ntfs 和 fuseblk 到文件系统支持列表里就行了：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">FILESYSTEMS=&quot;vfat ext2 ext3 ext4 hfsplus ntfs fuseblk&quot;</span><br></pre></td></tr></table></figure><p>盖上盖子，看了下die温度基本&lt;45, ok，完美。最后一步，来看 Kodi 如何使用蓝牙耳机：</p><h2 id="如何在-Kodi-下使用蓝牙耳机"><a href="#如何在-Kodi-下使用蓝牙耳机" class="headerlink" title="如何在 Kodi 下使用蓝牙耳机"></a>如何在 Kodi 下使用蓝牙耳机</h2><p>官方论坛有个<a href="https://forum.kodi.tv/showthread.php?tid=348258">帖子</a>说到：</p><blockquote><p>Bluetooth “receiver” functionality has to be done at OS level and has nothing to do with Kodi.<br>Kodi does not handle bluetooth at all, “bluetooth settings” you might see in LibreELEC is a part of a LE specific addon and is not present in vanilla Kodi.</p></blockquote><p>是的，Kodi 是作为一个 App 存在于 OS里。音频输出我不关心蓝牙，那是你的发行版需要关心的东西，所以不要因 LibreELEC 里有蓝牙配对就对我指手画脚。</p><p>ok, 那先把 Armbian 的蓝牙搞定，进lightdm, 果然<code>hciconfig</code>空空如也。</p><p>radax 官方 wiki 也是，buster 的都没有写，只写了 stretch 的，那玩意真的不准，费力啊。我们来看看，<a href="https://wiki.radxa.com/Rockpi4/Debian#Using_Bluetooth">根据提示</a>要装broadcom-wifibt-firmware 和 rockpi4-brcm-patch 两个包，看 stretch 用的 testing，一开始我选了 buster-testing，好家伙找不到，后来还是去 <a href="https://github.com/radxa/apt/tree/gh-pages/buster-stable/pool/main">radax 的 github apt仓</a> 看了下果然没有，是放到了buster-stable里，更正后却只有broadcom-wifibt-firmware，而没有 rockpi4-brcm-patch，取代的是安装了 brcm-patchram-plus1 这个包。nd，<code>hciconfig</code>还是没货，直到<a href="https://forum.radxa.com/t/ubuntu-server-image-no-bluetooth/160/13">发现一个帖子</a>提到要这个工具跑下，照着做果然<code>hciconfig</code>有输出了，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@rockpi-4b:~$ hciconfig </span><br><span class="line">hci0:Type: Primary  Bus: UART</span><br><span class="line">BD Address: xx:xx:xx:xx:xx:xx  ACL MTU: 1021:8  SCO MTU: 64:1</span><br><span class="line">UP RUNNING PSCAN </span><br><span class="line">RX bytes:890 acl:0 sco:0 events:64 errors:0</span><br><span class="line">TX bytes:5005 acl:0 sco:0 commands:64 errors:0</span><br></pre></td></tr></table></figure><p>radxa啊radxa，你就不能写个wiki嘛，等我有空来写？ 现在没空，赶紧拿出我心爱的漫步者耳麦，searching，配对，哈哈，it works。那 Kodi 咋用呢，摸索了下就是蓝牙连上后不要超时断开直接退出 lightdm 进 Kodi-GBM 就可以了，Kodi 音频输出设备里会多出一个蓝牙耳机的选项，选中它，哈哈，和 LibreELEC 一样一样的，装进我的外壳里，搞定。</p><h2 id="备份系统"><a href="#备份系统" class="headerlink" title="备份系统"></a>备份系统</h2><p>好不容易装好了，防止夜长了点，来备份吧，<code>dd</code>是备份整个disk，不合适大磁盘(我就没分区，简单啊，先用起来。。。)。<a href="https://wiki.radxa.com/Rockpi4/backup#Using_Rockpi4">官方的脚本</a>说是备份真实使用数据，用了下还是备份整个磁盘，估计有bug，没细看了。用原始<code>cp</code>方法吧，参考这个<a href="https://help.ubuntu.com/community/BackupYourSystem/TAR">帖子</a>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -cvpzf /home/tj/backup.tar.gz --exclude=/home/tj/backup.tar.gz --one-file-system / </span><br></pre></td></tr></table></figure><p>还是nvme快啊，分分钟搞定。</p><h2 id="装个散热风扇"><a href="#装个散热风扇" class="headerlink" title="装个散热风扇"></a>装个散热风扇</h2><p>这不快到6.1了吗，吹着风扇肯定双啊，我也能多起几个worker，装到壳子里面看来是没戏了，装外面吧，想了想，这货孔位兼容树莓派(raspberry pi)，逛了逛xbao，树莓派的外壳可真是琳琅满目啊，终于发现一款给集群用的简易亚克力外壳，中间层有风扇正好(幸好我螺丝多-_-!)，看看美图：</p><p><img src="https://tjtech.me/usr/uploads/2022/05/1026616912.png" alt="tj-rockpi4-case.png"></p><p>怎么能让它一直转悠！稍微吵了，尤其夜深时分。接3.3V，挂个三极管温控一把，美美的，gpio控制用<a href="https://wiki.radxa.com/Rockpi4/dev/libmraa">libmraa</a>。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rockpi4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转：EROFS ztailpacking 特性实现详解</title>
      <link href="/erofs-ztailpacking-explain.html"/>
      <url>/erofs-ztailpacking-explain.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/ZgKU68Jbgsk8bAK5eRR8EQ">EROFS ztailpacking 是 Linux kernel 5.17 合入的一个新特性，它完成了 tail-packing inline 对压缩文件的支持，从而节省更多空间提升性能。这篇文章主要介绍此特性的实现过程，包括 mkfs 侧 和 Kernel 侧。</a></p>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erofs </tag>
            
            <tag> tail-packing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从ali云弹性Web托管迁移Typecho到云虚拟主机遇坑说明</title>
      <link href="/migrate-typecho-from-aliapp-to-cloudvm.html"/>
      <url>/migrate-typecho-from-aliapp-to-cloudvm.html</url>
      
        <content type="html"><![CDATA[<p>ali云发来通知，弹性web托管2022.4.1下线，可以先免费提供云虚拟主机供替代，双啊，来移吧。本想着快点搞完，但是却忙中出错，看来还得静下心来理一理，保持个平常心:) 这里提下typecho(这个blog用的)迁移遇到的问题，主要涉及数据库，迁移步骤可以参考官方文档，这里就不写了。</p><ul><li>备份说明</li></ul><p>typecho的文章评论都在数据库里，管理员后台的备份就不适合这个迁移场景，用ali官方方法从弹性web托管备份数据库。另一个是网站的usr目录，usr嘛全是用户数据，自定义的修改都在里面，要我重改，要疯(虽然我本地有关联git)。防止万一，其他目录我也下载了，反正不大。</p><ul><li>typecho安装卡在确认数据库配置</li></ul><p>这个页面先不要关，我用的typecho版本是最新的，需要在install.php里56行添加<code>ob_start();</code>如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">55</span> <span class="keyword">else</span>:</span><br><span class="line"><span class="number">56</span> <span class="title function_ invoke__">ob_start</span>();</span><br><span class="line"><span class="number">57</span>    <span class="keyword">require_once</span> <span class="title function_ invoke__">dirname</span>(<span class="keyword">__FILE__</span>) . <span class="string">&#x27;/config.inc.php&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然后再在虚拟主机后台高级环境配置下PHP.INI里勾选如下:</p><p><img src="http://tjtech.me/usr/uploads/2022/02/2560896423.png" alt="ali-vm-php-ini.png"></p><p>现在，重新刷新下就能看到让你选择新建数据库还是要用旧数据库(前提是数据库已经迁移过来)，当然选择用旧数据库(这就是原来的备份文章数据啊)。</p><ul><li>域名解析失败</li></ul><p>主机后台域名新增绑定我的<code>tjtech.me</code>，记得勾选如下配置：</p><p><img src="http://tjtech.me/usr/uploads/2022/02/1105267136.png" alt="ali-vm-bind-domain.png"></p><p>绑定结果提示DNS域名解析失败，这个不用管，用下面工具里的检查项确认状态打勾才可以：</p><p><img src="http://tjtech.me/usr/uploads/2022/02/739792814.png" alt="ali-vm-parse-domain.png"></p><p>解析失败的要去域名解析配置页面确认，因为弹性web托管还保留以前的配置，需要变更下，具体有官方文档可查，用A记录填IP啥的。</p><ul><li>数据库类型确认</li></ul><p>之前弹性web托管用的mysql，云虚拟主机用的是pdo驱动的mysql。具体就是在安装完成后生成的<code>config.inc.php</code>(可能需要点时间或刷新图形ftp客户端)里：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$db</span> = <span class="keyword">new</span> <span class="title class_">Typecho_Db</span>(<span class="string">&#x27;Pdo_Mysql&#x27;</span>, <span class="string">&#x27;typecho_&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>404 not found</li></ul><p>只有index页面能看到，其他文章页面都404 not found, 后台可以打开，修改配置也不行。这里主要是后台的重写，要先关闭测试下，如果没问题，再启用如果提示下面:</p><p><img src="http://tjtech.me/usr/uploads/2022/02/1695653594.png" alt="typecho-rewrite-failed.png"></p><p>那要查一查<code>htdocs</code>目录下有没有<code>.htaccess</code>这个文件，这个文件是隐藏文件，filezilla图形客户端需要打开强制显示隐藏文件，可以从弹性web托管空间那里下载到本地再上传到云虚拟机上(估计自己创建一个也行，没测了，另两边server类型一样)。</p><p>wow, 一切又恢复了, well done!</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://help.aliyun.com/document_detail/312035.html">https://help.aliyun.com/document_detail/312035.html</a></p></li><li><p><a href="https://developer.aliyun.com/ask/24315">https://developer.aliyun.com/ask/24315</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typecho </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Read vfs_read() code</title>
      <link href="/read_linux_vfs_read.html"/>
      <url>/read_linux_vfs_read.html</url>
      
        <content type="html"><![CDATA[<p>主要关注page cache部分，参考Linux Kernel 4.14:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">407</span> <span class="type">ssize_t</span> __vfs_read(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count,</span><br><span class="line"><span class="number">408</span>                    <span class="type">loff_t</span> *pos)</span><br><span class="line"><span class="number">409</span> &#123;</span><br><span class="line"><span class="number">410</span>         <span class="keyword">if</span> (file-&gt;f_op-&gt;read)</span><br><span class="line"><span class="number">411</span>                 <span class="keyword">return</span> file-&gt;f_op-&gt;read(file, buf, count, pos);</span><br><span class="line"><span class="number">412</span>         <span class="keyword">else</span> <span class="keyword">if</span> (file-&gt;f_op-&gt;read_iter)</span><br><span class="line"><span class="number">413</span>                 <span class="keyword">return</span> new_sync_read(file, buf, count, pos);</span><br><span class="line"><span class="number">414</span>         <span class="keyword">else</span></span><br><span class="line"><span class="number">415</span>                 <span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="number">416</span> &#125;</span><br></pre></td></tr></table></figure><p><code>-&gt;read</code>和<code>-&gt;read_iter</code>的接口定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1699</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line"><span class="number">1702</span>         <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="number">1703</span>         <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="number">1704</span>         <span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="number">1705</span>         <span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br></pre></td></tr></table></figure><p>来看<code>new_sync_read()</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">new_sync_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> len, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123; .iov_base = buf, .iov_len = len &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kiocb</span> <span class="title">kiocb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iov_iter</span> <span class="title">iter</span>;</span></span><br><span class="line">        <span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">        init_sync_kiocb(&amp;kiocb, filp);</span><br><span class="line">        kiocb.ki_pos = *ppos;</span><br><span class="line">        iov_iter_init(&amp;iter, READ, &amp;iov, <span class="number">1</span>, len);</span><br><span class="line"></span><br><span class="line">        ret = call_read_iter(filp, &amp;kiocb, &amp;iter);</span><br><span class="line">        BUG_ON(ret == -EIOCBQUEUED);</span><br><span class="line">        *ppos = kiocb.ki_pos;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1769</span> <span class="type">static</span> <span class="keyword">inline</span> <span class="type">ssize_t</span> <span class="title function_">call_read_iter</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> kiocb *kio,</span></span><br><span class="line"><span class="params"><span class="number">1770</span>                                      <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">1771 &#123;</span><br><span class="line"><span class="number">1772</span>         <span class="keyword">return</span> file-&gt;f_op-&gt;read_iter(kio, iter);</span><br><span class="line"><span class="number">1773</span> &#125;</span><br></pre></td></tr></table></figure><p>在<code>vfs_open()</code>时会把inode关联到file。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">858</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"> <span class="number">863</span>         <span class="class"><span class="keyword">struct</span> <span class="title">path</span>             <span class="title">f_path</span>;</span></span><br><span class="line"> <span class="number">864</span>         <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>            *<span class="title">f_inode</span>;</span>       <span class="comment">/* cached value */</span></span><br><span class="line"> <span class="number">865</span>         <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">f_op</span>;</span></span><br><span class="line">...</span><br><span class="line"> <span class="number">894</span>         <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">f_mapping</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">879</span> <span class="type">int</span> <span class="title function_">vfs_open</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *path, <span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params"><span class="number">880</span>              <span class="type">const</span> <span class="keyword">struct</span> cred *cred)</span></span><br><span class="line">881 &#123;</span><br><span class="line"><span class="number">882</span>         <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> d_real(path-&gt;dentry, <span class="literal">NULL</span>, file-&gt;f_flags, <span class="number">0</span>);</span><br><span class="line"><span class="number">883</span></span><br><span class="line"><span class="number">884</span>         <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line"><span class="number">885</span>                 <span class="keyword">return</span> PTR_ERR(dentry);</span><br><span class="line"><span class="number">886</span></span><br><span class="line"><span class="number">887</span>         file-&gt;f_path = *path;</span><br><span class="line"><span class="number">888</span>         <span class="keyword">return</span> do_dentry_open(file, d_backing_inode(dentry), <span class="literal">NULL</span>, cred);</span><br><span class="line"><span class="number">889</span> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">714</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">do_dentry_open</span><span class="params">(<span class="keyword">struct</span> file *f,</span></span><br><span class="line"><span class="params"> <span class="number">715</span>                           <span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params"> <span class="number">716</span>                           <span class="type">int</span> (*open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *),</span></span><br><span class="line"><span class="params"> <span class="number">717</span>                           <span class="type">const</span> <span class="keyword">struct</span> cred *cred)</span></span><br><span class="line"> 718 &#123;</span><br><span class="line">...</span><br><span class="line"> <span class="number">726</span>         f-&gt;f_inode = inode;</span><br><span class="line"> <span class="number">727</span>         f-&gt;f_mapping = inode-&gt;i_mapping; <span class="comment">//tj: pagecache</span></span><br><span class="line">...</span><br><span class="line"> <span class="number">760</span>         f-&gt;f_op = fops_get(inode-&gt;i_fop); <span class="comment">//tj: f_op</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2150</span> <span class="meta">#<span class="keyword">define</span> fops_get(fops) \</span></span><br><span class="line"><span class="meta">2151         (((fops) &amp;&amp; try_module_get((fops)-&gt;owner) ? (fops) : NULL))</span></span><br></pre></td></tr></table></figure><p>vfs有个通用的<code>generic_file_read_iter()</code>接口，比如f2fs就直接用了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2795</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">f2fs_file_operations</span> =</span> &#123;</span><br><span class="line"><span class="number">2796</span>         .llseek         = f2fs_llseek,</span><br><span class="line"><span class="number">2797</span>         .read_iter      = generic_file_read_iter,</span><br></pre></td></tr></table></figure><p>在mm&#x2F;filemap.c:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2214</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">2215  * generic_file_read_iter - generic filesystem read routine</span></span><br><span class="line"><span class="comment">2216  * @iocb:       kernel I/O control block</span></span><br><span class="line"><span class="comment">2217  * @iter:       destination for the data read</span></span><br><span class="line"><span class="comment">2218  *</span></span><br><span class="line"><span class="comment">2219  * This is the &quot;read_iter()&quot; routine for all filesystems</span></span><br><span class="line"><span class="comment">2220  * that can use the page cache directly.</span></span><br><span class="line"><span class="comment">2221  */</span></span><br><span class="line"><span class="number">2222</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="number">2223</span> generic_file_read_iter(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span><br><span class="line"><span class="number">2224</span> &#123;</span><br><span class="line"><span class="number">2225</span>         <span class="type">size_t</span> count = iov_iter_count(iter);</span><br><span class="line"><span class="number">2226</span>         <span class="type">ssize_t</span> retval = <span class="number">0</span>;</span><br><span class="line"><span class="number">2227</span></span><br><span class="line"><span class="number">2228</span>         <span class="keyword">if</span> (!count)</span><br><span class="line"><span class="number">2229</span>                 <span class="keyword">goto</span> out; <span class="comment">/* skip atime */</span></span><br><span class="line"><span class="number">2230</span></span><br><span class="line"><span class="number">2231</span>         <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123;</span><br></pre></td></tr></table></figure><p><code>IOCB_DIRECT</code>不走page cache。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2272</span></span><br><span class="line"><span class="number">2273</span>         retval = generic_file_buffered_read(iocb, iter, retval);</span><br><span class="line"><span class="number">2274</span> out:</span><br><span class="line"><span class="number">2275</span>         <span class="keyword">return</span> retval;</span><br><span class="line"><span class="number">2276</span> &#125;</span><br></pre></td></tr></table></figure><p>来看 <code>generic_file_buffered_read()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1949</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">1950  * generic_file_buffered_read - generic file read routine</span></span><br><span class="line"><span class="comment">1951  * @iocb:       the iocb to read</span></span><br><span class="line"><span class="comment">1952  * @iter:       data destination</span></span><br><span class="line"><span class="comment">1953  * @written:    already copied</span></span><br><span class="line"><span class="comment">1954  *</span></span><br><span class="line"><span class="comment">1955  * This is a generic file read routine, and uses the</span></span><br><span class="line"><span class="comment">1956  * mapping-&gt;a_ops-&gt;readpage() function for the actual low-level stuff.</span></span><br><span class="line"><span class="comment">1957  *</span></span><br><span class="line"><span class="comment">1958  * This is really ugly. But the goto&#x27;s actually try to clarify some</span></span><br><span class="line"><span class="comment">1959  * of the logic when it comes to error handling etc.</span></span><br><span class="line"><span class="comment">1960  */</span></span><br><span class="line"><span class="number">1961</span> <span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">generic_file_buffered_read</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb,</span></span><br><span class="line"><span class="params"><span class="number">1962</span>                 <span class="keyword">struct</span> iov_iter *iter, <span class="type">ssize_t</span> written)</span></span><br><span class="line">1963 &#123;</span><br></pre></td></tr></table></figure><p>函数头注释已经提到了这里会用底层的<code>mapping-&gt;a_ops-&gt;readpage()</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1980</span>         index = *ppos &gt;&gt; PAGE_SHIFT;</span><br><span class="line"><span class="number">1981</span>         prev_index = ra-&gt;prev_pos &gt;&gt; PAGE_SHIFT;</span><br><span class="line"><span class="number">1982</span>         prev_offset = ra-&gt;prev_pos &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line"><span class="number">1983</span>         last_index = (*ppos + iter-&gt;count + PAGE_SIZE<span class="number">-1</span>) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"><span class="number">1984</span>         offset = *ppos &amp; ~PAGE_MASK;</span><br></pre></td></tr></table></figure><p>读范围：<code>index</code>和<code>last_index</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1999</span>                 page = find_get_page(mapping, index);</span><br></pre></td></tr></table></figure><p>先<code>find_get_page()</code>在page cache里找这个index偏移的page:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">263</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">264  * find_get_page - find and get a page reference</span></span><br><span class="line"><span class="comment">265  * @mapping: the address_space to search</span></span><br><span class="line"><span class="comment">266  * @offset: the page index</span></span><br><span class="line"><span class="comment">267  *</span></span><br><span class="line"><span class="comment">268  * Looks up the page cache slot at @mapping &amp; @offset.  If there is a</span></span><br><span class="line"><span class="comment">269  * page cache page, it is returned with an increased refcount.</span></span><br><span class="line"><span class="comment">270  *</span></span><br><span class="line"><span class="comment">271  * Otherwise, %NULL is returned.</span></span><br><span class="line"><span class="comment">272  */</span></span><br><span class="line"><span class="number">273</span> <span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page *<span class="title function_">find_get_page</span><span class="params">(<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params"><span class="number">274</span>                                         <span class="type">pgoff_t</span> offset)</span></span><br><span class="line">275 &#123;</span><br><span class="line"><span class="number">276</span>         <span class="keyword">return</span> pagecache_get_page(mapping, offset, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="number">277</span> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2000</span>                 <span class="keyword">if</span> (!page) &#123;</span><br><span class="line"><span class="number">2001</span>                         <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_NOWAIT)</span><br><span class="line"><span class="number">2002</span>                                 <span class="keyword">goto</span> would_block;</span><br><span class="line"><span class="number">2003</span>                         page_cache_sync_readahead(mapping,</span><br><span class="line"><span class="number">2004</span>                                         ra, filp,</span><br><span class="line"><span class="number">2005</span>                                         index, last_index - index);</span><br><span class="line"><span class="number">2006</span>                         page = find_get_page(mapping, index);</span><br><span class="line"><span class="number">2007</span>                         <span class="keyword">if</span> (unlikely(page == <span class="literal">NULL</span>))</span><br><span class="line"><span class="number">2008</span>                                 <span class="keyword">goto</span> no_cached_page;</span><br><span class="line"><span class="number">2009</span>                 &#125;</span><br></pre></td></tr></table></figure><p>如果找不到，就<code>page_cache_sync_readahead( , , , offset, req_size)</code>同步预读下，再找还找不到就走<code>no_cached_page</code>(可能性小)。来看同步读：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">489</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">490  * page_cache_sync_readahead - generic file readahead</span></span><br><span class="line"><span class="comment">491  * @mapping: address_space which holds the pagecache and I/O vectors</span></span><br><span class="line"><span class="comment">492  * @ra: file_ra_state which holds the readahead state</span></span><br><span class="line"><span class="comment">493  * @filp: passed on to -&gt;readpage() and -&gt;readpages()</span></span><br><span class="line"><span class="comment">494  * @offset: start offset into @mapping, in pagecache page-sized units</span></span><br><span class="line"><span class="comment">495  * @req_size: hint: total size of the read which the caller is performing in</span></span><br><span class="line"><span class="comment">496  *            pagecache pages</span></span><br><span class="line"><span class="comment">497  *</span></span><br><span class="line"><span class="comment">498  * page_cache_sync_readahead() should be called when a cache miss happened:</span></span><br><span class="line"><span class="comment">499  * it will submit the read.  The readahead logic may decide to piggyback more</span></span><br><span class="line"><span class="comment">500  * pages onto the read request if access patterns suggest it will improve</span></span><br><span class="line"><span class="comment">501  * performance.</span></span><br><span class="line"><span class="comment">502  */</span></span><br><span class="line"><span class="number">503</span> <span class="type">void</span> <span class="title function_">page_cache_sync_readahead</span><span class="params">(<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params"><span class="number">504</span>                                <span class="keyword">struct</span> file_ra_state *ra, <span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params"><span class="number">505</span>                                <span class="type">pgoff_t</span> offset, <span class="type">unsigned</span> <span class="type">long</span> req_size)</span></span><br><span class="line">506 &#123;</span><br><span class="line"><span class="number">507</span>         <span class="comment">/* no read-ahead */</span></span><br><span class="line"><span class="number">508</span>         <span class="keyword">if</span> (!ra-&gt;ra_pages)</span><br><span class="line"><span class="number">509</span>                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">510</span></span><br><span class="line"><span class="number">511</span>         <span class="comment">/* be dumb */</span></span><br><span class="line"><span class="number">512</span>         <span class="keyword">if</span> (filp &amp;&amp; (filp-&gt;f_mode &amp; FMODE_RANDOM)) &#123;</span><br><span class="line"><span class="number">513</span>                 force_page_cache_readahead(mapping, filp, offset, req_size);</span><br><span class="line"><span class="number">514</span>                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">515</span>         &#125;</span><br><span class="line"><span class="number">516</span></span><br><span class="line"><span class="number">517</span>         <span class="comment">/* do read-ahead */</span></span><br><span class="line"><span class="number">518</span>         ondemand_readahead(mapping, ra, filp, <span class="literal">false</span>, offset, req_size);</span><br><span class="line"><span class="number">519</span> &#125;</span><br></pre></td></tr></table></figure><p>cache miss时触发同步读， 如果是<code>FMODE_RANDOM</code>随机读走<code>force_page_cache_readahead()</code>，否则走<code>ondemand_readahead()</code>。</p><p>先看<code>force_page_cache_readahead()</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">205</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">206  * Chunk the readahead into 2 megabyte units, so that we don&#x27;t pin too much</span></span><br><span class="line"><span class="comment">207  * memory at once.</span></span><br><span class="line"><span class="comment">208  */</span></span><br><span class="line"><span class="number">209</span> <span class="type">int</span> <span class="title function_">force_page_cache_readahead</span><span class="params">(<span class="keyword">struct</span> address_space *mapping, <span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params"><span class="number">210</span>                                <span class="type">pgoff_t</span> offset, <span class="type">unsigned</span> <span class="type">long</span> nr_to_read)</span></span><br><span class="line">211 &#123;</span><br><span class="line"><span class="number">212</span>         <span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">bdi</span> =</span> inode_to_bdi(mapping-&gt;host);</span><br><span class="line"><span class="number">213</span>         <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span> *<span class="title">ra</span> =</span> &amp;filp-&gt;f_ra;</span><br><span class="line"><span class="number">214</span>         <span class="type">unsigned</span> <span class="type">long</span> max_pages;</span><br><span class="line"><span class="number">215</span></span><br><span class="line"><span class="number">216</span>         <span class="keyword">if</span> (unlikely(!mapping-&gt;a_ops-&gt;readpage &amp;&amp; !mapping-&gt;a_ops-&gt;readpages))</span><br><span class="line"><span class="number">217</span>                 <span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="number">218</span></span><br><span class="line"><span class="number">219</span>         <span class="comment">/*</span></span><br><span class="line"><span class="comment">220          * If the request exceeds the readahead window, allow the read to</span></span><br><span class="line"><span class="comment">221          * be up to the optimal hardware IO size</span></span><br><span class="line"><span class="comment">222          */</span></span><br><span class="line"><span class="number">223</span>         max_pages = <span class="type">max_t</span>(<span class="type">unsigned</span> <span class="type">long</span>, bdi-&gt;io_pages, ra-&gt;ra_pages);</span><br><span class="line"><span class="number">224</span>         nr_to_read = min(nr_to_read, max_pages);</span><br><span class="line"><span class="number">225</span>         <span class="keyword">while</span> (nr_to_read) &#123;</span><br><span class="line"><span class="number">226</span>                 <span class="type">int</span> err;</span><br><span class="line"><span class="number">227</span></span><br><span class="line"><span class="number">228</span>                 <span class="type">unsigned</span> <span class="type">long</span> this_chunk = (<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>) / PAGE_SIZE;</span><br><span class="line"><span class="number">229</span></span><br><span class="line"><span class="number">230</span>                 <span class="keyword">if</span> (this_chunk &gt; nr_to_read)</span><br><span class="line"><span class="number">231</span>                         this_chunk = nr_to_read;</span><br><span class="line"><span class="number">232</span>                 err = __do_page_cache_readahead(mapping, filp,</span><br><span class="line"><span class="number">233</span>                                                 offset, this_chunk, <span class="number">0</span>);</span><br><span class="line"><span class="number">234</span>                 <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">235</span>                         <span class="keyword">return</span> err;</span><br><span class="line"><span class="number">236</span></span><br><span class="line"><span class="number">237</span>                 offset += this_chunk;</span><br><span class="line"><span class="number">238</span>                 nr_to_read -= this_chunk;</span><br><span class="line"><span class="number">239</span>         &#125;</span><br><span class="line"><span class="number">240</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">241</span> &#125;</span><br></pre></td></tr></table></figure><p>就是按最大2MB单元大小的chunk进行预读，逻辑很单一。下面来看<code>ondemand_readahead()</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">372</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">373  * A minimal readahead algorithm for trivial sequential/random reads.</span></span><br><span class="line"><span class="comment">374  */</span></span><br><span class="line"><span class="number">375</span> <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"><span class="number">376</span> ondemand_readahead(<span class="keyword">struct</span> address_space *mapping,</span><br><span class="line"><span class="number">377</span>                    <span class="keyword">struct</span> file_ra_state *ra, <span class="keyword">struct</span> file *filp,</span><br><span class="line"><span class="number">378</span>                    <span class="type">bool</span> hit_readahead_marker, <span class="type">pgoff_t</span> offset,</span><br><span class="line"><span class="number">379</span>                    <span class="type">unsigned</span> <span class="type">long</span> req_size)</span><br><span class="line"><span class="number">380</span> &#123;</span><br></pre></td></tr></table></figure><p>算法逻辑就不看了，涉及到预读窗口readahead window: (<code>ra-&gt;start</code>, <code>ra-&gt;size</code>, <code>ra-&gt;async_size</code>), 最终调用<code>_do_page_cache_readahead()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">142</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">143 * __do_page_cache_readahead() actually reads a chunk of disk.  It allocates all</span></span><br><span class="line"><span class="comment">144 * the pages first, then submits them all for I/O. This avoids the very bad</span></span><br><span class="line"><span class="comment">145 * behaviour which would occur if page allocations are causing VM writeback.</span></span><br><span class="line"><span class="comment">146 * We really don&#x27;t want to intermingle reads and writes like that.</span></span><br><span class="line"><span class="comment">147 *</span></span><br><span class="line"><span class="comment">148 * Returns the number of pages requested, or the maximum amount of I/O allowed.</span></span><br><span class="line"><span class="comment">149 */</span></span><br><span class="line"><span class="number">150</span><span class="type">int</span> __do_page_cache_readahead(<span class="keyword">struct</span> address_space *mapping, <span class="keyword">struct</span> file *filp,</span><br><span class="line"><span class="number">151</span><span class="type">pgoff_t</span> offset, <span class="type">unsigned</span> <span class="type">long</span> nr_to_read,</span><br><span class="line"><span class="number">152</span><span class="type">unsigned</span> <span class="type">long</span> lookahead_size)</span><br></pre></td></tr></table></figure><p>先分配all pages再开始IO:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">193</span>         <span class="comment">/*</span></span><br><span class="line"><span class="comment">194          * Now start the IO.  We ignore I/O errors - if the page is not</span></span><br><span class="line"><span class="comment">195          * uptodate then the caller will launch readpage again, and</span></span><br><span class="line"><span class="comment">196          * will then handle the error.</span></span><br><span class="line"><span class="comment">197          */</span></span><br><span class="line"><span class="number">198</span>         <span class="keyword">if</span> (ret)</span><br><span class="line"><span class="number">199</span>                 read_pages(mapping, filp, &amp;page_pool, ret, gfp_mask);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">111</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">read_pages</span><span class="params">(<span class="keyword">struct</span> address_space *mapping, <span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">...</span></span><br><span class="line"><span class="params"><span class="number">120</span>         <span class="keyword">if</span> (mapping-&gt;a_ops-&gt;readpages) &#123;</span></span><br><span class="line"><span class="params"><span class="number">121</span>                 ret = mapping-&gt;a_ops-&gt;readpages(filp, mapping, pages, nr_pages);</span></span><br><span class="line"><span class="params"><span class="number">122</span>                 <span class="comment">/* Clean up the remaining pages */</span></span></span><br><span class="line"><span class="params"><span class="number">123</span>                 put_pages_list(pages);</span></span><br><span class="line"><span class="params"><span class="number">124</span>                 <span class="keyword">goto</span> out;</span></span><br><span class="line"><span class="params"><span class="number">125</span>         &#125;</span></span><br><span class="line"><span class="params"><span class="number">126</span></span></span><br><span class="line"><span class="params"><span class="number">127</span>         <span class="keyword">for</span> (page_idx = <span class="number">0</span>; page_idx &lt; nr_pages; page_idx++) &#123;</span></span><br><span class="line"><span class="params"><span class="number">128</span>                 <span class="keyword">struct</span> page *page = lru_to_page(pages);</span></span><br><span class="line"><span class="params"><span class="number">129</span>                 list_del(&amp;page-&gt;lru);</span></span><br><span class="line"><span class="params"><span class="number">130</span>                 <span class="keyword">if</span> (!add_to_page_cache_lru(page, mapping, page-&gt;index, gfp))</span></span><br><span class="line"><span class="params"><span class="number">131</span>                         mapping-&gt;a_ops-&gt;readpage(filp, page);</span></span><br><span class="line"><span class="params"><span class="number">132</span>                 put_page(page);</span></span><br><span class="line"><span class="params"><span class="number">133</span>         &#125;</span></span><br></pre></td></tr></table></figure><p>优先走<code>-&gt;readpages()</code>，如果没有走<code>-&gt;readpage()</code>。</p><p>接着看<code>generic_file_buffered_read()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2010</span>                 <span class="keyword">if</span> (PageReadahead(page)) &#123;</span><br><span class="line"><span class="number">2011</span>                         page_cache_async_readahead(mapping,</span><br><span class="line"><span class="number">2012</span>                                         ra, filp, page,</span><br><span class="line"><span class="number">2013</span>                                         index, last_index - index);</span><br><span class="line"><span class="number">2014</span>                 &#125;</span><br><span class="line"><span class="number">2015</span>                 <span class="keyword">if</span> (!PageUptodate(page)) &#123;</span><br><span class="line"><span class="number">2016</span>                         <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_NOWAIT) &#123;</span><br><span class="line"><span class="number">2017</span>                                 put_page(page);</span><br><span class="line"><span class="number">2018</span>                                 <span class="keyword">goto</span> would_block;</span><br><span class="line"><span class="number">2019</span>                         &#125;</span><br><span class="line"><span class="number">2020</span></span><br><span class="line"><span class="number">2021</span>                         <span class="comment">/*</span></span><br><span class="line"><span class="comment">2022                          * See comment in do_read_cache_page on why</span></span><br><span class="line"><span class="comment">2023                          * wait_on_page_locked is used to avoid unnecessarily</span></span><br><span class="line"><span class="comment">2024                          * serialisations and why it&#x27;s safe.</span></span><br><span class="line"><span class="comment">2025                          */</span></span><br><span class="line"><span class="number">2026</span>                         error = wait_on_page_locked_killable(page);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在page cache里找到了这个page，不过是<code>PG_readahead</code>就走个异步读。</p><p>要check page是不是最新的(2015行)，为啥, 让我们看<code>do_read_cache_pages()</code>里的<code>wait_on_page_locked</code>, ok，我们看下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2689</span> <span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">do_read_cache_page</span><span class="params">(<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params"><span class="number">2690</span>                                 <span class="type">pgoff_t</span> index,</span></span><br><span class="line"><span class="params"><span class="number">2691</span>                                 <span class="type">int</span> (*filler)(<span class="type">void</span> *, <span class="keyword">struct</span> page *),</span></span><br><span class="line"><span class="params"><span class="number">2692</span>                                 <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params"><span class="number">2693</span>                                 <span class="type">gfp_t</span> gfp)</span></span><br><span class="line">2694 &#123;</span><br><span class="line"><span class="number">2695</span>         <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="number">2696</span>         <span class="type">int</span> err;</span><br><span class="line"><span class="number">2697</span> repeat:</span><br><span class="line"><span class="number">2698</span>         page = find_get_page(mapping, index);</span><br><span class="line"><span class="number">2699</span>         <span class="keyword">if</span> (!page) &#123;</span><br><span class="line"><span class="number">2700</span>                 page = __page_cache_alloc(gfp | __GFP_COLD);</span><br><span class="line"><span class="number">2701</span>                 <span class="keyword">if</span> (!page)</span><br><span class="line"><span class="number">2702</span>                         <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"><span class="number">2703</span>                 err = add_to_page_cache_lru(page, mapping, index, gfp);</span><br><span class="line"><span class="number">2704</span>                 <span class="keyword">if</span> (unlikely(err)) &#123;</span><br><span class="line"><span class="number">2705</span>                         put_page(page);</span><br><span class="line"><span class="number">2706</span>                         <span class="keyword">if</span> (err == -EEXIST)</span><br><span class="line"><span class="number">2707</span>                                 <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="number">2708</span>                         <span class="comment">/* Presumably ENOMEM for radix tree node */</span></span><br><span class="line"><span class="number">2709</span>                         <span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line"><span class="number">2710</span>                 &#125;</span><br><span class="line"><span class="number">2711</span></span><br><span class="line"><span class="number">2712</span> filler:</span><br><span class="line"><span class="number">2713</span>                 err = filler(data, page);</span><br><span class="line"><span class="number">2714</span>                 <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">2715</span>                         put_page(page);</span><br><span class="line"><span class="number">2716</span>                         <span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line"><span class="number">2717</span>                 &#125;</span><br><span class="line"><span class="number">2718</span></span><br><span class="line"><span class="number">2719</span>                 page = wait_on_page_read(page);</span><br><span class="line"><span class="number">2720</span>                 <span class="keyword">if</span> (IS_ERR(page))</span><br><span class="line"><span class="number">2721</span>                         <span class="keyword">return</span> page;</span><br><span class="line"><span class="number">2722</span>                 <span class="keyword">goto</span> out;</span><br><span class="line"><span class="number">2723</span>         &#125;</span><br><span class="line"><span class="number">2724</span>         <span class="keyword">if</span> (PageUptodate(page))</span><br><span class="line"><span class="number">2725</span>                 <span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure><p>在<code>find_get_page()</code>找到了这个page后，这个page可能被锁：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2727</span>         <span class="comment">/*</span></span><br><span class="line"><span class="comment">2728          * Page is not up to date and may be locked due one of the following</span></span><br><span class="line"><span class="comment">2729          * case a: Page is being filled and the page lock is held</span></span><br><span class="line"><span class="comment">2730          * case b: Read/write error clearing the page uptodate status</span></span><br><span class="line"><span class="comment">2731          * case c: Truncation in progress (page locked)</span></span><br><span class="line"><span class="comment">2732          * case d: Reclaim in progress</span></span><br><span class="line"><span class="comment">2733          *</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">2757          */</span></span><br><span class="line"><span class="number">2758</span>         wait_on_page_locked(page);</span><br><span class="line"><span class="number">2759</span>         <span class="keyword">if</span> (PageUptodate(page))</span><br><span class="line"><span class="number">2760</span>                 <span class="keyword">goto</span> out;</span><br><span class="line"><span class="number">2761</span></span><br><span class="line"><span class="number">2762</span>         <span class="comment">/* Distinguish between all the cases under the safety of the lock */</span></span><br><span class="line"><span class="number">2763</span>         lock_page(page);</span><br><span class="line"><span class="number">2764</span></span><br><span class="line"><span class="number">2765</span>         <span class="comment">/* Case c or d, restart the operation */</span></span><br><span class="line"><span class="number">2766</span>         <span class="keyword">if</span> (!page-&gt;mapping) &#123;</span><br><span class="line"><span class="number">2767</span>                 unlock_page(page);</span><br><span class="line"><span class="number">2768</span>                 put_page(page);</span><br><span class="line"><span class="number">2769</span>                 <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="number">2770</span>         &#125;</span><br><span class="line"><span class="number">2771</span></span><br><span class="line"><span class="number">2772</span>         <span class="comment">/* Someone else locked and filled the page in a very small window */</span></span><br><span class="line"><span class="number">2773</span>         <span class="keyword">if</span> (PageUptodate(page)) &#123;</span><br><span class="line"><span class="number">2774</span>                 unlock_page(page);</span><br><span class="line"><span class="number">2775</span>                 <span class="keyword">goto</span> out;</span><br><span class="line"><span class="number">2776</span>         &#125;</span><br><span class="line"><span class="number">2777</span>         <span class="keyword">goto</span> filler;</span><br><span class="line"><span class="number">2778</span></span><br><span class="line"><span class="number">2779</span> out:</span><br><span class="line"><span class="number">2780</span>         mark_page_accessed(page);</span><br><span class="line"><span class="number">2781</span>         <span class="keyword">return</span> page;</span><br><span class="line"><span class="number">2782</span> &#125;</span><br></pre></td></tr></table></figure><p>可见，page的状态有多繁琐。</p><p>等待page被解锁：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">516</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">517  * Wait for a page to be unlocked.</span></span><br><span class="line"><span class="comment">518  *</span></span><br><span class="line"><span class="comment">519  * This must be called with the caller &quot;holding&quot; the page,</span></span><br><span class="line"><span class="comment">520  * ie with increased &quot;page-&gt;count&quot; so that the page won&#x27;t</span></span><br><span class="line"><span class="comment">521  * go away during the wait..</span></span><br><span class="line"><span class="comment">522  */</span></span><br><span class="line"><span class="number">523</span> <span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">wait_on_page_locked</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">524 &#123;</span><br><span class="line"><span class="number">525</span>         <span class="keyword">if</span> (PageLocked(page))</span><br><span class="line"><span class="number">526</span>                 wait_on_page_bit(compound_head(page), PG_locked);</span><br><span class="line"><span class="number">527</span> &#125;</span><br></pre></td></tr></table></figure><p>ok，so 等待unlock后，pageuptodate走<code>page_ok</code>, cp to user then next page:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2091</span>                 <span class="comment">/*</span></span><br><span class="line"><span class="comment">2092                  * Ok, we have the page, and it&#x27;s up-to-date, so</span></span><br><span class="line"><span class="comment">2093                  * now we can copy it to user space...</span></span><br><span class="line"><span class="comment">2094                  */</span></span><br><span class="line"><span class="number">2095</span></span><br><span class="line"><span class="number">2096</span>                 ret = copy_page_to_iter(page, offset, nr, iter);</span><br><span class="line"><span class="number">2097</span>                 offset += ret;</span><br><span class="line"><span class="number">2098</span>                 index += offset &gt;&gt; PAGE_SHIFT;</span><br><span class="line"><span class="number">2099</span>                 offset &amp;= ~PAGE_MASK;</span><br><span class="line"><span class="number">2100</span>                 prev_offset = offset;</span><br><span class="line"><span class="number">2101</span></span><br><span class="line"><span class="number">2102</span>                 put_page(page);</span><br><span class="line"><span class="number">2103</span>                 written += ret;</span><br><span class="line"><span class="number">2104</span>                 <span class="keyword">if</span> (!iov_iter_count(iter))</span><br><span class="line"><span class="number">2105</span>                         <span class="keyword">goto</span> out;</span><br><span class="line"><span class="number">2106</span>                 <span class="keyword">if</span> (ret &lt; nr) &#123;</span><br><span class="line"><span class="number">2107</span>                         error = -EFAULT;</span><br><span class="line"><span class="number">2108</span>                         <span class="keyword">goto</span> out;</span><br><span class="line"><span class="number">2109</span>                 &#125;</span><br><span class="line"><span class="number">2110</span>                 <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>简单一句话，就是pagecache找不到的就走底层的<code>-&gt;readpage(s)()</code>, 它只负责read disk。</p><p>Done。</p>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EROFS on-disk compact index 生成分析</title>
      <link href="/erofs-compacted-index-generation.html"/>
      <url>/erofs-compacted-index-generation.html</url>
      
        <content type="html"><![CDATA[<p>compact index是EROFS默认使用的压缩布局，内核提交描述如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">staging: erofs: add compacted ondisk compression indexes</span><br><span class="line"></span><br><span class="line">This patch introduces new compacted compression indexes.</span><br><span class="line"></span><br><span class="line">In contract to legacy compression indexes that</span><br><span class="line">   each 4k logical cluster has an 8-byte index,</span><br><span class="line">compacted ondisk compression indexes will have</span><br><span class="line">   amortized 2 bytes for each 4k logical cluster (compacted 2B)</span><br><span class="line">   amortized 4 bytes for each 4k logical cluster (compacted 4B)</span><br><span class="line"></span><br><span class="line">In detail, several continuous clusters will be encoded in</span><br><span class="line">a compacted pack with cluster types, offsets, and one blkaddr</span><br><span class="line">at the end of the pack to leave 4-byte margin for better</span><br><span class="line">decoding performance, as illustrated below:</span><br><span class="line">   _____________________________________________</span><br><span class="line">  |___@_____ encoded bits __________|_ blkaddr _|</span><br><span class="line">  0       .                                     amortized * vcnt</span><br><span class="line">  .          .</span><br><span class="line">  .             .                   amortized * vcnt - 4</span><br><span class="line">  .                .</span><br><span class="line">  .___________________.</span><br><span class="line">  |_type_|_clusterofs_|</span><br><span class="line"></span><br><span class="line">Note that compacted 2 / 4B should be aligned with 32 / 8 bytes</span><br><span class="line">in order to avoid each pack crossing page boundary.</span><br></pre></td></tr></table></figure><p>以下分析参考erofs-utils 1.3。</p><p>legacy compression的index是8个字节，对应一个4KB的lcluster:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">z_erofs_vle_decompressed_index</span> &#123;</span></span><br><span class="line">__le16 di_advise;</span><br><span class="line"><span class="comment">/* where to decompress in the head cluster */</span></span><br><span class="line">__le16 di_clusterofs;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="comment">/* for the head cluster */</span></span><br><span class="line">__le32 blkaddr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * for the rest clusters</span></span><br><span class="line"><span class="comment"> * eg. for 4k page-sized cluster, maximum 4K*64k = 256M)</span></span><br><span class="line"><span class="comment"> * [0] - pointing to the head cluster</span></span><br><span class="line"><span class="comment"> * [1] - pointing to the tail cluster</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__le16 delta[<span class="number">2</span>];</span><br><span class="line">&#125; di_u;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个文件的块index的大小<code>indexsize</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">vle_compressmeta_capacity</span><span class="params">(<span class="type">erofs_off_t</span> filesize)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> indexsize = BLK_ROUND_UP(filesize) *</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> z_erofs_vle_decompressed_index);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Z_EROFS_LEGACY_MAP_HEADER_SIZE + indexsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Z_EROFS_LEGACY_MAP_HEADER_SIZE</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">z_erofs_map_header</span> &#123;</span></span><br><span class="line">__le32h_reserved1;</span><br><span class="line">__le16h_advise;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bit 0-3 : algorithm type of head 1 (logical cluster type 01);</span></span><br><span class="line"><span class="comment"> * bit 4-7 : algorithm type of head 2 (logical cluster type 11).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__u8h_algorithmtype;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bit 0-2 : logical cluster bits - 12, e.g. 0 for 4096;</span></span><br><span class="line"><span class="comment"> * bit 3-7 : reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__u8h_clusterbits;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Z_EROFS_VLE_LEGACY_HEADER_PADDING       8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Z_EROFS_LEGACY_MAP_HEADER_SIZE\</span></span><br><span class="line"><span class="meta">(sizeof(struct z_erofs_map_header) + Z_EROFS_VLE_LEGACY_HEADER_PADDING)</span></span><br></pre></td></tr></table></figure><p>在写压缩文件时：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u8 *compressmeta = <span class="built_in">malloc</span>(vle_compressmeta_capacity(inode-&gt;i_size));</span><br><span class="line"><span class="keyword">if</span> (!compressmeta)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br></pre></td></tr></table></figure><p>注意到<code>z_erofs_map_header</code>也占用8Bytes。也就是如下布局图：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">             +----legacymetasize/extent_isize-------+</span><br><span class="line">             |                                      |</span><br><span class="line">+------------+            index start         index end</span><br><span class="line">|inode|xattrs|                |                     |</span><br><span class="line">+------------|---------+------|-----+-----+----+----|</span><br><span class="line">             | map hdr | pad  | 8B  | 8B  | ...|last|</span><br><span class="line">             |---------+------+-----+-----+----+----|</span><br><span class="line">             |                |                     |</span><br><span class="line">       compressmeta       metacur(1st)         metacur(last)</span><br><span class="line">             |                |</span><br><span class="line">             +-LEGACY MAP HDR-+                    </span><br></pre></td></tr></table></figure><p>ok，我们来看compact index，在<code>z_erofs_convert_to_compacted_format()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> mpos = Z_EROFS_VLE_EXTENT_ALIGN(inode-&gt;inode_isize +</span><br><span class="line">   inode-&gt;xattr_isize) +</span><br><span class="line">  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> z_erofs_map_header);</span><br></pre></td></tr></table></figure><p>留意到cluster type只有3种：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">Z_EROFS_VLE_CLUSTER_TYPE_PLAIN= <span class="number">0</span>,</span><br><span class="line">Z_EROFS_VLE_CLUSTER_TYPE_HEAD= <span class="number">1</span>,</span><br><span class="line">Z_EROFS_VLE_CLUSTER_TYPE_NONHEAD= <span class="number">2</span>,</span><br><span class="line">Z_EROFS_VLE_CLUSTER_TYPE_RESERVED= <span class="number">3</span>,</span><br><span class="line">Z_EROFS_VLE_CLUSTER_TYPE_MAX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用2个bits就可以了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Z_EROFS_VLE_DI_CLUSTER_TYPE_BITS        2</span></span><br></pre></td></tr></table></figure><p>而<code>di_clusterofs</code>有效数据只要12bits即可，也就是说type + clusterofs&#x2F;delta，14bits就可以搞定，也就是compact 2B。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (destsize == <span class="number">4</span>) &#123;</span><br><span class="line">        vcnt = <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (destsize == <span class="number">2</span> &amp;&amp; logical_clusterbits == <span class="number">12</span>) &#123;</span><br><span class="line">        vcnt = <span class="number">16</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">&#125;</span><br><span class="line">encodebits = (vcnt * destsize * <span class="number">8</span> - <span class="number">32</span>) / vcnt;</span><br></pre></td></tr></table></figure><p>对compact 2b，<code>encodebits</code>是(16x2Bx8-32)&#x2F;16&#x3D;14 bits, 对齐 32bits。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">                            in</span><br><span class="line">         8B align            |</span><br><span class="line">------------|---------+------|-----+-----+----+----|</span><br><span class="line">            | map hdr | pad  | 8B  | 8B  | ...|last|</span><br><span class="line">            |---------|------+-----+-----+----+----|</span><br><span class="line">                      |</span><br><span class="line">                      mpos</span><br></pre></td></tr></table></figure><p>因为compact 2b需要32bits对齐，如果mpos没有32bits对齐，那就要补上就有了<code>compact_4b_initial</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">compacted_4b_initial = (<span class="number">32</span> - mpos % <span class="number">32</span>) / <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>then，算下2b有多少：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">compacted_2b = rounddown(totalidx - compacted_4b_initial, <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>剩下的就是<code>compacted_4b_end</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">compacted_4b_end = totalidx - compacted_4b_initial - compacted_2b;</span><br></pre></td></tr></table></figure><p>来看<code>out</code>的生成：</p><p>type + offset的14bits分成了1个字节和6bits，so <code>rem</code>就是6，那剩下的2bits需要从next获取，然后拼接：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ch = out[pos / <span class="number">8</span>] &amp; ((<span class="number">1</span> &lt;&lt; rem) - <span class="number">1</span>);</span><br><span class="line">out[pos / <span class="number">8</span>] = (v &lt;&lt; rem) | ch;</span><br></pre></td></tr></table></figure><p>因为2bits被用了，那剩下的放到下一个字节，也就是:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">out[pos / <span class="number">8</span> + <span class="number">1</span>] = v &gt;&gt; (<span class="number">8</span> - rem); </span><br></pre></td></tr></table></figure><p>在此基础上再右移8bits得到下一个，也就是:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">out[pos / <span class="number">8</span> + <span class="number">2</span>] = v &gt;&gt; (<span class="number">16</span> - rem);</span><br></pre></td></tr></table></figure><p>Done.</p>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erofs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qemu和host间传输文件方法之挂载</title>
      <link href="/transfer-files-between-qemu-and-host-via-mount.html"/>
      <url>/transfer-files-between-qemu-and-host-via-mount.html</url>
      
        <content type="html"><![CDATA[<p>我们有时希望传输文件到qemu里，那如何做了？官方给的答复：</p><blockquote><p>Simple: Treat the virtual machine as if it was a real machine and<br>transfer files to and from it.</p><p>More to the point, the following are the most common methods:</p><p>A) If the virtual machine runs Windows, OS&#x2F;2 or Linux, create a Samba<br>network share on the Linux host (or anywhere else), put files on it,<br>and access the share over the network from the virtual machine. Some<br>qemu versions include options to automate this.</p><p>B) On the Linux host create a disk image of a floppy or CD with the<br>desired files, then use qemu commands to virtually insert the disk<br>image file in the virtual floppy or CD drive.  Again there are tools<br>to automate this.</p></blockquote><blockquote><p>C) Run a file transfer tool such as rsync, ssh, ftp etc. on the virtual<br>machine and the Linux host and use it to transfer files.</p><p>D) With the virtual machine not running, loop mount its virtual hard<br>drive on the Linux host, and copy files to and from it.</p></blockquote><p>我们来看下比较简单的D)方法，可以理解为移动硬盘(<code>-hda</code>)，具体操作如下：</p><p>Step1: 创建磁盘镜像</p><p>这里是256MB disk:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=disk.img bs=1M count=256</span><br></pre></td></tr></table></figure><p>Step2: 格式化磁盘</p><p>这里我们用ext4格式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 disk.img</span><br></pre></td></tr></table></figure><p>Step3: 挂载磁盘</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> disk_mnt //建个挂载点</span><br><span class="line">sudo mount disk.img disk_mnt/</span><br></pre></td></tr></table></figure><p>看下内容<code>ls -l disk_mnt/</code>是空的：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">total 12</span><br><span class="line">drwx------ 2 root root 12288 11月  6 11:57 lost+found</span><br></pre></td></tr></table></figure><p>ok, cp你想cp的东东。。。然后用<code>sudo umount disk_mnt</code>卸载。接下来我们就挂到qemu上。</p><p>Step4: 挂载磁盘到qemu</p><p>就是在末尾加上<code>-hda disk.img</code>, 进入后能看到如下磁盘信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@x86 ]<span class="comment"># ls -l /dev/sda </span></span><br><span class="line">brw-rw----    1 0        0           8,   0 Nov  6 04:14 /dev/sda</span><br><span class="line">[root@x86 ]<span class="comment"># dmesg | grep sda</span></span><br><span class="line">[    2.471753] sd 0:0:0:0: [sda] 524288 512-byte logical blocks: (268 MB/256 MiB)</span><br><span class="line">[    2.484847] sd 0:0:0:0: [sda] Write Protect is off</span><br><span class="line">[    2.486421] sd 0:0:0:0: [sda] Mode Sense: 00 3a 00 00</span><br><span class="line">[    2.488286] sd 0:0:0:0: [sda] Write cache: enabled, <span class="built_in">read</span> cache: enabled, doesn<span class="string">&#x27;t support DPO or FUA</span></span><br><span class="line"><span class="string">[    2.548810] sd 0:0:0:0: [sda] Attached SCSI disk</span></span><br></pre></td></tr></table></figure><p>ok, now 我们把这个硬盘挂上去。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@x86 ]# mount -t ext4 /dev/sda mnt/</span><br></pre></td></tr></table></figure><p>then, just use it. </p><p>Step5: 自动挂载</p><p>上面的退出qemu后就丢失了，因为fstab没有修改，我们回到之前制作rootfs那里，rootfs&#x2F;ext4&#x2F;fstab里添加：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dev/sda        /mnt            ext4    defaults                0       0</span><br></pre></td></tr></table></figure><p>then重新制作ramdisk.gz即可。</p><h2 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h2><p><a href="https://blog.csdn.net/geshifei/article/details/119869405">https://blog.csdn.net/geshifei/article/details/119869405</a></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转：如何在EROFS上支持Android文件块映射</title>
      <link href="/support-android-map-blocklist-on-erofs.html"/>
      <url>/support-android-map-blocklist-on-erofs.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/eqIQC5Mx4mkvnYVn0LnajA">本文首先从Ext4认识Android文件块映射，然后从生成EROFS文件系统的三个部分(非压缩文件、压缩文件和尾端数据)分析如何生成block list文件。</a></p>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erofs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Read squashfs readpage() code</title>
      <link href="/read_squashfs_readpage_code.html"/>
      <url>/read_squashfs_readpage_code.html</url>
      
        <content type="html"><![CDATA[<p>内核参考5.x:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> <span class="title">squashfs_aops</span> =</span> &#123;</span><br><span class="line">        .readpage = squashfs_readpage</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">squashfs_readpage</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">if</span> (bsize == <span class="number">0</span>)</span><br><span class="line">                        res = squashfs_readpage_sparse(page, expected);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        res = squashfs_readpage_block(page, block, bsize, expected); <span class="comment">//tj: note page</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">                res = squashfs_readpage_fragment(page, expected);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!res)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们只看<code>squashfs_readpage_block()</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./file_direct.c:25:int squashfs_readpage_block(struct page *target_page, u64 block, int bsize,</span><br><span class="line">./file_cache.c:21:int squashfs_readpage_block(struct page *page, u64 block, int bsize, int expected)</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">./Makefile:10:squashfs-<span class="variable">$(CONFIG_SQUASHFS_FILE_DIRECT)</span> += file_direct.o page_actor.o</span></span><br><span class="line"><span class="section">./Makefile:9:squashfs-<span class="variable">$(CONFIG_SQUASHFS_FILE_CACHE)</span> += file_cache.o</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">choice</span><br><span class="line">        prompt &quot;File decompression options&quot;</span><br><span class="line">        depends on SQUASHFS</span><br><span class="line">        help</span><br><span class="line">          Squashfs now supports two options for decompressing file</span><br><span class="line">          data.  Traditionally Squashfs has decompressed into an</span><br><span class="line">          intermediate buffer and then memcopied it into the page cache.</span><br><span class="line">          Squashfs now supports the ability to decompress directly into</span><br><span class="line">          the page cache.</span><br><span class="line"></span><br><span class="line">          If unsure, select &quot;Decompress file data into an intermediate buffer&quot;</span><br><span class="line"></span><br><span class="line">config SQUASHFS_FILE_CACHE</span><br><span class="line">        bool &quot;Decompress file data into an intermediate buffer&quot;</span><br><span class="line">        help</span><br><span class="line">          Decompress file data into an intermediate buffer and then</span><br><span class="line">          memcopy it into the page cache.</span><br><span class="line"></span><br><span class="line">config SQUASHFS_FILE_DIRECT</span><br><span class="line">        bool &quot;Decompress files directly into the page cache&quot;</span><br><span class="line">        help</span><br><span class="line">          Directly decompress file data into the page cache.</span><br><span class="line">          Doing so can significantly improve performance because</span><br><span class="line">          it eliminates a memcpy and it also removes the lock contention</span><br><span class="line">          on the single buffer.</span><br><span class="line"></span><br><span class="line">endchoice</span><br></pre></td></tr></table></figure><p>注释很清晰，我们先看<code>FILE_CACHE</code>(file_cache.c), 关注如何cp到page cache：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Read separately compressed datablock and memcopy into page cache */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">squashfs_readpage_block</span><span class="params">(<span class="keyword">struct</span> page *page, u64 block, <span class="type">int</span> bsize, <span class="type">int</span> expected)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">i</span> =</span> page-&gt;mapping-&gt;host;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">squashfs_cache_entry</span> *<span class="title">buffer</span> =</span> squashfs_get_datablock(i-&gt;i_sb,</span><br><span class="line">                block, bsize);</span><br><span class="line">        <span class="type">int</span> res = buffer-&gt;error;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res)</span><br><span class="line">                ERROR(<span class="string">&quot;Unable to read page, block %llx, size %x\n&quot;</span>, block,</span><br><span class="line">                        bsize);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                squashfs_copy_cache(page, buffer, expected, <span class="number">0</span>); <span class="comment">//tj: note page</span></span><br><span class="line"></span><br><span class="line">        squashfs_cache_put(buffer);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>临时中间buffer:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> squashfs_cache_entry *<span class="title function_">squashfs_get_datablock</span><span class="params">(<span class="keyword">struct</span> super_block *sb,</span></span><br><span class="line"><span class="params">                                u64 start_block, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">squashfs_sb_info</span> *<span class="title">msblk</span> =</span> sb-&gt;s_fs_info;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> squashfs_cache_get(sb, msblk-&gt;read_page, start_block, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Look-up block in cache, and increment usage count.  If not in cache, read</span></span><br><span class="line"><span class="comment"> * and decompress it from disk.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> squashfs_cache_entry *<span class="title function_">squashfs_cache_get</span><span class="params">(<span class="keyword">struct</span> super_block *sb,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> squashfs_cache *cache, u64 block, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>这里的cache是啥？我们来看：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> squashfs_cache_entry *<span class="title function_">squashfs_cache_get</span><span class="params">(<span class="keyword">struct</span> super_block *sb,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> squashfs_cache *cache, u64 block, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i, n;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">squashfs_cache_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">        spin_lock(&amp;cache-&gt;lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = cache-&gt;curr_blk, n = <span class="number">0</span>; n &lt; cache-&gt;entries; n++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cache-&gt;entry[i].block == block) &#123;</span><br><span class="line">                                cache-&gt;curr_blk = i;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        i = (i + <span class="number">1</span>) % cache-&gt;entries;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n == cache-&gt;entries) &#123;</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * Block not in cache, if all cache entries are used</span></span><br><span class="line"><span class="comment">                         * go to sleep waiting for one to become available.</span></span><br><span class="line"><span class="comment">                         */</span></span><br></pre></td></tr></table></figure><p>在入参<code>cache</code>里查找是否有<code>block</code>, 如果没有会从disk读出来：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initialise chosen cache entry, and fill it in from</span></span><br><span class="line"><span class="comment"> * disk.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cache-&gt;unused--;</span><br><span class="line">entry-&gt;block = block;</span><br><span class="line">entry-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">entry-&gt;pending = <span class="number">1</span>;</span><br><span class="line">entry-&gt;num_waiters = <span class="number">0</span>;</span><br><span class="line">entry-&gt;error = <span class="number">0</span>;</span><br><span class="line">spin_unlock(&amp;cache-&gt;lock);</span><br><span class="line"></span><br><span class="line">entry-&gt;length = squashfs_read_data(sb, block, length,</span><br><span class="line">        &amp;entry-&gt;next_index, entry-&gt;actor);  <span class="comment">//tj: here, note that -&gt;actor</span></span><br><span class="line"></span><br><span class="line">spin_lock(&amp;cache-&gt;lock);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">squashfs_read_data</span><span class="params">(<span class="keyword">struct</span> super_block *sb, u64 index, <span class="type">int</span> length,</span></span><br><span class="line"><span class="params">                       u64 *next_index, <span class="keyword">struct</span> squashfs_page_actor *output)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        res = squashfs_bio_read(sb, index, length, &amp;bio, &amp;offset); <span class="comment">//tj: rd from disk</span></span><br><span class="line">        <span class="keyword">if</span> (res)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (compressed) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!msblk-&gt;stream) &#123;</span><br><span class="line">                        res = -EIO;</span><br><span class="line">                        <span class="keyword">goto</span> out_free_bio;</span><br><span class="line">                &#125;</span><br><span class="line">                res = squashfs_decompress(msblk, bio, offset, length, output);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = copy_bio_to_actor(bio, output, offset, length);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们看下解压到哪里了, check lz4:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">lz4_uncompress</span><span class="params">(<span class="keyword">struct</span> squashfs_sb_info *msblk, <span class="type">void</span> *strm,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> bio *bio, <span class="type">int</span> offset, <span class="type">int</span> length,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> squashfs_page_actor *output)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bvec_iter_all</span> <span class="title">iter_all</span> =</span> &#123;&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> *<span class="title">bvec</span> =</span> bvec_init_iter_all(&amp;iter_all);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">squashfs_lz4</span> *<span class="title">stream</span> =</span> strm;</span><br><span class="line">        <span class="type">void</span> *buff = stream-&gt;input, *data;</span><br><span class="line">        <span class="type">int</span> bytes = length, res;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tj: get -&gt;input</span></span><br><span class="line">        <span class="keyword">while</span> (bio_next_segment(bio, &amp;iter_all)) &#123;</span><br><span class="line">                <span class="type">int</span> avail = min(bytes, ((<span class="type">int</span>)bvec-&gt;bv_len) - offset);</span><br><span class="line"></span><br><span class="line">                data = page_address(bvec-&gt;bv_page) + bvec-&gt;bv_offset;</span><br><span class="line">                <span class="built_in">memcpy</span>(buff, data + offset, avail);</span><br><span class="line">                buff += avail;</span><br><span class="line">                bytes -= avail;</span><br><span class="line">                offset = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = LZ4_decompress_safe(stream-&gt;input, stream-&gt;output,</span><br><span class="line">                length, output-&gt;length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line">        bytes = res;</span><br><span class="line">        data = squashfs_first_page(output);</span><br><span class="line">        buff = stream-&gt;output;</span><br><span class="line">        <span class="keyword">while</span> (data) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bytes &lt;= PAGE_SIZE) &#123;</span><br><span class="line">                        <span class="built_in">memcpy</span>(data, buff, bytes);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memcpy</span>(data, buff, PAGE_SIZE);</span><br><span class="line">                buff += PAGE_SIZE;</span><br><span class="line">                bytes -= PAGE_SIZE;</span><br><span class="line">                data = squashfs_next_page(output);</span><br><span class="line">        &#125;</span><br><span class="line">        squashfs_finish_page(output);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用解压前，原始<code>-&gt;input</code>来自<code>bio</code>，具体不跟了。来看下解压完后:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">squashfs_first_page</span><span class="params">(<span class="keyword">struct</span> squashfs_page_actor *actor)</span></span><br><span class="line">&#123;</span><br><span class="line">        actor-&gt;next_page = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> actor-&gt;page[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">squashfs_next_page</span><span class="params">(<span class="keyword">struct</span> squashfs_page_actor *actor)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> actor-&gt;next_page == actor-&gt;pages ? <span class="literal">NULL</span> :</span><br><span class="line">                actor-&gt;page[actor-&gt;next_page++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解压后的数据都放到了<code>actor-&gt;page</code>。ok, 看下如何cp的page cache:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Copy data into page cache  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">squashfs_copy_cache</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="keyword">struct</span> squashfs_cache_entry *buffer,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> bytes, <span class="type">int</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> page-&gt;mapping-&gt;host;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">squashfs_sb_info</span> *<span class="title">msblk</span> =</span> inode-&gt;i_sb-&gt;s_fs_info;</span><br><span class="line">        <span class="type">int</span> i, mask = (<span class="number">1</span> &lt;&lt; (msblk-&gt;block_log - PAGE_SHIFT)) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> start_index = page-&gt;index &amp; ~mask, end_index = start_index | mask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Loop copying datablock into pages.  As the datablock likely covers</span></span><br><span class="line"><span class="comment">         * many PAGE_SIZE pages (default block size is 128 KiB) explicitly</span></span><br><span class="line"><span class="comment">         * grab the pages from the page cache, except for the page that we&#x27;ve</span></span><br><span class="line"><span class="comment">         * been called to fill.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (i = start_index; i &lt;= end_index &amp;&amp; bytes &gt; <span class="number">0</span>; i++,</span><br><span class="line">                        bytes -= PAGE_SIZE, offset += PAGE_SIZE) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">push_page</span>;</span></span><br><span class="line">                <span class="type">int</span> avail = buffer ? <span class="type">min_t</span>(<span class="type">int</span>, bytes, PAGE_SIZE) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                TRACE(<span class="string">&quot;bytes %d, i %d, available_bytes %d\n&quot;</span>, bytes, i, avail);</span><br><span class="line"></span><br><span class="line">                push_page = (i == page-&gt;index) ? page :</span><br><span class="line">                        grab_cache_page_nowait(page-&gt;mapping, i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!push_page)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (PageUptodate(push_page))</span><br><span class="line">                        <span class="keyword">goto</span> skip_page;</span><br><span class="line"></span><br><span class="line">                squashfs_fill_page(push_page, buffer, offset, avail);</span><br><span class="line">skip_page:</span><br><span class="line">                unlock_page(push_page);</span><br><span class="line">                <span class="keyword">if</span> (i != page-&gt;index)</span><br><span class="line">                        put_page(push_page);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从page cache里获取page:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page *<span class="title function_">grab_cache_page_nowait</span><span class="params">(<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">                                <span class="type">pgoff_t</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> pagecache_get_page(mapping, index,</span><br><span class="line">                        FGP_LOCK|FGP_CREAT|FGP_NOFS|FGP_NOWAIT,</span><br><span class="line">                        mapping_gfp_mask(mapping));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.x引入了folio，不知道啥，我们看下4.14上的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pagecache_get_page - find and get a page reference</span></span><br><span class="line"><span class="comment"> * @mapping: the address_space to search</span></span><br><span class="line"><span class="comment"> * @offset: the page index</span></span><br><span class="line"><span class="comment"> * @fgp_flags: PCG flags</span></span><br><span class="line"><span class="comment"> * @gfp_mask: gfp mask to use for the page cache data page allocation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Looks up the page cache slot at @mapping &amp; @offset.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PCG flags modify how the page is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @fgp_flags can be:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - FGP_ACCESSED: the page will be marked accessed</span></span><br><span class="line"><span class="comment"> * - FGP_LOCK: Page is return locked</span></span><br><span class="line"><span class="comment"> * - FGP_CREAT: If page is not present then a new page is allocated using</span></span><br><span class="line"><span class="comment"> *   @gfp_mask and added to the page cache and the VM&#x27;s LRU</span></span><br><span class="line"><span class="comment"> *   list. The page is returned locked and with an increased</span></span><br><span class="line"><span class="comment"> *   refcount.</span></span><br><span class="line"><span class="comment"> * - FGP_FOR_MMAP: Similar to FGP_CREAT, only we want to allow the caller to do</span></span><br><span class="line"><span class="comment"> *   its own locking dance if the page is already in cache, or unlock the page</span></span><br><span class="line"><span class="comment"> *   before returning if we had to add the page to pagecache.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If FGP_LOCK or FGP_CREAT are specified then the function may sleep even</span></span><br><span class="line"><span class="comment"> * if the GFP flags specified for FGP_CREAT are atomic.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If there is a page cache page, it is returned with an increased refcount.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">pagecache_get_page</span><span class="params">(<span class="keyword">struct</span> address_space *mapping, <span class="type">pgoff_t</span> offset,</span></span><br><span class="line"><span class="params"><span class="type">int</span> fgp_flags, <span class="type">gfp_t</span> gfp_mask)</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>啊，在page cache中查找某个slot, 这个slot用<code>@mapping &amp; @offset</code>唯一标识。</p><p>而真正的cp在<code>squashfs_fill_page()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">squashfs_fill_page</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="keyword">struct</span> squashfs_cache_entry *buffer, <span class="type">int</span> offset, <span class="type">int</span> avail)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> copied;</span><br><span class="line">        <span class="type">void</span> *pageaddr;</span><br><span class="line"></span><br><span class="line">        pageaddr = kmap_atomic(page); <span class="comment">//tj: virtual page of this page</span></span><br><span class="line">        copied = squashfs_copy_data(pageaddr, buffer, offset, avail); <span class="comment">//tj: here</span></span><br><span class="line">        <span class="built_in">memset</span>(pageaddr + copied, <span class="number">0</span>, PAGE_SIZE - copied);</span><br><span class="line">        kunmap_atomic(pageaddr);</span><br><span class="line"></span><br><span class="line">        flush_dcache_page(page);</span><br><span class="line">        <span class="keyword">if</span> (copied == avail)</span><br><span class="line">                SetPageUptodate(page);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                SetPageError(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, 为了性能，来看file_direct.c：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Read separately compressed datablock directly into page cache */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">squashfs_readpage_block</span><span class="params">(<span class="keyword">struct</span> page *target_page, u64 block, <span class="type">int</span> bsize,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> expected)</span></span><br></pre></td></tr></table></figure><p>首先创建一个<code>page actor</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a &quot;page actor&quot; which will kmap and kunmap the</span></span><br><span class="line"><span class="comment"> * page cache pages appropriately within the decompressor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">actor = squashfs_page_actor_init_special(page, pages, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (actor == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> squashfs_page_actor *<span class="title function_">squashfs_page_actor_init_special</span><span class="params">(<span class="keyword">struct</span> page **page,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> pages, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">squashfs_page_actor</span> *<span class="title">actor</span> =</span> kmalloc(<span class="keyword">sizeof</span>(*actor), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (actor == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        actor-&gt;length = length ? : pages * PAGE_SIZE;</span><br><span class="line">        actor-&gt;page = page; <span class="comment">//tj: note</span></span><br><span class="line">        actor-&gt;pages = pages;</span><br><span class="line">        actor-&gt;next_page = <span class="number">0</span>;</span><br><span class="line">        actor-&gt;pageaddr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>接下来和file_cache.c一样，从page cache获取page：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Try to grab all the pages covered by the Squashfs block */</span></span><br><span class="line"><span class="keyword">for</span> (missing_pages = <span class="number">0</span>, i = <span class="number">0</span>, n = start_index; i &lt; pages; i++, n++) &#123;</span><br><span class="line">        page[i] = (n == target_page-&gt;index) ? target_page :</span><br><span class="line">                grab_cache_page_nowait(target_page-&gt;mapping, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (page[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                missing_pages++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PageUptodate(page[i])) &#123;</span><br><span class="line">                unlock_page(page[i]);</span><br><span class="line">                put_page(page[i]);</span><br><span class="line">                page[i] = <span class="literal">NULL</span>;</span><br><span class="line">                missing_pages++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果获取不到，fall back到临时的buffer like file_cache.c:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (missing_pages) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Couldn&#x27;t get one or more pages, this page has either</span></span><br><span class="line"><span class="comment">         * been VM reclaimed, but others are still in the page cache</span></span><br><span class="line"><span class="comment">         * and uptodate, or we&#x27;re racing with another thread in</span></span><br><span class="line"><span class="comment">         * squashfs_readpage also trying to grab them.  Fall back to</span></span><br><span class="line"><span class="comment">         * using an intermediate buffer.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        res = squashfs_read_cache(target_page, block, bsize, pages,</span><br><span class="line">                                                page, expected);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> mark_errored;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">squashfs_read_cache</span><span class="params">(<span class="keyword">struct</span> page *target_page, u64 block, <span class="type">int</span> bsize,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> pages, <span class="keyword">struct</span> page **page, <span class="type">int</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">i</span> =</span> target_page-&gt;mapping-&gt;host;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">squashfs_cache_entry</span> *<span class="title">buffer</span> =</span> squashfs_get_datablock(i-&gt;i_sb,</span><br><span class="line">                                                 block, bsize);</span><br><span class="line">        <span class="type">int</span> res = buffer-&gt;error, n, offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                ERROR(<span class="string">&quot;Unable to read page, block %llx, size %x\n&quot;</span>, block,</span><br><span class="line">                        bsize);</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; pages &amp;&amp; bytes &gt; <span class="number">0</span>; n++,</span><br><span class="line">                        bytes -= PAGE_SIZE, offset += PAGE_SIZE) &#123;</span><br><span class="line">                <span class="type">int</span> avail = <span class="type">min_t</span>(<span class="type">int</span>, bytes, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (page[n] == <span class="literal">NULL</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                squashfs_fill_page(page[n], buffer, offset, avail); <span class="comment">//tj: here</span></span><br><span class="line">                unlock_page(page[n]);</span><br><span class="line">                <span class="keyword">if</span> (page[n] != target_page)</span><br><span class="line">                        put_page(page[n]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">        squashfs_cache_put(buffer);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能获取到，直接解压到page cache buffers:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Decompress directly into the page cache buffers */</span></span><br><span class="line">res = squashfs_read_data(inode-&gt;i_sb, block, bsize, <span class="literal">NULL</span>, actor);</span><br></pre></td></tr></table></figure><p>前文已经分析过了，最终解压到了<code>actor-&gt;page</code>, 来源一开始：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">squashfs_readpage_block</span><span class="params">(<span class="keyword">struct</span> page *target_page, u64 block, <span class="type">int</span> bsize,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> expected)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="type">int</span> start_index = target_page-&gt;index &amp; ~mask;</span><br><span class="line">        <span class="type">int</span> end_index = start_index | mask;</span><br><span class="line">...</span><br><span class="line">        pages = end_index - start_index + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        page = kmalloc_array(pages, <span class="keyword">sizeof</span>(<span class="type">void</span> *), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (page == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>最终处理：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Mark pages as uptodate, unlock and release */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pages; i++) &#123;</span><br><span class="line">        flush_dcache_page(page[i]);</span><br><span class="line">        SetPageUptodate(page[i]);</span><br><span class="line">        unlock_page(page[i]);</span><br><span class="line">        <span class="keyword">if</span> (page[i] != target_page) <span class="comment">//tj: 不释放target_page</span></span><br><span class="line">                put_page(page[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> squashfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>e-Paper Weather Station</title>
      <link href="/epaper-weather-station.html"/>
      <url>/epaper-weather-station.html</url>
      
        <content type="html"><![CDATA[<p>I always want to use the 7.5 e-Paper(i already have) to display weather forecast instead of my previous solution displayed on LCD. You know, the old one is not beautiful for me any more since i have seen that on e-paper. That feel is so good to me. I decide to switch on it.</p><p>Yes, i only need to update display code related with e-Paper library. Moreover, i need a set of beautiful weather icons instead of current not available at all for e-Paper.</p><p>Yes, i find <a href="https://github.com/manifestinteractive/weather-underground-icons/tree/master/dist/icons/solid-black/svg">them</a>. It looks very very comfortable when the final effect is coming out. Let’s take a look at below:</p><p><img src="http://tjtech.me/usr/uploads/2021/08/1332443131.jpg" alt="epaper-w.jpg"></p><p>Perfect, rt? e-Paper does almost consume none power. Only a little when refresh. </p><p>And i will not show the back side:) It’s just using raspberry pi zero + USB wifi which is cheaper than zero W.</p><p>About how to use these icons for e-Paper, i just change the format, check below or google&#x2F;baidu it:</p>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> e-paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>erofs-utils mkfs 概览</title>
      <link href="/erofs-mkfs-overview.html"/>
      <url>/erofs-mkfs-overview.html</url>
      
        <content type="html"><![CDATA[<p>参考erofs-utils 1.2.1, 入口是<code>erofs_mkfs_build_tree()</code>, 不关注xattr&#x2F;extent, 看之前我们再了解下inode:</p><blockquote><p>Inodes store information about files and directories (folders), such as file ownership, access mode (read, write, execute permissions), and file type.<br>Each file is associated with an inode, which is identified by an integer, often referred to as an i-number or inode number.</p></blockquote><p>ok, let’s start:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> erofs_inode *<span class="title function_">erofs_mkfs_build_tree</span><span class="params">(<span class="keyword">struct</span> erofs_inode *dir)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!S_ISDIR(dir-&gt;i_mode)) &#123;</span><br><span class="line"><span class="keyword">if</span> (S_ISLNK(dir-&gt;i_mode)) &#123;</span><br><span class="line"><span class="type">char</span> *<span class="type">const</span> symlink = <span class="built_in">malloc</span>(dir-&gt;i_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!symlink)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">ret = readlink(dir-&gt;i_srcpath, symlink, dir-&gt;i_size);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">free</span>(symlink);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-errno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = erofs_write_file_from_buffer(dir, symlink);</span><br><span class="line"><span class="built_in">free</span>(symlink);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret = erofs_write_file(dir);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">erofs_prepare_inode_buffer(dir);</span><br><span class="line">erofs_write_tail_end(dir);</span><br><span class="line"><span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看link file，走<code>erofs_write_file_from_buffer()</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">erofs_write_file_from_buffer</span><span class="params">(<span class="keyword">struct</span> erofs_inode *inode, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> nblocks = erofs_blknr(inode-&gt;i_size);</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">inode-&gt;datalayout = EROFS_INODE_FLAT_INLINE; <span class="comment">//tj: inline data</span></span><br><span class="line"></span><br><span class="line">ret = __allocate_inode_bh_data(inode, nblocks);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nblocks)</span><br><span class="line">blk_write(buf, inode-&gt;u.i_blkaddr, nblocks);</span><br><span class="line">inode-&gt;idata_size = inode-&gt;i_size % EROFS_BLKSIZ; <span class="comment">//tj: get tail-end size</span></span><br><span class="line"><span class="keyword">if</span> (inode-&gt;idata_size) &#123;</span><br><span class="line">inode-&gt;idata = <span class="built_in">malloc</span>(inode-&gt;idata_size);</span><br><span class="line"><span class="keyword">if</span> (!inode-&gt;idata)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="built_in">memcpy</span>(inode-&gt;idata, buf + blknr_to_addr(nblocks),</span><br><span class="line">       inode-&gt;idata_size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关fields:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">erofs_inode</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="type">umode_t</span> i_mode;</span><br><span class="line"><span class="type">erofs_off_t</span> i_size; <span class="comment">//tj: file size</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">u32 i_blkaddr; <span class="comment">//tj: for uncompressed</span></span><br><span class="line">u32 i_blocks; <span class="comment">//tj: for compressed</span></span><br><span class="line">u32 i_rdev;</span><br><span class="line">&#125; u;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> inode_isize;</span><br><span class="line"><span class="comment">/* inline tail-end packing size */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> idata_size;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> xattr_isize;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> extent_isize;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *idata; <span class="comment">//tj: hold tail-end data</span></span><br></pre></td></tr></table></figure><p><code>__allocate_inode_bh_data()</code>用来分配data buffer，得到块首地址(<code>inode-&gt;u.i_blkaddr</code>)，涉及buffer cache，这里暂略过。</p><p>!link file(也应该就是regular file)走的是<code>erofs_write_file()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">erofs_write_file</span><span class="params">(<span class="keyword">struct</span> erofs_inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret, fd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!inode-&gt;i_size) &#123;</span><br><span class="line">inode-&gt;datalayout = EROFS_INODE_FLAT_PLAIN;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cfg.c_compr_alg_master &amp;&amp; erofs_file_is_compressible(inode)) &#123;</span><br><span class="line">ret = erofs_write_compressed_file(inode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ret || ret != -ENOSPC)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fallback to all data uncompressed */</span></span><br><span class="line">fd = open(inode-&gt;i_srcpath, O_RDONLY | O_BINARY);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -errno;</span><br><span class="line"></span><br><span class="line">ret = write_uncompressed_file_from_fd(inode, fd);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先check有压缩就走压缩流程: <code>erofs_write_compressed_file()</code>，如果压缩失败就走uncompressed: <code>write_uncompressed_file_from_fd()</code>。</p><p>先看写压缩：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">erofs_write_compressed_file</span><span class="params">(<span class="keyword">struct</span> erofs_inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">blkaddr = erofs_mapbh(bh-&gt;block, <span class="literal">true</span>);<span class="comment">/* start_blkaddr */</span></span><br><span class="line">ctx.blkaddr = blkaddr;</span><br><span class="line">ctx.metacur = compressmeta + Z_EROFS_LEGACY_MAP_HEADER_SIZE;</span><br><span class="line">ctx.head = ctx.tail = <span class="number">0</span>;</span><br><span class="line">ctx.clusterofs = <span class="number">0</span>;</span><br><span class="line">remaining = inode-&gt;i_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (remaining) &#123;</span><br><span class="line"><span class="type">const</span> u64 readcount = <span class="type">min_t</span>(u64, remaining,</span><br><span class="line">    <span class="keyword">sizeof</span>(ctx.<span class="built_in">queue</span>) - ctx.tail);</span><br><span class="line"></span><br><span class="line">ret = read(fd, ctx.<span class="built_in">queue</span> + ctx.tail, readcount);</span><br><span class="line"><span class="keyword">if</span> (ret != readcount) &#123;</span><br><span class="line">ret = -errno;</span><br><span class="line"><span class="keyword">goto</span> err_bdrop;</span><br><span class="line">&#125;</span><br><span class="line">remaining -= readcount;</span><br><span class="line">ctx.tail += readcount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* do one compress round */</span></span><br><span class="line">ret = vle_compress_one(inode, &amp;ctx, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err_bdrop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* do the final round */</span></span><br><span class="line">ret = vle_compress_one(inode, &amp;ctx, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err_bdrop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fall back to no compression mode */</span></span><br><span class="line">compressed_blocks = ctx.blkaddr - blkaddr;</span><br><span class="line"><span class="keyword">if</span> (compressed_blocks &gt;= BLK_ROUND_UP(inode-&gt;i_size)) &#123;</span><br><span class="line">ret = -ENOSPC; <span class="comment">//tj: </span></span><br><span class="line"><span class="keyword">goto</span> err_bdrop;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">erofs_info(<span class="string">&quot;compressed %s (%llu bytes) into %u blocks&quot;</span>,</span><br><span class="line">   inode-&gt;i_srcpath, (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)inode-&gt;i_size,</span><br><span class="line">   compressed_blocks);</span><br></pre></td></tr></table></figure><p>整体逻辑就是压缩，压缩，到最后一次 via <code>vle_compress_one()</code>。到最后区分压缩类型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cfg.c_legacy_compress) &#123;</span><br><span class="line">inode-&gt;extent_isize = legacymetasize;</span><br><span class="line">inode-&gt;datalayout = EROFS_INODE_FLAT_COMPRESSION_LEGACY; <span class="comment">//tj: 老旧压缩</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret = z_erofs_convert_to_compacted_format(inode, blkaddr - <span class="number">1</span>,</span><br><span class="line">  legacymetasize, <span class="number">12</span>);</span><br><span class="line">DBG_BUGON(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看非压缩：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_uncompressed_file_from_fd</span><span class="params">(<span class="keyword">struct</span> erofs_inode *inode, <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nblocks, i;</span><br><span class="line"></span><br><span class="line">inode-&gt;datalayout = EROFS_INODE_FLAT_INLINE;</span><br><span class="line">nblocks = inode-&gt;i_size / EROFS_BLKSIZ;</span><br><span class="line"></span><br><span class="line">ret = __allocate_inode_bh_data(inode, nblocks);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nblocks; ++i) &#123;</span><br><span class="line"><span class="type">char</span> buf[EROFS_BLKSIZ];</span><br><span class="line"></span><br><span class="line">ret = read(fd, buf, EROFS_BLKSIZ);</span><br><span class="line"><span class="keyword">if</span> (ret != EROFS_BLKSIZ) &#123;</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -errno;</span><br><span class="line"><span class="keyword">return</span> -EAGAIN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = blk_write(buf, inode-&gt;u.i_blkaddr + i, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，先通过<code>__allocate_inode_bh_data()</code>分配data buffer得到<code>i_blkaddr</code>，然后写入img。Then, check尾端数据:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* read the tail-end data */</span></span><br><span class="line">inode-&gt;idata_size = inode-&gt;i_size % EROFS_BLKSIZ;</span><br><span class="line"><span class="keyword">if</span> (inode-&gt;idata_size) &#123;</span><br><span class="line">inode-&gt;idata = <span class="built_in">malloc</span>(inode-&gt;idata_size);</span><br><span class="line"><span class="keyword">if</span> (!inode-&gt;idata)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">ret = read(fd, inode-&gt;idata, inode-&gt;idata_size);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; inode-&gt;idata_size) &#123;</span><br><span class="line"><span class="built_in">free</span>(inode-&gt;idata);</span><br><span class="line">inode-&gt;idata = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有<code>tail-end data</code>，那么读出来到<code>inode-&gt;idata</code>供后面使用。</p><p>ok，接下来会call <code>erofs_prepare_inode_buffer()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">erofs_prepare_inode_buffer</span><span class="params">(<span class="keyword">struct</span> erofs_inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> inodesize;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">erofs_buffer_head</span> *<span class="title">bh</span>, *<span class="title">ibh</span>;</span></span><br><span class="line"></span><br><span class="line">DBG_BUGON(inode-&gt;bh || inode-&gt;bh_inline);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_inode_layout_compression(inode))</span><br><span class="line"><span class="keyword">goto</span> noinline; <span class="comment">//tj: 压缩不会出现inline了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * if the file size is block-aligned for uncompressed files,</span></span><br><span class="line"><span class="comment"> * should use EROFS_INODE_FLAT_PLAIN data mapping mode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!inode-&gt;idata_size)</span><br><span class="line">inode-&gt;datalayout = EROFS_INODE_FLAT_PLAIN;</span><br><span class="line"></span><br><span class="line">bh = erofs_balloc(INODE, inodesize, <span class="number">0</span>, inode-&gt;idata_size);</span><br><span class="line"><span class="keyword">if</span> (bh == ERR_PTR(-ENOSPC)) &#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">inode-&gt;datalayout = EROFS_INODE_FLAT_PLAIN;</span><br><span class="line">noinline:</span><br><span class="line"><span class="comment">/* expend an extra block for tail-end data */</span></span><br><span class="line">ret = erofs_prepare_tail_block(inode);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">bh = erofs_balloc(INODE, inodesize, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(bh))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(bh);</span><br><span class="line">DBG_BUGON(inode-&gt;bh_inline);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(bh)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(bh);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (inode-&gt;idata_size) &#123;</span><br><span class="line">inode-&gt;datalayout = EROFS_INODE_FLAT_INLINE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocate inline buffer */</span></span><br><span class="line">ibh = erofs_battach(bh, META, inode-&gt;idata_size);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ibh))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(ibh);</span><br><span class="line"></span><br><span class="line">ibh-&gt;op = &amp;erofs_skip_write_bhops;</span><br><span class="line">inode-&gt;bh_inline = ibh; <span class="comment">//tj: here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bh-&gt;fsprivate = erofs_igrab(inode);</span><br><span class="line">bh-&gt;op = &amp;erofs_write_inode_bhops;</span><br><span class="line">inode-&gt;bh = bh;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要在分配buffer供inline tail-end data用。如果没有空间via <code>erofs_balloc()</code>，那么就扩展一个block。inline data用<code>-&gt;bh_inline</code>来标识。</p><p>再来看接下来的<code>erofs_write_tail_end()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">erofs_write_tail_end</span><span class="params">(<span class="keyword">struct</span> erofs_inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">erofs_buffer_head</span> *<span class="title">bh</span>, *<span class="title">ibh</span>;</span></span><br><span class="line"></span><br><span class="line">bh = inode-&gt;bh_data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!inode-&gt;idata_size)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure><p>这是对齐case，no tail。看tail处理：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* have enough room to inline data */</span></span><br><span class="line"><span class="keyword">if</span> (inode-&gt;bh_inline) &#123;</span><br><span class="line">ibh = inode-&gt;bh_inline;</span><br><span class="line"></span><br><span class="line">ibh-&gt;fsprivate = erofs_igrab(inode);</span><br><span class="line">ibh-&gt;op = &amp;erofs_write_inline_bhops;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure><p>这是inline data，就赋给了一个<code>op</code>操作为<code>erofs_write_inline_bhops()</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">erofs_bhops</span> <span class="title">erofs_write_inline_bhops</span> =</span> &#123;</span><br><span class="line">.flush = erofs_bh_flush_write_inline,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>non-inline tail处理:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">erofs_off_t</span> pos;</span><br><span class="line"></span><br><span class="line">erofs_mapbh(bh-&gt;block, <span class="literal">true</span>);</span><br><span class="line">pos = erofs_btell(bh, <span class="literal">true</span>) - EROFS_BLKSIZ;</span><br><span class="line">ret = dev_write(inode-&gt;idata, pos, inode-&gt;idata_size);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="keyword">if</span> (inode-&gt;idata_size &lt; EROFS_BLKSIZ) &#123;</span><br><span class="line">ret = dev_fillzero(pos + inode-&gt;idata_size,</span><br><span class="line">   EROFS_BLKSIZ - inode-&gt;idata_size,</span><br><span class="line">   <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是通过buffer cache得到了<code>pos</code>， 直接写入img。build完成后call <code>erofs_bflush()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* flush all remaining buffers */</span></span><br><span class="line"><span class="keyword">if</span> (!erofs_bflush(<span class="literal">NULL</span>))</span><br><span class="line">err = -EIO;</span><br><span class="line"><span class="keyword">else</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">erofs_bflush</span><span class="params">(<span class="keyword">struct</span> erofs_buffer_block *bb)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">list_for_each_entry_safe(bh, nbh, &amp;p-&gt;buffers.<span class="built_in">list</span>, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="comment">/* flush and remove bh */</span></span><br><span class="line"><span class="keyword">if</span> (!bh-&gt;op-&gt;flush(bh)) <span class="comment">//tj:here</span></span><br><span class="line">skip = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>-&gt;flush</code>就是<code>erofs_bh_flush_write_inline()</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">erofs_bh_flush_write_inline</span><span class="params">(<span class="keyword">struct</span> erofs_buffer_head *bh)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">erofs_inode</span> *<span class="title">const</span> <span class="title">inode</span> =</span> bh-&gt;fsprivate;</span><br><span class="line"><span class="type">const</span> <span class="type">erofs_off_t</span> off = erofs_btell(bh, <span class="literal">false</span>);</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = dev_write(inode-&gt;idata, off, inode-&gt;idata_size);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">inode-&gt;idata_size = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">free</span>(inode-&gt;idata);</span><br><span class="line">inode-&gt;idata = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">erofs_iput(inode);</span><br><span class="line"><span class="keyword">return</span> erofs_bh_flush_generic_end(bh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-&gt;idata</code>就是<code>write_uncompressed_file_from_fd()</code>里获取的尾端数据。</p><p>另，整个的buffer cache就是用来管理不完整的metadata的，mark to check later.</p><p>关于inline data, readme有写到：</p><blockquote><p>[1] According to the erofs on-disk format, the tail block of files<br>    could be inlined aggressively with its metadata in order to reduce<br>    the I&#x2F;O overhead and save the storage space (called tail-packing).</p></blockquote><p>查了下ext4：</p><blockquote><p>The inline data feature was designed to handle the case that a file’s data is so tiny that it readily fits inside the inode, which (theoretically) reduces disk block consumption and reduces seeks. </p></blockquote><p>就是存储到inode里。</p><h2 id="refer-doc"><a href="#refer-doc" class="headerlink" title="refer doc"></a>refer doc</h2><p><a href="https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout#Inline_Data">https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout#Inline_Data</a></p>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erofs-utils </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eMMC CMDQ 超时分析</title>
      <link href="/mmc_cmdq_timeout.html"/>
      <url>/mmc_cmdq_timeout.html</url>
      
        <content type="html"><![CDATA[<h2 id="先看HW架构"><a href="#先看HW架构" class="headerlink" title="先看HW架构"></a>先看HW架构</h2><p><img src="http://tjtech.me/usr/uploads/2021/05/1079657507.png" alt="host-arch-with-cqe.png"></p><p>CQE: Command Queueing Engine，负责管理software和eMMC device的data传输。</p><p>首先CQE接收来自SW的task(via TDL和doorbell)，接下来的command flows主要有三步：</p><ul><li>Step1. Queuing a Transaction(CMD44+CMD45)</li></ul><p>CQE发出CMD44&#x2F;CMD45给eMMC用来queue a (data xfer) task, 当device有个R1响应就表示这个task已经queued in the device。可以通过读CQDPT寄存器来判断, CQE接收到R1响应就会置位，任务完成clear the bit。</p><ul><li>Step2. Checking the Queue Status(CMD13)</li></ul><p>CQE发出CMD13读QSR(Queue Status Register)来决定执行哪个task, device会反应个R1, 这个R1就是32bit value，每个bit对应一个task，如果bit&#x3D;0，那这个task没有ready for execution，bit&#x3D;1就是ready了。</p><ul><li>Step3. Execution of a Queued Task(CMD46&#x2F;CMD47)</li></ul><p>CQE发出CMD46(读) or CMD47(写)给那些在QSR里已经”ready for execution”的tasks。</p><h2 id="Linux代码分析"><a href="#Linux代码分析" class="headerlink" title="Linux代码分析"></a>Linux代码分析</h2><p>看下超时相关代码，msm kernel 4.14</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mmc0: request with tag: 25 flags: 0x103001 timed out </span><br></pre></td></tr></table></figure><p>find the code:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> blk_eh_timer_return <span class="title function_">mmc_cmdq_rq_timed_out</span><span class="params">(<span class="keyword">struct</span> request *req)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue</span> *<span class="title">mq</span> =</span> req-&gt;q-&gt;queuedata;</span><br><span class="line"></span><br><span class="line">pr_err(<span class="string">&quot;%s: request with tag: %d flags: 0x%x timed out\n&quot;</span>,</span><br><span class="line">       mmc_hostname(mq-&gt;card-&gt;host), req-&gt;tag, req-&gt;cmd_flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mq-&gt;cmdq_req_timed_out(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mmc_cmdq_init</span><span class="params">(<span class="keyword">struct</span> mmc_queue *mq, <span class="keyword">struct</span> mmc_card *card)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">blk_queue_rq_timed_out(mq-&gt;<span class="built_in">queue</span>, mmc_cmdq_rq_timed_out); <span class="comment">//tj: here</span></span><br><span class="line">blk_queue_rq_timeout(mq-&gt;<span class="built_in">queue</span>, <span class="number">120</span> * HZ); <span class="comment">//tj: 120s</span></span><br><span class="line">card-&gt;cmdq_init = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>block&#x2F;blk-setting.c:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">blk_queue_rq_timeout</span><span class="params">(<span class="keyword">struct</span> request_queue *q, <span class="type">unsigned</span> <span class="type">int</span> timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">q-&gt;rq_timeout = timeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">blk_queue_rq_timed_out</span><span class="params">(<span class="keyword">struct</span> request_queue *q, rq_timed_out_fn *fn)</span></span><br><span class="line">&#123;</span><br><span class="line">WARN_ON_ONCE(q-&gt;mq_ops);</span><br><span class="line">q-&gt;rq_timed_out_fn = fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下who calls <code>-&gt;rq_timed_out_fn</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">blk_rq_timed_out</span><span class="params">(<span class="keyword">struct</span> request *req)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">q</span> =</span> req-&gt;q;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">blk_eh_timer_return</span> <span class="title">ret</span> =</span> BLK_EH_RESET_TIMER;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q-&gt;rq_timed_out_fn)</span><br><span class="line">                ret = q-&gt;rq_timed_out_fn(req);  <span class="comment">//tj: here</span></span><br><span class="line">        <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">        <span class="keyword">case</span> BLK_EH_HANDLED:</span><br><span class="line">                __blk_complete_request(req); <span class="comment">//tj: here</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BLK_EH_RESET_TIMER:</span><br><span class="line">                blk_add_timer(req);</span><br><span class="line">                blk_clear_rq_complete(req);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BLK_EH_NOT_HANDLED:</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * LLD handles this for now but in the future</span></span><br><span class="line"><span class="comment">                 * we can send a request msg to abort the command</span></span><br><span class="line"><span class="comment">                 * and we can move more of the generic scsi eh code to</span></span><br><span class="line"><span class="comment">                 * the blk layer.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;block: bad eh return: %d\n&quot;</span>, ret);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shoud be from <code>blk_rq_check_expired()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">blk_rq_check_expired</span><span class="params">(<span class="keyword">struct</span> request *rq, <span class="type">unsigned</span> <span class="type">long</span> *next_timeout,</span></span><br><span class="line"><span class="params">                          <span class="type">unsigned</span> <span class="type">int</span> *next_set)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (time_after_eq(jiffies, rq-&gt;deadline)) &#123;</span><br><span class="line">                list_del_init(&amp;rq-&gt;timeout_list);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Check if we raced with end io completion</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!blk_mark_rq_complete(rq))</span><br><span class="line">                        blk_rq_timed_out(rq); <span class="comment">//here</span></span><br><span class="line">        &#125; </span><br></pre></td></tr></table></figure><p>这里的<code>rq-&gt;deadline</code>是120s，这个request超过了120s？ 这就是异常了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">blk_timeout_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">q</span> =</span></span><br><span class="line">                container_of(work, <span class="keyword">struct</span> request_queue, timeout_work);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> flags, next = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">rq</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">        <span class="type">int</span> next_set = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        spin_lock_irqsave(q-&gt;queue_lock, flags);</span><br><span class="line"></span><br><span class="line">        list_for_each_entry_safe(rq, tmp, &amp;q-&gt;timeout_list, timeout_list)</span><br><span class="line">                blk_rq_check_expired(rq, &amp;next, &amp;next_set);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INIT_WORK(&amp;q-&gt;timeout_work, blk_timeout_work);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">blk_rq_timed_out_timer</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">q</span> =</span> (<span class="keyword">struct</span> request_queue *)data;</span><br><span class="line"></span><br><span class="line">        kblockd_schedule_work(&amp;q-&gt;timeout_work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> request_queue *<span class="title function_">blk_alloc_queue_node</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">int</span> node_id)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        setup_timer(&amp;q-&gt;timeout, blk_rq_timed_out_timer, (<span class="type">unsigned</span> <span class="type">long</span>) q);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>who trigger this timer? should be <code>blk_add_timer()</code> when start request:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * blk_add_timer - Start timeout timer for a single request</span></span><br><span class="line"><span class="comment"> * @req:        request that is about to start running.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Notes:</span></span><br><span class="line"><span class="comment"> *    Each request has its own timer, and as it is added to the queue, we</span></span><br><span class="line"><span class="comment"> *    set up the timer. When the request completes, we cancel the timer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">blk_add_timer</span><span class="params">(<span class="keyword">struct</span> request *req)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">q</span> =</span> req-&gt;q;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> expiry;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!q-&gt;mq_ops)</span><br><span class="line">                lockdep_assert_held(q-&gt;queue_lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* blk-mq has its own handler, so we don&#x27;t need -&gt;rq_timed_out_fn */</span></span><br><span class="line">        <span class="keyword">if</span> (!q-&gt;mq_ops &amp;&amp; !q-&gt;rq_timed_out_fn)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        BUG_ON(!list_empty(&amp;req-&gt;timeout_list));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Some LLDs, like scsi, peek at the timeout to prevent a</span></span><br><span class="line"><span class="comment">         * command from being retried forever.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!req-&gt;timeout)</span><br><span class="line">                req-&gt;timeout = q-&gt;rq_timeout;</span><br><span class="line"></span><br><span class="line">        req-&gt;deadline = jiffies + req-&gt;timeout;</span><br></pre></td></tr></table></figure><p>看到没有, <code>req-&gt;timeout</code>就是120s，给了<code>req-&gt;deadline</code>。跟下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">blk_queue_start_tag() -&gt; blk_start_request() -&gt; blk_add_timer()</span><br></pre></td></tr></table></figure><p>ok, 回到mmc driver:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">mmc_check_blk_queue_start_tag</span><span class="params">(<span class="keyword">struct</span> request_queue *q,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> request *req)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">spin_lock_irq(q-&gt;queue_lock);</span><br><span class="line">ret = blk_queue_start_tag(q, req); <span class="comment">//tj:here</span></span><br><span class="line">spin_unlock_irq(q-&gt;queue_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> !!ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">mmc_cmdq_ready_wait</span><span class="params">(<span class="keyword">struct</span> mmc_host *host,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> mmc_queue *mq)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_cmdq_context_info</span> *<span class="title">ctx</span> =</span> &amp;host-&gt;cmdq_ctx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">q</span> =</span> mq-&gt;<span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wait until all of the following conditions are true:</span></span><br><span class="line"><span class="comment"> * 1. There is a request pending in the block layer queue</span></span><br><span class="line"><span class="comment"> *    to be processed.</span></span><br><span class="line"><span class="comment"> * 2. If the peeked request is flush/discard then there shouldn&#x27;t</span></span><br><span class="line"><span class="comment"> *    be any other direct command active.</span></span><br><span class="line"><span class="comment"> * 3. cmdq state should be unhalted.</span></span><br><span class="line"><span class="comment"> * 4. cmdq state shouldn&#x27;t be in error state.</span></span><br><span class="line"><span class="comment"> * 5. There is no outstanding RPMB request pending.</span></span><br><span class="line"><span class="comment"> * 6. free tag available to process the new request.</span></span><br><span class="line"><span class="comment"> *    (This must be the last condtion to check)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">wait_event(ctx-&gt;wait, kthread_should_stop()</span><br><span class="line">|| (mmc_peek_request(mq) &amp;&amp;</span><br><span class="line">!(((req_op(mq-&gt;cmdq_req_peeked) == REQ_OP_FLUSH) ||</span><br><span class="line">   (req_op(mq-&gt;cmdq_req_peeked) == REQ_OP_DISCARD) ||</span><br><span class="line">   (req_op(mq-&gt;cmdq_req_peeked) == REQ_OP_SECURE_ERASE))</span><br><span class="line">  &amp;&amp; test_bit(CMDQ_STATE_DCMD_ACTIVE, &amp;ctx-&gt;curr_state))</span><br><span class="line">&amp;&amp; !(!host-&gt;card-&gt;part_curr &amp;&amp; !mmc_card_suspended(host-&gt;card)</span><br><span class="line">     &amp;&amp; mmc_host_halt(host))</span><br><span class="line">&amp;&amp; !(!host-&gt;card-&gt;part_curr &amp;&amp; mmc_host_cq_disable(host) &amp;&amp;</span><br><span class="line">!mmc_card_suspended(host-&gt;card))</span><br><span class="line">&amp;&amp; !test_bit(CMDQ_STATE_ERR, &amp;ctx-&gt;curr_state)</span><br><span class="line">&amp;&amp; !<span class="type">atomic_read</span>(&amp;host-&gt;rpmb_req_pending)</span><br><span class="line">&amp;&amp; !mmc_check_blk_queue_start_tag(q, mq-&gt;cmdq_req_peeked))); <span class="comment">//tj: here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>check上面注释的no.6.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mmc_cmdq_thread</span><span class="params">(<span class="type">void</span> *d)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue</span> *<span class="title">mq</span> =</span> d;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_card</span> *<span class="title">card</span> =</span> mq-&gt;card;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_host</span> *<span class="title">host</span> =</span> card-&gt;host;</span><br><span class="line"></span><br><span class="line">current-&gt;flags |= PF_MEMALLOC;</span><br><span class="line"><span class="keyword">if</span> (card-&gt;host-&gt;wakeup_on_idle)</span><br><span class="line">set_wake_up_idle(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">mmc_cmdq_ready_wait(host, mq);</span><br><span class="line"><span class="keyword">if</span> (kthread_should_stop())</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">ret = mmc_cmdq_down_rwsem(host, mq-&gt;cmdq_req_peeked);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">mmc_cmdq_up_rwsem(host);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = mq-&gt;cmdq_issue_fn(mq, mq-&gt;cmdq_req_peeked);</span><br><span class="line">mmc_cmdq_up_rwsem(host);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don&#x27;t requeue if issue_fn fails.</span></span><br><span class="line"><span class="comment"> * Recovery will be come by completion softirq</span></span><br><span class="line"><span class="comment"> * Also we end the request if there is a partition switch</span></span><br><span class="line"><span class="comment"> * error, so we should not requeue the request here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125; <span class="comment">/* loop */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mmc_init_queue</span><span class="params">(<span class="keyword">struct</span> mmc_queue *mq, <span class="keyword">struct</span> mmc_card *card,</span></span><br><span class="line"><span class="params">   <span class="type">spinlock_t</span> *lock, <span class="type">const</span> <span class="type">char</span> *subname, <span class="type">int</span> area_type)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">mq-&gt;thread = kthread_run(mmc_cmdq_thread, mq,</span><br><span class="line"> <span class="string">&quot;mmc-cmdqd/%d%s&quot;</span>, <span class="comment">//tj:here</span></span><br><span class="line"> host-&gt;index,</span><br><span class="line"> subname ? subname : <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(mq-&gt;thread)) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;%s: %d: cmdq: failed to start mmc-cmdqd thread\n&quot;</span>,</span><br><span class="line">mmc_hostname(card-&gt;host), ret);</span><br><span class="line">ret = PTR_ERR(mq-&gt;thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，cmdq状态ok后可以仍请求给HW CMDQ, rt? 在check cmdq状态时发现有tag超时了。</p><p>我们再来看下超时后的异常处理, 超时的entry: <code>-&gt;cmdq_req_timed_out</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mmc_blk_data *<span class="title function_">mmc_blk_alloc_req</span><span class="params">(<span class="keyword">struct</span> mmc_card *card,</span></span><br><span class="line"><span class="params">...</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">...</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (card-&gt;cmdq_init) &#123;</span></span><br><span class="line"><span class="params">md-&gt;flags |= MMC_BLK_CMD_QUEUE;</span></span><br><span class="line"><span class="params">md-&gt;<span class="built_in">queue</span>.cmdq_complete_fn = mmc_blk_cmdq_complete_rq;</span></span><br><span class="line"><span class="params">md-&gt;<span class="built_in">queue</span>.cmdq_issue_fn = mmc_blk_cmdq_issue_rq;</span></span><br><span class="line"><span class="params">md-&gt;<span class="built_in">queue</span>.cmdq_error_fn = mmc_blk_cmdq_err;</span></span><br><span class="line"><span class="params">md-&gt;<span class="built_in">queue</span>.cmdq_req_timed_out = mmc_blk_cmdq_req_timed_out;  <span class="comment">//tj: here</span></span></span><br><span class="line"><span class="params">md-&gt;<span class="built_in">queue</span>.cmdq_shutdown = mmc_blk_cmdq_shutdown;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">enum</span> blk_eh_timer_return <span class="title function_">mmc_blk_cmdq_req_timed_out</span><span class="params">(<span class="keyword">struct</span> request *req)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue</span> *<span class="title">mq</span> =</span> req-&gt;q-&gt;queuedata;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_host</span> *<span class="title">host</span> =</span> mq-&gt;card-&gt;host;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue_req</span> *<span class="title">mq_rq</span> =</span> req-&gt;special;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_request</span> *<span class="title">mrq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_cmdq_req</span> *<span class="title">cmdq_req</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_cmdq_context_info</span> *<span class="title">ctx_info</span> =</span> &amp;host-&gt;cmdq_ctx;</span><br><span class="line"></span><br><span class="line">BUG_ON(!host);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The mmc_queue_req will be present only if the request</span></span><br><span class="line"><span class="comment"> * is issued to the LLD. The request could be fetched from</span></span><br><span class="line"><span class="comment"> * block layer queue but could be waiting to be issued</span></span><br><span class="line"><span class="comment"> * (for e.g. clock scaling is waiting for an empty cmdq queue)</span></span><br><span class="line"><span class="comment"> * Reset the timer in such cases to give LLD more time</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!mq_rq) &#123;</span><br><span class="line">pr_warn(<span class="string">&quot;%s: restart timer for tag: %d\n&quot;</span>, __func__, req-&gt;tag);</span><br><span class="line"><span class="keyword">return</span> BLK_EH_RESET_TIMER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mrq = &amp;mq_rq-&gt;cmdq_req.mrq;</span><br><span class="line">cmdq_req = &amp;mq_rq-&gt;cmdq_req;</span><br><span class="line"></span><br><span class="line">BUG_ON(!mrq || !cmdq_req);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cmdq_req-&gt;cmdq_req_flags &amp; DCMD)</span><br><span class="line">mrq-&gt;cmd-&gt;error = -ETIMEDOUT;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">mrq-&gt;data-&gt;error = -ETIMEDOUT;</span><br><span class="line"></span><br><span class="line">host-&gt;err_stats[MMC_ERR_CMDQ_REQ_TIMEOUT]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mrq-&gt;cmd &amp;&amp; mrq-&gt;cmd-&gt;error) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(mrq-&gt;req-&gt;cmd_flags &amp; REQ_PREFLUSH)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Notify completion for non flush commands like</span></span><br><span class="line"><span class="comment"> * discard that wait for DCMD finish.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_bit(CMDQ_STATE_REQ_TIMED_OUT,</span><br><span class="line">&amp;ctx_info-&gt;curr_state);</span><br><span class="line">complete(&amp;mrq-&gt;completion);</span><br><span class="line"><span class="keyword">return</span> BLK_EH_NOT_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (test_bit(CMDQ_STATE_REQ_TIMED_OUT, &amp;ctx_info-&gt;curr_state) ||</span><br><span class="line">test_bit(CMDQ_STATE_ERR, &amp;ctx_info-&gt;curr_state))</span><br><span class="line"><span class="keyword">return</span> BLK_EH_NOT_HANDLED;</span><br><span class="line"></span><br><span class="line">set_bit(CMDQ_STATE_REQ_TIMED_OUT, &amp;ctx_info-&gt;curr_state);</span><br><span class="line"><span class="keyword">return</span> BLK_EH_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是记录为超时<code>-ETIMEDOUT</code>, 然后把<code>curr_state</code>标记<code>CMDQ_STATE_REQ_TIMED_OUT</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">blk_rq_timed_out</span><span class="params">(<span class="keyword">struct</span> request *req)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">q</span> =</span> req-&gt;q;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">blk_eh_timer_return</span> <span class="title">ret</span> =</span> BLK_EH_RESET_TIMER;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q-&gt;rq_timed_out_fn)</span><br><span class="line">                ret = q-&gt;rq_timed_out_fn(req);  <span class="comment">//tj: here</span></span><br><span class="line">        <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">        <span class="keyword">case</span> BLK_EH_HANDLED:</span><br><span class="line">                __blk_complete_request(req); <span class="comment">//tj: here</span></span><br></pre></td></tr></table></figure><p>block&#x2F;blk-softirq.c:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __blk_complete_request(<span class="keyword">struct</span> request *req)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (ccpu == cpu || shared) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line">do_local:</span><br><span class="line">                <span class="built_in">list</span> = this_cpu_ptr(&amp;blk_cpu_done);</span><br><span class="line">                list_add_tail(&amp;req-&gt;ipi_list, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * if the list only contains our just added request,</span></span><br><span class="line"><span class="comment">                 * signal a raise of the softirq. If there are already</span></span><br><span class="line"><span class="comment">                 * entries there, someone already raised the irq but it</span></span><br><span class="line"><span class="comment">                 * hasn&#x27;t run yet.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;next == &amp;req-&gt;ipi_list)</span><br><span class="line">                        raise_softirq_irqoff(BLOCK_SOFTIRQ); <span class="comment">//tj: here</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (raise_blk_irq(ccpu, req))</span><br><span class="line">                <span class="keyword">goto</span> do_local;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>softirq有关，should be <code>raise_softirq_irqoff()</code>, 我们看下mmc drv:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mmc_cmdq_init</span><span class="params">(<span class="keyword">struct</span> mmc_queue *mq, <span class="keyword">struct</span> mmc_card *card)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">blk_queue_softirq_done(mq-&gt;<span class="built_in">queue</span>, mmc_cmdq_softirq_done);</span><br><span class="line">INIT_WORK(&amp;mq-&gt;cmdq_err_work, mmc_cmdq_error_work);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">blk_queue_softirq_done</span><span class="params">(<span class="keyword">struct</span> request_queue *q, softirq_done_fn *fn)</span></span><br><span class="line">&#123;</span><br><span class="line">q-&gt;softirq_done_fn = fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">blk_done_softirq() -&gt; mmc_cmdq_softirq_done (-&gt;softirq_done_fn)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __init <span class="type">int</span> <span class="title function_">blk_softirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        for_each_possible_cpu(i)</span><br><span class="line">                INIT_LIST_HEAD(&amp;per_cpu(blk_cpu_done, i));</span><br><span class="line"></span><br><span class="line">        open_softirq(BLOCK_SOFTIRQ, blk_done_softirq);</span><br></pre></td></tr></table></figure><p>ok, timerout error handler最后<code>mmc_cmdq_softirq_done()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mmc_cmdq_softirq_done</span><span class="params">(<span class="keyword">struct</span> request *rq)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue</span> *<span class="title">mq</span> =</span> rq-&gt;q-&gt;queuedata;</span><br><span class="line"></span><br><span class="line">mq-&gt;cmdq_complete_fn(rq); <span class="comment">//tj: mmc_blk_cmdq_complete_rq(), check above</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* invoked by block layer in softirq context */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmc_blk_cmdq_complete_rq</span><span class="params">(<span class="keyword">struct</span> request *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//tj: 先取得error</span></span><br><span class="line"><span class="keyword">if</span> (mrq-&gt;cmd &amp;&amp; mrq-&gt;cmd-&gt;error)</span><br><span class="line">err = mrq-&gt;cmd-&gt;error;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mrq-&gt;data &amp;&amp; mrq-&gt;data-&gt;error)</span><br><span class="line">err = mrq-&gt;data-&gt;error;</span><br><span class="line"><span class="keyword">if</span> (cmdq_req-&gt;resp_err)</span><br><span class="line">err_resp = cmdq_req-&gt;resp_err;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tj: 然后check err</span></span><br><span class="line"><span class="keyword">if</span> ((err || err_resp) &amp;&amp; !cmdq_req-&gt;skip_err_handling) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;%s: %s: txfr error(%d)/resp_err(%d)\n&quot;</span>,</span><br><span class="line">mmc_hostname(mrq-&gt;host), __func__, err,</span><br><span class="line">err_resp);</span><br><span class="line"><span class="keyword">if</span> (test_bit(CMDQ_STATE_ERR, &amp;ctx_info-&gt;curr_state)) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;%s: CQ in error state, ending current req: %d\n&quot;</span>,</span><br><span class="line">__func__, err);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">set_bit(CMDQ_STATE_ERR, &amp;ctx_info-&gt;curr_state);</span><br><span class="line">BUG_ON(host-&gt;err_mrq != <span class="literal">NULL</span>);</span><br><span class="line">host-&gt;err_mrq = mrq;</span><br><span class="line">schedule_work(&amp;mq-&gt;cmdq_err_work); <span class="comment">//tj: here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们<code>-&gt;curr_state</code>是<code>CMDQ_STATE_REQ_TIMED_OUT</code>，check <code>-&gt;cmdq_err_work</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mmc_cmdq_error_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue</span> *<span class="title">mq</span> =</span> container_of(work, <span class="keyword">struct</span> mmc_queue,</span><br><span class="line">    cmdq_err_work);</span><br><span class="line"></span><br><span class="line">mq-&gt;cmdq_error_fn(mq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mmc_blk_cmdq_err: error handling of cmdq error requests.</span></span><br><span class="line"><span class="comment"> * Function should be called in context of error out request</span></span><br><span class="line"><span class="comment"> * which has claim_host and rpm acquired.</span></span><br><span class="line"><span class="comment"> * This may be called with CQ engine halted. Make sure to</span></span><br><span class="line"><span class="comment"> * unhalt it after error recovery.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> Currently cmdq error handler does reset_all in case</span></span><br><span class="line"><span class="comment"> * of any erorr. Need to optimize error handling.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mmc_blk_cmdq_err</span><span class="params">(<span class="keyword">struct</span> mmc_queue *mq)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">pr_err(<span class="string">&quot;%s: %s Starting cmdq Error handler\n&quot;</span>,</span><br><span class="line">mmc_hostname(host), __func__);</span><br><span class="line">q = mrq-&gt;req-&gt;q;</span><br><span class="line">err = mmc_cmdq_halt(host, <span class="literal">true</span>); <span class="comment">//tj: 先halt cmdq</span></span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;halt: failed: %d\n&quot;</span>, err);</span><br><span class="line"><span class="keyword">goto</span> reset;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//tj: 当timeout时获取device status</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TIMEOUT errrors can happen because of execution error</span></span><br><span class="line"><span class="comment"> * in the last command. So send cmd 13 to get device status</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((mrq-&gt;cmd &amp;&amp; (mrq-&gt;cmd-&gt;error == -ETIMEDOUT)) ||</span><br><span class="line">(mrq-&gt;data &amp;&amp; (mrq-&gt;data-&gt;error == -ETIMEDOUT))) &#123;</span><br><span class="line"><span class="keyword">if</span> (mmc_host_halt(host) || mmc_host_cq_disable(host)) &#123;</span><br><span class="line">ret = get_card_status(host-&gt;card, &amp;status, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">pr_err(<span class="string">&quot;%s: CMD13 failed with err %d\n&quot;</span>,</span><br><span class="line">mmc_hostname(host), ret);</span><br><span class="line">&#125;</span><br><span class="line">pr_err(<span class="string">&quot;%s: Timeout error detected with device status 0x%08x\n&quot;</span>,</span><br><span class="line">mmc_hostname(host), status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In case of software request time-out, we schedule err work only for</span></span><br><span class="line"><span class="comment"> * the first error out request and handles all other request in flight</span></span><br><span class="line"><span class="comment"> * here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (test_bit(CMDQ_STATE_REQ_TIMED_OUT, &amp;ctx_info-&gt;curr_state)) &#123;</span><br><span class="line">err = -ETIMEDOUT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mrq-&gt;data &amp;&amp; mrq-&gt;data-&gt;error) &#123;</span><br><span class="line">err = mrq-&gt;data-&gt;error;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mrq-&gt;cmd &amp;&amp; mrq-&gt;cmd-&gt;error) &#123;</span><br><span class="line"><span class="comment">/* DCMD commands */</span></span><br><span class="line">err = mrq-&gt;cmd-&gt;error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">mmc_blk_cmdq_reset_all(host, err); <span class="comment">//tj: reset all</span></span><br><span class="line"><span class="keyword">if</span> (mrq-&gt;cmdq_req-&gt;resp_err)</span><br><span class="line">mrq-&gt;cmdq_req-&gt;resp_err = <span class="literal">false</span>;</span><br><span class="line">mmc_cmdq_halt(host, <span class="literal">false</span>); <span class="comment">//tj: unhalt cmdq</span></span><br><span class="line"></span><br><span class="line">host-&gt;err_mrq = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tj: clear CMDQ_STATE_REQ_TIMED_OUT/CMDQ_STATE_ERR</span></span><br><span class="line">clear_bit(CMDQ_STATE_REQ_TIMED_OUT, &amp;ctx_info-&gt;curr_state);</span><br><span class="line">WARN_ON(!test_and_clear_bit(CMDQ_STATE_ERR, &amp;ctx_info-&gt;curr_state));</span><br></pre></td></tr></table></figure><p>来看<code>mmc_blk_cmdq_reset_all()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mmc_blk_cmdq_reset_all - Reset everything for CMDQ block request.</span></span><br><span class="line"><span class="comment"> * @host:mmc_host pointer.</span></span><br><span class="line"><span class="comment"> * @err:error for which reset is performed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function implements reset_all functionality for</span></span><br><span class="line"><span class="comment"> * cmdq. It resets the controller, power cycle the card,</span></span><br><span class="line"><span class="comment"> * and invalidate all busy tags(requeue all request back to</span></span><br><span class="line"><span class="comment"> * elevator).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mmc_blk_cmdq_reset_all</span><span class="params">(<span class="keyword">struct</span> mmc_host *host, <span class="type">int</span> err)</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>看注释是复位controller，掉电复位eMMC，还有就是清理busy tags。call stack:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mmc_blk_cmdq_reset(,false) -&gt; mmc_cmdq_hw_reset()</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mmc_cmdq_hw_reset: Helper API for doing</span></span><br><span class="line"><span class="comment"> * reset_all of host and reinitializing card.</span></span><br><span class="line"><span class="comment"> * This must be called with mmc_claim_host</span></span><br><span class="line"><span class="comment"> * acquired by the caller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mmc_cmdq_hw_reset</span><span class="params">(<span class="keyword">struct</span> mmc_host *host)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!host-&gt;bus_ops-&gt;reset)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> host-&gt;bus_ops-&gt;reset(host); <span class="comment">//tj: mmc_reset()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mmc_reset</span><span class="params">(<span class="keyword">struct</span> mmc_host *host)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_card</span> *<span class="title">card</span> =</span> host-&gt;card;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((host-&gt;caps &amp; MMC_CAP_HW_RESET) &amp;&amp; host-&gt;ops-&gt;hw_reset &amp;&amp;</span><br><span class="line">     mmc_can_reset(card)) &#123;</span><br><span class="line">mmc_host_clk_hold(host);</span><br><span class="line"><span class="comment">/* If the card accept RST_n signal, send it. */</span></span><br><span class="line">mmc_set_clock(host, host-&gt;f_init);</span><br><span class="line">host-&gt;ops-&gt;hw_reset(host);</span><br><span class="line"><span class="comment">/* Set initial state and call mmc_set_ios */</span></span><br><span class="line">mmc_set_initial_state(host);</span><br><span class="line">mmc_host_clk_release(host);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Do a brute force power cycle */</span></span><br><span class="line">mmc_power_cycle(host, card-&gt;ocr);</span><br><span class="line">mmc_pwrseq_reset(host);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (host-&gt;inlinecrypt_support)</span><br><span class="line">host-&gt;inlinecrypt_reset_needed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">ret = mmc_init_card(host, host-&gt;card-&gt;ocr, host-&gt;card);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;%s: %s: mmc_init_card failed (%d)\n&quot;</span>,</span><br><span class="line">mmc_hostname(host), __func__, ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看host有没有实现reset，如果有直接发复位信号给eMMC。如果没有就强迫power cycle(掉电)。最后然后走软复位card(<code>mmc_init_card()</code>)。</p><h2 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h2><ul><li><p>JEDEC STANDARD JESD84-B51.pdf</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMDQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UFS Write Booster 分析</title>
      <link href="/analyze-ufs-write-booster.html"/>
      <url>/analyze-ufs-write-booster.html</url>
      
        <content type="html"><![CDATA[<p>先来看看JEDEC有关WriteBooster(WB)的描述：</p><p>TLC NAND比SLC NAND慢的原因就是TLC里面有更多的programming steps。ok，为了提高性能，那就把TLC NAND的一部分配置成SLC NAND不就行了。rt，WriteBooster特性由此而来，就是把这部分SLC NAND用作WriteBooster Buffer。有个概率图：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+------+                   +---------------------------------------------+</span><br><span class="line">|      | 1.Write data in   |  +--------------+              +---------+  |</span><br><span class="line">|      | WriteBooster mode |  |              |              |         |  |</span><br><span class="line">| Host |-------------------|-&gt;| WriteBooster |   3.Flush    | Normal  |  |</span><br><span class="line">|      |&lt;------------------|--| Buffer       |-------------&gt;| Storage |  |</span><br><span class="line">|      |  2.fast response  |  | (SLC)        |              | (TLC)   |  |</span><br><span class="line">+------+                   |  +--------------+              |         |  |</span><br><span class="line">                           |  Device                        +---------+  |</span><br><span class="line">                           +---------------------------------------------+</span><br></pre></td></tr></table></figure><h2 id="Writing-data-to-WriteBooster-Buffer"><a href="#Writing-data-to-WriteBooster-Buffer" class="headerlink" title="Writing data to WriteBooster Buffer"></a>Writing data to WriteBooster Buffer</h2><p>这里有两个WriteBooster mode，一个是LU dedicated buffer mode，一个是shared buffer mode。</p><p>bSupportedWriteBoosterBuferTypes暗示了哪一个模式被设备支持。</p><p>LU dedicated buffer mode就是指定某个LU为这个WB Buffer。shared buffer mode就是所有的LU共享这个WB Buffer了，不过well-known LUs例外。</p><p>注意这个WB Buffer是有生命周期的，你懂的:)</p><h2 id="Flushing-WriteBooster-Buffer"><a href="#Flushing-WriteBooster-Buffer" class="headerlink" title="Flushing WriteBooster Buffer"></a>Flushing WriteBooster Buffer</h2><p>当整个WriteBooster buffer被用完了，device就通过WRITEBOOSTER_FLAUSH_NEEDED事件通知Host: need flush( to normal storage)。如果flush有错，那就直接写到normal storage了。</p><p>有两个方法flush，一个是flush命令，另一个是在hibernate时。只有当command queue为空时才执行flush。当正在flush时要是有host cmd过来，那就suspend flush，等处理完host cmd后, consume之前suspend的flush。</p><h2 id="User-space-configurations"><a href="#User-space-configurations" class="headerlink" title="User space configurations"></a>User space configurations</h2><p>既然有一部分用作WB Buffer，那用户可用空间肯定少了啊，rt，这就是user space reduction。但还有个配置可以保留这个空间，当normal storage都用完了，那就用WB Buffer，此时WB Buffer需要回到normal storage，类似flush操作，性能就会下降。</p><h2 id="Linux代码分析"><a href="#Linux代码分析" class="headerlink" title="Linux代码分析"></a>Linux代码分析</h2><p>参考内核5.x, 先看下<code>struct ufs_dev_info</code>，关注WB code。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ufs_dev_info</span> &#123;</span></span><br><span class="line"><span class="type">bool</span>f_power_on_wp_en;</span><br><span class="line"><span class="comment">/* Keeps information if any of the LU is power on write protected */</span></span><br><span class="line"><span class="type">bool</span>is_lu_power_on_wp;</span><br><span class="line"><span class="comment">/* Maximum number of general LU supported by the UFS device */</span></span><br><span class="line">u8max_lu_supported;</span><br><span class="line">u16wmanufacturerid;</span><br><span class="line"><span class="comment">/*UFS device Product Name */</span></span><br><span class="line">u8*model;</span><br><span class="line">u16wspecversion;</span><br><span class="line">u32clk_gating_wait_us;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UFS WB related flags */</span></span><br><span class="line"><span class="type">bool</span>    wb_enabled;  <span class="comment">//tj: 特性使能</span></span><br><span class="line"><span class="type">bool</span>    wb_buf_flush_enabled; <span class="comment">//tj: flush操作</span></span><br><span class="line">u8wb_dedicated_lu; <span class="comment">//tj: LU dedicated buffer mode</span></span><br><span class="line">u8      wb_buffer_type;  <span class="comment">//tj: WriteBooster模式</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span>b_rpm_dev_flush_capable;</span><br><span class="line">u8b_presrv_uspc_en; <span class="comment">//tj: 保留用户空间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>获取设备描述符时会check WB，入口是<code>ufshcd_wb_probe()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ufshcd_wb_probe</span><span class="params">(<span class="keyword">struct</span> ufs_hba *hba, u8 *desc_buf)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Probe WB only for UFS-2.2 and UFS-3.1 (and later) devices or</span></span><br><span class="line"><span class="comment"> * UFS devices with quirk UFS_DEVICE_QUIRK_SUPPORT_EXTENDED_FEATURES</span></span><br><span class="line"><span class="comment"> * enabled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!(dev_info-&gt;wspecversion &gt;= <span class="number">0x310</span> ||</span><br><span class="line">      dev_info-&gt;wspecversion == <span class="number">0x220</span> ||</span><br><span class="line">     (hba-&gt;dev_quirks &amp; UFS_DEVICE_QUIRK_SUPPORT_EXTENDED_FEATURES)))</span><br><span class="line"><span class="keyword">goto</span> wb_disabled;</span><br></pre></td></tr></table></figure><p>UFS-2.2和UFS-3.1(and later)有这个能力。</p><p>注意还有个不管标准了，只要有<code>UFS_DEVICE_QUIRK_SUPPORT_EXTENDED_FEATURES</code>这个quirk也行。来看下这个quirk:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Some pre-3.1 UFS devices can support extended features by upgrading</span></span><br><span class="line"><span class="comment"> * the firmware. Enable this quirk to make UFS core driver probe and enable</span></span><br><span class="line"><span class="comment"> * supported features on such devices.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UFS_DEVICE_QUIRK_SUPPORT_EXTENDED_FEATURES (1 &lt;&lt; 10)</span></span><br></pre></td></tr></table></figure><p>好家伙，通过升级固件的方式也可以具备WB。So，市面上出现的UFS-3.0 + WriteBooster就是这个喽？</p><p>继续看code, WB device支持的条件需要：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ext_ufs_feature = get_unaligned_be32(desc_buf +</span><br><span class="line">DEVICE_DESC_PARAM_EXT_UFS_FEATURE_SUP);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(ext_ufs_feature &amp; UFS_DEV_WRITE_BOOSTER_SUP))</span><br><span class="line"><span class="keyword">goto</span> wb_disabled;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEVICE_DESC_PARAM_EXT_UFS_FEATURE_SUP= <span class="number">0x4F</span>,</span><br></pre></td></tr></table></figure><p>继续：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dev_info-&gt;wb_buffer_type == WB_BUF_MODE_SHARED) &#123;</span><br><span class="line"><span class="keyword">if</span> (!get_unaligned_be32(desc_buf +</span><br><span class="line">   DEVICE_DESC_PARAM_WB_SHARED_ALLOC_UNITS))</span><br><span class="line"><span class="keyword">goto</span> wb_disabled;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (lun = <span class="number">0</span>; lun &lt; UFS_UPIU_MAX_WB_LUN_ID; lun++) &#123;</span><br><span class="line">d_lu_wb_buf_alloc = <span class="number">0</span>;</span><br><span class="line">ufshcd_read_unit_desc_param(hba,</span><br><span class="line">lun,</span><br><span class="line">UNIT_DESC_PARAM_WB_BUF_ALLOC_UNITS,</span><br><span class="line">(u8 *)&amp;d_lu_wb_buf_alloc,</span><br><span class="line"><span class="keyword">sizeof</span>(d_lu_wb_buf_alloc));</span><br><span class="line"><span class="keyword">if</span> (d_lu_wb_buf_alloc) &#123;</span><br><span class="line">dev_info-&gt;wb_dedicated_lu = lun;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!d_lu_wb_buf_alloc)</span><br><span class="line"><span class="keyword">goto</span> wb_disabled;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">wb_disabled:</span><br><span class="line">hba-&gt;caps &amp;= ~UFSHCD_CAP_WB_EN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享模式，查看分配大小<code>DEVICE_DESC_PARAM_WB_SHARED_ALLOC_UNITS</code>(dNumSharedWriteBoosterBufferAllocUnits)，如果没分配那就disable WB。</p><p>LU专有模式就是从0-7个LU里找看谁分配了WB Buffer就用那个了。</p><p>WB特性使能：<code>ufshcd_wb_ctrl()</code>。</p><p>两种flush使能: <code>ufshcd_wb_toggle_flush()</code>和<code>ufshcd_wb_toggle_flush_during_h8()</code>。</p><p>对于user space reduction，可用buffer大小&lt;10%那就需要flush了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">ufshcd_wb_need_flush</span><span class="params">(<span class="keyword">struct</span> ufs_hba *hba)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!hba-&gt;dev_info.b_presrv_uspc_en) &#123;</span><br><span class="line"><span class="keyword">if</span> (avail_buf &lt;= UFS_WB_BUF_REMAIN_PERCENT(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 preserve user space，多了个当前WB buffer大小的check:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">ufshcd_wb_presrv_usrspc_keep_vcc_on</span><span class="params">(<span class="keyword">struct</span> ufs_hba *hba,</span></span><br><span class="line"><span class="params">u32 avail_buf)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!cur_buf) &#123;</span><br><span class="line">dev_info(hba-&gt;dev, <span class="string">&quot;dCurWBBuf: %d WB disabled until free-space is available\n&quot;</span>,</span><br><span class="line"> cur_buf);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Let it continue to flush when available buffer exceeds threshold */</span></span><br><span class="line"><span class="keyword">if</span> (avail_buf &lt; hba-&gt;vps-&gt;wb_flush_threshold)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面说过因为perserve，WB buffer大小是可能变化的，当WB buffer全部都回到user space，那就等于没有WB了，也就不需要flush了。</p><p>这里可用的buffer门限取决于host侧? 默认是40。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ufs_hba_variant_params</span> <span class="title">ufs_hba_vps</span> =</span> &#123;</span><br><span class="line">.hba_enable_delay_us= <span class="number">1000</span>,</span><br><span class="line">.wb_flush_threshold= UFS_WB_BUF_REMAIN_PERCENT(<span class="number">40</span>),</span><br></pre></td></tr></table></figure><p>mtk改变了flush策略，门限定了80%。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Enable WriteBooster */</span></span><br><span class="line">hba-&gt;caps |= UFSHCD_CAP_WB_EN;</span><br><span class="line">hba-&gt;quirks |= UFSHCI_QUIRK_SKIP_MANUAL_WB_FLUSH_CTRL;</span><br><span class="line">hba-&gt;vps-&gt;wb_flush_threshold = UFS_WB_BUF_REMAIN_PERCENT(<span class="number">80</span>);</span><br></pre></td></tr></table></figure><p>也就是说，使用了&gt;20%就要flush了，才这么点？</p><h2 id="Refer-doc"><a href="#Refer-doc" class="headerlink" title="Refer doc"></a>Refer doc</h2><p>JEDEC standard UFS version 2.2 (free)</p>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WriteBooster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>schedutil CPUFreq governor 代码分析</title>
      <link href="/analyze-schedutil-code.html"/>
      <url>/analyze-schedutil-code.html</url>
      
        <content type="html"><![CDATA[<p>参考内核5.x, code是kernel&#x2F;sched&#x2F;cpufreq_schedutil.c，配置说明：</p><blockquote><p>config CPU_FREQ_GOV_SCHEDUTIL<br>       bool “‘schedutil’ cpufreq policy governor”<br>       depends on CPU_FREQ &amp;&amp; SMP<br>       select CPU_FREQ_GOV_ATTR_SET<br>       select IRQ_WORK<br>       help<br>         This governor makes decisions based on the utilization data provided<br>         by the scheduler.  It sets the CPU frequency to be proportional to<br>         the utilization&#x2F;capacity ratio coming from the scheduler.  If the<br>         utilization is frequency-invariant, the new frequency is also<br>         proportional to the maximum available frequency.  If that is not the<br>         case, it is proportional to the current frequency of the CPU.  The<br>         frequency tipping point is at utilization&#x2F;capacity equal to 80% in<br>         both cases.</p></blockquote><p>就是根据调度时CPU utilization变化进行调频。EAS只用schedutil，因为EAS也是根据util来调度，文档描述：</p><blockquote><p>told to do, for example), schedutil as opposed to other CPUFreq governors at<br>least <em>requests</em> frequencies calculated using the utilization signals.<br>Consequently, the only sane governor to use together with EAS is schedutil,<br>because it is the only one providing some degree of consistency between<br>frequency requests and energy predictions.</p></blockquote><h2 id="Update-Utilization"><a href="#Update-Utilization" class="headerlink" title="Update Utilization"></a>Update Utilization</h2><p>that is <code>cpufreq_update_util()</code>, util变化时会call，比如CFS:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">cfs_rq_util_change</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> =</span> rq_of(cfs_rq);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (&amp;rq-&gt;cfs == cfs_rq) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * There are a few boundary cases this might miss but it should</span></span><br><span class="line"><span class="comment"> * get called often enough that that should (hopefully) not be</span></span><br><span class="line"><span class="comment"> * a real problem.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It will not get called when we go idle, because the idle</span></span><br><span class="line"><span class="comment"> * thread is a different class (!fair), nor will the utilization</span></span><br><span class="line"><span class="comment"> * number include things like RT tasks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * As is, the util number is not freq-invariant (we&#x27;d have to</span></span><br><span class="line"><span class="comment"> * implement arch_scale_freq_capacity() for that).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See cpu_util().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cpufreq_update_util(rq, flags); <span class="comment">//here</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">cpufreq_update_util</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">update_util_data</span> *<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">data = rcu_dereference_sched(*per_cpu_ptr(&amp;cpufreq_update_util_data,</span><br><span class="line">  cpu_of(rq)));</span><br><span class="line"><span class="keyword">if</span> (data)</span><br><span class="line">data-&gt;func(data, rq_clock(rq), flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>-&gt;func</code>是在<code>sugov_start()</code>里注册的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (policy_is_shared(policy))</span><br><span class="line">uu = sugov_update_shared;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (policy-&gt;fast_switch_enabled &amp;&amp; cpufreq_driver_has_adjust_perf())</span><br><span class="line">uu = sugov_update_single_perf;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">uu = sugov_update_single_freq;</span><br><span class="line"></span><br><span class="line">for_each_cpu(cpu, policy-&gt;cpus) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_cpu</span> *<span class="title">sg_cpu</span> =</span> &amp;per_cpu(sugov_cpu, cpu);</span><br><span class="line"></span><br><span class="line">cpufreq_add_update_util_hook(cpu, &amp;sg_cpu-&gt;update_util, uu); <span class="comment">//tj: here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cpufreq_add_update_util_hook</span><span class="params">(<span class="type">int</span> cpu, <span class="keyword">struct</span> update_util_data *data,</span></span><br><span class="line"><span class="params"><span class="type">void</span> (*func)(<span class="keyword">struct</span> update_util_data *data, u64 time,</span></span><br><span class="line"><span class="params">     <span class="type">unsigned</span> <span class="type">int</span> flags))</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (WARN_ON(!data || !func))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(per_cpu(cpufreq_update_util_data, cpu)))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">data-&gt;func = func; <span class="comment">//tj: here</span></span><br><span class="line">rcu_assign_pointer(per_cpu(cpufreq_update_util_data, cpu), data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的更新还区分shared(多个CPU共享)和single(only单个CPU使用)两种policy。</p><p>同时，还支持快速和慢速两种更新方式，比如在<code>sugov_update_single_freq()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sg_policy-&gt;policy-&gt;fast_switch_enabled) &#123;</span><br><span class="line">sugov_fast_switch(sg_policy, time, next_f); <span class="comment">//tj: fast path</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">raw_spin_lock(&amp;sg_policy-&gt;update_lock);</span><br><span class="line">sugov_deferred_update(sg_policy, time, next_f); <span class="comment">//tj: slow path</span></span><br><span class="line">raw_spin_unlock(&amp;sg_policy-&gt;update_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sugov_fast_switch()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sugov_fast_switch</span><span class="params">(<span class="keyword">struct</span> sugov_policy *sg_policy, u64 time,</span></span><br><span class="line"><span class="params">      <span class="type">unsigned</span> <span class="type">int</span> next_freq)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sugov_update_next_freq(sg_policy, time, next_freq))</span><br><span class="line">cpufreq_driver_fast_switch(sg_policy-&gt;policy, next_freq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slow path借助一个work来完成，call <code>__cpufreq_driver_target()</code>完成，需要mutex。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sugov_work</span><span class="params">(<span class="keyword">struct</span> kthread_work *work)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_policy</span> *<span class="title">sg_policy</span> =</span> container_of(work, <span class="keyword">struct</span> sugov_policy, work);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> freq;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Hold sg_policy-&gt;update_lock shortly to handle the case where:</span></span><br><span class="line"><span class="comment"> * incase sg_policy-&gt;next_freq is read here, and then updated by</span></span><br><span class="line"><span class="comment"> * sugov_deferred_update() just before work_in_progress is set to false</span></span><br><span class="line"><span class="comment"> * here, we may miss queueing the new update.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: If a work was queued after the update_lock is released,</span></span><br><span class="line"><span class="comment"> * sugov_work() will just be called again by kthread_work code; and the</span></span><br><span class="line"><span class="comment"> * request will be proceed before the sugov thread sleeps.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">raw_spin_lock_irqsave(&amp;sg_policy-&gt;update_lock, flags);</span><br><span class="line">freq = sg_policy-&gt;next_freq;</span><br><span class="line">sg_policy-&gt;work_in_progress = <span class="literal">false</span>;</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;sg_policy-&gt;update_lock, flags);</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;sg_policy-&gt;work_lock);</span><br><span class="line">__cpufreq_driver_target(sg_policy-&gt;policy, freq, CPUFREQ_RELATION_L); <span class="comment">//tj: here</span></span><br><span class="line">mutex_unlock(&amp;sg_policy-&gt;work_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切换之前还有个<code>if (sugov_update_next_freq())</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">sugov_update_next_freq</span><span class="params">(<span class="keyword">struct</span> sugov_policy *sg_policy, u64 time,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">int</span> next_freq)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sg_policy-&gt;need_freq_update)</span><br><span class="line">sg_policy-&gt;need_freq_update = cpufreq_driver_test_flags(CPUFREQ_NEED_UPDATE_LIMITS);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sg_policy-&gt;next_freq == next_freq)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">sg_policy-&gt;next_freq = next_freq;</span><br><span class="line">sg_policy-&gt;last_freq_update_time = time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑是只要<code>need_freq_update</code> flag被设置了，那就更新。(也符合这个flag的名字，rt:) 反之，如果当前freq和之前的一样，就不要更新了。</p><p><code>need_freq_update</code>来自<code>limits_changed</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(sg_policy-&gt;limits_changed)) &#123;</span><br><span class="line">sg_policy-&gt;limits_changed = <span class="literal">false</span>;</span><br><span class="line">sg_policy-&gt;need_freq_update = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>set <code>limits_changed</code>有两处：</p><p>一是<code>sugov_limits()</code>，就是policy min&#x2F;max改变了。另一个是<code>ignore_dl_rate_limit()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Make sugov_should_update_freq() ignore the rate limit when DL</span></span><br><span class="line"><span class="comment"> * has increased the utilization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">ignore_dl_rate_limit</span><span class="params">(<span class="keyword">struct</span> sugov_cpu *sg_cpu)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cpu_bw_dl(cpu_rq(sg_cpu-&gt;cpu)) &gt; sg_cpu-&gt;bw_dl)</span><br><span class="line">sg_cpu-&gt;sg_policy-&gt;limits_changed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果deadline task增加了CPU utilization那就忽略限速，强制更新。</p><p><code>sugov_get_util()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sugov_get_util</span><span class="params">(<span class="keyword">struct</span> sugov_cpu *sg_cpu)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> =</span> cpu_rq(sg_cpu-&gt;cpu);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> max = arch_scale_cpu_capacity(sg_cpu-&gt;cpu);</span><br><span class="line"></span><br><span class="line">sg_cpu-&gt;max = max;</span><br><span class="line">sg_cpu-&gt;bw_dl = cpu_bw_dl(rq);</span><br><span class="line">sg_cpu-&gt;util = effective_cpu_util(sg_cpu-&gt;cpu, cpu_util_cfs(rq), max,  <span class="comment">//tj:here</span></span><br><span class="line">  FREQUENCY_UTIL, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>effective_cpu_util()</code>获取当前的CPU utilization，里面会根据schedule class来聚合util，涉及调度侧，暂略过。</p><h2 id="计算频率"><a href="#计算频率" class="headerlink" title="计算频率"></a>计算频率</h2><p><code>get_next_freq()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get_next_freq - Compute a new frequency for a given cpufreq policy.</span></span><br><span class="line"><span class="comment"> * @sg_policy: schedutil policy object to compute the new frequency for.</span></span><br><span class="line"><span class="comment"> * @util: Current CPU utilization.</span></span><br><span class="line"><span class="comment"> * @max: CPU capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the utilization is frequency-invariant, choose the new frequency to be</span></span><br><span class="line"><span class="comment"> * proportional to it, that is</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * next_freq = C * max_freq * util / max</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Otherwise, approximate the would-be frequency-invariant utilization by</span></span><br><span class="line"><span class="comment"> * util_raw * (curr_freq / max_freq) which leads to</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * next_freq = C * curr_freq * util_raw / max</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Take C = 1.25 for the frequency tipping point at (util / max) = 0.8.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The lowest driver-supported frequency which is equal or greater than the raw</span></span><br><span class="line"><span class="comment"> * next_freq (as calculated above) is returned, subject to policy min/max and</span></span><br><span class="line"><span class="comment"> * cpufreq driver limitations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">get_next_freq</span><span class="params">(<span class="keyword">struct</span> sugov_policy *sg_policy,</span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">long</span> util, <span class="type">unsigned</span> <span class="type">long</span> max)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span> =</span> sg_policy-&gt;policy;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> freq = arch_scale_freq_invariant() ?</span><br><span class="line">policy-&gt;cpuinfo.max_freq : policy-&gt;cur;</span><br><span class="line"></span><br><span class="line">freq = map_util_freq(util, freq, max);</span><br></pre></td></tr></table></figure><p>注释很详细，next freq就是: (1.25 * freq * util &#x2F; max), 1.25来自临界点0.8。</p><h2 id="IO-wait-boosting"><a href="#IO-wait-boosting" class="headerlink" title="IO-wait boosting"></a>IO-wait boosting</h2><p>如果任务最近一直在等待I&#x2F;O，那么就(逐步)调频到最大的freq，以免连续IO请求吞吐性能不足。</p><p>主要是两个函数：<code>sugov_iowait_boost()</code>和<code>sugov_iowait_apply()</code>。</p><p><code>sugov_iowait_boost()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sugov_iowait_boost() - Updates the IO boost status of a CPU.</span></span><br><span class="line"><span class="comment"> * @sg_cpu: the sugov data for the CPU to boost</span></span><br><span class="line"><span class="comment"> * @time: the update time from the caller</span></span><br><span class="line"><span class="comment"> * @flags: SCHED_CPUFREQ_IOWAIT if the task is waking up after an IO wait</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Each time a task wakes up after an IO operation, the CPU utilization can be</span></span><br><span class="line"><span class="comment"> * boosted to a certain utilization which doubles at each &quot;frequent and</span></span><br><span class="line"><span class="comment"> * successive&quot; wakeup from IO, ranging from IOWAIT_BOOST_MIN to the utilization</span></span><br><span class="line"><span class="comment"> * of the maximum OPP.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To keep doubling, an IO boost has to be requested at least once per tick,</span></span><br><span class="line"><span class="comment"> * otherwise we restart from the utilization of the minimum OPP.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>留意最后一段：为了保持doubling，IO boost每个tick至少来1次，否则重新开始。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sugov_iowait_boost</span><span class="params">(<span class="keyword">struct</span> sugov_cpu *sg_cpu, u64 time,</span></span><br><span class="line"><span class="params">       <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> set_iowait_boost = flags &amp; SCHED_CPUFREQ_IOWAIT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reset boost if the CPU appears to have been idle enough */</span></span><br><span class="line"><span class="keyword">if</span> (sg_cpu-&gt;iowait_boost &amp;&amp;</span><br><span class="line">    sugov_iowait_reset(sg_cpu, time, set_iowait_boost))</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>当<code>iowait_boost</code>有值，如果此boost超过1个tick，那忽略这次boost，复位从头再来。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">sugov_iowait_reset</span><span class="params">(<span class="keyword">struct</span> sugov_cpu *sg_cpu, u64 time,</span></span><br><span class="line"><span class="params">       <span class="type">bool</span> set_iowait_boost)</span></span><br><span class="line">&#123;</span><br><span class="line">s64 delta_ns = time - sg_cpu-&gt;last_update;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reset boost only if a tick has elapsed since last request */</span></span><br><span class="line"><span class="keyword">if</span> (delta_ns &lt;= TICK_NSEC)  <span class="comment">//tj: here, 连续的IO wait必须在one tick内</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">sg_cpu-&gt;iowait_boost = set_iowait_boost ? IOWAIT_BOOST_MIN : <span class="number">0</span>;</span><br><span class="line">sg_cpu-&gt;iowait_boost_pending = set_iowait_boost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Boost only tasks waking up after IO */</span></span><br><span class="line"><span class="keyword">if</span> (!set_iowait_boost)</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p><code>SCHED_CPUFREQ_IOWAIT</code>是由调度传过来in <code>enqueue_task_fair()</code>，没配置就不需要boost了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If in_iowait is set, the code below may not trigger any cpufreq</span></span><br><span class="line"><span class="comment"> * utilization updates, so do it here explicitly with the IOWAIT flag</span></span><br><span class="line"><span class="comment"> * passed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;in_iowait)</span><br><span class="line">        cpufreq_update_util(rq, SCHED_CPUFREQ_IOWAIT);</span><br></pre></td></tr></table></figure><p>继续看：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ensure boost doubles only one time at each request */</span></span><br><span class="line"><span class="keyword">if</span> (sg_cpu-&gt;iowait_boost_pending)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">sg_cpu-&gt;iowait_boost_pending = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Double the boost at each request */</span></span><br><span class="line"><span class="keyword">if</span> (sg_cpu-&gt;iowait_boost) &#123;</span><br><span class="line">sg_cpu-&gt;iowait_boost =</span><br><span class="line"><span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>, sg_cpu-&gt;iowait_boost &lt;&lt; <span class="number">1</span>, SCHED_CAPACITY_SCALE);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一次boost只double一次。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* First wakeup after IO: start with minimum boost */</span></span><br><span class="line">sg_cpu-&gt;iowait_boost = IOWAIT_BOOST_MIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次boost从<code>IOWAIT_BOOST_MIN</code>开始。</p><h2 id="Rate-Limit"><a href="#Rate-Limit" class="headerlink" title="Rate Limit"></a>Rate Limit</h2><p>降低freq update过快带来的消耗:</p><blockquote><pre><code>   Minimum time (in microseconds) that has to pass between two consecutive   runs of governor computations (default: 1000 times the scaling driver&#39;s   transition latency).   The purpose of this tunable is to reduce the scheduler context overhead   of the governor which might be excessive without it.</code></pre></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">sugov_should_update_freq</span><span class="params">(<span class="keyword">struct</span> sugov_policy *sg_policy, u64 time)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">delta_ns = time - sg_policy-&gt;last_freq_update_time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> delta_ns &gt;= sg_policy-&gt;freq_update_delay_ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有个DL的rate limit(<code>ignore_dl_rate_limit()</code>):</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Make sugov_should_update_freq() ignore the rate limit when DL</span></span><br><span class="line"><span class="comment"> * has increased the utilization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">ignore_dl_rate_limit</span><span class="params">(<span class="keyword">struct</span> sugov_cpu *sg_cpu)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cpu_bw_dl(cpu_rq(sg_cpu-&gt;cpu)) &gt; sg_cpu-&gt;bw_dl)</span><br><span class="line">sg_cpu-&gt;sg_policy-&gt;limits_changed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下调用：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ignore_dl_rate_limit(sg_cpu);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sugov_should_update_freq(sg_cpu-&gt;sg_policy, time))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(sg_policy-&gt;limits_changed)) &#123;</span><br><span class="line">sg_policy-&gt;limits_changed = <span class="literal">false</span>;</span><br><span class="line">sg_policy-&gt;need_freq_update = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delta_ns = time - sg_policy-&gt;last_freq_update_time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> delta_ns &gt;= sg_policy-&gt;freq_update_delay_ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>走<code>need_freq_update</code>强制更新。</p><h2 id="Refer-Doc"><a href="#Refer-Doc" class="headerlink" title="Refer Doc"></a>Refer Doc</h2><ul><li>Documentation&#x2F;admin-guide&#x2F;pm&#x2F;cpufreq.rst (schedutil)</li><li>Documentation&#x2F;scheduler&#x2F;sched-energy.rst</li></ul>]]></content>
      
      
      <categories>
          
          <category> perf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> schedutil </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM EAS Overview</title>
      <link href="/arm-eas-overview.html"/>
      <url>/arm-eas-overview.html</url>
      
        <content type="html"><![CDATA[<p>EAS全称是Energy Aware Scheduling，主要目标就是降低功耗同时兼顾性能，专门针对异构CPU，比如Arm大小核架构。</p><p>EAS利用task load(PELT or WALT) 和 Engery Model (EM) 找到engergy-efficient CPU。</p><p>这里的PELT是per-entity load tracking，上游Linux使用。</p><p>QCOM认为PELT有缺陷，提出了一个新的WALT(Window Assited Loading Track)机制。</p><p>对于一些轻中度utilization场景，EAS帮助很多，但是对于high utilization场景(over-utilization), 就不用EAS，调度回退到load balancing了。</p><h2 id="Engery-Model"><a href="#Engery-Model" class="headerlink" title="Engery Model"></a>Engery Model</h2><p>就是提供各种设备的power消耗到上层子系统(EAS&#x2F;thermal)供他们做出一些相关决策。</p><p>配置选项是<code>CONFIG_ENERGY_MODEL</code>, code在kernel&#x2F;power&#x2F;energy_model.c。</p><blockquote><pre><code>  +---------------+  +-----------------+  +---------------+  | Thermal (IPA) |  | Scheduler (EAS) |  |     Other     |  +---------------+  +-----------------+  +---------------+          |                   | em_cpu_energy()   |          |                   | em_cpu_get()      |          +---------+         |         +---------+                    |         |         |                    v         v         v                   +---------------------+                   |    Energy Model     |                   |     Framework       |                   +---------------------+                      ^       ^       ^                      |       |       | em_dev_register_perf_domain()           +----------+       |       +---------+           |                  |                 |   +---------------+  +---------------+  +--------------+   |  cpufreq-dt   |  |   arm_scmi    |  |    Other     |   +---------------+  +---------------+  +--------------+           ^                  ^                 ^           |                  |                 |   +--------------+   +---------------+  +--------------+   | Device Tree  |   |   Firmware    |  |      ?       |   +--------------+   +---------------+  +--------------+</code></pre></blockquote><p>两个关键API:</p><ul><li>em_cpu_get(): 访问power const tables。</li><li>em_pd_energy(): 估计一个performance domain的能耗。</li></ul><h2 id="PELT"><a href="#PELT" class="headerlink" title="PELT"></a>PELT</h2><p>想法就是当下non-runnable entities&#x2F;tasks也会对load产生影响(via decay来实现)</p><p>一个entity的load计算是：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">L = L0 + L1*y + L2*y*y + ...</span><br></pre></td></tr></table></figure><p>y是decay factor，当前代码实现 y^32 &#x3D; 0.5。</p><p>代码在kernel&#x2F;sched&#x2F;pelt.c。</p><h2 id="WALT"><a href="#WALT" class="headerlink" title="WALT"></a>WALT</h2><p>相比PELT，WALT只考虑当前运行的任务，waiting不算，但是一旦变成可运行的，它之前的load会纳入考虑。</p><h2 id="task-placement"><a href="#task-placement" class="headerlink" title="task placement"></a>task placement</h2><p>目的就是找到每一个performance domain里的engery efficient CPU, 有个计算公式：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">CPU spare capacity = CPU capatity - CPU utilization</span><br></pre></td></tr></table></figure><p>CPU spare capcity最多的那些CPUs就是第一步筛选出来的, 然后根据任务(比如此时在CPU0上)迁移到这些CPUs包括prev_cpu(CPU0)的去向，分别计算得到power消耗，消耗最低的就是最终人选。</p><p>需要注意的是，小核不总是比大核更省电，比如下面的模型：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   Energy Model</span><br><span class="line">+-----------+-------------+</span><br><span class="line">|  Little   |     Big     |</span><br><span class="line">+-----+-----+------+------+</span><br><span class="line">| Cap | Pwr | Cap  | Pwr  |</span><br><span class="line">+-----+-----+------+------+</span><br><span class="line">| 170 | 50  | 512  | 300  |</span><br><span class="line">| 341 | 150 | 768  | 800  |</span><br><span class="line">| 512 | 400 | 1024 | 1700 |</span><br><span class="line">+-----+-----+------+------+</span><br></pre></td></tr></table></figure><p>小核最大Cap的Pwr(400)比大核最小Cap其实要耗电。</p><p>代码入口：<code>find_energy_efficient_cpu()</code>。</p><h2 id="over-utilization"><a href="#over-utilization" class="headerlink" title="over-utilization"></a>over-utilization</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">cpu_overutilized</span><span class="params">(<span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !fits_capacity(cpu_util(cpu), capacity_of(cpu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The margin used when comparing utilization with CPU capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (default: ~20%)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fits_capacity(cap, max)((cap) * 1280 &lt; (max) * 1024)</span></span><br></pre></td></tr></table></figure><p>fits_capacity的条件是cap&#x2F;max &lt; 80%(1024&#x2F;1280), 也就是说80%以上的utilization就是non fit了。</p><h2 id="refer-doc"><a href="#refer-doc" class="headerlink" title="refer doc"></a>refer doc</h2><ul><li>Documentation&#x2F;scheduler&#x2F;sched-energy.rst</li></ul>]]></content>
      
      
      <categories>
          
          <category> perf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析erofs-utils canned fs_config查找失败问题</title>
      <link href="/canned-fs-config-for-erofs-utils.html"/>
      <url>/canned-fs-config-for-erofs-utils.html</url>
      
        <content type="html"><![CDATA[<p>H的erofs已经支持Android，QC&#x2F;droid 10下生成镜像有如下错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">failed to find [app] in canned fs_config</span><br></pre></td></tr></table></figure><p>code在system&#x2F;core&#x2F;libcutils&#x2F;canned_fs_config.cpp:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">canned_fs_config</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">int</span> dir, <span class="type">const</span> <span class="type">char</span>* target_out_path,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">unsigned</span>* uid, <span class="type">unsigned</span>* gid, <span class="type">unsigned</span>* mode, <span class="type">uint64_t</span>* capabilities)</span> </span>&#123;</span><br><span class="line">    Path key, *p;</span><br><span class="line"></span><br><span class="line">    key.path = path;</span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) key.path++; <span class="comment">// canned paths lack the leading &#x27;/&#x27;</span></span><br><span class="line">    p = (Path*) <span class="built_in">bsearch</span>(&amp;key, canned_data, canned_used, <span class="built_in">sizeof</span>(Path), path_compare);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;failed to find [%s] in canned fs_config\n&quot;</span>, path); <span class="comment">//tj: here</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对<code>canned_data</code>和<code>canned_used</code>做<code>bsearch()</code>无结果。先有个<code>load_canned_fs_config()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WITH_ANDROID</span></span><br><span class="line">        <span class="keyword">if</span> (cfg.fs_config_file &amp;&amp;</span><br><span class="line">            load_canned_fs_config(cfg.fs_config_file) &lt; <span class="number">0</span>) &#123; <span class="comment">//tj: here</span></span><br><span class="line">                erofs_err(<span class="string">&quot;failed to load fs config %s&quot;</span>, cfg.fs_config_file);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>cfg.fs_config_file</code>是工具传入：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WITH_ANDROID</span></span><br><span class="line">              <span class="string">&quot;\nwith following android-specific options:\n&quot;</span></span><br><span class="line">              <span class="string">&quot; --mount-point=X    X=prefix of target fs path (default: /)\n&quot;</span></span><br><span class="line">              <span class="string">&quot; --product-out=X    X=product_out directory\n&quot;</span></span><br><span class="line">              <span class="string">&quot; --fs-config-file=X X=fs_config file\n&quot;</span> <span class="comment">//tj: here</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">                <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                        cfg.fs_config_file = optarg;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>load_canned_fs_config()</code>在system&#x2F;core&#x2F;libcutils&#x2F;canned_fs_config.cpp.</p><p>看下传入fs_config文件，product分区：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"> 0 0 755 selabel=u:object_r:rootfs:s0 capabilities=0x0</span><br><span class="line">product/app 0 0 755 selabel=u:object_r:system_file:s0 capabilities=0x0</span><br><span class="line">product/app/CalculatorGoogle 0 0 755 selabel=u:object_r:system_file:s0 capabilities=0x0</span><br></pre></td></tr></table></figure><p>多了个product目录，txt should来源：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> BUILDING_PRODUCT_IMAGE</span><br><span class="line">        <span class="variable">$(hide)</span> <span class="variable">$(<span class="built_in">call</span> fs_config,<span class="variable">$(zip_root)</span>/PRODUCT,product/)</span> &gt; <span class="variable">$(zip_root)</span>/META/product_filesystem_config.txt</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Run fs_config while creating the target files package</span></span><br><span class="line"><span class="comment"># $1: root directory</span></span><br><span class="line"><span class="comment"># $2: add prefix</span></span><br><span class="line"><span class="keyword">define</span> fs_config</span><br><span class="line">(cd $(1); find . -type d | sed &#x27;s,$$,/,&#x27;; find . \! -type d) | cut -c 3- | sort | sed &#x27;s,^,$(2),&#x27; | <span class="variable">$(HOST_OUT_EXECUTABLES)</span>/fs_config -C -D <span class="variable">$(TARGET_OUT)</span> -S <span class="variable">$(SELINUX_FC)</span> -R <span class="string">&quot;$(2)&quot;</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure><p>so，应该是build时增加了product这个prefix。</p><p>看下erofs的处理：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int erofs_droid_inode_fsconfig(struct erofs_inode *inode,</span><br><span class="line">                               struct stat64 *st,</span><br><span class="line">                               const char *path)</span><br><span class="line">&#123;</span><br><span class="line">        /* filesystem_config does not preserve file type bits */</span><br><span class="line">        mode_t stat_file_type_mask = st-&gt;st_mode &amp; S_IFMT;</span><br><span class="line">        unsigned int uid = 0, gid = 0, mode = 0;</span><br><span class="line">        char *fspath;</span><br><span class="line"></span><br><span class="line">        inode-&gt;capabilities = 0;</span><br><span class="line">        if (cfg.fs_config_file)</span><br><span class="line">                canned_fs_config(erofs_fspath(path), //tj: here</span><br><span class="line">                                 S_ISDIR(st-&gt;st_mode),</span><br><span class="line">                                 cfg.target_out_path,</span><br><span class="line">                                 &amp;uid, &amp;gid, &amp;mode, &amp;inode-&gt;capabilities);</span><br><span class="line">        else if (cfg.mount_point) &#123;</span><br><span class="line">                if (asprintf(&amp;fspath, &quot;%s/%s&quot;, cfg.mount_point,</span><br><span class="line">                             erofs_fspath(path)) &lt;= 0)</span><br><span class="line">                        return -ENOMEM;</span><br><span class="line"></span><br><span class="line">                fs_config(fspath, S_ISDIR(st-&gt;st_mode),</span><br><span class="line">                          cfg.target_out_path,</span><br><span class="line">                          &amp;uid, &amp;gid, &amp;mode, &amp;inode-&gt;capabilities);</span><br><span class="line">                free(fspath);</span><br><span class="line">        &#125;</span><br><span class="line">        st-&gt;st_uid = uid;</span><br><span class="line">        st-&gt;st_gid = gid;</span><br><span class="line">        st-&gt;st_mode = mode | stat_file_type_mask;</span><br><span class="line"></span><br><span class="line">        erofs_dbg(&quot;/%s -&gt; mode = 0x%x, uid = 0x%x, gid = 0x%x, &quot;</span><br><span class="line">                  &quot;capabilities = 0x%&quot; PRIx64 &quot;\n&quot;,</span><br><span class="line">                  erofs_fspath(path),</span><br><span class="line">                  mode, uid, gid, inode-&gt;capabilities);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>check <code>erofs_fspath()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">erofs_fspath</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fullpath)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *s = fullpath + fullpath_prefix;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                s++;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fullpath_prefix</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> fullpath_prefix;    <span class="comment">/* root directory prefix length */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">erofs_set_fs_root</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *rootdir)</span></span><br><span class="line">&#123;</span><br><span class="line">        fullpath_prefix = <span class="built_in">strlen</span>(rootdir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">erofs_set_fs_root(cfg.c_src_path);</span><br></pre></td></tr></table></figure><p>so, <code>erofs_fspath()</code>就是子目录了, 而<code>product_filesystem_config.txt</code>是有前缀的(就是挂载点), 那加上前缀就可以了。</p><p>具体讨论看这里：<a href="https://lore.kernel.org/linux-erofs/20201222020430.12512-1-zbestahu@gmail.com/">https://lore.kernel.org/linux-erofs/20201222020430.12512-1-zbestahu@gmail.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erofs </tag>
            
            <tag> fs_config </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超慢速电影播放相框</title>
      <link href="/slow-movie-raspberrypi-based-using-epaper.html"/>
      <url>/slow-movie-raspberrypi-based-using-epaper.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>How cool would this be playing your favourite film onto a plain wall somewhere you can see it throughout the day?</p></blockquote><h2 id="库布里克的2001是真慢"><a href="#库布里克的2001是真慢" class="headerlink" title="库布里克的2001是真慢"></a><em>库布里克的2001是真慢</em></h2><p><img src="http://tjtech.me/usr/uploads/2020/11/747090441.png#center" alt="epd-2001.png"></p><h2 id="放动画美美滴"><a href="#放动画美美滴" class="headerlink" title="放动画美美滴"></a><em>放动画美美滴</em></h2><p><img src="http://tjtech.me/usr/uploads/2020/11/1683481683.png#center" alt="epd-top1.png"></p><h2 id="背面"><a href="#背面" class="headerlink" title="背面"></a>背面</h2><p><img src="http://tjtech.me/usr/uploads/2020/12/2550723301.png#center" alt="epd-bottom.png"></p><p><em>btw: 没必要pi 4，pi zero就够了，cpu会高一点，稍微改改脚本</em></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://make.quwj.com/project/339">https://make.quwj.com/project/339</a></p></li><li><p><a href="https://www.raspberrypi.org/blog/raspberry-pi-powered-e-paper-display-takes-months-to-show-a-movie/">https://www.raspberrypi.org/blog/raspberry-pi-powered-e-paper-display-takes-months-to-show-a-movie/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> epaper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kernel Panic实例分析三:Unable to handle kernel paging request</title>
      <link href="/page-fault-analysis-3-using-crash-utility.html"/>
      <url>/page-fault-analysis-3-using-crash-utility.html</url>
      
        <content type="html"><![CDATA[<p>QC armv7平台kernel 4.x出现的死机问题，一开始很随机以为是DDR硬件问题，直到后面死机越來越多，还出现过pc一样的现场，让人不得不怀疑是SW issue，同步提给QC看，看QC的答复就是用tracer32来定位的，下来温习了下armv7，完全可以用red hat的crash工具结合反汇编和源码分析定位，对小厂算是节约license成本了?</p><p>我们先看死机现场:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">551 [   63.694025] Unable to handle kernel paging request at virtual address 383c0a1d</span><br><span class="line">552 [   63.694034] pgd = db387da1</span><br><span class="line">553 [   63.694036] [383c0a1d] *pgd=00000000</span><br><span class="line">554 [   63.694045] Internal error: Oops: 5 [#1] PREEMPT SMP ARM</span><br><span class="line">555 [   63.694048] Modules linked in: machine_ext_dlkm(O) machine_dlkm(O) cpe_lsm_dlkm(O) wcd_cpe_dlkm(O) analog_cdc_dlkm(O) aw87359_dlkm(O) digital_cdc_dlkm(O) stub_dlkm(O) mbhc_dlkm(O) wcd    9xxx_dlkm(O) wcd_core_dlkm(O) swr_ctrl_dlkm(O) swr_dlkm(O) pinctrl_wcd_dlkm(O) native_dlkm(O) platform_dlkm(O) usf_dlkm(O) q6_dlkm(O) adsp_loader_dlkm(O) apr_dlkm(O) q6_notifier_dlkm(O)</span><br><span class="line">558 [   63.694126] task: b4fb24a1 task.stack: 4ddc1adc</span><br><span class="line">559 [   63.694137] PC is at kernfs_find_ns+0x78/0xf8</span><br><span class="line">560 [   63.694143] LR is at kernfs_name_hash+0x10/0x68</span><br><span class="line">561 [   63.694147] pc : [&lt;c02dc290&gt;]    lr : [&lt;c02db85c&gt;]    psr: 200b0013</span><br><span class="line">562                sp : d9fa9d68  ip : 00000000  fp : 00000000</span><br><span class="line">563 [   63.694150] r10: d9fa9ec0  r9 : 00000011  r8 : e47522a8</span><br><span class="line">564 [   63.694153] r7 : 00000000  r6 : e4477bdc  r5 : 5d64df2d  r4 : 383c0a0d</span><br><span class="line">565 [   63.694156] r3 : 7473616d  r2 : 00000031  r1 : 26e33aa1  r0 : 5d64df2d</span><br><span class="line">...</span><br><span class="line">599 [   63.694571] Stack: (0xd9fa9d68 to 0xd9faa000)</span><br><span class="line">600 [   63.694577] 9d60:                   e47522a8 000409e3 00080040 ea0172d0 e4477bb0 e9d9bbe8</span><br><span class="line">601 [   63.694584] 9d80: e9d9bc60 c02dc3d8 e4477bb0 c13091c8 e9d9bbe8 c026d0a8 00000000 d9fa9d9c</span><br><span class="line">602 [   63.694591] 9da0: d9fa9d9c 000409e3 00000000 00000001 d9fa9eb8 00000000 c13091c8 d9fa9eb8</span><br><span class="line">603 [   63.694599] 9dc0: d9fa8000 e47522a8 00000009 c0271234 c11532d0 e9d9bbe8 00000001 d9fa9eb8</span><br><span class="line">604 [   63.694607] 9de0: d9fa8000 000409e3 b4ea6d82 61c88647 c13091c8 cedc902a d9fa9eb8 c0271488</span><br><span class="line">605 [   63.694615] 9e00: 00000000 00000009 00000142 c03c2560 c03c2524 c1153ae8 c1153358 c03bead0</span><br><span class="line">606 [   63.694623] 9e20: c50ed480 000409e3 d9fa9eb8 d9fa9eb8 d9fa9f70 cedc9010 00000001 c50ed480</span><br><span class="line">607 [   63.694631] 9e40: d9fa8000 00000142 00000009 c0271a58 ebaa2908 c01a0b30 eba0e440 eba0e490</span><br><span class="line">621 [   63.694751] [&lt;c02dc290&gt;] (kernfs_find_ns) from [&lt;c02dc3d8&gt;] (kernfs_iop_lookup+0x48/0xd8)</span><br><span class="line">622 [   63.694760] [&lt;c02dc3d8&gt;] (kernfs_iop_lookup) from [&lt;c026d0a8&gt;] (lookup_slow+0x94/0x158)</span><br><span class="line">623 [   63.694768] [&lt;c026d0a8&gt;] (lookup_slow) from [&lt;c0271234&gt;] (walk_component+0x1fc/0x2cc)</span><br><span class="line">624 [   63.694775] [&lt;c0271234&gt;] (walk_component) from [&lt;c0271488&gt;] (link_path_walk+0x184/0x4e4)</span><br><span class="line">625 [   63.694782] [&lt;c0271488&gt;] (link_path_walk) from [&lt;c0271a58&gt;] (path_openat+0x88/0xc70)</span><br><span class="line">626 [   63.694789] [&lt;c0271a58&gt;] (path_openat) from [&lt;c02739f8&gt;] (do_filp_open+0x6c/0x110)</span><br><span class="line">627 [   63.694797] [&lt;c02739f8&gt;] (do_filp_open) from [&lt;c0261074&gt;] (do_sys_open+0x128/0x23c)</span><br><span class="line">628 [   63.694806] [&lt;c0261074&gt;] (do_sys_open) from [&lt;c0108b40&gt;] (ret_fast_syscall+0x0/0x54)</span><br><span class="line">629 [   63.694814] Code: aa00000c e5944008 e3540000 0a000006 (e5943010)</span><br><span class="line">630 [   63.694818] ---[ end trace 9656f9b4178497a9 ]---</span><br></pre></td></tr></table></figure><p>非法地址访问，当前pc是c02dc290, 在<code>kernfs_find_ns</code>里。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">crash.arm&gt; sym c02dc290</span><br><span class="line">c02dc290 (t) kernfs_find_ns+120 .../fs/kernfs/dir.c: 306</span><br></pre></td></tr></table></figure><p>找到对应的c code:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">303</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">kernfs_name_compare</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> hash, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"><span class="number">304</span>                                <span class="type">const</span> <span class="type">void</span> *ns, <span class="type">const</span> <span class="keyword">struct</span> kernfs_node *kn)</span></span><br><span class="line">305 &#123;</span><br><span class="line"><span class="number">306</span>         <span class="keyword">if</span> (hash &lt; kn-&gt;hash) <span class="comment">//pc</span></span><br><span class="line"><span class="number">307</span>                 <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p><code>kernfs_find_ns()</code> calls <code>kernfs_name_compare()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">737</span> <span class="type">static</span> <span class="keyword">struct</span> kernfs_node *<span class="title function_">kernfs_find_ns</span><span class="params">(<span class="keyword">struct</span> kernfs_node *parent,</span></span><br><span class="line"><span class="params"><span class="number">738</span>                                           <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"><span class="number">739</span>                                           <span class="type">const</span> <span class="type">void</span> *ns)</span></span><br><span class="line">740 &#123;</span><br><span class="line"><span class="number">741</span>         <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span> =</span> parent-&gt;dir.children.rb_node;</span><br><span class="line"><span class="number">742</span>         <span class="type">bool</span> has_ns = kernfs_ns_enabled(parent);</span><br><span class="line"><span class="number">743</span>         <span class="type">unsigned</span> <span class="type">int</span> hash;</span><br><span class="line"><span class="number">744</span></span><br><span class="line"><span class="number">745</span>         lockdep_assert_held(&amp;kernfs_mutex);</span><br><span class="line"><span class="number">746</span></span><br><span class="line"><span class="number">747</span>         <span class="keyword">if</span> (has_ns != (<span class="type">bool</span>)ns) &#123;</span><br><span class="line"><span class="number">748</span>                 WARN(<span class="number">1</span>, KERN_WARNING <span class="string">&quot;kernfs: ns %s in &#x27;%s&#x27; for &#x27;%s&#x27;\n&quot;</span>,</span><br><span class="line"><span class="number">749</span>                      has_ns ? <span class="string">&quot;required&quot;</span> : <span class="string">&quot;invalid&quot;</span>, parent-&gt;name, name);</span><br><span class="line"><span class="number">750</span>                 <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">751</span>         &#125;</span><br><span class="line"><span class="number">752</span></span><br><span class="line"><span class="number">753</span>         hash = kernfs_name_hash(name, ns);</span><br><span class="line"><span class="number">754</span>         <span class="keyword">while</span> (node) &#123;</span><br><span class="line"><span class="number">755</span>                 <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span> *<span class="title">kn</span>;</span></span><br><span class="line"><span class="number">756</span>                 <span class="type">int</span> result;</span><br><span class="line"><span class="number">757</span></span><br><span class="line"><span class="number">758</span>                 kn = rb_to_kn(node);</span><br><span class="line"><span class="number">759</span>                 result = kernfs_name_compare(hash, name, ns, kn); <span class="comment">//tj: here</span></span><br><span class="line"><span class="number">760</span>                 <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">761</span>                         node = node-&gt;rb_left;</span><br><span class="line"><span class="number">762</span>                 <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>)</span><br><span class="line"><span class="number">763</span>                         node = node-&gt;rb_right;</span><br><span class="line"><span class="number">764</span>                 <span class="keyword">else</span></span><br><span class="line"><span class="number">765</span>                         <span class="keyword">return</span> kn;</span><br><span class="line"><span class="number">766</span>         &#125;</span><br><span class="line"><span class="number">767</span>         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">768</span> &#125;</span><br></pre></td></tr></table></figure><p><code>kernfs_find_ns</code> lr：c02dc3d8</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">crash.arm&gt; sym c02dc3d8</span><br><span class="line">c02dc3d8 (t) kernfs_iop_lookup+72 .../fs/kernfs/dir.c: 990</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">972</span> <span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">kernfs_iop_lookup</span><span class="params">(<span class="keyword">struct</span> inode *dir,</span></span><br><span class="line"><span class="params"><span class="number">973</span>                                         <span class="keyword">struct</span> dentry *dentry,</span></span><br><span class="line"><span class="params"><span class="number">974</span>                                         <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">975 &#123;</span><br><span class="line"><span class="number">976</span>         <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">ret</span>;</span></span><br><span class="line"><span class="number">977</span>         <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span> *<span class="title">parent</span> =</span> dentry-&gt;d_parent-&gt;d_fsdata;</span><br><span class="line"><span class="number">978</span>         <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span> *<span class="title">kn</span>;</span></span><br><span class="line"><span class="number">979</span>         <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"><span class="number">980</span>         <span class="type">const</span> <span class="type">void</span> *ns = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">981</span></span><br><span class="line"><span class="number">982</span>         mutex_lock(&amp;kernfs_mutex);</span><br><span class="line"><span class="number">983</span></span><br><span class="line"><span class="number">984</span>         <span class="keyword">if</span> (kernfs_ns_enabled(parent))</span><br><span class="line"><span class="number">985</span>                 ns = kernfs_info(dir-&gt;i_sb)-&gt;ns;</span><br><span class="line"><span class="number">986</span></span><br><span class="line"><span class="number">987</span>         kn = kernfs_find_ns(parent, dentry-&gt;d_name.name, ns);</span><br><span class="line"><span class="number">988</span></span><br><span class="line"><span class="number">989</span>         <span class="comment">/* no such entry */</span></span><br><span class="line"><span class="number">990</span>         <span class="keyword">if</span> (!kn || !kernfs_active(kn)) &#123; <span class="comment">//tj: here</span></span><br><span class="line"><span class="number">991</span>                 ret = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">992</span>                 <span class="keyword">goto</span> out_unlock;</span><br><span class="line"><span class="number">993</span>         &#125;</span><br></pre></td></tr></table></figure><p>ok, 先有个代码印象，下面看下出错附近的反汇编：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crash.arm&gt; dis kernfs_find_ns</span><br><span class="line">0xc02dc218 &lt;kernfs_find_ns&gt;:    push    &#123;r4, r5, r6, r7, lr&#125;</span><br><span class="line">0xc02dc21c &lt;kernfs_find_ns+4&gt;:  adds    r12, r2, #0</span><br><span class="line">0xc02dc220 &lt;kernfs_find_ns+8&gt;:  ldrh    r3, [r0, #68]   ; 0x44</span><br><span class="line">0xc02dc224 &lt;kernfs_find_ns+12&gt;: mov     r6, r1</span><br><span class="line">0xc02dc228 &lt;kernfs_find_ns+16&gt;: movne   r12, #1</span><br><span class="line">0xc02dc22c &lt;kernfs_find_ns+20&gt;: sub     sp, sp, #12</span><br><span class="line">0xc02dc230 &lt;kernfs_find_ns+24&gt;: ubfx    r1, r3, #5, #1</span><br><span class="line">0xc02dc234 &lt;kernfs_find_ns+28&gt;: ldr     r4, [r0, #44]   ; 0x2c</span><br><span class="line">0xc02dc238 &lt;kernfs_find_ns+32&gt;: cmp     r1, r12</span><br><span class="line">0xc02dc23c &lt;kernfs_find_ns+36&gt;: bne     0xc02dc2c8 &lt;kernfs_find_ns+176&gt;</span><br><span class="line">0xc02dc240 &lt;kernfs_find_ns+40&gt;: mov     r0, r6</span><br><span class="line">0xc02dc244 &lt;kernfs_find_ns+44&gt;: mov     r1, r2</span><br><span class="line">0xc02dc248 &lt;kernfs_find_ns+48&gt;: mov     r7, r2</span><br><span class="line">0xc02dc24c &lt;kernfs_find_ns+52&gt;: bl      0xc02db84c &lt;kernfs_name_hash&gt;</span><br><span class="line">0xc02dc250 &lt;kernfs_find_ns+56&gt;: cmp     r4, #0</span><br><span class="line">0xc02dc254 &lt;kernfs_find_ns+60&gt;: mov     r5, r0</span><br><span class="line">0xc02dc258 &lt;kernfs_find_ns+64&gt;: bne     0xc02dc290 &lt;kernfs_find_ns+120&gt;</span><br><span class="line">0xc02dc25c &lt;kernfs_find_ns+68&gt;: b       0xc02dc308 &lt;kernfs_find_ns+240&gt;</span><br><span class="line">0xc02dc260 &lt;kernfs_find_ns+72&gt;: ldr     r3, [r4, #12]</span><br><span class="line">0xc02dc264 &lt;kernfs_find_ns+76&gt;: mov     r0, r6</span><br><span class="line">0xc02dc268 &lt;kernfs_find_ns+80&gt;: cmp     r7, r3</span><br><span class="line">0xc02dc26c &lt;kernfs_find_ns+84&gt;: bcc     0xc02dc284 &lt;kernfs_find_ns+108&gt;</span><br><span class="line">0xc02dc270 &lt;kernfs_find_ns+88&gt;: bhi     0xc02dc2a0 &lt;kernfs_find_ns+136&gt;</span><br><span class="line">0xc02dc274 &lt;kernfs_find_ns+92&gt;: ldr     r1, [r4, #-4]</span><br><span class="line">0xc02dc278 &lt;kernfs_find_ns+96&gt;: bl      0xc0444610 &lt;strcmp&gt;</span><br><span class="line">0xc02dc27c &lt;kernfs_find_ns+100&gt;:        cmp     r0, #0</span><br><span class="line">0xc02dc280 &lt;kernfs_find_ns+104&gt;:        bge     0xc02dc2b8 &lt;kernfs_find_ns+160&gt;</span><br><span class="line">0xc02dc284 &lt;kernfs_find_ns+108&gt;:        ldr     r4, [r4, #8]</span><br><span class="line">0xc02dc288 &lt;kernfs_find_ns+112&gt;:        cmp     r4, #0</span><br><span class="line">0xc02dc28c &lt;kernfs_find_ns+116&gt;:        beq     0xc02dc2ac &lt;kernfs_find_ns+148&gt;</span><br><span class="line">0xc02dc290 &lt;kernfs_find_ns+120&gt;:        ldr     r3, [r4, #16]</span><br><span class="line">0xc02dc294 &lt;kernfs_find_ns+124&gt;:        cmp     r5, r3</span><br><span class="line">0xc02dc298 &lt;kernfs_find_ns+128&gt;:        bcc     0xc02dc284 &lt;kernfs_find_ns+108&gt;</span><br><span class="line">0xc02dc29c &lt;kernfs_find_ns+132&gt;:        bls     0xc02dc260 &lt;kernfs_find_ns+72&gt;</span><br><span class="line">0xc02dc2a0 &lt;kernfs_find_ns+136&gt;:        ldr     r4, [r4, #4]</span><br><span class="line">0xc02dc2a4 &lt;kernfs_find_ns+140&gt;:        cmp     r4, #0</span><br><span class="line">0xc02dc2a8 &lt;kernfs_find_ns+144&gt;:        bne     0xc02dc290 &lt;kernfs_find_ns+120&gt;</span><br><span class="line">0xc02dc2ac &lt;kernfs_find_ns+148&gt;:        mov     r0, #0</span><br><span class="line">0xc02dc2b0 &lt;kernfs_find_ns+152&gt;:        add     sp, sp, #12</span><br><span class="line">0xc02dc2b4 &lt;kernfs_find_ns+156&gt;:        pop     &#123;r4, r5, r6, r7, pc&#125;</span><br><span class="line">0xc02dc2b8 &lt;kernfs_find_ns+160&gt;:        bne     0xc02dc2a0 &lt;kernfs_find_ns+136&gt;</span><br><span class="line">0xc02dc2bc &lt;kernfs_find_ns+164&gt;:        sub     r0, r4, #16</span><br><span class="line">0xc02dc2c0 &lt;kernfs_find_ns+168&gt;:        add     sp, sp, #12</span><br><span class="line">0xc02dc2c4 &lt;kernfs_find_ns+172&gt;:        pop     &#123;r4, r5, r6, r7, pc&#125;</span><br><span class="line">0xc02dc2c8 &lt;kernfs_find_ns+176&gt;:        ldr     lr, [r0, #12]</span><br><span class="line">0xc02dc2cc &lt;kernfs_find_ns+180&gt;:        cmp     r1, #0</span><br><span class="line">0xc02dc2d0 &lt;kernfs_find_ns+184&gt;:        movw    r12, #22808     ; 0x5918</span><br><span class="line">0xc02dc2d4 &lt;kernfs_find_ns+188&gt;:        movw    r3, #46236      ; 0xb49c</span><br><span class="line">0xc02dc2d8 &lt;kernfs_find_ns+192&gt;:        movt    r12, #49410     ; 0xc102</span><br><span class="line">0xc02dc2dc &lt;kernfs_find_ns+196&gt;:        movw    r0, #46068      ; 0xb3f4</span><br><span class="line">0xc02dc2e0 &lt;kernfs_find_ns+200&gt;:        movw    r2, #46244      ; 0xb4a4</span><br><span class="line">0xc02dc2e4 &lt;kernfs_find_ns+204&gt;:        movt    r3, #49404      ; 0xc0fc</span><br><span class="line">0xc02dc2e8 &lt;kernfs_find_ns+208&gt;:        str     r6, [sp, #4]</span><br><span class="line">0xc02dc2ec &lt;kernfs_find_ns+212&gt;:        movt    r0, #49404      ; 0xc0fc</span><br><span class="line">0xc02dc2f0 &lt;kernfs_find_ns+216&gt;:        str     lr, [sp]</span><br><span class="line">0xc02dc2f4 &lt;kernfs_find_ns+220&gt;:        movne   r3, r12</span><br><span class="line">0xc02dc2f8 &lt;kernfs_find_ns+224&gt;:        movt    r2, #49404      ; 0xc0fc</span><br><span class="line">0xc02dc2fc &lt;kernfs_find_ns+228&gt;:        movw    r1, #749        ; 0x2ed</span><br><span class="line">0xc02dc300 &lt;kernfs_find_ns+232&gt;:        bl      0xc012aecc &lt;warn_slowpath_fmt&gt;</span><br><span class="line">0xc02dc304 &lt;kernfs_find_ns+236&gt;:        b       0xc02dc2ac &lt;kernfs_find_ns+148&gt;</span><br><span class="line">0xc02dc308 &lt;kernfs_find_ns+240&gt;:        mov     r0, r4</span><br><span class="line">0xc02dc30c &lt;kernfs_find_ns+244&gt;:        b       0xc02dc2b0 &lt;kernfs_find_ns+152&gt;</span><br></pre></td></tr></table></figure><p>pc是这里：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xc02dc290 &lt;kernfs_find_ns+120&gt;:        ldr     r3, [r4, #16]</span><br></pre></td></tr></table></figure><p>死机现场<code>r4 : 383c0a0d</code>，r4+16就是383c0a1d了，也就是log出现的那个非法地址访问:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">551 [   63.694025] Unable to handle kernel paging request at virtual address 383c0a1d</span><br></pre></td></tr></table></figure><p>+16是啥？我们看c code:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">303</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">kernfs_name_compare</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> hash, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"><span class="number">304</span>                                <span class="type">const</span> <span class="type">void</span> *ns, <span class="type">const</span> <span class="keyword">struct</span> kernfs_node *kn)</span></span><br><span class="line">305 &#123;</span><br><span class="line"><span class="number">306</span>         <span class="keyword">if</span> (hash &lt; kn-&gt;hash) <span class="comment">//pc</span></span><br><span class="line"><span class="number">307</span>                 <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>会是<code>-&gt;hash</code>吗？<code>-&gt;hash</code>的偏移：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">crash.arm&gt; struct kernfs_node.hash</span><br><span class="line">struct kernfs_node &#123;</span><br><span class="line">  [32] unsigned int hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不对。继续看反汇编，可以借助-l打印出code行数帮助定位：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.../fs/kernfs/dir.c: 754</span><br><span class="line">0xc02dc288 &lt;kernfs_find_ns+112&gt;:        cmp     r4, #0 </span><br><span class="line">0xc02dc28c &lt;kernfs_find_ns+116&gt;:        beq     0xc02dc2ac &lt;kernfs_find_ns+148&gt;</span><br><span class="line">.../fs/kernfs/dir.c: 306</span><br><span class="line">0xc02dc290 &lt;kernfs_find_ns+120&gt;:        ldr     r3, [r4, #16] //tj: pc</span><br></pre></td></tr></table></figure><p>754行：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">754</span>         <span class="keyword">while</span> (node) &#123;</span><br><span class="line"><span class="number">755</span>                 <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span> *<span class="title">kn</span>;</span></span><br></pre></td></tr></table></figure><p>0xc02dc2ac:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.../fs/kernfs/dir.c: 750</span><br><span class="line">0xc02dc2ac &lt;kernfs_find_ns+148&gt;:        mov     r0, #0</span><br><span class="line">.../fs/kernfs/dir.c: 768</span><br><span class="line">0xc02dc2b0 &lt;kernfs_find_ns+152&gt;:        add     sp, sp, #12</span><br><span class="line">0xc02dc2b4 &lt;kernfs_find_ns+156&gt;:        pop     &#123;r4, r5, r6, r7, pc&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">750</span>                 <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">...</span><br><span class="line"> <span class="number">767</span>         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> <span class="number">768</span> &#125;</span><br></pre></td></tr></table></figure><p>到这里可以推断r4是node，那这个推断对不对了，我们继续分析，后面主要会从反汇编&#x2F;c&#x2F;armv7栈以及crash工具的使用推导计算出log里的非法地址,大概还有一半多的内容。</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> panic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to get kaslr offset on ARM64</title>
      <link href="/how-to-get-kaslr-offset-on-arm64.html"/>
      <url>/how-to-get-kaslr-offset-on-arm64.html</url>
      
        <content type="html"><![CDATA[<p>Red Hat的crash工具有个option是<code>--kaslr</code>，一般解析ramdump会用，工具定义：</p><blockquote><p> –kaslr offset | auto<br>   If x86, x86_64 or s390x kernel was configured with CONFIG_RANDOMIZE_BASE,<br>   the offset value is equal to the difference between the symbol values<br>   compiled into the vmlinux file and their relocated KASLR value.  If<br>   set to auto, the KASLR offset value will be automatically calculated.</p></blockquote><p>ok, what is <code>CONFIG_RANDOMIZE_BASE</code>? 和arch有关，我们看下ARM64的定义，参考kernel 4.x。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config RANDOMIZE_BASE</span><br><span class="line">        bool &quot;Randomize the address of the kernel image&quot;</span><br><span class="line">        select ARM64_MODULE_PLTS if MODULES</span><br><span class="line">        select RELOCATABLE</span><br><span class="line">        help</span><br><span class="line">          Randomizes the virtual address at which the kernel image is</span><br><span class="line">          loaded, as a security feature that deters exploit attempts</span><br><span class="line">          relying on knowledge of the location of kernel internals.</span><br><span class="line"></span><br><span class="line">          It is the bootloader&#x27;s job to provide entropy, by passing a</span><br><span class="line">          random u64 value in /chosen/kaslr-seed at kernel entry.</span><br><span class="line"></span><br><span class="line">          When booting via the UEFI stub, it will invoke the firmware&#x27;s</span><br><span class="line">          EFI_RNG_PROTOCOL implementation (if available) to supply entropy</span><br><span class="line">          to the kernel proper. In addition, it will randomise the physical</span><br><span class="line">          location of the kernel Image as well.</span><br><span class="line"></span><br><span class="line">          If unsure, say N.</span><br></pre></td></tr></table></figure><blockquote><h2 id="Kernel-Address-Space-Layout-Randomization-KASLR"><a href="#Kernel-Address-Space-Layout-Randomization-KASLR" class="headerlink" title="Kernel Address Space Layout Randomization (KASLR)"></a>Kernel Address Space Layout Randomization (KASLR)</h2><p>Since the location of kernel memory is almost always instrumental in<br>mounting a successful attack, making the location non-deterministic<br>raises the difficulty of an exploit. (Note that this in turn makes<br>the value of information exposures higher, since they may be used to<br>discover desired memory locations.)</p></blockquote><p>ok, 大概明了是一个安全特性，地址随机，防止被攻击。bootloader提供<code>/chosen/kaslr-seed</code>:</p><p>QCOM LK:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">162<span class="comment">#Enable kaslr seed support</span></span><br><span class="line">163ifeq (<span class="variable">$(ENABLE_KASLRSEED)</span>,1)</span><br><span class="line">164  DEFINES += ENABLE_KASLRSEED_SUPPORT=1</span><br><span class="line">165else</span><br><span class="line">166  DEFINES += ENABLE_KASLRSEED_SUPPORT=0</span><br><span class="line">167endif</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2139</span><span class="meta">#<span class="keyword">if</span> ENABLE_KASLRSEED_SUPPORT</span></span><br><span class="line"><span class="number">2140</span><span class="keyword">if</span> (!scm_random((<span class="type">uintptr_t</span> *)&amp;kaslrseed, <span class="keyword">sizeof</span>(kaslrseed))) &#123;</span><br><span class="line"><span class="number">2141</span><span class="comment">/* Adding Kaslr Seed to the chosen node */</span></span><br><span class="line"><span class="number">2142</span>ret = fdt_appendprop_u64 (fdt, offset, (<span class="type">const</span> <span class="type">char</span> *)<span class="string">&quot;kaslr-seed&quot;</span>, (<span class="type">uint64_t</span>)kaslrseed);</span><br><span class="line"><span class="number">2143</span><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="number">2144</span>dprintf(CRITICAL, <span class="string">&quot;ERROR: Cannot update chosen node [kaslr-seed] - 0x%x\n&quot;</span>, ret);</span><br><span class="line"><span class="number">2145</span><span class="keyword">else</span></span><br><span class="line"><span class="number">2146</span>dprintf(CRITICAL, <span class="string">&quot;kaslr-Seed is added to chosen node\n&quot;</span>);</span><br><span class="line"><span class="number">2147</span>&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">2148</span>dprintf(CRITICAL, <span class="string">&quot;ERROR: Cannot generate Kaslr Seed\n&quot;</span>);</span><br><span class="line"><span class="number">2149</span>&#125;</span><br><span class="line"><span class="number">2150</span><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>同样在UEFI下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">609</span>  Status = GetKaslrSeed (&amp;KaslrSeed);</span><br><span class="line"><span class="number">610</span>  <span class="keyword">if</span> (Status == EFI_SUCCESS) &#123;</span><br><span class="line"><span class="number">611</span>    <span class="comment">/* Adding Kaslr Seed to the chosen node */</span></span><br><span class="line"><span class="number">612</span>    ret = fdt_appendprop_u64 (fdt, offset, (CONST <span class="type">char</span> *)<span class="string">&quot;kaslr-seed&quot;</span>,</span><br><span class="line"><span class="number">613</span>                              (UINT64)KaslrSeed);</span><br><span class="line"><span class="number">614</span>    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="number">615</span>      DEBUG ((EFI_D_INFO,</span><br><span class="line"><span class="number">616</span>              <span class="string">&quot;ERROR: Cannot update chosen node [kaslr-seed] - 0x%x\n&quot;</span>, ret));</span><br><span class="line"><span class="number">617</span>    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">618</span>      DEBUG ((EFI_D_VERBOSE, <span class="string">&quot;kaslr-Seed is added to chosen node\n&quot;</span>));</span><br><span class="line"><span class="number">619</span>    &#125;</span><br><span class="line"><span class="number">620</span>  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">621</span>    DEBUG ((EFI_D_INFO, <span class="string">&quot;ERROR: Cannot generate Kaslr Seed - %r\n&quot;</span>, Status));</span><br><span class="line"><span class="number">622</span>  &#125;</span><br></pre></td></tr></table></figure><p>一样一样的。</p><p>btw: arm貌似不支持CONFIG_RANDOMIZE_BASE。</p><p>内核有个参数可以直接disable:</p><blockquote><pre><code>   nokaslr         [KNL]                   When CONFIG_RANDOMIZE_BASE is set, this disables                   kernel and module base offset ASLR (Address Space                   Layout Randomization).</code></pre></blockquote><p>kernel具体实现在arch&#x2F;arm64&#x2F;kernel&#x2F;kaslr.c。</p><p>留意到高通的power code也有处理:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">drivers/power/reset/msm-poweroff.c:261:<span class="comment">#ifdef CONFIG_RANDOMIZE_BASE</span></span><br></pre></td></tr></table></figure><p>我们来看下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RANDOMIZE_BASE</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *kaslr_imem_addr;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">store_kaslr_offset</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        kaslr_imem_addr = map_prop_mem(KASLR_OFFSET_PROP);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kaslr_imem_addr) &#123;</span><br><span class="line">                __raw_writel(<span class="number">0xdead4ead</span>, kaslr_imem_addr);</span><br><span class="line">                __raw_writel(KASLR_OFFSET_BIT_MASK &amp;</span><br><span class="line">                (kimage_vaddr - KIMAGE_VADDR), kaslr_imem_addr + <span class="number">4</span>);</span><br><span class="line">                __raw_writel(KASLR_OFFSET_BIT_MASK &amp;</span><br><span class="line">                        ((kimage_vaddr - KIMAGE_VADDR) &gt;&gt; <span class="number">32</span>),</span><br><span class="line">                        kaslr_imem_addr + <span class="number">8</span>);</span><br><span class="line">                iounmap(kaslr_imem_addr);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存这个地址到imem上：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">kaslr_imem_addr   ---&gt;| 0xdead4ead |</span><br><span class="line">kaslr_imem_addr+4 ---&gt;| (kimage_vaddr - KIMAGE_VADDR).L32 |</span><br><span class="line">kaslr_imem_addr+8 ---&gt;| (kimage_vaddr - KIMAGE_VADDR).H32 |</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KASLR_OFFSET_PROP <span class="string">&quot;qcom,msm-imem-kaslr_offset&quot;</span></span></span><br></pre></td></tr></table></figure><p><code>map_prop_mem()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">map_prop_mem</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *propname)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> of_find_compatible_node(<span class="literal">NULL</span>, <span class="literal">NULL</span>, propname);</span><br><span class="line">        <span class="type">void</span> *addr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!np) &#123;</span><br><span class="line">                pr_err(<span class="string">&quot;Unable to find DT property: %s\n&quot;</span>, propname);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addr = of_iomap(np, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!addr)</span><br><span class="line">                pr_err(<span class="string">&quot;Unable to map memory for DT property: %s\n&quot;</span>, propname);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，找的设备树，好嘛，dt qcom已经放到私有目录了，就不贴了, <code>kaslr_imem_addr</code>地址来源设备树配置。</p><p><code>KIMAGE_VADDR</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PAGE_OFFSET - the virtual address of the start of the linear map (top</span></span><br><span class="line"><span class="comment"> *               (VA_BITS - 1))</span></span><br><span class="line"><span class="comment"> * KIMAGE_VADDR - the virtual address of the start of the kernel image</span></span><br><span class="line"><span class="comment"> * VA_BITS - the maximum number of bits for virtual addresses.</span></span><br><span class="line"><span class="comment"> * VA_START - the first kernel virtual address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VA_BITS                 (CONFIG_ARM64_VA_BITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VA_START                (UL(0xffffffffffffffff) - \</span></span><br><span class="line"><span class="meta">        (UL(1) &lt;&lt; VA_BITS) + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_OFFSET             (UL(0xffffffffffffffff) - \</span></span><br><span class="line"><span class="meta">        (UL(1) &lt;&lt; (VA_BITS - 1)) + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KIMAGE_VADDR            (MODULES_END)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULES_END             (MODULES_VADDR + MODULES_VSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULES_VADDR           (VA_START + KASAN_SHADOW_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULES_VSIZE           (SZ_128M)</span></span><br></pre></td></tr></table></figure><p>可以从这些定义中找出。</p><p><code>kimage_vaddr</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* the virtual base of the kernel image (minus TEXT_OFFSET) */</span></span><br><span class="line"><span class="keyword">extern</span> u64                      kimage_vaddr;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(kimage_vaddr)</span><br><span class="line">        .quad           _text - TEXT_OFFSET</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_START      _text</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_END        _end</span></span><br></pre></td></tr></table></figure><p><code>TEXT_OFFSET</code>：</p><blockquote><p>  Say Y here if you want the image load offset (AKA TEXT_OFFSET)<br>  of the kernel to be randomized at build-time. When selected,</p></blockquote><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The byte offset of the kernel image in RAM from the start of RAM.</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CONFIG_ARM64_RANDOMIZE_TEXT_OFFSET)</span>, y)</span><br><span class="line">TEXT_OFFSET := <span class="variable">$(<span class="built_in">shell</span> awk &quot;BEGIN &#123;srand()</span>; printf \<span class="string">&quot;0x%06x\n\&quot;, \</span></span><br><span class="line"><span class="string"> int(2 * 1024 * 1024 / (2 ^ <span class="variable">$(CONFIG_ARM64_PAGE_SHIFT)</span>) * \</span></span><br><span class="line"><span class="string"> rand()) * (2 ^ <span class="variable">$(CONFIG_ARM64_PAGE_SHIFT)</span>)&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">TEXT_OFFSET := 0x00080000 //tj: here</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>留意一个接口：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">kaslr_offset</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> kimage_vaddr - KIMAGE_VADDR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>panic时会dump这个<code>kaslr_offset()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Dump out kernel offset information on panic.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dump_kernel_offset</span><span class="params">(<span class="keyword">struct</span> notifier_block *self, <span class="type">unsigned</span> <span class="type">long</span> v,</span></span><br><span class="line"><span class="params">                              <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> offset = kaslr_offset();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IS_ENABLED(CONFIG_RANDOMIZE_BASE) &amp;&amp; offset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pr_emerg(<span class="string">&quot;Kernel Offset: 0x%lx from 0x%lx\n&quot;</span>,</span><br><span class="line">                         offset, KIMAGE_VADDR);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pr_emerg(<span class="string">&quot;Kernel Offset: disabled\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>like:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">505.654475:   &lt;6&gt; Kernel Offset: 0x2c28000000 from 0xffffff8008000000</span><br></pre></td></tr></table></figure><p>这个值也存到了QCOM的imem上，QCOM的ramparser会解析，在ramdump.py里：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">determine_kaslr_offset</span>(<span class="params">self</span>):</span><br><span class="line">    self.kaslr_offset = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> self.kaslr_addr <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print_out_str(<span class="string">&#x27;!!!! Kaslr addr is not provided.&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        kaslr_magic = self.read_u32(self.kaslr_addr, <span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> kaslr_magic != <span class="number">0xdead4ead</span>:</span><br><span class="line">            print_out_str(<span class="string">&#x27;!!!! Kaslr magic does not match.&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.kaslr_offset = self.read_u64(self.kaslr_addr + <span class="number">4</span>, <span class="literal">False</span>)</span><br><span class="line">            print_out_str(<span class="string">&quot;The kaslr_offset extracted is: &quot;</span> + <span class="built_in">str</span>(<span class="built_in">hex</span>(self.kaslr_offset))) //tj:here</span><br></pre></td></tr></table></figure><p>从地址<code>self.kaslr_addr + 4</code>读8个字节，可不就是<code>kaslr_offset()</code>嘛:]</p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kaslr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kernel Panic实例分析二:Null pointer</title>
      <link href="/kernel-null-pointer-analysis-2.html"/>
      <url>/kernel-null-pointer-analysis-2.html</url>
      
        <content type="html"><![CDATA[<p>QCOM安卓armv7 smp平台, kernel 4.x。死机时dmesg:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    4.790798] Unable to handle kernel NULL pointer dereference at virtual address 000001e0</span><br><span class="line">[    4.790803] pgd = edfd65c2</span><br><span class="line">[    4.790807] [000001e0] *pgd=00000000</span><br><span class="line">[    4.790813] Internal error: Oops: 5 [#1] PREEMPT SMP ARM</span><br><span class="line">[    4.790817] Modules linked in:</span><br><span class="line">[    4.790822] CPU: 2 PID: 300 Comm: kworker/2:2 Not tainted 4.x</span><br><span class="line">[    4.790838] Workqueue: events monitor_soc_work</span><br><span class="line">[    4.790841] task: 82e93681 task.stack: be01efa9</span><br><span class="line">[    4.790848] PC is at _raw_spin_lock_irqsave+0x30/0x70</span><br><span class="line">[    4.790854] LR is at preempt_count_add+0xa4/0xb8</span><br><span class="line">[    4.790859] pc : [&lt;c10638c8&gt;]    lr : [&lt;c0168194&gt;]    psr: 40000193</span><br><span class="line">[    4.790859] sp : e9707d80  ip : e9707d60  fp : e9707d94</span><br><span class="line">[    4.790861] r10: c1909248  r9 : e9707e48  r8 : 00000000</span><br><span class="line">[    4.790864] r7 : e972d9e4  r6 : 00000020  r5 : 60000113  r4 : 000001e0</span><br><span class="line">[    4.790866] r3 : c1909a68  r2 : 00000001  r1 : 00000000  r0 : 00000000</span><br><span class="line">[    4.790870] Flags: nZcv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment none</span><br><span class="line">[    4.790873] Control: 10c0383d  Table: 8000406a  DAC: 00000051</span><br></pre></td></tr></table></figure><p>QCOM私有的那个分析工具的Call Stacks就看不出来，Red Hat的crash的bt提示不能work：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crash.arm&gt; bt</span><br><span class="line">PID: 300    TASK: e9698e80  CPU: 2   COMMAND: <span class="string">&quot;kworker/2:2&quot;</span></span><br><span class="line">bt: WARNING: cannot determine starting stack frame <span class="keyword">for</span> task e9698e80</span><br></pre></td></tr></table></figure><p>Why? mark to check later.</p><p>用QCOM的ramparser继续check:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parsing CPU2 context start aab41000 end aab41800</span><br><span class="line">Core 2 PC: _raw_spin_lock+4c &lt;c106350c&gt;</span><br><span class="line">Core 2 LR: _raw_spin_lock+20 &lt;c10634e0&gt;</span><br><span class="line"></span><br><span class="line">[&lt;c106350c&gt;] _raw_spin_lock+0x4c</span><br><span class="line">[&lt;c105bfa0&gt;] __schedule+0xc0</span><br><span class="line">[&lt;c105cac0&gt;] schedule+0x58</span><br><span class="line">[&lt;c013794c&gt;] do_exit+0x95c</span><br><span class="line">[&lt;c010ea9c&gt;] die+0x248</span><br><span class="line">[&lt;c0121c90&gt;] __do_kernel_fault.part.0+0x74</span><br><span class="line">[&lt;c1064e6c&gt;] do_page_fault+0x44c</span><br><span class="line">[&lt;c010130c&gt;] do_DataAbort+0x58</span><br><span class="line">[&lt;c10640bc&gt;] __dabt_svc+0x5c</span><br><span class="line">[&lt;c01584dc&gt;] kthread_data+0x18</span><br><span class="line">[&lt;c0151cec&gt;] wq_worker_sleeping+0x18</span><br><span class="line">[&lt;c105c2d4&gt;] __schedule+0x3f4</span><br><span class="line">[&lt;c016fa08&gt;] do_task_dead+0xa4</span><br><span class="line">[&lt;c0137808&gt;] do_exit+0x818</span><br><span class="line">[&lt;c010ea9c&gt;] die+0x248</span><br><span class="line">[&lt;c0121c90&gt;] __do_kernel_fault.part.0+0x74</span><br><span class="line">[&lt;c1064e6c&gt;] do_page_fault+0x44c</span><br><span class="line">[&lt;c1064f88&gt;] do_translation_fault+0x110</span><br><span class="line">[&lt;c010130c&gt;] do_DataAbort+0x58</span><br><span class="line">[&lt;c10640bc&gt;] __dabt_svc+0x5c</span><br><span class="line">[&lt;c10638c8&gt;] _raw_spin_lock_irqsave+0x30</span><br><span class="line">[&lt;c0aee46c&gt;] power_supply_changed+0x3c</span><br><span class="line">[&lt;c0b66510&gt;] qpnp_batt_power_set_property+0xf0</span><br><span class="line">[&lt;c0aee330&gt;] power_supply_set_property+0x34</span><br><span class="line">[&lt;c0b55760&gt;] report_eoc+0x90</span><br><span class="line">[&lt;c0b579d4&gt;] report_vm_bms_soc+0x7c8</span><br><span class="line">[&lt;c0b5a398&gt;] monitor_soc_work+0x708</span><br><span class="line">[&lt;c014f814&gt;] process_one_work+0x184</span><br><span class="line">[&lt;c014fc20&gt;] worker_thread+0x54</span><br><span class="line">[&lt;c0157720&gt;] kthread+0x128</span><br><span class="line">[&lt;c0109774&gt;] ret_from_fork+0x14</span><br></pre></td></tr></table></figure><p>ok, 以上就是panic时call stack。先来看c code:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">113</span><span class="type">void</span> <span class="title function_">power_supply_changed</span><span class="params">(<span class="keyword">struct</span> power_supply *psy)</span></span><br><span class="line">114&#123;</span><br><span class="line"><span class="number">115</span><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="number">116</span></span><br><span class="line"><span class="number">117</span>dev_dbg(&amp;psy-&gt;dev, <span class="string">&quot;%s\n&quot;</span>, __func__);</span><br><span class="line"><span class="number">118</span></span><br><span class="line"><span class="number">119</span>spin_lock_irqsave(&amp;psy-&gt;changed_lock, flags); <span class="comment">//tj: here</span></span><br><span class="line"><span class="number">120</span>psy-&gt;changed = <span class="literal">true</span>;</span><br><span class="line"><span class="number">121</span>pm_stay_awake(&amp;psy-&gt;dev);</span><br><span class="line"><span class="number">122</span>spin_unlock_irqrestore(&amp;psy-&gt;changed_lock, flags);</span><br><span class="line"><span class="number">123</span>schedule_work(&amp;psy-&gt;changed_work);</span><br><span class="line"><span class="number">124</span>&#125;</span><br><span class="line"><span class="number">125</span>EXPORT_SYMBOL_GPL(power_supply_changed);</span><br></pre></td></tr></table></figure><p>看name，好像是死在<code>spin_lock_irqsave()</code>里了。来看看是不是：</p><p><code>spin_lock_irqsave()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">335</span><span class="meta">#<span class="keyword">define</span> spin_lock_irqsave(lock, flags)\</span></span><br><span class="line"><span class="meta">336do &#123;\</span></span><br><span class="line"><span class="meta">337raw_spin_lock_irqsave(spinlock_check(lock), flags);\</span></span><br><span class="line"><span class="meta">338&#125; while (0)</span></span><br></pre></td></tr></table></figure><p><code>spinlock_check()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">289</span><span class="type">static</span> __always_inline <span class="type">raw_spinlock_t</span> *<span class="title function_">spinlock_check</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">290&#123;</span><br><span class="line"><span class="number">291</span><span class="keyword">return</span> &amp;lock-&gt;rlock;</span><br><span class="line"><span class="number">292</span>&#125;</span><br></pre></td></tr></table></figure><p><code>raw_spin_lock_irqsave()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">203</span><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)</span></span><br><span class="line"><span class="number">204</span></span><br><span class="line"><span class="number">205</span><span class="meta">#<span class="keyword">define</span> raw_spin_lock_irqsave(lock, flags)\</span></span><br><span class="line"><span class="meta">206do &#123;\</span></span><br><span class="line"><span class="meta">207typecheck(unsigned long, flags);\</span></span><br><span class="line"><span class="meta">208flags = _raw_spin_lock_irqsave(lock);\</span></span><br><span class="line"><span class="meta">209&#125; while (0)</span></span><br></pre></td></tr></table></figure><p><code>_raw_spin_lock_irqsave()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">156</span><span class="meta">#<span class="keyword">ifndef</span> CONFIG_INLINE_SPIN_LOCK_IRQSAVE</span></span><br><span class="line"><span class="number">157u</span>nsigned <span class="type">long</span> __lockfunc _raw_spin_lock_irqsave(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line"><span class="number">158</span>&#123;</span><br><span class="line"><span class="number">159</span><span class="keyword">return</span> __raw_spin_lock_irqsave(lock);</span><br><span class="line"><span class="number">160</span>&#125;</span><br><span class="line"><span class="number">161</span>EXPORT_SYMBOL(_raw_spin_lock_irqsave);</span><br><span class="line"><span class="number">162</span><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>ps: <code>CONFIG_INLINE_SPIN_LOCK_IRQSAVE</code>未配置。</p><p>ok，<code>_raw_spin_lock_irqsave</code>出现了，正如我们预料的。继续看：</p><p><code>__raw_spin_lock_irqsave()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If lockdep is enabled then we use the non-preemption spin-ops</span></span><br><span class="line"><span class="comment"> * even on CONFIG_PREEMPT, because lockdep assumes that interrupts are</span></span><br><span class="line"><span class="comment"> * not re-enabled during lock-acquire (which the preempt-spin-ops do):</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_GENERIC_LOCKBREAK) || defined(CONFIG_DEBUG_LOCK_ALLOC)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> __raw_spin_lock_irqsave(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">        local_irq_save(flags);</span><br><span class="line">        preempt_disable();</span><br><span class="line">        spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * On lockdep we dont want the hand-coded irq-enable of</span></span><br><span class="line"><span class="comment">         * do_raw_spin_lock_flags() code, because lockdep assumes</span></span><br><span class="line"><span class="comment">         * that interrupts are not re-enabled during lock-acquire:</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">        LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        do_raw_spin_lock_flags(lock, &amp;flags);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok。我们来看死机现场asm code:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    4.790848] PC is at _raw_spin_lock_irqsave+0x30/0x70</span><br><span class="line">...</span><br><span class="line">[    4.790859] pc : [&lt;c10638c8&gt;]  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;c10638c8&gt;] _raw_spin_lock_irqsave+0x30</span><br></pre></td></tr></table></figure><p>不用objdump整个vmlinux，这时crash就派上用场了，直接dis就可以：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crash.arm&gt; dis _raw_spin_lock_irqsave</span><br><span class="line">0xc1063898 &lt;_raw_spin_lock_irqsave&gt;:    mov     r12, sp</span><br><span class="line">0xc106389c &lt;_raw_spin_lock_irqsave+4&gt;:  push    &#123;r4, r5, r11, r12, lr, pc&#125;</span><br><span class="line">0xc10638a0 &lt;_raw_spin_lock_irqsave+8&gt;:  sub     r11, r12, #4</span><br><span class="line">0xc10638a4 &lt;_raw_spin_lock_irqsave+12&gt;: push    &#123;lr&#125;            ; (str lr, [sp, #-4]!)</span><br><span class="line">0xc10638a8 &lt;_raw_spin_lock_irqsave+16&gt;: ldmfd   sp!, &#123;lr&#125;</span><br><span class="line">0xc10638ac &lt;_raw_spin_lock_irqsave+20&gt;: mov     r4, r0</span><br><span class="line">0xc10638b0 &lt;_raw_spin_lock_irqsave+24&gt;: mrs     r5, CPSR</span><br><span class="line">0xc10638b4 &lt;_raw_spin_lock_irqsave+28&gt;: cpsid   i</span><br><span class="line">0xc10638b8 &lt;_raw_spin_lock_irqsave+32&gt;: bl      0xc0239fe0 &lt;trace_hardirqs_off&gt;</span><br><span class="line">0xc10638bc &lt;_raw_spin_lock_irqsave+36&gt;: mov     r0, #1</span><br><span class="line">0xc10638c0 &lt;_raw_spin_lock_irqsave+40&gt;: bl      0xc01680f0 &lt;preempt_count_add&gt;</span><br><span class="line">0xc10638c4 &lt;_raw_spin_lock_irqsave+44&gt;: pldw    [r4]</span><br><span class="line">0xc10638c8 &lt;_raw_spin_lock_irqsave+48&gt;: ldrex   r3, [r4] //tj: pc</span><br><span class="line">0xc10638cc &lt;_raw_spin_lock_irqsave+52&gt;: add     r2, r3, #65536  ; 0x10000</span><br><span class="line">0xc10638d0 &lt;_raw_spin_lock_irqsave+56&gt;: strex   r1, r2, [r4]</span><br><span class="line">0xc10638d4 &lt;_raw_spin_lock_irqsave+60&gt;: teq     r1, #0</span><br><span class="line">0xc10638d8 &lt;_raw_spin_lock_irqsave+64&gt;: bne     0xc10638c8 &lt;_raw_spin_lock_irqsave+48&gt;</span><br><span class="line">0xc10638dc &lt;_raw_spin_lock_irqsave+68&gt;: lsr     r2, r3, #16</span><br><span class="line">0xc10638e0 &lt;_raw_spin_lock_irqsave+72&gt;: uxth    r3, r3</span><br><span class="line">0xc10638e4 &lt;_raw_spin_lock_irqsave+76&gt;: cmp     r2, r3</span><br><span class="line">0xc10638e8 &lt;_raw_spin_lock_irqsave+80&gt;: beq     0xc10638fc &lt;_raw_spin_lock_irqsave+100&gt;</span><br><span class="line">0xc10638ec &lt;_raw_spin_lock_irqsave+84&gt;: wfe</span><br><span class="line">0xc10638f0 &lt;_raw_spin_lock_irqsave+88&gt;: ldrh    r3, [r4]</span><br><span class="line">0xc10638f4 &lt;_raw_spin_lock_irqsave+92&gt;: cmp     r2, r3</span><br><span class="line">0xc10638f8 &lt;_raw_spin_lock_irqsave+96&gt;: bne     0xc10638ec &lt;_raw_spin_lock_irqsave+84&gt;</span><br><span class="line">0xc10638fc &lt;_raw_spin_lock_irqsave+100&gt;:        dmb     ish</span><br><span class="line">0xc1063900 &lt;_raw_spin_lock_irqsave+104&gt;:        mov     r0, r5</span><br><span class="line">0xc1063904 &lt;_raw_spin_lock_irqsave+108&gt;:        ldm     sp, &#123;r4, r5, r11, sp, pc&#125;</span><br><span class="line">crash.arm&gt;</span><br></pre></td></tr></table></figure><p>pc:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xc10638c8 &lt;_raw_spin_lock_irqsave+48&gt;: ldrex   r3, [r4] //tj: pc</span><br></pre></td></tr></table></figure><p>现场r4是:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r4 : 000001e0</span><br></pre></td></tr></table></figure><p>r4就来源r0：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xc10638ac &lt;_raw_spin_lock_irqsave+20&gt;: mov     r4, r0</span><br></pre></td></tr></table></figure><p>r0就是<code>_raw_spin_lock_irqsave()</code>的入参喽。前面看过c code了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">157u</span>nsigned <span class="type">long</span> __lockfunc _raw_spin_lock_irqsave(<span class="type">raw_spinlock_t</span> *lock)</span><br></pre></td></tr></table></figure><p>这个<code>lock</code>是000001e0？ 不是<code>[    4.790798] Unable to handle kernel NULL pointer dereference at virtual address 000001e0</code>吗？哪里有0?</p><p>看下<code>NULL pointer</code>由来：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">131</span><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="number">132</span>__do_kernel_fault(<span class="keyword">struct</span> mm_struct *mm, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">int</span> fsr,</span><br><span class="line"><span class="number">133</span>  <span class="keyword">struct</span> pt_regs *regs)</span><br><span class="line"><span class="number">134</span>&#123;</span><br><span class="line"><span class="number">135</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">136 * Are we prepared to handle this kernel fault?</span></span><br><span class="line"><span class="comment">137 */</span></span><br><span class="line"><span class="number">138</span><span class="keyword">if</span> (fixup_exception(regs))</span><br><span class="line"><span class="number">139</span><span class="keyword">return</span>;</span><br><span class="line"><span class="number">140</span></span><br><span class="line"><span class="number">141</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">142 * No handler, we&#x27;ll have to terminate things with extreme prejudice.</span></span><br><span class="line"><span class="comment">143 */</span></span><br><span class="line"><span class="number">144</span>bust_spinlocks(<span class="number">1</span>);</span><br><span class="line"><span class="number">145</span>pr_alert(<span class="string">&quot;Unable to handle kernel %s at virtual address %08lx\n&quot;</span>,</span><br><span class="line"><span class="number">146</span> (addr &lt; PAGE_SIZE) ? <span class="string">&quot;NULL pointer dereference&quot;</span> :</span><br><span class="line"><span class="number">147</span> <span class="string">&quot;paging request&quot;</span>, addr);</span><br></pre></td></tr></table></figure><p>好嘛，只要<code>addr &lt; PAGE_SIZE</code>就是<code>NULL pointer</code>了。那<code>_raw_spin_lock_irqsave(raw_spinlock_t *lock)</code>入参<code>lock</code>是不是000001e0？继续分析:</p><p>这个<code>lock</code>来源：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">335</span><span class="meta">#<span class="keyword">define</span> spin_lock_irqsave(lock, flags)\</span></span><br><span class="line"><span class="meta">336do &#123;\</span></span><br><span class="line"><span class="meta">337raw_spin_lock_irqsave(spinlock_check(lock), flags);\</span></span><br><span class="line"><span class="meta">338&#125; while (0)</span></span><br></pre></td></tr></table></figure><p><code>spinlock_check</code>的反汇编check下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crash.arm&gt; dis spinlock_check</span><br><span class="line">symbol not found: spinlock_check</span><br><span class="line">possible alternatives:</span><br><span class="line">  (none found)</span><br></pre></td></tr></table></figure><p>应该是inline的原因：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">289</span><span class="type">static</span> __always_inline <span class="type">raw_spinlock_t</span> *<span class="title function_">spinlock_check</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">290&#123;</span><br><span class="line"><span class="number">291</span><span class="keyword">return</span> &amp;lock-&gt;rlock;</span><br><span class="line"><span class="number">292</span>&#125;</span><br></pre></td></tr></table></figure><p>spinlock_t结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br></pre></td></tr></table></figure><p>继续看caller：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">113</span><span class="type">void</span> <span class="title function_">power_supply_changed</span><span class="params">(<span class="keyword">struct</span> power_supply *psy)</span></span><br><span class="line">114&#123;</span><br><span class="line"><span class="number">115</span><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="number">116</span></span><br><span class="line"><span class="number">117</span>dev_dbg(&amp;psy-&gt;dev, <span class="string">&quot;%s\n&quot;</span>, __func__);</span><br><span class="line"><span class="number">118</span></span><br><span class="line"><span class="number">119</span>spin_lock_irqsave(&amp;psy-&gt;changed_lock, flags); <span class="comment">//tj: here</span></span><br></pre></td></tr></table></figure><p>so，这里的<code>&amp;psy-&gt;changed_lock</code>是000001e0吗？ 继续反汇编分析：</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> panic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to build Red Hat Crash for ARM under x86_64 Ubuntu</title>
      <link href="/how-to-build-redhat-crash-for-arm-under-x86_64-ubuntu.html"/>
      <url>/how-to-build-redhat-crash-for-arm-under-x86_64-ubuntu.html</url>
      
        <content type="html"><![CDATA[<p>Now, our building environments for Android are almost x86_64 Ubuntu, but we still have low-end products based on armv7 kernel. For analyze ramdump under armv7, let’s build it on Ubuntu 18.04 (should be same for others).</p><h2 id="Step0-install-essential-build-tools"><a href="#Step0-install-essential-build-tools" class="headerlink" title="Step0: install essential build tools"></a>Step0: install essential build tools</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure><h2 id="Step1-download-crash-source-code"><a href="#Step1-download-crash-source-code" class="headerlink" title="Step1: download crash source code"></a>Step1: download crash source code</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span>  https://github.com/crash-utility/crash.git</span><br></pre></td></tr></table></figure><h2 id="Step2-make-for-ARM"><a href="#Step2-make-for-ARM" class="headerlink" title="Step2: make for ARM"></a>Step2: make for ARM</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make target=ARM</span><br></pre></td></tr></table></figure><p>note that:</p><ul><li>it’s not cross compiling, we will use the crash tool in current enviroment(x86_64).</li><li>we will get gdb-7.6.tar.gz after this step</li></ul><h2 id="Step3-install-related-libraries"><a href="#Step3-install-related-libraries" class="headerlink" title="Step3: install related libraries"></a>Step3: install related libraries</h2><h3 id="install-termcap-library"><a href="#install-termcap-library" class="headerlink" title="install termcap library"></a>install termcap library</h3><p>met below error:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">configure: error: no termcap library found</span><br></pre></td></tr></table></figure><p>download termcap-1.3.1.tar.gz from <a href="https://ftp.gnu.org/gnu/termcap/">https://ftp.gnu.org/gnu/termcap/</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="install-gcc-multilib"><a href="#install-gcc-multilib" class="headerlink" title="install gcc-multilib"></a>install gcc-multilib</h3><p>met below errors:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-linux-gnu/7/libgcc.a when searching <span class="keyword">for</span> -lgcc</span><br><span class="line">/usr/bin/ld: cannot find -lgcc</span><br><span class="line">/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-linux-gnu/7/libgcc_s.so.1 when searching <span class="keyword">for</span> libgcc_s.so.1</span><br><span class="line">/usr/bin/ld: cannot find libgcc_s.so.1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gcc-multilib</span><br></pre></td></tr></table></figure><h3 id="install-lib32ncurses5-dev"><a href="#install-lib32ncurses5-dev" class="headerlink" title="install lib32ncurses5-dev"></a>install lib32ncurses5-dev</h3><p>met below error:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: cannot find libncurses.so.5</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install lib32ncurses5-dev </span><br></pre></td></tr></table></figure><h3 id="install-lib32z1-dev"><a href="#install-lib32z1-dev" class="headerlink" title="install lib32z1-dev"></a>install lib32z1-dev</h3><p>met below errors:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: skipping incompatible //usr/lib/x86_64-linux-gnu/libz.so when searching for -lz</span><br><span class="line">/usr/bin/ld: skipping incompatible //usr/lib/x86_64-linux-gnu/libz.a when searching for -lz</span><br><span class="line">/usr/bin/ld: cannot find -lz</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install lib32z1-dev</span><br></pre></td></tr></table></figure><h2 id="Step4-check-crash"><a href="#Step4-check-crash" class="headerlink" title="Step4: check crash"></a>Step4: check crash</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@tj-X230:~/tools/crash$ ./crash --version</span><br><span class="line"></span><br><span class="line">crash 7.2.8++</span><br><span class="line">Copyright (C) 2002-2020  Red Hat, Inc.</span><br><span class="line">Copyright (C) 2004, 2005, 2006, 2010  IBM Corporation</span><br><span class="line">Copyright (C) 1999-2006  Hewlett-Packard Co</span><br><span class="line">Copyright (C) 2005, 2006, 2011, 2012  Fujitsu Limited</span><br><span class="line">Copyright (C) 2006, 2007  VA Linux Systems Japan K.K.</span><br><span class="line">Copyright (C) 2005, 2011  NEC Corporation</span><br><span class="line">Copyright (C) 1999, 2002, 2007  Silicon Graphics, Inc.</span><br><span class="line">Copyright (C) 1999, 2000, 2001, 2002  Mission Critical Linux, Inc.</span><br><span class="line">This program is free software, covered by the GNU General Public License,</span><br><span class="line">and you are welcome to change it and/or distribute copies of it under</span><br><span class="line">certain conditions.  Enter <span class="string">&quot;help copying&quot;</span> to see the conditions.</span><br><span class="line">This program has absolutely no warranty.  Enter <span class="string">&quot;help warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line"> </span><br><span class="line">GNU gdb (GDB) 7.6</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">&quot;show copying&quot;</span></span><br><span class="line">and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;--host=x86_64-unknown-linux-gnu --target=arm-elf-linux&quot;</span>.</span><br></pre></td></tr></table></figure><p>We can see <code>This GDB was configured as &quot;--host=x86_64-unknown-linux-gnu --target=arm-elf-linux&quot;.</code></p><p>The <code>--host</code> means the crash tool is used on.</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解Android 10 DSU</title>
      <link href="/understand-dsu-in-android10.html"/>
      <url>/understand-dsu-in-android10.html</url>
      
        <content type="html"><![CDATA[<p>DSU(Dynamic System Updates)是Android 10引入的一个feature。先了解下GSI。</p><h2 id="GSI"><a href="#GSI" class="headerlink" title="GSI"></a>GSI</h2><p>GSI(Generic System Image)看字面就是通用的系统镜像了，就是Google官方Android，没有设备制造商(如某米)的自定义修改。</p><p>Android 9开始就能用了，是for app开发。官方给的说明是：</p><blockquote><p>The GSI project helps improve the Android ecosystem by providing more ways to improve app and OS quality before the next release of the OS. </p></blockquote><p>改善生态！9上使用还有两个条件：</p><ol><li>Bootloader要解锁 </li><li>Fully Treble-compliant</li></ol><p>要unlock bootloader? Google提供了GSI image下载方法，安装方法可以手动刷(flashing) or via DSU。Treble-compliant是啥？</p><h2 id="Project-Treble"><a href="#Project-Treble" class="headerlink" title="Project Treble"></a>Project Treble</h2><p>就是Android 8.0 re-architected the Android OS framework。</p><blockquote><p>On the Android team, we view each dessert release as an opportunity to make Android better for our users and our ecosystem partners. One thing we’ve consistently heard from our device-maker partners is that updating existing devices to a new version of Android is incredibly time consuming and costly.</p><p>With Android O, we’ve been working very closely with device makers and silicon manufacturers to take steps toward solving this problem, and we’re excited to give you a sneak peek at Project Treble, the biggest change to the low-level system architecture of Android to date.</p></blockquote><p>加速设备(米啊，OV啊。。)更新新系统。在系统实现上就是OS framework不要依赖vendor，模块化Android。so，官方blog给treble的另一个定义就是：</p><blockquote><p>A modular base for Android</p></blockquote><h2 id="DSU"><a href="#DSU" class="headerlink" title="DSU"></a>DSU</h2><p>顾名思义，是系统更新了，还是动态的。这里的更新是更新的GSI image。动态是说不干扰当前运行系统，你不喜欢可以切回原系统。依赖动态分区(super分区)。</p><p>DSU方式安装GSI不用解锁bootloader，更方便些。</p><h2 id="multiple-DSU-partitions"><a href="#multiple-DSU-partitions" class="headerlink" title="multiple DSU partitions"></a>multiple DSU partitions</h2><p>一开始DSU仅仅for Google GSI，那厂商的img也要做DSU怎么办？so:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The idea is to allow OEMs install OTA packages on /data, then using &quot;DSU&quot; [1] flow to mount product.img, system.img, vendor.img from /data.</span><br><span class="line"></span><br><span class="line">After using it for a while, the user can decide if they want to &quot;commit&quot; those images to /super or not.</span><br><span class="line"></span><br><span class="line">Note that currently DSU is exclusive for GSI.</span><br><span class="line">However, this change allows DSU to boot either GSI or OEM system.img, product.img, vendor.img, etc.</span><br></pre></td></tr></table></figure><p>既然有generic system(GSI)，那也应该有generic kernel(kernel.org&#x2F;GKI)? 有的哈，后面看。</p><p>kernel的修改path:</p><p>upsteam kernel (kernel.org) -&gt; AOSP kernel -&gt; vendor kernel(like QCOM&#x2F;MTK…) -&gt; OEM&#x2F;device custom kernel (like mi, OV…)</p><h2 id="refer-doc"><a href="#refer-doc" class="headerlink" title="refer doc"></a>refer doc</h2><ul><li><a href="https://source.android.com/devices/architecture">https://source.android.com/devices/architecture</a></li><li><a href="https://developer.android.com/topic/dsu">https://developer.android.com/topic/dsu</a></li><li><a href="https://android-developers.googleblog.com/2017/05/here-comes-treble-modular-base-for.html">https://android-developers.googleblog.com/2017/05/here-comes-treble-modular-base-for.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UFS FFU 实践</title>
      <link href="/ufs-ffu-example.html"/>
      <url>/ufs-ffu-example.html</url>
      
        <content type="html"><![CDATA[<p>前文提到ufs-utils这个工具可以做UFS FFU，我们先看这个工具的使用。</p><h2 id="ufs-util"><a href="#ufs-util" class="headerlink" title="ufs-util"></a>ufs-util</h2><p>Android自带的aarch64貌似编译有问题，换个工具编译ok，ffu怎么用了？</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ufs-utils ffu --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"> FFU <span class="built_in">command</span> usage:</span><br><span class="line"></span><br><span class="line">        ufs-utils ffu [-t] &lt;ffu cmd idn&gt; [-p] &lt;path to device&gt;?</span><br><span class="line"></span><br><span class="line">        -t       FFU cmd idn</span><br><span class="line">                         0  : FFU, flash FFU</span><br><span class="line">                         1  : Check FFU status (check FFU status attribute and display FW version)</span><br><span class="line"></span><br><span class="line">        -s       Max chunk size <span class="keyword">in</span> KB alignment to 4KB, <span class="built_in">which</span> FFU file will be <span class="built_in">split</span> (optional)</span><br><span class="line"></span><br><span class="line">        -w       path to FFU file</span><br><span class="line"></span><br><span class="line">        -g       sg struct ver - 0: SG_IO_VER4 (default), 1: SG_IO_VER3</span><br><span class="line"></span><br><span class="line">        -p       bsg device path <span class="keyword">for</span> FFU, ufs-bsg <span class="keyword">for</span> Check FFU status</span><br></pre></td></tr></table></figure><p><code>-p</code>的bsg device path就是前面提到的&#x2F;dev&#x2F;0:0:0:0(sg v4) or &#x2F;dev&#x2F;block&#x2F;sda(sg v3)。</p><p>usf-bsg用于Check FFU status，device是&#x2F;dev&#x2F;ufs-bsg。</p><p>what is ufs bsg? 看文档：</p><blockquote><ol start="4"><li><h1 id="BSG-Support"><a href="#BSG-Support" class="headerlink" title="BSG Support"></a>BSG Support</h1></li></ol><p>This transport driver supports exchanging UFS protocol information units<br>(UPIUs) with a UFS device. Typically, user space will allocate<br>struct ufs_bsg_request and struct ufs_bsg_reply (see ufs_bsg.h) as<br>request_upiu and reply_upiu respectively.  Filling those UPIUs should<br>be done in accordance with JEDEC spec UFS2.1 paragraph 10.7.<br><em>Caveat emptor</em>: The driver makes no further input validations and sends the<br>UPIU to the device as it is.  Open the bsg device in &#x2F;dev&#x2F;ufs-bsg and<br>send SG_IO with the applicable sg_io_v4::</p><pre><code>   io_hdr_v4.guard = &#39;Q&#39;;   io_hdr_v4.protocol = BSG_PROTOCOL_SCSI;   io_hdr_v4.subprotocol = BSG_SUB_PROTOCOL_SCSI_TRANSPORT;   io_hdr_v4.response = (__u64)reply_upiu;   io_hdr_v4.max_response_len = reply_len;   io_hdr_v4.request_len = request_len;   io_hdr_v4.request = (__u64)request_upiu;   if (dir == SG_DXFER_TO_DEV) &#123;           io_hdr_v4.dout_xfer_len = (uint32_t)byte_cnt;           io_hdr_v4.dout_xferp = (uintptr_t)(__u64)buff;   &#125; else &#123;           io_hdr_v4.din_xfer_len = (uint32_t)byte_cnt;           io_hdr_v4.din_xferp = (uintptr_t)(__u64)buff;   &#125;</code></pre></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config SCSI_UFS_BSG</span><br><span class="line">        bool &quot;Universal Flash Storage BSG device node&quot;</span><br><span class="line">        depends on SCSI_UFSHCD</span><br><span class="line">        select BLK_DEV_BSGLIB</span><br><span class="line">        help</span><br><span class="line">          Universal Flash Storage (UFS) is SCSI transport specification for</span><br><span class="line">          accessing flash storage on digital cameras, mobile phones and</span><br><span class="line">          consumer electronic devices.</span><br><span class="line">          A UFS controller communicates with a UFS device by exchanging</span><br><span class="line">          UFS Protocol Information Units (UPIUs).</span><br><span class="line">          UPIUs can not only be used as a transport layer for the SCSI protocol</span><br><span class="line">          but are also used by the UFS native command set.</span><br><span class="line">          This transport driver supports exchanging UFS protocol information units</span><br><span class="line">          with a UFS device. See also the ufshcd driver, which is a SCSI driver</span><br><span class="line">          that supports UFS devices.</span><br><span class="line"></span><br><span class="line">          Select this if you need a bsg device node for your UFS controller.</span><br><span class="line">          If unsure, say N.</span><br></pre></td></tr></table></figure><p>重点是<code>UPIUs are also used by the UFS native command set</code>。</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ufshcd-core-<span class="variable">$(CONFIG_SCSI_UFS_BSG)</span>   += ufs_bsg.o</span><br></pre></td></tr></table></figure><p>code是<code>driver\scsi\ufs\ufs_bsg.c</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bsg endpoint that supports UPIUs</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2018 Western Digital Corporation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ufs_bsg.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>当前QCOM低内核还不支持ufs bsg，我从5.x port过来可以用了，有些接口小冲突需要fix。</p><p>不过drv有对应属性是:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UFS_ATTRIBUTE(ffu_status, _FFU_STATUS);</span><br></pre></td></tr></table></figure><p>sysfs在：</p><blockquote><p>What:           &#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers&#x2F;ufshcd&#x2F;*&#x2F;attributes&#x2F;ffu_status<br>Date:           February 2018<br>Contact:        Stanislav Nijnikov <a href="mailto:&#115;&#x74;&#x61;&#110;&#x69;&#115;&#108;&#97;&#x76;&#x2e;&#x6e;&#x69;&#106;&#110;&#105;&#107;&#x6f;&#x76;&#64;&#119;&#x64;&#99;&#x2e;&#x63;&#111;&#x6d;">&#115;&#x74;&#x61;&#110;&#x69;&#115;&#108;&#97;&#x76;&#x2e;&#x6e;&#x69;&#106;&#110;&#105;&#107;&#x6f;&#x76;&#64;&#119;&#x64;&#99;&#x2e;&#x63;&#111;&#x6d;</a><br>Description:    This file provides the ffu status UFS device attribute.<br>                The full information about the attribute could be found at<br>                UFS specifications 2.1.<br>                The file is read only.</p></blockquote><p>ufs spec的定义：</p><p><img src="http://tjtech.me/usr/uploads/2020/09/857586476.png" alt="ffu-status.png"></p><blockquote><p>The column “MDV” (Manufacturer Default Value) specifies atrribute values after device manufacturing</p></blockquote><p>就是出厂值是0了，升级成功是1。</p><p>ok，QCOM平台直接使用如下命令升级(固件升级文件是xxx.bin)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ufs-utils ffu -t 0 -w xxx.bin -p /dev/block/sda</span><br></pre></td></tr></table></figure><p>nm，报错了，一下心哇凉哇凉的:</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Start : write_buffer mode 14 , buf_id 0</span><br><span class="line">Start : send_scsi_cmd cmd = 3b len 262144 sg_type 0</span><br><span class="line"></span><br><span class="line">writing file scsi_cmd_cdb_1.bin length=10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Err: Command fail with status 1 , senseKey Miscompare</span><br><span class="line"></span><br><span class="line"> Err: SG_IO WRITE BUFFER data error ret -22</span><br><span class="line"></span><br><span class="line"> Err: Write error -22:</span><br></pre></td></tr></table></figure><p>工具默认没开debug，打开即可:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-<span class="comment">#CXXFLAGS = -DDEBUG</span></span><br><span class="line">+CXXFLAGS = -DDEBUG</span><br></pre></td></tr></table></figure><p><code>senseKey Miscompare</code>是啥意思？我们先看工具code：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* description of the sense key values */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> snstext[] = &#123;</span><br><span class="line">        <span class="string">&quot;No Sense&quot;</span>,         <span class="comment">/* 0: There is no sense information */</span></span><br><span class="line">        <span class="string">&quot;Recovered Error&quot;</span>,  <span class="comment">/* 1: The last command completed successfully</span></span><br><span class="line"><span class="comment">                                  but used error correction */</span></span><br><span class="line">        <span class="string">&quot;Not Ready&quot;</span>,        <span class="comment">/* 2: The addressed target is not ready */</span></span><br><span class="line">        <span class="string">&quot;Medium Error&quot;</span>,     <span class="comment">/* 3: Data error detected on the medium */</span></span><br><span class="line">        <span class="string">&quot;Hardware Error&quot;</span>,   <span class="comment">/* 4: Controller or device failure */</span></span><br><span class="line">        <span class="string">&quot;Illegal Request&quot;</span>,  <span class="comment">/* 5: Error in request */</span></span><br><span class="line">        <span class="string">&quot;Unit Attention&quot;</span>,   <span class="comment">/* 6: Removable medium was changed, or</span></span><br><span class="line"><span class="comment">                                  the target has been reset, or ... */</span></span><br><span class="line">        <span class="string">&quot;Data Protect&quot;</span>,     <span class="comment">/* 7: Access to the data is blocked */</span></span><br><span class="line">        <span class="string">&quot;Blank Check&quot;</span>,      <span class="comment">/* 8: Reached unexpected written or unwritten</span></span><br><span class="line"><span class="comment">                                  region of the medium */</span></span><br><span class="line">        <span class="string">&quot;Vendor Specific&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Copy Aborted&quot;</span>,     <span class="comment">/* A: COPY or COMPARE was aborted */</span></span><br><span class="line">        <span class="string">&quot;Aborted Command&quot;</span>,  <span class="comment">/* B: The target aborted the command */</span></span><br><span class="line">        <span class="string">&quot;Equal&quot;</span>,            <span class="comment">/* C: A SEARCH DATA command found data equal */</span></span><br><span class="line">        <span class="string">&quot;Volume Overflow&quot;</span>,  <span class="comment">/* D: Medium full with still data to be written */</span></span><br><span class="line">        <span class="string">&quot;Miscompare&quot;</span>,       <span class="comment">/* E: Source data and data on the medium</span></span><br><span class="line"><span class="comment">                                  do not agree */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * send_scsi_cmd - Utility function for SCSI command sending</span></span><br><span class="line"><span class="comment"> * @fd: bsg driver file descriptor</span></span><br><span class="line"><span class="comment"> * @cdb: pointer to SCSI cmd cdb buffer</span></span><br><span class="line"><span class="comment"> * @buf: pointer to the SCSI cmd data buffer</span></span><br><span class="line"><span class="comment"> * @cmd_len: SCSI command length</span></span><br><span class="line"><span class="comment"> * @byte_cnt: SCSI data length</span></span><br><span class="line"><span class="comment"> * @dir: The cmd direction</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">send_scsi_cmd</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> __u8 *cdb, <span class="type">void</span> *buf, __u8 cmd_len,</span></span><br><span class="line"><span class="params">                __u32 byte_cnt, <span class="type">int</span> dir, __u8 sg_type)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                io_hdr_v3.interface_id = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">                io_hdr_v3.cmd_len = cmd_len;</span><br><span class="line">                io_hdr_v3.mx_sb_len = SENSE_BUFF_LEN;</span><br><span class="line">                io_hdr_v3.dxfer_direction = dir;</span><br><span class="line">                io_hdr_v3.dxfer_len = byte_cnt;</span><br><span class="line">                io_hdr_v3.dxferp = buf;</span><br><span class="line">                <span class="comment">/* pointer to command buf (rbufCmdBlk) */</span></span><br><span class="line">                io_hdr_v3.cmdp = (<span class="type">unsigned</span> <span class="type">char</span> *)cdb;</span><br><span class="line">                io_hdr_v3.sbp = sense_buffer; <span class="comment">//tj: here</span></span><br><span class="line">                io_hdr_v3.timeout = DEF_TIMEOUT_MSEC;</span><br><span class="line">                sg_struct = &amp;io_hdr_v3;</span><br><span class="line">        &#125;</span><br><span class="line">        WRITE_LOG(<span class="string">&quot;Start : %s cmd = %x len %d sg_type %d\n&quot;</span>, __func__, cdb[<span class="number">0</span>],</span><br><span class="line">                        byte_cnt, sg_type);</span><br><span class="line"></span><br><span class="line">        write_file_with_counter(<span class="string">&quot;scsi_cmd_cdb_%d.bin&quot;</span>,</span><br><span class="line">                        cdb, cmd_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (((ret = ioctl(fd, SG_IO, sg_struct)) &lt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                ((errno == EINTR) || (errno == EAGAIN)));</span><br><span class="line">        <span class="keyword">if</span> (sg_type == SG4_TYPE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (io_hdr_v4.info != <span class="number">0</span>) &#123;</span><br><span class="line">                        print_error(<span class="string">&quot;Command fail with status %x , senseKey %s&quot;</span>,</span><br><span class="line">                                io_hdr_v4.info,</span><br><span class="line">                                sense_key_string(sense_buffer[<span class="number">2</span>]));</span><br><span class="line">                        ret = -EINVAL;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (io_hdr_v3.status) &#123;</span><br><span class="line">                        print_error(<span class="string">&quot;Command fail with status %x , senseKey %s&quot;</span>,</span><br><span class="line">                                io_hdr_v3.status,</span><br><span class="line">                                sense_key_string(sense_buffer[<span class="number">2</span>]));</span><br><span class="line">                        ret = -EINVAL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用的是v3，<code>io_hdr_v3.status</code>是1，ioctl cmd是<code>SG_IO</code>。</p><p>看下v3 interface:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SCSI Generic v3 struct copied from include/scsi/sg.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sg_io_hdr</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> interface_id;           <span class="comment">/* [i] &#x27;S&#x27; for SCSI generic (required) */</span></span><br><span class="line">        <span class="type">int</span> dxfer_direction;        <span class="comment">/* [i] data transfer direction  */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> cmd_len;      <span class="comment">/* [i] SCSI command length ( &lt;= 16 bytes) */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> mx_sb_len;    <span class="comment">/* [i] max length to write to sbp */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iovec_count; <span class="comment">/* [i] 0 implies no scatter gather */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> dxfer_len;     <span class="comment">/* [i] byte count of data transfer */</span></span><br><span class="line">        <span class="type">void</span> *dxferp;              <span class="comment">/* [i], [*io] points to data transfer memory</span></span><br><span class="line"><span class="comment">                                 or scatter gather list */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *cmdp;       <span class="comment">/* [i], [*i] points to command to perform */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *sbp;        <span class="comment">/* [i], [*o] points to sense_buffer memory */</span> <span class="comment">//tj:here</span></span><br></pre></td></tr></table></figure><p><code>sbp</code>就是响应了，看样子是写进去了，怎么会不匹配，拍了拍脑袋想了想改了改代码居然可以了，容我慢慢道来:)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FFU was written to the device, reboot and check status</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SCSI generic(sg) overview</title>
      <link href="/scsi-generic-overview.html"/>
      <url>/scsi-generic-overview.html</url>
      
        <content type="html"><![CDATA[<p>UFS固件升级来袭，QCOM&#x2F;UEFI平台都懂的，发现西数提供一个工具叫ufs-utils，里面提到了FFU：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">The following options may work with the SCSI BSG device</span><br><span class="line">using sg v4 structure (e.g. /dev/0:0:0:0)</span><br><span class="line">or via a SCSI Generic interface using sg v3 struct (e.g. /dev/block/sda)</span><br><span class="line">d) Error History</span><br><span class="line">e) FFU - Field Firmware Update</span><br></pre></td></tr></table></figure><p>What is sg v4? sg v3? ok，让我们先了解下sg。</p><p>SCSI设备驱动主要有四类：sd(disk), st(tape), sr(CDROM), sg(generic)。</p><p>menuconfig:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   *** SCSI support type (dis, tape, SD-ROM) ***</span><br><span class="line">&lt;&gt; SCSI disk support</span><br><span class="line">&lt;&gt; SCSI tape support</span><br><span class="line">&lt;&gt; SCSI CDROM support</span><br><span class="line">&lt;&gt; SCSI generic support</span><br></pre></td></tr></table></figure><p>sg: 顾名思义就是更通用的了，大概看下sg v3和v4，以下参考kernel 5.x。</p><p>v4的Kconfig定义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config BLK_DEV_BSG</span><br><span class="line">        bool &quot;Block layer SG support v4&quot;</span><br><span class="line">        default y</span><br><span class="line">        select BLK_SCSI_REQUEST</span><br><span class="line">        help</span><br><span class="line">          Saying Y here will enable generic SG (SCSI generic) v4 support</span><br><span class="line">          for any block device.</span><br><span class="line"></span><br><span class="line">          Unlike SG v3 (aka block/scsi_ioctl.c drivers/scsi/sg.c), SG v4</span><br><span class="line">          can handle complicated SCSI commands: tagged variable length cdbs</span><br><span class="line">          with bidirectional data transfers and generic request/response</span><br><span class="line">          protocols (e.g. Task Management Functions and SMP in Serial</span><br><span class="line">          Attached SCSI).</span><br><span class="line"></span><br><span class="line">          This option is required by recent UDEV versions to properly</span><br><span class="line">          access device serial numbers, etc.</span><br><span class="line"></span><br><span class="line">          If unsure, say Y.</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">block/Makefile:15:obj-<span class="variable">$(CONFIG_BLK_DEV_BSG)</span>   += bsg.o</span></span><br></pre></td></tr></table></figure><p>ok, sg v3的code：block&#x2F;scsi_ioctl.c + drivers&#x2F;scsi&#x2F;sg.c (CONFIG_CHR_DEV_SG)</p><p>sg v4的code：block&#x2F;bsg.c (CONFIG_BLK_DEV_BSG)</p><p>v3的interface: include&#x2F;scsi&#x2F;sg.h:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sg_io_hdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> interface_id;           <span class="comment">/* [i] &#x27;S&#x27; for SCSI generic (required) */</span></span><br></pre></td></tr></table></figure><p>v4的interface: include&#x2F;uapi&#x2F;linux&#x2F;bsg.h:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sg_io_v4</span> &#123;</span></span><br><span class="line">        __s32 guard;            <span class="comment">/* [i] &#x27;Q&#x27; to differentiate from v3 */</span></span><br></pre></td></tr></table></figure><p>block layer来源于driver&#x2F;scsi，bsg是block layer sg, bsg只支持sg v4。</p><p>当前qcom平台只能看到&#x2F;dev&#x2F;block&#x2F;sda，用sg v3就能FFU for UFS? to be continue.</p><h2 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h2><ul><li>Documentation&#x2F;scsi&#x2F;scsi-generic.rst</li><li><a href="https://github.com/westerndigitalcorporation/ufs-utils/README.md">https://github.com/westerndigitalcorporation/ufs-utils/README.md</a></li><li><a href="http://sg.danny.cz/sg/sg_v40.html">http://sg.danny.cz/sg/sg_v40.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scsi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Kernel WARN()&amp;amp;BUG(), Oops&amp;amp;Panic, Tainted分析</title>
      <link href="/analyze-linux-warn-bug-oops-panic-tainted.html"/>
      <url>/analyze-linux-warn-bug-oops-panic-tainted.html</url>
      
        <content type="html"><![CDATA[<p>稳定性范畴, 参考5.x kernel。</p><h2 id="kernel-Oops"><a href="#kernel-Oops" class="headerlink" title="kernel Oops"></a>kernel Oops</h2><p>Oops指的就是内核的不正确行为，比如对驱动来说：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i82092aa_pci_probe</span><span class="params">(<span class="keyword">struct</span> pci_dev *dev,</span></span><br><span class="line"><span class="params">                              <span class="type">const</span> <span class="keyword">struct</span> pci_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> configbyte;</span><br><span class="line">        <span class="type">int</span> i, ret;</span><br><span class="line"></span><br><span class="line">        ret = pci_enable_device(dev);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* PCI Configuration Control */</span></span><br><span class="line">        pci_read_config_byte(dev, <span class="number">0x40</span>, &amp;configbyte);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (configbyte&amp;<span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                socket_count = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                socket_count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                socket_count = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                dev_err(&amp;dev-&gt;dev,</span><br><span class="line">                        <span class="string">&quot;Oops, you did something we didn&#x27;t think of.\n&quot;</span>);</span><br><span class="line">                ret = -EIO;</span><br><span class="line">                <span class="keyword">goto</span> err_out_disable;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里的PCI配置读出来有异常，我们就认为他是一个Oops，打印一个错误，探测失败。</p><p>分配内存失败也算一种Oops，只不过不需要打出错误信息。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">td = kmalloc (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> FS_BPENTRY), GFP_ATOMIC);</span><br><span class="line">fs_dprintk (FS_DEBUG_ALLOC, <span class="string">&quot;Alloc transd: %p(%zd)\n&quot;</span>, td, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> FS_BPENTRY));</span><br><span class="line"><span class="keyword">if</span> (!td) &#123;</span><br><span class="line">        <span class="comment">/* Oops out of mem */</span></span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在体系架构方面的Oops，比如arm64的bug Oops:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bug_handler</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="type">unsigned</span> <span class="type">int</span> esr)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">switch</span> (report_bug(regs-&gt;pc, regs)) &#123;</span><br><span class="line">        <span class="keyword">case</span> BUG_TRAP_TYPE_BUG:</span><br><span class="line">                die(<span class="string">&quot;Oops - BUG&quot;</span>, regs, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>如果<code>report_bug()</code>返回的是<code>BUG_TRAP_TYPE_BUG</code>，那就报个Oops log。</p><p>再比如非法访问也会走<code>die(&quot;Oops&quot;, )</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">die_kernel_fault</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">                             <span class="type">unsigned</span> <span class="type">int</span> esr, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">        bust_spinlocks(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        pr_alert(<span class="string">&quot;Unable to handle kernel %s at virtual address %016lx\n&quot;</span>, msg,</span><br><span class="line">                 addr);</span><br><span class="line"></span><br><span class="line">        mem_abort_decode(esr);</span><br><span class="line"></span><br><span class="line">        show_pte(addr);</span><br><span class="line">        die(<span class="string">&quot;Oops&quot;</span>, regs, esr); <span class="comment">//tj</span></span><br><span class="line">        bust_spinlocks(<span class="number">0</span>);</span><br><span class="line">        do_exit(SIGKILL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下<code>die()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="keyword">struct</span> pt_regs *regs, <span class="type">int</span> err)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">        raw_spin_lock_irqsave(&amp;die_lock, flags);</span><br><span class="line"></span><br><span class="line">        oops_enter();</span><br><span class="line"></span><br><span class="line">        console_verbose();</span><br><span class="line">        bust_spinlocks(<span class="number">1</span>);</span><br><span class="line">        ret = __die(str, err, regs); <span class="comment">//tj</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (regs &amp;&amp; kexec_should_crash(current))</span><br><span class="line">                crash_kexec(regs);</span><br><span class="line"></span><br><span class="line">        bust_spinlocks(<span class="number">0</span>);</span><br><span class="line">        add_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);</span><br><span class="line">        oops_exit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_interrupt())</span><br><span class="line">                panic(<span class="string">&quot;Fatal exception in interrupt&quot;</span>); <span class="comment">//tj</span></span><br><span class="line">        <span class="keyword">if</span> (panic_on_oops)</span><br><span class="line">                panic(<span class="string">&quot;Fatal exception&quot;</span>); <span class="comment">//tj</span></span><br><span class="line"></span><br><span class="line">        raw_spin_unlock_irqrestore(&amp;die_lock, flags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret != NOTIFY_STOP)</span><br><span class="line">                do_exit(SIGSEGV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下<code>__die()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __die(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> err, <span class="keyword">struct</span> pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> die_counter;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">        pr_emerg(<span class="string">&quot;Internal error: %s: %x [#%d]&quot;</span> S_PREEMPT S_SMP <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                 str, err, ++die_counter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* trap and error numbers are mostly meaningless on ARM */</span></span><br><span class="line">        ret = notify_die(DIE_OOPS, str, regs, err, <span class="number">0</span>, SIGSEGV);</span><br><span class="line">        <span class="keyword">if</span> (ret == NOTIFY_STOP)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        print_modules();</span><br><span class="line">        show_regs(regs);</span><br><span class="line"></span><br><span class="line">        dump_kernel_instr(KERN_EMERG, regs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印类似如下log:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">35.449887:   &lt;6&gt; Internal error: Oops - BUG: 0 [#1] PREEMPT SMP</span><br><span class="line">35.449893:   &lt;6&gt; Modules linked in:</span><br><span class="line">35.449901:   &lt;6&gt; Process init (pid: 1, stack limit = 0x00000000826895f7)</span><br></pre></td></tr></table></figure><p>后面会call <code>panic()</code>，不过是有条件的:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_interrupt())</span><br><span class="line">        panic(<span class="string">&quot;Fatal exception in interrupt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (panic_on_oops)</span><br><span class="line">        panic(<span class="string">&quot;Fatal exception&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果这个Oops在中断里，会走<code>panic()</code>。如果不在但<code>if (panic_on_oops)</code>成立，也走<code>panic()</code>。</p><p>可见，Oops不一定会导致panic。<code>bug_handle()</code>对<code>BUG_TRAP_TYPE_BUG</code>还不默认panic?</p><p>btw: arm64的Oops是怎么触发的了？稍后看。</p><h2 id="Kernel-panic"><a href="#Kernel-panic" class="headerlink" title="Kernel panic"></a>Kernel panic</h2><p>kernel panic就是不可恢复的错误了，怎么处理？我想复位or我就想定这。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *panic - halt the system</span></span><br><span class="line"><span class="comment"> *@fmt: The text string to print</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Display a message, then perform cleanups.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *This function never returns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">pr_emerg(<span class="string">&quot;Kernel panic - not syncing: %s\n&quot;</span>, buf);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (panic_timeout &gt; <span class="number">0</span>) &#123; <span class="comment">//tj: 延迟重启</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Delay timeout seconds before rebooting the machine.</span></span><br><span class="line"><span class="comment"> * We can&#x27;t use the &quot;normal&quot; timers since we just panicked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pr_emerg(<span class="string">&quot;Rebooting in %d seconds..\n&quot;</span>, panic_timeout); <span class="comment">//tj</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; panic_timeout * <span class="number">1000</span>; i += PANIC_TIMER_STEP) &#123;</span><br><span class="line">touch_nmi_watchdog();</span><br><span class="line"><span class="keyword">if</span> (i &gt;= i_next) &#123;</span><br><span class="line">i += panic_blink(state ^= <span class="number">1</span>);</span><br><span class="line">i_next = i + <span class="number">3600</span> / PANIC_BLINK_SPD;</span><br><span class="line">&#125;</span><br><span class="line">mdelay(PANIC_TIMER_STEP);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (panic_timeout != <span class="number">0</span>) &#123; <span class="comment">//tj: 立即reboot</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This will not be a clean reboot, with everything</span></span><br><span class="line"><span class="comment"> * shutting down.  But if there is a chance of</span></span><br><span class="line"><span class="comment"> * rebooting the system it will be rebooted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (panic_reboot_mode != REBOOT_UNDEFINED)</span><br><span class="line">reboot_mode = panic_reboot_mode;</span><br><span class="line">emergency_restart();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">pr_emerg(<span class="string">&quot;---[ end Kernel panic - not syncing: %s ]---\n&quot;</span>, buf); <span class="comment">//tj: 一直卡这</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do not scroll important messages printed above */</span></span><br><span class="line">suppress_printk = <span class="number">1</span>;</span><br><span class="line">local_irq_enable();</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; ; i += PANIC_TIMER_STEP) &#123;</span><br><span class="line">touch_softlockup_watchdog();</span><br><span class="line"><span class="keyword">if</span> (i &gt;= i_next) &#123;</span><br><span class="line">i += panic_blink(state ^= <span class="number">1</span>);</span><br><span class="line">i_next = i + <span class="number">3600</span> / PANIC_BLINK_SPD;</span><br><span class="line">&#125;</span><br><span class="line">mdelay(PANIC_TIMER_STEP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config PANIC_TIMEOUT</span><br><span class="line">        int &quot;panic timeout&quot;</span><br><span class="line">        default 0</span><br><span class="line">        help</span><br><span class="line">          Set the timeout value (in seconds) until a reboot occurs when the</span><br><span class="line">          the kernel panics. If n = 0, then we wait forever. A timeout</span><br><span class="line">          value n &gt; 0 will wait n seconds before rebooting, while a timeout</span><br><span class="line">          value n &lt; 0 will reboot immediately.</span><br></pre></td></tr></table></figure><p>这个panic timeout在Kconfig里说的很清楚。</p><h2 id="BUG-ifndef-HAVE-ARCH-BUG"><a href="#BUG-ifndef-HAVE-ARCH-BUG" class="headerlink" title="BUG() ifndef HAVE_ARCH_BUG"></a>BUG() ifndef HAVE_ARCH_BUG</h2><p>先看代码注释:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don&#x27;t use BUG() or BUG_ON() unless there&#x27;s really no way out; one</span></span><br><span class="line"><span class="comment"> * example might be detecting data structure corruption in the middle</span></span><br><span class="line"><span class="comment"> * of an operation that can&#x27;t be backed out of.  If the (sub)system</span></span><br><span class="line"><span class="comment"> * can somehow continue operating, perhaps with reduced functionality,</span></span><br><span class="line"><span class="comment"> * it&#x27;s probably not BUG-worthy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If you&#x27;re tempted to BUG(), think again:  is completely giving up</span></span><br><span class="line"><span class="comment"> * really the *only* solution?  There are usually better options, where</span></span><br><span class="line"><span class="comment"> * users don&#x27;t need to reboot ASAP and can mostly shut down cleanly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HAVE_ARCH_BUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUG() do &#123; \</span></span><br><span class="line"><span class="meta">printk(<span class="string">&quot;BUG: failure at %s:%d/%s()!\n&quot;</span>, __FILE__, __LINE__, __func__); \</span></span><br><span class="line"><span class="meta">barrier_before_unreachable(); \</span></span><br><span class="line"><span class="meta">panic(<span class="string">&quot;BUG!&quot;</span>); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>无路可走了？那就call me。如果只是丢失功能，系统还能继续跑，那就不算BUG。我就call你debug不行啊:)</p><p>这里有个宏<code>HAVE_ARCH_BUG</code>，没有实现arch bug，那就用它了，会直接导致panic，这是bug嘛，当然panic，感觉哪里不对劲？</p><h2 id="BUG-on-arm64"><a href="#BUG-on-arm64" class="headerlink" title="BUG() on arm64"></a>BUG() on arm64</h2><p>看下arm64的实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __BUG_FLAGS(flags)                              \</span></span><br><span class="line"><span class="meta">        asm volatile (__stringify(ASM_BUG_FLAGS(flags)));</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUG() do &#123;                                      \</span></span><br><span class="line"><span class="meta">        __BUG_FLAGS(0);                                 \</span></span><br><span class="line"><span class="meta">        unreachable();                                  \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WARN_FLAGS(flags) __BUG_FLAGS(BUGFLAG_WARNING|(flags))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_ARCH_BUG  <span class="comment">//tj: define</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm-generic/bug.h&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_BUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BUG_ENTRY(flags)                              \</span></span><br><span class="line"><span class="meta">                .pushsection __bug_table,<span class="string">&quot;aw&quot;</span>;          \</span></span><br><span class="line"><span class="meta">                .align 2;                               \</span></span><br><span class="line"><span class="meta">        14470:  .long 14471f - 14470b;                  \</span></span><br><span class="line"><span class="meta">_BUGVERBOSE_LOCATION(__FILE__, __LINE__)                \</span></span><br><span class="line"><span class="meta">                .short flags;                           \</span></span><br><span class="line"><span class="meta">                .popsection;                            \</span></span><br><span class="line"><span class="meta">        14471:</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ASM_BUG_FLAGS(flags)                            \</span></span><br><span class="line"><span class="meta">        __BUG_ENTRY(flags)                              \</span></span><br><span class="line"><span class="meta">        brk     BUG_BRK_IMM</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * #imm16 values used for BRK instruction generation</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 0x800: kernel-mode BUG() and WARN() traps</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUG_BRK_IMM                     0x800</span></span><br></pre></td></tr></table></figure><p>arm64的<code>BUG()</code>就是抛个<code>brk 0x800</code>指令，注释也写明了。</p><p><code>bug_handler()</code>就是对应这个的处理。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bug_handler</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="type">unsigned</span> <span class="type">int</span> esr)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">switch</span> (report_bug(regs-&gt;pc, regs)) &#123; <span class="comment">//tj: report_bug()</span></span><br><span class="line">        <span class="keyword">case</span> BUG_TRAP_TYPE_BUG:</span><br><span class="line">                die(<span class="string">&quot;Oops - BUG&quot;</span>, regs, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BUG_TRAP_TYPE_WARN:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">/* unknown/unrecognised bug trap type */</span></span><br><span class="line">                <span class="keyword">return</span> DBG_HOOK_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If thread survives, skip over the BUG instruction and continue: */</span></span><br><span class="line">        arm64_skip_faulting_instruction(regs, AARCH64_INSN_SIZE);</span><br><span class="line">        <span class="keyword">return</span> DBG_HOOK_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">break_hook</span> <span class="title">bug_break_hook</span> =</span> &#123;</span><br><span class="line">        .fn = bug_handler,</span><br><span class="line">        .imm = BUG_BRK_IMM,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>report bug:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> bug_trap_type <span class="title function_">report_bug</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> bugaddr, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (!is_valid_bugaddr(bugaddr))</span><br><span class="line">                <span class="keyword">return</span> BUG_TRAP_TYPE_NONE;</span><br><span class="line"></span><br><span class="line">        bug = find_bug(bugaddr);</span><br><span class="line">        <span class="keyword">if</span> (!bug)</span><br><span class="line">                <span class="keyword">return</span> BUG_TRAP_TYPE_NONE;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (file)</span><br><span class="line">                pr_crit(<span class="string">&quot;kernel BUG at %s:%u!\n&quot;</span>, file, line);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                pr_crit(<span class="string">&quot;Kernel BUG at %pB [verbose debug info unavailable]\n&quot;</span>,</span><br><span class="line">                        (<span class="type">void</span> *)bugaddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BUG_TRAP_TYPE_BUG;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_valid_bugaddr</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * bug_handler() only called for BRK #BUG_BRK_IMM.</span></span><br><span class="line"><span class="comment">         * So the answer is trivial -- any spurious instances with no</span></span><br><span class="line"><span class="comment">         * bug table entry will be rejected by report_bug() and passed</span></span><br><span class="line"><span class="comment">         * back to the debug-monitors code and handled as a fatal</span></span><br><span class="line"><span class="comment">         * unexpected debug exception.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是bug，log里会报出来<code>pr_crit(&quot;kernel BUG </code>。再大概看下<code>bug_handler()</code>的触发：</p><p><code>bug_handler</code>就是<code>bug_break_hook.fn</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">trap_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        register_kernel_break_hook(&amp;bug_break_hook);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN_SW_TAGS</span></span><br><span class="line">        register_kernel_break_hook(&amp;kasan_break_hook);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        debug_traps_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是register:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(kernel_break_hook)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_kernel_break_hook</span><span class="params">(<span class="keyword">struct</span> break_hook *hook)</span></span><br><span class="line">&#123;</span><br><span class="line">        register_debug_hook(&amp;hook-&gt;node, &amp;kernel_break_hook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">register_debug_hook</span><span class="params">(<span class="keyword">struct</span> list_head *node, <span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        spin_lock(&amp;debug_hook_lock);</span><br><span class="line">        list_add_rcu(node, <span class="built_in">list</span>);</span><br><span class="line">        spin_unlock(&amp;debug_hook_lock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加到list <code>kernel_break_hook</code>。然后初始化：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_ESR_EVT_BRK         0x6</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">debug_traps_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        hook_debug_fault_code(DBG_ESR_EVT_HWSS, single_step_handler, SIGTRAP,</span><br><span class="line">                              TRAP_TRACE, <span class="string">&quot;single-step handler&quot;</span>);</span><br><span class="line">        hook_debug_fault_code(DBG_ESR_EVT_BRK, brk_handler, SIGTRAP,</span><br><span class="line">                              TRAP_BRKPT, <span class="string">&quot;ptrace BRK handler&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">hook_debug_fault_code</span><span class="params">(<span class="type">int</span> nr,</span></span><br><span class="line"><span class="params">                                  <span class="type">int</span> (*fn)(<span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">int</span>, <span class="keyword">struct</span> pt_regs *),</span></span><br><span class="line"><span class="params">                                  <span class="type">int</span> sig, <span class="type">int</span> code, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">        BUG_ON(nr &lt; <span class="number">0</span> || nr &gt;= ARRAY_SIZE(debug_fault_info));</span><br><span class="line"></span><br><span class="line">        debug_fault_info[nr].fn         = fn; <span class="comment">//tj: brk_handler</span></span><br><span class="line">        debug_fault_info[nr].sig        = sig;</span><br><span class="line">        debug_fault_info[nr].code       = code;</span><br><span class="line">        debug_fault_info[nr].name       = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fault_info</span> __<span class="title">refdata</span> <span class="title">debug_fault_info</span>[] =</span> &#123;</span><br><span class="line">        &#123; do_bad,       SIGTRAP,        TRAP_HWBKPT,    <span class="string">&quot;hardware breakpoint&quot;</span>   &#125;,</span><br><span class="line">        &#123; do_bad,       SIGTRAP,        TRAP_HWBKPT,    <span class="string">&quot;hardware single-step&quot;</span>  &#125;,</span><br><span class="line">        &#123; do_bad,       SIGTRAP,        TRAP_HWBKPT,    <span class="string">&quot;hardware watchpoint&quot;</span>   &#125;,</span><br><span class="line">        &#123; do_bad,       SIGKILL,        SI_KERNEL,      <span class="string">&quot;unknown 3&quot;</span>             &#125;,</span><br><span class="line">        &#123; do_bad,       SIGTRAP,        TRAP_BRKPT,     <span class="string">&quot;aarch32 BKPT&quot;</span>          &#125;,</span><br><span class="line">        &#123; do_bad,       SIGKILL,        SI_KERNEL,      <span class="string">&quot;aarch32 vector catch&quot;</span>  &#125;,</span><br><span class="line">        &#123; early_brk64,  SIGTRAP,        TRAP_BRKPT,     <span class="string">&quot;aarch64 BRK&quot;</span>           &#125;, <span class="comment">//tj: here, index=6</span></span><br><span class="line">        &#123; do_bad,       SIGKILL,        SI_KERNEL,      <span class="string">&quot;unknown 7&quot;</span>             &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就是这里的<code>early_bk64</code>被替换成了<code>brk_handler</code>。</p><p>默认的<code>early_brk64()</code>直接call <code>bug_handler()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initial handler for AArch64 BRK exceptions</span></span><br><span class="line"><span class="comment"> * This handler only used until debug_traps_init().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">early_brk64</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">int</span> esr,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN_SW_TAGS</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> comment = esr &amp; ESR_ELx_BRK64_ISS_COMMENT_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((comment &amp; ~KASAN_BRK_MASK) == KASAN_BRK_IMM)</span><br><span class="line">                <span class="keyword">return</span> kasan_handler(regs, esr) != DBG_HOOK_HANDLED;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> bug_handler(regs, esr) != DBG_HOOK_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>brk_handler()</code>会走hook:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">brk_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> unused, <span class="type">unsigned</span> <span class="type">int</span> esr,</span></span><br><span class="line"><span class="params">                       <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (call_break_hook(regs, esr) == DBG_HOOK_HANDLED)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user_mode(regs)) &#123;</span><br><span class="line">                send_user_sigtrap(TRAP_BRKPT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pr_warn(<span class="string">&quot;Unexpected kernel BRK exception at EL1\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>call_break_hook()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">call_break_hook</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="type">unsigned</span> <span class="type">int</span> esr)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">break_hook</span> *<span class="title">hook</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line">        <span class="type">int</span> (*fn)(<span class="keyword">struct</span> pt_regs *regs, <span class="type">unsigned</span> <span class="type">int</span> esr) = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">list</span> = user_mode(regs) ? &amp;user_break_hook : &amp;kernel_break_hook;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Since brk exception disables interrupt, this function is</span></span><br><span class="line"><span class="comment">         * entirely not preemptible, and we can use rcu list safely here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list_for_each_entry_rcu(hook, <span class="built_in">list</span>, node) &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> comment = esr &amp; ESR_ELx_BRK64_ISS_COMMENT_MASK;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((comment &amp; ~hook-&gt;mask) == hook-&gt;imm)</span><br><span class="line">                        fn = hook-&gt;fn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fn ? fn(regs, esr) : DBG_HOOK_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是在list里找到<code>hook-&gt;fn</code>,也就是<code>bug_handler()</code>。</p><p>那BUG_ON()怎么进入的panic()，除了中断就是靠<code>panic_on_oops</code>控制：</p><blockquote><h1 id="panic-on-oops"><a href="#panic-on-oops" class="headerlink" title="panic_on_oops"></a>panic_on_oops</h1><p>Controls the kernel’s behaviour when an oops or BUG is encountered.</p><p>&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>0 Try to continue operation.<br>1 Panic immediately.  If the <code>panic</code> sysctl is also non-zero then the<br>  machine will be rebooted.<br>&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p></blockquote><p>Android一般在init.rc开启：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">on init</span><br><span class="line">    ...</span><br><span class="line">    write /proc/sys/kernel/panic_on_oops 1</span><br></pre></td></tr></table></figure><h2 id="WARN"><a href="#WARN" class="headerlink" title="WARN()"></a>WARN()</h2><p>先看注释：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * WARN(), WARN_ON(), WARN_ON_ONCE, and so on can be used to report</span></span><br><span class="line"><span class="comment"> * significant kernel issues that need prompt attention if they should ever</span></span><br><span class="line"><span class="comment"> * appear at runtime.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Do not use these macros when checking for invalid external inputs</span></span><br><span class="line"><span class="comment"> * (e.g. invalid system call arguments, or invalid data coming from</span></span><br><span class="line"><span class="comment"> * network/devices), and on transient conditions like ENOMEM or EAGAIN.</span></span><br><span class="line"><span class="comment"> * These macros should be used for recoverable kernel issues only.</span></span><br><span class="line"><span class="comment"> * For invalid external inputs, transient conditions, etc use</span></span><br><span class="line"><span class="comment"> * pr_err[_once/_ratelimited]() followed by dump_stack(), if necessary.</span></span><br><span class="line"><span class="comment"> * Do not include &quot;BUG&quot;/&quot;WARNING&quot; in format strings manually to make these</span></span><br><span class="line"><span class="comment"> * conditions distinguishable from kernel issues.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use the versions with printk format strings to provide better diagnostics.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>WARN()系是用来报告一些可修复的(recoverable)内核问题，不是用来check入参啊，没内存啊等场景。</p><p>WARN()系有个区分<code>__WARN_FLAGS</code>，与体系架构有关：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __WARN_FLAGS</span></span><br><span class="line"><span class="keyword">extern</span> __printf(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="type">void</span> <span class="title function_">warn_slowpath_fmt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">int</span> line, <span class="type">unsigned</span> taint,</span></span><br><span class="line"><span class="params">       <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WARN()__WARN_printf(TAINT_WARN, NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WARN_printf(taint, arg...) do &#123;\</span></span><br><span class="line"><span class="meta">instrumentation_begin();\</span></span><br><span class="line"><span class="meta">warn_slowpath_fmt(__FILE__, __LINE__, taint, arg);\</span></span><br><span class="line"><span class="meta">instrumentation_end();\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">extern</span> __printf(<span class="number">1</span>, <span class="number">2</span>) <span class="type">void</span> __warn_printk(<span class="type">const</span> <span class="type">char</span> *fmt, ...);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WARN()__WARN_FLAGS(BUGFLAG_TAINT(TAINT_WARN))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WARN_printf(taint, arg...) do &#123;\</span></span><br><span class="line"><span class="meta">instrumentation_begin();\</span></span><br><span class="line"><span class="meta">__warn_printk(arg);\</span></span><br><span class="line"><span class="meta">__WARN_FLAGS(BUGFLAG_NO_CUT_HERE | BUGFLAG_TAINT(taint));\</span></span><br><span class="line"><span class="meta">instrumentation_end();\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WARN_ON_ONCE(condition) (&#123;\</span></span><br><span class="line"><span class="meta">int __ret_warn_on = !!(condition);\</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (unlikely(__ret_warn_on))\</span></span><br><span class="line"><span class="meta">__WARN_FLAGS(BUGFLAG_ONCE |\</span></span><br><span class="line"><span class="meta">     BUGFLAG_TAINT(TAINT_WARN));\</span></span><br><span class="line"><span class="meta">unlikely(__ret_warn_on);\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>关注arm64：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __BUG_FLAGS(flags)                              \</span></span><br><span class="line"><span class="meta">        asm volatile (__stringify(ASM_BUG_FLAGS(flags)));</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WARN_FLAGS(flags) __BUG_FLAGS(BUGFLAG_WARNING|(flags))</span></span><br></pre></td></tr></table></figure><p>和arm64的<code>BUG()</code>定义放一起的，<code>BUGFLAG_WARNING</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_BUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUGFLAG_WARNING         (1 &lt;&lt; 0) <span class="comment">//tj: here</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUGFLAG_ONCE            (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUGFLAG_DONE            (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUGFLAG_NO_CUT_HERE     (1 &lt;&lt; 3)        <span class="comment">/* CUT_HERE already sent */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUGFLAG_TAINT(taint)    ((taint) &lt;&lt; 8) <span class="comment">//tj</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUG_GET_TAINT(bug)      ((bug)-&gt;flags &gt;&gt; 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __WARN()__WARN_FLAGS(BUGFLAG_TAINT(TAINT_WARN))</span></span><br></pre></td></tr></table></figure><p>主要差异体现在<code>__BUG_ENTRY</code>，具体涉及arm64汇编，这里不关注。</p><p><code>__WARN_printf</code>就是多了个log。</p><p>还有个<code>__warn()</code>函数，lib&#x2F;bug.c在<code>report_bug()</code>会用：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> bug_trap_type <span class="title function_">report_bug</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> bugaddr, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (bug) &#123;</span><br><span class="line">...</span><br><span class="line">   warning = (bug-&gt;flags &amp; BUGFLAG_WARNING) != <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> ((bug-&gt;flags &amp; BUGFLAG_NO_CUT_HERE) == <span class="number">0</span>)</span><br><span class="line">printk(KERN_DEFAULT CUT_HERE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (warning) &#123;</span><br><span class="line"><span class="comment">/* this is a WARN_ON rather than BUG/BUG_ON */</span></span><br><span class="line">__warn(file, line, (<span class="type">void</span> *)bugaddr, BUG_GET_TAINT(bug), regs,</span><br><span class="line">       <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> BUG_TRAP_TYPE_WARN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (file)</span><br><span class="line">pr_crit(<span class="string">&quot;kernel BUG at %s:%u!\n&quot;</span>, file, line);</span><br></pre></td></tr></table></figure><p><code>bug-&gt;flags</code>就是前面定义的哈，arm64 warn也触发的<code>bug_handler()</code>。</p><p><code>__warn()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __warn(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line, <span class="type">void</span> *caller, <span class="type">unsigned</span> taint,</span><br><span class="line">    <span class="keyword">struct</span> pt_regs *regs, <span class="keyword">struct</span> warn_args *args)</span><br><span class="line">&#123;</span><br><span class="line">disable_trace_on_warning();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (file)</span><br><span class="line">pr_warn(<span class="string">&quot;WARNING: CPU: %d PID: %d at %s:%d %pS\n&quot;</span>,</span><br><span class="line">raw_smp_processor_id(), current-&gt;pid, file, line,</span><br><span class="line">caller);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pr_warn(<span class="string">&quot;WARNING: CPU: %d PID: %d at %pS\n&quot;</span>,</span><br><span class="line">raw_smp_processor_id(), current-&gt;pid, caller);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (args)</span><br><span class="line">vprintk(args-&gt;fmt, args-&gt;args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (panic_on_warn) &#123; <span class="comment">//tj: here</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This thread may hit another WARN() in the panic path.</span></span><br><span class="line"><span class="comment"> * Resetting this prevents additional WARN() from panicking the</span></span><br><span class="line"><span class="comment"> * system on this thread.  Other threads are blocked by the</span></span><br><span class="line"><span class="comment"> * panic_mutex in panic().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">panic_on_warn = <span class="number">0</span>;</span><br><span class="line">panic(<span class="string">&quot;panic_on_warn set ...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_modules();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (regs)</span><br><span class="line">show_regs(regs);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dump_stack();</span><br><span class="line"></span><br><span class="line">print_irqtrace_events(current);</span><br><span class="line"></span><br><span class="line">print_oops_end_marker();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Just a warning, don&#x27;t kill lockdep. */</span></span><br><span class="line">add_taint(taint, LOCKDEP_STILL_OK);</span><br></pre></td></tr></table></figure><p>what? panic还能发生在warn上？没错，就是这个<code>panic_on_warn</code>，看下缘由：</p><blockquote><h1 id="panic-on-warn"><a href="#panic-on-warn" class="headerlink" title="panic_on_warn"></a>panic_on_warn</h1><p>Calls panic() in the WARN() path when set to 1.  This is useful to avoid<br>a kernel rebuild when attempting to kdump at the location of a WARN().</p><p>&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>0 Only WARN(), default behaviour.<br>1 Call panic() after printing out WARN() location.<br>&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p></blockquote><p>kdump用时不用rebuild，ok。</p><h2 id="tainted-kernels"><a href="#tainted-kernels" class="headerlink" title="tainted-kernels"></a>tainted-kernels</h2><p>一些Oops log会看到<code>Tainted</code>字样如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">35.449908:   &lt;6&gt; CPU: 0 PID: 1 Comm: init Tainted: G S      W       4.14.117-perf+ #65</span><br></pre></td></tr></table></figure><p>就是内核被污染了，查问题时用得上。即使污染源被去除后，污染状态一直保留。</p><p>运行时状态查询在：<code>/proc/sys/kernel/tainted</code>, bug, oops, panics都会打印出来。</p><p>arm64的<code>die()</code>中就会增加污染标记:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="keyword">struct</span> pt_regs *regs, <span class="type">int</span> err)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">bust_spinlocks(<span class="number">0</span>);</span><br><span class="line">add_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE); <span class="comment">//tj</span></span><br><span class="line">oops_exit();</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_taint</span><span class="params">(<span class="type">unsigned</span> flag, <span class="keyword">enum</span> lockdep_ok lockdep_ok)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lockdep_ok == LOCKDEP_NOW_UNRELIABLE &amp;&amp; __debug_locks_off())</span><br><span class="line">pr_warn(<span class="string">&quot;Disabling lock debugging due to kernel taint\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">set_bit(flag, &amp;tainted_mask); <span class="comment">//tj</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tainted_mask &amp; panic_on_taint) &#123;</span><br><span class="line">panic_on_taint = <span class="number">0</span>;</span><br><span class="line">panic(<span class="string">&quot;panic_on_taint set ...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>污染标记到<code>tainted_mask</code>里。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This cannot be an enum because some may be used in assembly source. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_PROPRIETARY_MODULE        0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_FORCED_MODULE             1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_CPU_OUT_OF_SPEC           2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_FORCED_RMMOD              3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_MACHINE_CHECK             4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_BAD_PAGE                  5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_USER                      6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_DIE                       7 <span class="comment">//tj</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_OVERRIDDEN_ACPI_TABLE     8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_WARN                      9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_CRAP                      10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_FIRMWARE_WORKAROUND       11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_OOT_MODULE                12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_UNSIGNED_MODULE           13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_SOFTLOCKUP                14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_LIVEPATCH                 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_AUX                       16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_RANDSTRUCT                17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAINT_FLAGS_COUNT               18</span></span><br></pre></td></tr></table></figure><p>这么多污染种类。打印污染状态时：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print_tainted - return a string to represent the kernel taint state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For individual taint flag meanings, see Documentation/admin-guide/sysctl/kernel.rst</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The string is overwritten by the next call to print_tainted(),</span></span><br><span class="line"><span class="comment"> * but is always NULL terminated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">print_tainted</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[TAINT_FLAGS_COUNT + <span class="keyword">sizeof</span>(<span class="string">&quot;Tainted: &quot;</span>)];</span><br><span class="line"></span><br><span class="line">BUILD_BUG_ON(ARRAY_SIZE(taint_flags) != TAINT_FLAGS_COUNT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tainted_mask) &#123;</span><br><span class="line"><span class="type">char</span> *s;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">s = buf + <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Tainted: &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TAINT_FLAGS_COUNT; i++) &#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">taint_flag</span> *<span class="title">t</span> =</span> &amp;taint_flags[i];</span><br><span class="line">*s++ = test_bit(i, &amp;tainted_mask) ? <span class="comment">//tj</span></span><br><span class="line">t-&gt;c_true : t-&gt;c_false;</span><br><span class="line">&#125;</span><br><span class="line">*s = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;Not tainted&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>tainted_mask</code>里取出之前设置的标记via <code>test_bit(i, &amp;tainted_mask)</code>。像<code>WARN()</code>就设置了<code>TAINT_WARN</code>。</p><p>那都被污染了要不要panic？取决于<code>panic_on_taint</code>：</p><blockquote><pre><code>   panic_on_taint= Bitmask for conditionally calling panic() in add_taint()                   Format: &lt;hex&gt;[,nousertaint]                   Hexadecimal bitmask representing the set of TAINT flags                   that will cause the kernel to panic when add_taint() is                   called with any of the flags in this set.                   The optional switch &quot;nousertaint&quot; can be utilized to                   prevent userspace forced crashes by writing to sysctl                   /proc/sys/kernel/tainted any flagset matching with the                   bitmask set on panic_on_taint.                   See Documentation/admin-guide/tainted-kernels.rst for                   extra details on the taint flags that users can pick                   to compose the bitmask to assign to panic_on_taint.</code></pre></blockquote><p>哪些污染要panic，你自己决定了。所以才会有<code>tainted_mask &amp; panic_on_taint</code>。</p><h2 id="sysctl-for-panic"><a href="#sysctl-for-panic" class="headerlink" title="sysctl for panic"></a>sysctl for panic</h2><p>&#x2F;proc&#x2F;sys&#x2F;kernel</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/proc/sys/kernel <span class="comment"># ls -l panic*</span></span><br><span class="line">-rw-r--r-- 1 root root 0 2020-07-11 20:32 panic</span><br><span class="line">-rw-r--r-- 1 root root 0 2020-07-11 20:32 panic_on_oops</span><br><span class="line">-rw-r--r-- 1 root root 0 2020-07-11 20:32 panic_on_rcu_stall</span><br><span class="line">-rw-r--r-- 1 root root 0 2020-07-11 20:32 panic_on_warn</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li>Documentation&#x2F;admin-guide&#x2F;sysctl&#x2F;kernel.rst</li><li>Documentation&#x2F;admin-guide&#x2F;tainted-kernels.rst</li><li>Documentation&#x2F;admin-guide&#x2F;kernel-parameters.txt</li></ul>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速验证sepolicy TE文件修改</title>
      <link href="/how-to-verify-sepolicy-te-file-change.html"/>
      <url>/how-to-verify-sepolicy-te-file-change.html</url>
      
        <content type="html"><![CDATA[<p>Android平台经常遇到sepolicy权限问题，log类似如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[  170.390794] type=1400 audit(1594061213.935:90): avc: denied &#123; write &#125; for comm=&quot;kworker/4:1&quot; path=&quot;/dev/block/sda3&quot; dev=&quot;tmpfs&quot; ino=50 scontext=u:r:kernel:s0 tcontext=u:object_r:device_a:s0 tclass=blk_file permissive=0</span><br></pre></td></tr></table></figure><p>不允许kernel对&#x2F;dev&#x2F;block&#x2F;sda3直接写，这里device_a已经定义过了，找到kernel.te，添加如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">allow kernel device_a:blk_file &#123;read write&#125;;</span><br></pre></td></tr></table></figure><p>ok，此时没有编译过整个系统，编译刷入bootimage没生效，难道要编译刷入整个系统？答案是不需要。</p><p>既然是build相关，以下参考Android 10，其他应该差不多，我们先进.&#x2F;system&#x2F;sepolicy看下Android.mk：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vendor_policy.cil - the vendor sepolicy. This needs attributization and to be combined</span></span><br><span class="line"><span class="comment"># with the platform-provided policy.  It makes use of the reqd_policy_mask files from private</span></span><br><span class="line"><span class="comment"># policy and the platform public policy files in order to use checkpolicy.</span></span><br><span class="line">LOCAL_MODULE := vendor_sepolicy.cil //tj</span><br><span class="line">LOCAL_MODULE_CLASS := ETC</span><br><span class="line">...</span><br><span class="line">LOCAL_MODULE_PATH := <span class="variable">$(TARGET_OUT_VENDOR)</span>/etc/selinux</span><br></pre></td></tr></table></figure><p>这个sepolicy最终会编译成<code>vendor_sepolicy.cil</code>, 生成路径在<code>$(TARGET_OUT_VENDOR)</code>:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TARGET_OUT_VENDOR := <span class="variable">$(PRODUCT_OUT)</span>/<span class="variable">$(TARGET_COPY_OUT_VENDOR)</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TARGET_COPY_OUT_VENDOR := vendor</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">PRODUCT_OUT := <span class="variable">$(TARGET_PRODUCT_OUT_ROOT)</span>/<span class="variable">$(TARGET_DEVICE)</span></span><br><span class="line"></span><br><span class="line">TARGET_PRODUCT_OUT_ROOT := <span class="variable">$(TARGET_OUT_ROOT)</span>/product </span><br><span class="line">TARGET_OUT_ROOT := <span class="variable">$(OUT_DIR)</span>/target </span><br></pre></td></tr></table></figure><p>ok，这个路径基本就是out&#x2F;target&#x2F;product&#x2F;xxx&#x2F;vendor&#x2F;etc&#x2F;selinux&#x2F;vendor_sepolicy.cil, xxx是<code>$(TARGET_DEVICE)</code>, rt?</p><p>手机里也有这个文件，直接替换即可。还不会的可以参考下面验证方法：</p>]]></content>
      
      
      <categories>
          
          <category> security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sepolicy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓QCOM平台子系统复位原因记录分析</title>
      <link href="/qcom-ssr-analysis.html"/>
      <url>/qcom-ssr-analysis.html</url>
      
        <content type="html"><![CDATA[<p>参考LA msm-4.14 kernel，先看下在drivers&#x2F;soc&#x2F;qcom&#x2F;subsys-pil-tz.c里记录失败原因的接口：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">log_failure_reason</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pil_tz_data *d)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> size;</span><br><span class="line"><span class="type">char</span> *smem_reason, reason[MAX_SSR_REASON_LEN];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name = d-&gt;subsys_desc.name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (d-&gt;smem_id == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">smem_reason = qcom_smem_get(QCOM_SMEM_HOST_ANY, d-&gt;smem_id, &amp;size); <span class="comment">//tj</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(smem_reason) || !size) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;%s SFR: (unknown, qcom_smem_get failed).\n&quot;</span>,</span><br><span class="line">name);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!smem_reason[<span class="number">0</span>]) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;%s SFR: (unknown, empty string found).\n&quot;</span>, name);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strlcpy(reason, smem_reason, min(size, (<span class="type">size_t</span>)MAX_SSR_REASON_LEN)); <span class="comment">//tj</span></span><br><span class="line">pr_err(<span class="string">&quot;%s subsystem failure reason: %s.\n&quot;</span>, name, reason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>qcom_smem_get()</code>获得subsystem复位原因，记录在栈<code>reason</code>中。</p><p>ok，既然是stack var，func结束就丢了。如何保存这个<code>reason</code>？因为我们不可能老是连着串口，有的crash不一定能复现，pstore有时没有记录，尤其是用户退货机分析。</p><p>在调试阶段，我想一个有效方法可以把这个<code>reason</code>放到保留memory里。对退货机，就要保存到存储上了，直接从fs层写到block设备上就行了。看了下pstore next加了block支持(全志贡献的)，回头看看。这里我们主要看下如何保存到存储上。</p><p>直接在这个接口里加blk读写是否可以？我们来看代码上下文。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">subsys_err_fatal_intr_handler</span> <span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pil_tz_data</span> *<span class="title">d</span> =</span> subsys_to_data(dev_id);</span><br><span class="line"></span><br><span class="line">        pr_err(<span class="string">&quot;Fatal error on %s!\n&quot;</span>, d-&gt;subsys_desc.name);</span><br><span class="line">        <span class="keyword">if</span> (subsys_get_crash_status(d-&gt;subsys)) &#123;</span><br><span class="line">                pr_err(<span class="string">&quot;%s: Ignoring error fatal, restart in progress\n&quot;</span>,</span><br><span class="line">                                                        d-&gt;subsys_desc.name);</span><br><span class="line">                <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">        &#125;</span><br><span class="line">        subsys_set_crash_status(d-&gt;subsys, CRASH_STATUS_ERR_FATAL);</span><br><span class="line">        log_failure_reason(d); <span class="comment">//tj: here</span></span><br><span class="line">        subsystem_restart_dev(d-&gt;subsys);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">subsys_wdog_bite_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pil_tz_data</span> *<span class="title">d</span> =</span> subsys_to_data(dev_id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (subsys_get_crash_status(d-&gt;subsys))</span><br><span class="line">                <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">        pr_err(<span class="string">&quot;Watchdog bite received from %s!\n&quot;</span>, d-&gt;subsys_desc.name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (d-&gt;subsys_desc.system_debug)</span><br><span class="line">                panic(<span class="string">&quot;%s: System ramdump requested. Triggering device restart!\n&quot;</span>,</span><br><span class="line">                                                        __func__);</span><br><span class="line">        subsys_set_crash_status(d-&gt;subsys, CRASH_STATUS_WDOG_BITE);</span><br><span class="line">        log_failure_reason(d); <span class="comment">//tj: here</span></span><br><span class="line">        subsystem_restart_dev(d-&gt;subsys);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">clear_wdog</span><span class="params">(<span class="keyword">struct</span> pil_tz_data *d)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* Check crash status to know if device is restarting*/</span></span><br><span class="line">        <span class="keyword">if</span> (!subsys_get_crash_status(d-&gt;subsys)) &#123;</span><br><span class="line">                pr_err(<span class="string">&quot;wdog bite received from %s!\n&quot;</span>, d-&gt;subsys_desc.name);</span><br><span class="line">                __raw_writel(BIT(d-&gt;bits_arr[ERR_READY]), d-&gt;irq_clear);</span><br><span class="line">                subsys_set_crash_status(d-&gt;subsys, CRASH_STATUS_WDOG_BITE);</span><br><span class="line">                log_failure_reason(d); <span class="comment">//tj:here</span></span><br><span class="line">                subsystem_restart_dev(d-&gt;subsys);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">subsys_generic_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pil_tz_data</span> *<span class="title">d</span> =</span> subsys_to_data(dev_id);</span><br><span class="line">        <span class="type">uint32_t</span> status_val, err_value;</span><br><span class="line"></span><br><span class="line">        err_value =  __raw_readl(d-&gt;err_status_spare);</span><br><span class="line">        status_val = __raw_readl(d-&gt;irq_status);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((status_val &amp; BIT(d-&gt;bits_arr[ERR_READY])) &amp;&amp; !err_value)</span><br><span class="line">                clear_err_ready(d);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((status_val &amp; BIT(d-&gt;bits_arr[ERR_READY])) &amp;&amp;</span><br><span class="line">                                        err_value == <span class="number">0x44554d50</span>)</span><br><span class="line">                clear_wdog(d);</span><br></pre></td></tr></table></figure><p>ok, 是在中断服务里call <code>log_failure_reason()</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pil_tz_driver_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (of_property_read_bool(pdev-&gt;dev.of_node,</span><br><span class="line">                                        <span class="string">&quot;qcom,pil-generic-irq-handler&quot;</span>)) &#123;</span><br><span class="line">                d-&gt;subsys_desc.generic_handler = subsys_generic_handler;</span><br><span class="line">...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                d-&gt;subsys_desc.err_fatal_handler =</span><br><span class="line">                                                subsys_err_fatal_intr_handler;</span><br><span class="line">                d-&gt;subsys_desc.wdog_bite_handler = subsys_wdog_bite_irq_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般都走<code>Fatal error</code> or <code>Watchdog bite received</code>。</p><p>首先设置crash状态：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">subsys_set_crash_status(d-&gt;subsys, CRASH_STATUS_ERR_FATAL);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">subsys_set_crash_status(d-&gt;subsys, CRASH_STATUS_WDOG_BITE);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">subsys_set_crash_status</span><span class="params">(<span class="keyword">struct</span> subsys_device *dev,</span></span><br><span class="line"><span class="params">                                <span class="keyword">enum</span> crash_status crashed)</span></span><br><span class="line">&#123;</span><br><span class="line">        dev-&gt;crashed = crashed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后call <code>log_failure_reason()</code>记录，中断服务最后call <code>subsystem_restart_dev()</code>，看下这个restart接口：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">subsystem_restart_dev</span><span class="params">(<span class="keyword">struct</span> subsys_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!get_device(&amp;dev-&gt;dev))</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!try_module_get(dev-&gt;owner)) &#123;</span><br><span class="line">                put_device(&amp;dev-&gt;dev);</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        name = dev-&gt;desc-&gt;name;</span><br><span class="line"></span><br><span class="line">        send_early_notifications(dev-&gt;early_notify);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If a system reboot/shutdown is underway, ignore subsystem errors.</span></span><br><span class="line"><span class="comment">         * However, print a message so that we know that a subsystem behaved</span></span><br><span class="line"><span class="comment">         * unexpectedly here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (system_state == SYSTEM_RESTART</span><br><span class="line">                || system_state == SYSTEM_POWER_OFF) &#123;</span><br><span class="line">                pr_err(<span class="string">&quot;%s crashed during a system poweroff/shutdown.\n&quot;</span>, name);</span><br><span class="line">                <span class="keyword">return</span> -EBUSY; <span class="comment">//tj</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pr_info(<span class="string">&quot;Restart sequence requested for %s, restart_level = %s.\n&quot;</span>,</span><br><span class="line">                name, restart_levels[dev-&gt;restart_level]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (disable_restart_work == DISABLE_SSR) &#123;</span><br><span class="line">                pr_warn(<span class="string">&quot;subsys-restart: Ignoring restart request for %s\n&quot;</span>,</span><br><span class="line">                                                                        name);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (dev-&gt;restart_level) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> RESET_SUBSYS_COUPLED:</span><br><span class="line">                __subsystem_restart_dev(dev);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RESET_SOC:</span><br><span class="line">                __pm_stay_awake(&amp;dev-&gt;ssr_wlock);</span><br><span class="line">                schedule_work(&amp;dev-&gt;device_restart_work);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                panic(<span class="string">&quot;subsys-restart: Unknown restart level!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        module_put(dev-&gt;owner);</span><br><span class="line">        put_device(&amp;dev-&gt;dev);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看系统状态如果reboot&#x2F;shutdown进行中就认为忙，退出。如果禁用了SSR，直接返回。下来是主要功能，按<code>-&gt;restart_level</code>走不同的流程，这两个level定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> restart_levels[] = &#123;</span><br><span class="line">        [RESET_SOC] = <span class="string">&quot;SYSTEM&quot;</span>,</span><br><span class="line">        [RESET_SUBSYS_COUPLED] = <span class="string">&quot;RELATED&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先看<code>RESET_SOC</code>，从字面看就是系统级的了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> RESET_SOC:</span><br><span class="line">        __pm_stay_awake(&amp;dev-&gt;ssr_wlock);</span><br><span class="line">        schedule_work(&amp;dev-&gt;device_restart_work);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> subsys_device *<span class="title function_">subsys_register</span><span class="params">(<span class="keyword">struct</span> subsys_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        INIT_WORK(&amp;subsys-&gt;device_restart_work, device_restart_work_hdlr);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct subsys_device - subsystem device</span></span><br><span class="line"><span class="comment"> ...</span></span><br><span class="line"><span class="comment"> * @device_restart_work: work struct for device restart</span></span><br><span class="line"><span class="comment"> ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_device</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">subsys_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> <span class="title">ssr_wlock</span>;</span></span><br><span class="line">        <span class="type">char</span> wlname[<span class="number">64</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">device_restart_work</span>;</span></span><br></pre></td></tr></table></figure><p>ok, 进work task <code>device_restart_work_hdlr()</code>看下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">device_restart_work_hdlr</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">subsys_device</span> *<span class="title">dev</span> =</span> container_of(work, <span class="keyword">struct</span> subsys_device,</span><br><span class="line">                                                        device_restart_work);</span><br><span class="line"></span><br><span class="line">        notify_each_subsys_device(&amp;dev, <span class="number">1</span>, SUBSYS_SOC_RESET, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Temporary workaround until ramdump userspace application calls</span></span><br><span class="line"><span class="comment">         * sync() and fclose() on attempting the dump.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        msleep(<span class="number">100</span>);</span><br><span class="line">        panic(<span class="string">&quot;subsys-restart: Resetting the SoC - %s crashed.&quot;</span>,</span><br><span class="line">                                                        dev-&gt;desc-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>call <code>notify_each_subsys_device()</code>通知每个子系统复位：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">notify_each_subsys_device</span><span class="params">(<span class="keyword">struct</span> subsys_device **<span class="built_in">list</span>,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">int</span> count,</span></span><br><span class="line"><span class="params">                <span class="keyword">enum</span> subsys_notif_type notif, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">subsys_device</span> *<span class="title">subsys</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">subsys_device</span> *<span class="title">dev</span> =</span> *<span class="built_in">list</span>++;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">notif_data</span> <span class="title">notif_data</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span>;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!dev)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                pdev = container_of(dev-&gt;desc-&gt;dev, <span class="keyword">struct</span> platform_device,</span><br><span class="line">                                                                        dev);</span><br><span class="line">                dev-&gt;notif_state = notif;</span><br><span class="line"></span><br><span class="line">                mutex_lock(&amp;subsys_list_lock);</span><br><span class="line">                list_for_each_entry(subsys, &amp;subsys_list, <span class="built_in">list</span>)</span><br><span class="line">                        <span class="keyword">if</span> (dev != subsys &amp;&amp;</span><br><span class="line">                                subsys-&gt;track.state == SUBSYS_ONLINE) &#123;</span><br><span class="line">                                setup_timeout(dev-&gt;desc, subsys-&gt;desc,</span><br><span class="line">                                              SUBSYS_TO_SUBSYS_SYSMON);</span><br><span class="line">                                sysmon_send_event(subsys-&gt;desc, dev-&gt;desc,</span><br><span class="line">                                                  notif); <span class="comment">//tj</span></span><br><span class="line">                                cancel_timeout(dev-&gt;desc);</span><br><span class="line">                        &#125;</span><br><span class="line">                mutex_unlock(&amp;subsys_list_lock);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (notif == SUBSYS_AFTER_POWERUP &amp;&amp;</span><br><span class="line">                                dev-&gt;track.state == SUBSYS_ONLINE)</span><br><span class="line">                        send_sysmon_notif(dev);</span><br><span class="line"></span><br><span class="line">                notif_data.crashed = subsys_get_crash_status(dev);</span><br><span class="line">                notif_data.enable_ramdump = is_ramdump_enabled(dev); <span class="comment">//tj</span></span><br><span class="line">                notif_data.enable_mini_ramdumps = enable_mini_ramdumps;</span><br><span class="line">                notif_data.no_auth = dev-&gt;desc-&gt;no_auth;</span><br><span class="line">                notif_data.pdev = pdev;</span><br><span class="line"></span><br><span class="line">                trace_pil_notif(<span class="string">&quot;before_send_notif&quot;</span>, notif, dev-&gt;desc-&gt;fw_name);</span><br><span class="line">                setup_timeout(dev-&gt;desc, <span class="literal">NULL</span>, SUBSYS_TO_HLOS);</span><br><span class="line">                subsys_notif_queue_notification(dev-&gt;notify, notif,</span><br><span class="line">                                                                &amp;notif_data);</span><br><span class="line">                cancel_timeout(dev-&gt;desc);</span><br><span class="line">                trace_pil_notif(<span class="string">&quot;after_send_notif&quot;</span>, notif, dev-&gt;desc-&gt;fw_name);</span><br><span class="line">                subsys_notif_uevent(dev-&gt;desc, notif);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>call <code>list_for_each_entry()</code>去遍历每一个在线子系统，<code>notif_data</code>包括是否使能<code>enable_ramdump</code>和<code>enable_mini_ramdumps</code>。如果使能，应该就去dump ram了。</p><p>so, 才能有：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Temporary workaround until ramdump userspace application calls</span></span><br><span class="line"><span class="comment"> * sync() and fclose() on attempting the dump.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">msleep(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>am i right? 最后call kernel panic()。</p><p>ok, 我们再看另一个level: <code>RELATED</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> RESET_SUBSYS_COUPLED:</span><br><span class="line">        __subsystem_restart_dev(dev);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __subsystem_restart_dev(<span class="keyword">struct</span> subsys_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">subsys_desc</span> *<span class="title">desc</span> =</span> dev-&gt;desc;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name = dev-&gt;desc-&gt;name;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">subsys_tracking</span> *<span class="title">track</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">        pr_debug(<span class="string">&quot;Restarting %s [level=%s]!\n&quot;</span>, desc-&gt;name,</span><br><span class="line">                        restart_levels[dev-&gt;restart_level]);</span><br><span class="line"></span><br><span class="line">        track = subsys_get_track(dev);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Allow drivers to call subsystem_restart&#123;_dev&#125;() as many times as</span></span><br><span class="line"><span class="comment">         * they want up until the point where the subsystem is shutdown.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        spin_lock_irqsave(&amp;track-&gt;s_lock, flags);</span><br><span class="line">        <span class="keyword">if</span> (track-&gt;p_state != SUBSYS_CRASHED &amp;&amp;</span><br><span class="line">                                        dev-&gt;track.state == SUBSYS_ONLINE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (track-&gt;p_state != SUBSYS_RESTARTING) &#123;</span><br><span class="line">                        track-&gt;p_state = SUBSYS_CRASHED;</span><br><span class="line">                        __pm_stay_awake(&amp;dev-&gt;ssr_wlock);</span><br><span class="line">                        queue_work(ssr_wq, &amp;dev-&gt;work); <span class="comment">//tj</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        panic(<span class="string">&quot;Subsystem %s crashed during SSR!&quot;</span>, name);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">                WARN(dev-&gt;track.state == SUBSYS_OFFLINE,</span><br><span class="line">                        <span class="string">&quot;SSR aborted: %s subsystem not online\n&quot;</span>, name);</span><br><span class="line">        spin_unlock_irqrestore(&amp;track-&gt;s_lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INIT_WORK(&amp;subsys-&gt;work, subsystem_restart_wq_func);</span><br></pre></td></tr></table></figure><p>check <code>subsystem_restart_wq_func()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">subsystem_restart_wq_func</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        pr_debug(<span class="string">&quot;[%s:%d]: Starting restart sequence for %s\n&quot;</span>,</span><br><span class="line">                        current-&gt;comm, current-&gt;pid, desc-&gt;name);</span><br><span class="line">        notify_each_subsys_device(<span class="built_in">list</span>, count, SUBSYS_BEFORE_SHUTDOWN, <span class="literal">NULL</span>);</span><br><span class="line">        ret = for_each_subsys_device(<span class="built_in">list</span>, count, <span class="literal">NULL</span>, subsystem_shutdown);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">        notify_each_subsys_device(<span class="built_in">list</span>, count, SUBSYS_AFTER_SHUTDOWN, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        notify_each_subsys_device(<span class="built_in">list</span>, count, SUBSYS_RAMDUMP_NOTIFICATION,</span><br><span class="line">                                                                        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        spin_lock_irqsave(&amp;track-&gt;s_lock, flags);</span><br><span class="line">        track-&gt;p_state = SUBSYS_RESTARTING;</span><br><span class="line">        spin_unlock_irqrestore(&amp;track-&gt;s_lock, flags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Collect ram dumps for all subsystems in order here */</span></span><br><span class="line">        for_each_subsys_device(<span class="built_in">list</span>, count, <span class="literal">NULL</span>, subsystem_ramdump);</span><br><span class="line"></span><br><span class="line">        for_each_subsys_device(<span class="built_in">list</span>, count, <span class="literal">NULL</span>, subsystem_free_memory);</span><br><span class="line"></span><br><span class="line">        notify_each_subsys_device(<span class="built_in">list</span>, count, SUBSYS_BEFORE_POWERUP, <span class="literal">NULL</span>);</span><br><span class="line">        ret = for_each_subsys_device(<span class="built_in">list</span>, count, <span class="literal">NULL</span>, subsystem_powerup);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">        notify_each_subsys_device(<span class="built_in">list</span>, count, SUBSYS_AFTER_POWERUP, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        pr_info(<span class="string">&quot;[%s:%d]: Restart sequence for %s completed.\n&quot;</span>,</span><br><span class="line">                        current-&gt;comm, current-&gt;pid, desc-&gt;name);</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">for_each_subsys_device</span><span class="params">(<span class="keyword">struct</span> subsys_device **<span class="built_in">list</span>,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">int</span> count, <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> (*fn)(<span class="keyword">struct</span> subsys_device *, <span class="type">void</span> *))</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">subsys_device</span> *<span class="title">dev</span> =</span> *<span class="built_in">list</span>++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!dev)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                ret = fn(dev, data);</span><br><span class="line">                <span class="keyword">if</span> (ret)</span><br><span class="line">                        <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看到这个接口在做ramdump:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">subsystem_ramdump</span><span class="params">(<span class="keyword">struct</span> subsys_device *dev, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name = dev-&gt;desc-&gt;name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;desc-&gt;ramdump)</span><br><span class="line">                <span class="keyword">if</span> (dev-&gt;desc-&gt;ramdump(is_ramdump_enabled(dev), dev-&gt;desc) &lt; <span class="number">0</span>)</span><br><span class="line">                        pr_warn(<span class="string">&quot;%s[%s:%d]: Ramdump failed.\n&quot;</span>,</span><br><span class="line">                                name, current-&gt;comm, current-&gt;pid);</span><br><span class="line">        dev-&gt;do_ramdump_on_put = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，他没有像<code>SYSTEM</code> level那样直接call kernel panic。也就是所谓的subsystem restart? </p><p>好了，到这里应该知道在哪里加入复位原因到block device了。也可以参考下面的修改：</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDIO Card传输分析</title>
      <link href="/sdio-card-data-transfer-analysis.html"/>
      <url>/sdio-card-data-transfer-analysis.html</url>
      
        <content type="html"><![CDATA[<p>前面分析了SDIO探测原理，现在我们来看下SDIO读写传输。SDIO提供了两个新的I&#x2F;O读写命令: CMD52(IO_RW_DIRECT)和CMD53(IO_RW_EXTENDED)。CMD52用来读写一个字节，CMD53用来读写更多的数据。</p><p>CMD53数据传输分块传输(block mode)和字节传输(byte mode)两种模式，下表是与SD memory card传输格式对比：</p><table><thead><tr><th>SDIO card</th><th>SD memory card</th></tr></thead><tbody><tr><td>CMD53 rd (byte)</td><td>CMD17 (READ_SINGLE_BLOCK)</td></tr><tr><td>CMD53 wr (byte)</td><td>CMD24 (WRITE_BLOCK)</td></tr><tr><td>CMD53 rd (blk)</td><td>CMD18 (READ_MULTIPLE_BLOCK)</td></tr><tr><td>CMD53 wr (blk)</td><td>CMD25 (WRITE_MULTIPLE_BLOCK)</td></tr></tbody></table><p>SDIO的一个feature就是可以interrupt host，前提是使能card的相应功能中断(CCCR的IENx&#x2F;IENM)。host检测到这个pending中断后(CCCR的INTx)后会做一些特定处理。</p><p>看下CCCR(common control registers)相关寄存器定义 :</p><p><img src="http://tjtech.me/usr/uploads/2020/06/2443302635.png#center" alt="sdio-cccr.png"></p><h2 id="Linux-Kernel传输分析"><a href="#Linux-Kernel传输分析" class="headerlink" title="Linux Kernel传输分析"></a>Linux Kernel传输分析</h2><p>参考5.x:</p><p><code>sdio_claim_irq()</code>会使能中断：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *      sdio_claim_irq - claim the IRQ for a SDIO function</span></span><br><span class="line"><span class="comment"> *      @func: SDIO function</span></span><br><span class="line"><span class="comment"> *      @handler: IRQ handler callback</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Claim and activate the IRQ for the given SDIO function. The provided</span></span><br><span class="line"><span class="comment"> *      handler will be called when that IRQ is asserted.  The host is always</span></span><br><span class="line"><span class="comment"> *      claimed already when the handler is called so the handler should not</span></span><br><span class="line"><span class="comment"> *      call sdio_claim_host() or sdio_release_host().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sdio_claim_irq</span><span class="params">(<span class="keyword">struct</span> sdio_func *func, <span class="type">sdio_irq_handler_t</span> *handler)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> reg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!func)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        pr_debug(<span class="string">&quot;SDIO: Enabling IRQ for %s...\n&quot;</span>, sdio_func_id(func));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (func-&gt;irq_handler) &#123;</span><br><span class="line">                pr_debug(<span class="string">&quot;SDIO: IRQ for %s already in use.\n&quot;</span>, sdio_func_id(func));</span><br><span class="line">                <span class="keyword">return</span> -EBUSY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = mmc_io_rw_direct(func-&gt;card, <span class="number">0</span>, <span class="number">0</span>, SDIO_CCCR_IENx, <span class="number">0</span>, &amp;reg);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        reg |= <span class="number">1</span> &lt;&lt; func-&gt;num;</span><br><span class="line"></span><br><span class="line">        reg |= <span class="number">1</span>; <span class="comment">/* Master interrupt enable */</span></span><br><span class="line"></span><br><span class="line">        ret = mmc_io_rw_direct(func-&gt;card, <span class="number">1</span>, <span class="number">0</span>, SDIO_CCCR_IENx, reg, <span class="literal">NULL</span>); <span class="comment">//tj: enable int</span></span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        func-&gt;irq_handler = handler; <span class="comment">//tj: 注册isr</span></span><br><span class="line">        ret = sdio_card_irq_get(func-&gt;card);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                func-&gt;irq_handler = <span class="literal">NULL</span>;</span><br><span class="line">        sdio_single_irq_set(func-&gt;card);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(sdio_claim_irq);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SDIO_CCCR_IENx                0x04    <span class="comment">/* Function/Master Interrupt Enable */</span></span></span><br></pre></td></tr></table></figure><p>call <code>mmc_io_rw_direct()</code>使能此<code>func</code>的中断并挂接中断处理<code>func-&gt;irq_handler = handler</code>。然后使能host侧中断：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sdio_card_irq_get</span><span class="params">(<span class="keyword">struct</span> mmc_card *card)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mmc_host</span> *<span class="title">host</span> =</span> card-&gt;host;</span><br><span class="line"></span><br><span class="line">        WARN_ON(!host-&gt;claimed);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!host-&gt;sdio_irqs++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(host-&gt;caps2 &amp; MMC_CAP2_SDIO_IRQ_NOTHREAD)) &#123;</span><br><span class="line">                        <span class="type">atomic_set</span>(&amp;host-&gt;sdio_irq_thread_abort, <span class="number">0</span>);</span><br><span class="line">                        host-&gt;sdio_irq_thread =</span><br><span class="line">                                kthread_run(sdio_irq_thread, host,</span><br><span class="line">                                            <span class="string">&quot;ksdioirqd/%s&quot;</span>, mmc_hostname(host));</span><br><span class="line">                        <span class="keyword">if</span> (IS_ERR(host-&gt;sdio_irq_thread)) &#123;</span><br><span class="line">                                <span class="type">int</span> err = PTR_ERR(host-&gt;sdio_irq_thread);</span><br><span class="line">                                host-&gt;sdio_irqs--;</span><br><span class="line">                                <span class="keyword">return</span> err;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (host-&gt;caps &amp; MMC_CAP_SDIO_IRQ) &#123;</span><br><span class="line">                        host-&gt;ops-&gt;enable_sdio_irq(host, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看下具备<code>MMC_CAP_SDIO_IRQ</code>能力会走一个host的callback操作(<code>-&gt;enable_sdio_irq</code>)。对标准的SD host controller，这个callback定义在sdhci.c：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mmc_host_ops</span> <span class="title">sdhci_ops</span> =</span> &#123;</span><br><span class="line">        .request        = sdhci_request,</span><br><span class="line">        .post_req       = sdhci_post_req,</span><br><span class="line">        .pre_req        = sdhci_pre_req,</span><br><span class="line">        .set_ios        = sdhci_set_ios,</span><br><span class="line">        .get_cd         = sdhci_get_cd,</span><br><span class="line">        .get_ro         = sdhci_get_ro,</span><br><span class="line">        .hw_reset       = sdhci_hw_reset,</span><br><span class="line">        .enable_sdio_irq = sdhci_enable_sdio_irq, <span class="comment">//tj: here</span></span><br></pre></td></tr></table></figure><p><code>sdhci_enable_sdio_irq()</code>会call <code>sdhci_enable_sdio_irq_nolock()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sdhci_enable_sdio_irq_nolock</span><span class="params">(<span class="keyword">struct</span> sdhci_host *host, <span class="type">int</span> enable)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(host-&gt;flags &amp; SDHCI_DEVICE_DEAD)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (enable)</span><br><span class="line">                        host-&gt;ier |= SDHCI_INT_CARD_INT;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        host-&gt;ier &amp;= ~SDHCI_INT_CARD_INT;</span><br><span class="line"></span><br><span class="line">                sdhci_writel(host, host-&gt;ier, SDHCI_INT_ENABLE);</span><br><span class="line">                sdhci_writel(host, host-&gt;ier, SDHCI_SIGNAL_ENABLE);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight h"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SDHCI_INT_ENABLE        0x34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDHCI_SIGNAL_ENABLE     0x38</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  SDHCI_INT_CARD_INT     0x00000100</span></span><br></pre></td></tr></table></figure><p>host spec有如下定义：</p><p><img src="http://tjtech.me/usr/uploads/2020/06/1725249090.png#center" alt="sdio-host-34h-reg.png"></p><p><img src="http://tjtech.me/usr/uploads/2020/06/2082050560.png#center" alt="sdio-host-38h-reg.png"></p><p>clear? ok. </p><p>看下isr call stack:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sdhci_irq() -&gt; sdio_signal_irq() with SDHCI_INT_CARD_INT -&gt; queue_delayed_work()</span><br><span class="line">sdio_irq_work() -&gt; sdio_run_irqs() -&gt; process_sdio_pending_irqs()</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">process_sdio_pending_irqs</span><span class="params">(<span class="keyword">struct</span> mmc_host *host)</span></span><br><span class="line">&#123;</span><br><span class="line">        ...</span><br><span class="line">        ret = sdio_get_pending_irqs(host, &amp;pending);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pending &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                        func = card-&gt;sdio_func[i - <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (!func) &#123;</span><br><span class="line">                                pr_warn(<span class="string">&quot;%s: pending IRQ for non-existent function\n&quot;</span>,</span><br><span class="line">                                        mmc_card_id(card));</span><br><span class="line">                                ret = -EINVAL;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (func-&gt;irq_handler) &#123;</span><br><span class="line">                                func-&gt;irq_handler(func);</span><br><span class="line">                                count++;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                pr_warn(<span class="string">&quot;%s: pending IRQ with no handler\n&quot;</span>,</span><br><span class="line">                                        sdio_func_id(func));</span><br><span class="line">                                ret = -EINVAL;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是获取pending:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sdio_get_pending_irqs</span><span class="params">(<span class="keyword">struct</span> mmc_host *host, u8 *pending)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mmc_card</span> *<span class="title">card</span> =</span> host-&gt;card;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">        WARN_ON(!host-&gt;claimed);</span><br><span class="line"></span><br><span class="line">        ret = mmc_io_rw_direct(card, <span class="number">0</span>, <span class="number">0</span>, SDIO_CCCR_INTx, <span class="number">0</span>, pending);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                pr_debug(<span class="string">&quot;%s: error %d reading SDIO_CCCR_INTx\n&quot;</span>,</span><br><span class="line">                       mmc_card_id(card), ret);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后如果有pending(<code>pending &amp; (1 &lt;&lt; i)</code>)，走callback(<code>irq_handler</code>)，也就是之前在<code>sdio_claim_irq()</code>注册的handler。</p><p>sdio_io.c主要是单字节读写传输接口：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*      sdio_readb - read a single byte from a SDIO function</span><br><span class="line">*      sdio_writeb - write a single byte to a SDIO function</span><br></pre></td></tr></table></figure><p>就是封装了<code>mmc_io_rw_direct()</code>。</p><p>多数据传输：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*      sdio_readsb - read from a FIFO on a SDIO function</span><br><span class="line">*      sdio_writesb - write to a FIFO of a SDIO function</span><br></pre></td></tr></table></figure><p>一样的数据切割处理最后call <code>mmc_io_rw_extended( ..., blocks, blksz)</code>。</p><p>Done.</p>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sdio card </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDIO Card初始化分析</title>
      <link href="/sdio-card-init.html"/>
      <url>/sdio-card-init.html</url>
      
        <content type="html"><![CDATA[<p>SDIO Card全称是Secure Digital Input Output Card，它是在SD memory card的基础上扩展了I&#x2F;O功能。SDIO再加上memory就变成了Combo card(组合卡?)，这里主要看下SDIO card。</p><p>SDIO card分快(High-Speed)慢(Low-Speed)两种版本。传输模式分为SPI和SD两种，SD又分成1-bit和4-bit，SPI和1-bit SD是强制要求，SD 4-bit是快速SDIO card必备了。</p><h2 id="SD-mode卡初始化流程图"><a href="#SD-mode卡初始化流程图" class="headerlink" title="SD mode卡初始化流程图"></a>SD mode卡初始化流程图</h2><p>先来看下Spec的初始化流程图，重点关注SDIO card(红线)：</p><p><img src="http://tjtech.me/usr/uploads/2020/05/2910362261.png#center" alt="card_ini_flow_in_sd_mode.png"></p><p><img src="http://tjtech.me/usr/uploads/2020/05/567224915.png#center" alt="card_ini_flow_in_sd_mode_cont.png"></p><p>提下图上的几个term含义：</p><p>OCR: Operation Conditions Register. The supported minimum and maximum values for VDD.</p><p>RCA: relative card address register, 所有的功能都共享同样的card addess。</p><p>CMD5: 是IO_SEND_OP_COND command，用来获取OCR。</p><p>CMD3: 是SEND_RELATIVE_ADDR command，用来获取RCA。</p><h2 id="Linux-Kernel初始化"><a href="#Linux-Kernel初始化" class="headerlink" title="Linux Kernel初始化"></a>Linux Kernel初始化</h2><p>参考5.x, 相关code文件如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">linaro@rpi:~/code/kernel/linux/drivers/mmc$ <span class="built_in">ls</span> -l core/sdio*</span><br><span class="line">-rw-r--r-- 1 linaro linaro  8407 Feb  5 10:58 core/sdio_bus.c</span><br><span class="line">-rw-r--r-- 1 linaro linaro   443 Feb  5 10:58 core/sdio_bus.h</span><br><span class="line">-rw-r--r-- 1 linaro linaro 28230 Feb  5 10:58 core/sdio.c</span><br><span class="line">-rw-r--r-- 1 linaro linaro  9021 Feb  5 10:58 core/sdio_cis.c</span><br><span class="line">-rw-r--r-- 1 linaro linaro   476 Feb  5 10:58 core/sdio_cis.h</span><br><span class="line">-rw-r--r-- 1 linaro linaro 21666 Feb  5 10:58 core/sdio_io.c</span><br><span class="line">-rw-r--r-- 1 linaro linaro  8952 Feb  5 10:58 core/sdio_irq.c</span><br><span class="line">-rw-r--r-- 1 linaro linaro  4601 Feb  5 10:58 core/sdio_ops.c</span><br><span class="line">-rw-r--r-- 1 linaro linaro   932 Feb  5 10:58 core/sdio_ops.h</span><br></pre></td></tr></table></figure><p>初始化入口：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mmc_attach_sdio</span><span class="params">(<span class="keyword">struct</span> mmc_host *host)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> err, i, funcs;</span><br><span class="line">        u32 ocr, rocr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mmc_card</span> *<span class="title">card</span>;</span></span><br><span class="line"></span><br><span class="line">        WARN_ON(!host-&gt;claimed);</span><br><span class="line"></span><br><span class="line">        err = mmc_send_io_op_cond(host, <span class="number">0</span>, &amp;ocr);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err; </span><br><span class="line"></span><br><span class="line">        mmc_attach_bus(host, &amp;mmc_sdio_ops);</span><br><span class="line">        <span class="keyword">if</span> (host-&gt;ocr_avail_sdio)</span><br><span class="line">                host-&gt;ocr_avail = host-&gt;ocr_avail_sdio;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        rocr = mmc_select_voltage(host, ocr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Can we support the voltage(s) of the card(s)?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!rocr) &#123;</span><br><span class="line">                err = -EINVAL;</span><br><span class="line">                <span class="keyword">goto</span> err; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先走<code>mmc_send_io_op_cond()</code>获得ocr：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SD_IO_SEND_OP_COND          5 <span class="comment">/* bcr  [23:0] OCR         R4  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mmc_send_io_op_cond</span><span class="params">(<span class="keyword">struct</span> mmc_host *host, u32 ocr, u32 *rocr)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mmc_command</span> <span class="title">cmd</span> =</span> &#123;&#125;; </span><br><span class="line">        <span class="type">int</span> i, err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        cmd.opcode = SD_IO_SEND_OP_COND;</span><br><span class="line">        cmd.arg = ocr;</span><br><span class="line">        cmd.flags = MMC_RSP_SPI_R4 | MMC_RSP_R4 | MMC_CMD_BCR;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">100</span>; i; i--) &#123;</span><br><span class="line">                err = mmc_wait_for_cmd(host, &amp;cmd, MMC_CMD_RETRIES);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* if we&#x27;re just probing, do a single pass */</span></span><br><span class="line">                <span class="keyword">if</span> (ocr == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;  <span class="comment">//tj: here</span></span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rocr)</span><br><span class="line">                *rocr = cmd.resp[mmc_host_is_spi(host) ? <span class="number">1</span> : <span class="number">0</span>]; <span class="comment">//tj: get OCR</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>ocr</code>传进来就是0，被定义为probing。如果host支持，<code>mmc_host_is_spi()</code>会在drivers&#x2F;mmc&#x2F;host&#x2F;mmc_spi.c里定义。</p><p>下来select voltage:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Mask off any voltages we don&#x27;t support and select</span></span><br><span class="line"><span class="comment"> * the lowest voltage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u32 <span class="title function_">mmc_select_voltage</span><span class="params">(<span class="keyword">struct</span> mmc_host *host, u32 ocr)</span> </span><br></pre></td></tr></table></figure><p>电压test and select后，进入探测初始化<code>mmc_sdio_init_card(host, rocr, NULL)</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Handle the detection and initialisation of a card.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In the case of a resume, &quot;oldcard&quot; will contain the card</span></span><br><span class="line"><span class="comment"> * we&#x27;re trying to reinitialise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mmc_sdio_init_card</span><span class="params">(<span class="keyword">struct</span> mmc_host *host, u32 ocr, </span></span><br><span class="line"><span class="params">                              <span class="keyword">struct</span> mmc_card *oldcard)</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p><code>oldcard</code>是给reinit用，探测传入是<code>NULL</code>，暂不关心。看下这个接口主要做了哪些事情，这里不关心SPI mode：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Inform the card of the voltage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">err = mmc_send_io_op_cond(host, ocr, &amp;rocr);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> err; </span><br></pre></td></tr></table></figure><p>首先把之前select的voltage再设置下，然后根据响应<code>rocr</code>里是否有MP flag(<code>R4_MEMORY_PRESENT</code>)区分出SDIO card type(<code>MMC_TYPE_SDIO</code>)。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((rocr &amp; R4_MEMORY_PRESENT) &amp;&amp;</span><br><span class="line">    mmc_sd_get_cid(host, ocr &amp; rocr, card-&gt;raw_cid, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        card-&gt;type = MMC_TYPE_SD_COMBO;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        card-&gt;type = MMC_TYPE_SDIO;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来set card RCA：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For native busses:  set card RCA and quit open drain mode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!mmc_host_is_spi(host)) &#123;</span><br><span class="line">        err = mmc_send_relative_addr(host, &amp;card-&gt;rca);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">goto</span> remove;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mmc_send_relative_addr</span><span class="params">(<span class="keyword">struct</span> mmc_host *host, <span class="type">unsigned</span> <span class="type">int</span> *rca)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mmc_command</span> <span class="title">cmd</span> =</span> &#123;&#125;; </span><br><span class="line"></span><br><span class="line">        cmd.opcode = SD_SEND_RELATIVE_ADDR;</span><br><span class="line">        cmd.arg = <span class="number">0</span>;</span><br><span class="line">        cmd.flags = MMC_RSP_R6 | MMC_CMD_BCR;</span><br><span class="line"></span><br><span class="line">        err = mmc_wait_for_cmd(host, &amp;cmd, MMC_CMD_RETRIES);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        *rca = cmd.resp[<span class="number">0</span>] &gt;&gt; <span class="number">16</span>;  <span class="comment">//tj: get RCA</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>then select card（due to 操作依赖）:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Select card, as all following commands rely on that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!mmc_host_is_spi(host)) &#123;</span><br><span class="line">        err = mmc_select_card(card);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">goto</span> remove;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>then 读common information area(CIA)，包括CCCR(card common control)和CIS(card information struture):</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read the common registers. Note that we should try to</span></span><br><span class="line"><span class="comment"> * validate whether UHS would work or not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">err = sdio_read_cccr(card, ocr);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read the common CIS tuples.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">err = sdio_read_common_cis(card);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目的就是让host决定要用哪些功能，最后设置High-Speed if support&#x2F;clock&#x2F;4-bit SD if support:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*   </span></span><br><span class="line"><span class="comment"> * Switch to high-speed (if supported).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">err = sdio_enable_hs(card);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/*   </span></span><br><span class="line"><span class="comment"> * Change to the card&#x27;s maximum speed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mmc_set_clock(host, mmc_sdio_get_max_clock(card));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*   </span></span><br><span class="line"><span class="comment"> * Switch to wider bus (if supported).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">err = sdio_enable_4bit_bus(card);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>high-speed:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Enable SDIO/combo card&#x27;s high-speed mode. Return 0/1 if [not]supported.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sdio_enable_hs</span><span class="params">(<span class="keyword">struct</span> mmc_card *card)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret; </span><br><span class="line"></span><br><span class="line">        ret = mmc_sdio_switch_hs(card, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span> || card-&gt;type == MMC_TYPE_SDIO)</span><br><span class="line">                <span class="keyword">return</span> ret; </span><br></pre></td></tr></table></figure><p>先test是否支持then切换：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Test if the card supports high-speed mode and, if so, switch to it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mmc_sdio_switch_hs</span><span class="params">(<span class="keyword">struct</span> mmc_card *card, <span class="type">int</span> enable)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        u8 speed;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(card-&gt;host-&gt;caps &amp; MMC_CAP_SD_HIGHSPEED))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!card-&gt;cccr.high_speed)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ret = mmc_io_rw_direct(card, <span class="number">0</span>, <span class="number">0</span>, SDIO_CCCR_SPEED, <span class="number">0</span>, &amp;speed); <span class="comment">//tj:read</span></span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enable)</span><br><span class="line">                speed |= SDIO_SPEED_EHS;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                speed &amp;= ~SDIO_SPEED_EHS;</span><br><span class="line"></span><br><span class="line">        ret = mmc_io_rw_direct(card, <span class="number">1</span>, <span class="number">0</span>, SDIO_CCCR_SPEED, speed, <span class="literal">NULL</span>); <span class="comment">//tj:write</span></span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4-bit:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sdio_enable_4bit_bus</span><span class="params">(<span class="keyword">struct</span> mmc_card *card)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> err; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (card-&gt;type == MMC_TYPE_SDIO)</span><br><span class="line">                err = sdio_enable_wide(card);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先test是否支持then配置4-bit：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sdio_enable_wide</span><span class="params">(<span class="keyword">struct</span> mmc_card *card)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret; </span><br><span class="line">        u8 ctrl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(card-&gt;host-&gt;caps &amp; MMC_CAP_4_BIT_DATA))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (card-&gt;cccr.low_speed &amp;&amp; !card-&gt;cccr.wide_bus)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ret = mmc_io_rw_direct(card, <span class="number">0</span>, <span class="number">0</span>, SDIO_CCCR_IF, <span class="number">0</span>, &amp;ctrl); <span class="comment">//tj: read</span></span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((ctrl &amp; SDIO_BUS_WIDTH_MASK) == SDIO_BUS_WIDTH_RESERVED)</span><br><span class="line">                pr_warn(<span class="string">&quot;%s: SDIO_CCCR_IF is invalid: 0x%02x\n&quot;</span>,</span><br><span class="line">                        mmc_hostname(card-&gt;host), ctrl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set as 4-bit bus width */</span></span><br><span class="line">        ctrl &amp;= ~SDIO_BUS_WIDTH_MASK;</span><br><span class="line">        ctrl |= SDIO_BUS_WIDTH_4BIT;</span><br><span class="line"></span><br><span class="line">        ret = mmc_io_rw_direct(card, <span class="number">1</span>, <span class="number">0</span>, SDIO_CCCR_IF, ctrl, <span class="literal">NULL</span>); <span class="comment">//tj: write</span></span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Done.</p><p>BTW: Mobile bootloader seems do not support SDIO card, but i can:]</p>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sdio card </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UFS概览</title>
      <link href="/ufs-overview.html"/>
      <url>/ufs-overview.html</url>
      
        <content type="html"><![CDATA[<p>UFS(Universal Flash Storage)的出现就是为了取代eMMC和SD cards，它兼具eMMC优点(low power)和SCSI SSD优点(high performance)，因而是基于SCSI架构的，称它mobile SSD最合适。如果是可移除(removable)的就是UFS card了。</p><h2 id="SCSI-architectural-model"><a href="#SCSI-architectural-model" class="headerlink" title="SCSI architectural model"></a>SCSI architectural model</h2><p>SCSI devices之间关系是一个client-server model：</p><p><img src="http://tjtech.me/usr/uploads/2020/05/1134088607.png#center" alt="scsi-cs-model.png"></p><p>如上图，client是SCSI Initiator，server是SCSI Target，client负责发起request，server则respond这个请求，他们通过Service Delivery Subsystem连接起来。</p><p>另外，SCSI Target由一到多个LU组成，用LUN来识别:</p><p><img src="http://tjtech.me/usr/uploads/2020/05/1260790788.png#center" alt="scsi-cs-with-lun-model.png"></p><p>LU包含Device Server和Task Manager，分别处理client发来的相应request。用well know LU定义只包含特定的功能的LU。</p><p>看下C&#x2F;S通信使用的三层协议模型：</p><p><img src="http://tjtech.me/usr/uploads/2020/05/3622247594.png#center" alt="scsi-3layer-prot.png"></p><p>Interconnect layer就是C&#x2F;S模型里提到的Service Delivery Subsystem，还提供了一些服务和信号机制供物理层数据传输用, 缩成SIL。</p><p>最后还有个SCSI domain model:</p><p><img src="http://tjtech.me/usr/uploads/2020/05/3506005009.png#center" alt="scsi-domain.png"></p><p>可见，SCSI domain由SCSI devices和a servce delivery subsystem组成。</p><h2 id="UFS-architectural-overview"><a href="#UFS-architectural-overview" class="headerlink" title="UFS architectural overview"></a>UFS architectural overview</h2><p>ok，UFS arch是基于SCSI arch的，来看spec里的arch图：</p><p><img src="http://tjtech.me/usr/uploads/2020/05/3970542103.png#center" alt="ufs-top-lvl-arch.png"></p><p>三层架构，来详细点：</p><ul><li><p>Application Layer: UCS(处理r&#x2F;w等normal cmds) + device manager(device level控制) + task manager(command queue控制)三大块组成。</p></li><li><p>UTP: 提供服务给上层用，UTP架构采用了SCSI的C&#x2F;S model，其中UFS Host是client，UFS device是server。它们之间的交流使用一个叫做UPIU(UFS Protocol Information Unit)的东东。</p></li><li><p>UIC: 处理连接，由MIPI UniPro和MIPI M-PHY组成。UniPro就是Unified Protocol，mobile领域使用的一种高速互连接口。通常都和物理层(如M-PHY)一道完成通讯。</p></li></ul><p>UniPro还有子层：</p><p><img src="http://tjtech.me/usr/uploads/2020/05/137533952.png#center" alt="unipro-layer-view.png"></p><p>UniPro提供给DME(Device Management Entity)访问。</p><h2 id="UFS-LUs"><a href="#UFS-LUs" class="headerlink" title="UFS LUs"></a>UFS LUs</h2><p>先看下spec的UFS domain图:</p><p><img src="http://tjtech.me/usr/uploads/2020/05/1392881938.png#center" alt="ufs-scsi-domain.png"></p><p>这个图很清楚，提下UFS最大支持N个LU，除了well-known LUs。Device server处理cmd，Task set是一组cmds，Task manager控制cmd顺序。</p><p>4个Well-Known LU(W-LU) in UFS:</p><p>SCSI REPORT LUNS + UFS Device + Boot(启动相关) + RPMB(安全有关)</p><p>一般买来的UFS没有LUN，需要create，这个行为叫做provisioning，也叫Logical block provisioning。</p><p>UFS的UPIU有个Query function，定义了Query Request UPIU和Query Response UPIU。Query查询用来在C&#x2F;S间读写数据，这些数据包含了system data，配置，descriptor，flags等。</p><p>这些关于device的descriptors分成好多种，比如有GEOMETRY描述符，里面定义了UFS大小:</p><p><img src="http://tjtech.me/usr/uploads/2020/05/2868324373.png#center" alt="ufs-geo-desc-size.png"></p><h2 id="UFSHCI"><a href="#UFSHCI" class="headerlink" title="UFSHCI"></a>UFSHCI</h2><p>来看下Host侧的相关定义，UFSHCI是Host Controller Interface，它的目标就是定义一个统一的访问HW的接口，这样的好处是可以提供一个通用的driver，这个driver可以和不同vendor的HCI一起工作。</p><p>我们看下从HCI角度的UFS架构图：</p><p><img src="http://tjtech.me/usr/uploads/2020/05/2216724356.png#center" alt="ufs-arch-from-hci.png"></p><p>这个接口位于Host driver和HW之间，由Host controller管理。</p><p>UFSHCI定义了两个接口空间(interface spaces)：MMIO space + Host memory space，看下这个interface架构：</p><p><img src="http://tjtech.me/usr/uploads/2020/05/2623443533.png#center" alt="ufshci-intf-arch.png"></p><p>MMIO space&#x2F;IO Memory就是各种Registers，结合Host memory中的Transfer Request Descriptors完成和HW通信。</p><h2 id="Linux-kernel-support"><a href="#Linux-kernel-support" class="headerlink" title="Linux kernel support"></a>Linux kernel support</h2><ul><li>Documentation&#x2F;scsi&#x2F;ufs.txt</li><li>Documentation&#x2F;ABI&#x2F;testing&#x2F;sysfs-driver-ufs</li><li>ufs device drv: drivers&#x2F;scsi&#x2F;ufs</li><li>ufs phy drv: drivers&#x2F;phy&#x2F;phy-core.c + drivers&#x2F;phy&#x2F;qualcomm</li></ul><p>Done.</p><p>ps: 以上参考UFS和SCSI相关free spec。</p>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ufs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android如何在No command下进入recovery</title>
      <link href="/how-to-enter-recovery-menu-under-no-command.html"/>
      <url>/how-to-enter-recovery-menu-under-no-command.html</url>
      
        <content type="html"><![CDATA[<p>一般我们用<code>adb reboot recovery</code>或从bootloader按键进入recovery时，会出现一个倒地小机器人，下方提示No command。</p><p>我们来看下为啥会这样以及此场景下如何进入recovery menu。</p><p>ok, 让我们先check <code>No command</code>，以下参考10.0:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> GRSurface* <span class="title">ScreenRecoveryUI::GetCurrentText</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (current_icon_) &#123;</span><br><span class="line">    <span class="keyword">case</span> ERASING:</span><br><span class="line">      <span class="keyword">return</span> erasing_text_.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">case</span> ERROR:</span><br><span class="line">      <span class="keyword">return</span> error_text_.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">case</span> INSTALLING_UPDATE:</span><br><span class="line">      <span class="keyword">return</span> installing_text_.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">case</span> NO_COMMAND:</span><br><span class="line">      <span class="keyword">return</span> no_command_text_.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">case</span> NONE:</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>倒地小机器人是：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> GRSurface* <span class="title">ScreenRecoveryUI::GetCurrentFrame</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current_icon_ == INSTALLING_UPDATE || current_icon_ == ERASING) &#123;</span><br><span class="line">    <span class="keyword">return</span> intro_done_ ? loop_frames_[current_frame_].<span class="built_in">get</span>() : intro_frames_[current_frame_].<span class="built_in">get</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> error_icon_.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, 追下caller：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Clear the screen and draw the currently selected background icon (if any).</span></span><br><span class="line"><span class="comment">// Should only be called with updateMutex locked.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScreenRecoveryUI::draw_background_locked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  pagesIdentical = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">gr_color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="built_in">gr_clear</span>();</span><br><span class="line">  <span class="keyword">if</span> (current_icon_ != NONE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max_stage != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="type">int</span> stage_height = <span class="built_in">gr_get_height</span>(stage_marker_empty_.<span class="built_in">get</span>());</span><br><span class="line">      <span class="type">int</span> stage_width = <span class="built_in">gr_get_width</span>(stage_marker_empty_.<span class="built_in">get</span>());</span><br><span class="line">      <span class="type">int</span> x = (<span class="built_in">ScreenWidth</span>() - max_stage * <span class="built_in">gr_get_width</span>(stage_marker_empty_.<span class="built_in">get</span>())) / <span class="number">2</span>;</span><br><span class="line">      <span class="type">int</span> y = <span class="built_in">ScreenHeight</span>() - stage_height - margin_height_;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_stage; ++i) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; stage_surface = (i &lt; stage) ? stage_marker_fill_ : stage_marker_empty_;</span><br><span class="line">        <span class="built_in">DrawSurface</span>(stage_surface.<span class="built_in">get</span>(), <span class="number">0</span>, <span class="number">0</span>, stage_width, stage_height, x, y);</span><br><span class="line">        x += stage_width;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; text_surface = <span class="built_in">GetCurrentText</span>();</span><br><span class="line">    <span class="type">int</span> text_x = (<span class="built_in">ScreenWidth</span>() - <span class="built_in">gr_get_width</span>(text_surface)) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> text_y = <span class="built_in">GetTextBaseline</span>();</span><br><span class="line">    <span class="built_in">gr_color</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">DrawTextIcon</span>(text_x, text_y, text_surface);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Draws the animation and progress bar (if any) on the screen. Does not flip pages. Should only be</span></span><br><span class="line"><span class="comment">// called with updateMutex locked.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScreenRecoveryUI::draw_foreground_locked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current_icon_ != NONE) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; frame = <span class="built_in">GetCurrentFrame</span>();</span><br><span class="line">    <span class="type">int</span> frame_width = <span class="built_in">gr_get_width</span>(frame);</span><br><span class="line">    <span class="type">int</span> frame_height = <span class="built_in">gr_get_height</span>(frame);</span><br><span class="line">    <span class="type">int</span> frame_x = (<span class="built_in">ScreenWidth</span>() - frame_width) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> frame_y = <span class="built_in">GetAnimationBaseline</span>();</span><br><span class="line">    <span class="built_in">DrawSurface</span>(frame, <span class="number">0</span>, <span class="number">0</span>, frame_width, frame_height, frame_x, frame_y);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>有没有发现一个是foreground，一个是background。继续看：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Redraws everything on the screen. Does not flip pages. Should only be called with updateMutex</span></span><br><span class="line"><span class="comment">// locked.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScreenRecoveryUI::draw_screen_locked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!show_text) &#123;</span><br><span class="line">    <span class="built_in">draw_background_locked</span>();</span><br><span class="line">    <span class="built_in">draw_foreground_locked</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">gr_color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="built_in">gr_clear</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clang-format off</span></span><br><span class="line">  <span class="type">static</span> std::vector&lt;std::string&gt; REGULAR_HELP&#123;</span><br><span class="line">    <span class="string">&quot;Use volume up/down and power.&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">static</span> std::vector&lt;std::string&gt; LONG_PRESS_HELP&#123;</span><br><span class="line">    <span class="string">&quot;Any button cycles highlight.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Long-press activates.&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// clang-format on</span></span><br><span class="line">  <span class="built_in">draw_menu_and_text_buffer_locked</span>(<span class="built_in">HasThreeButtons</span>() ? REGULAR_HELP : LONG_PRESS_HELP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>draw_screen_locked()</code>会根据<code>show_text</code>来区分，<code>draw_menu_and_text_buffer_locked()</code>才是recovery menu的drawer。</p><p>ok，我们转看下<code>show_text</code>:</p><blockquote><p>  –show_text - show the recovery text menu, used by some bootloader (e.g. <a href="http://b/36872519">http://b/36872519</a>).</p></blockquote><p>说的很清楚，这个变量就代表是否要show recovery text menu。</p><p>我们看下recovery入口：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ui-&gt;<span class="built_in">SetBackground</span>(RecoveryUI::NONE);</span><br><span class="line"><span class="keyword">if</span> (show_text) ui-&gt;<span class="built_in">ShowText</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Starting recovery (pid &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;) on &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;start);</span><br></pre></td></tr></table></figure><p><code>show_text</code>默认是false，如果带上参数<code>show_text</code>就直接show menu。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">option</span> OPTIONS[] = &#123;</span><br><span class="line">  &#123; <span class="string">&quot;fastboot&quot;</span>, no_argument, <span class="literal">nullptr</span>, <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;locale&quot;</span>, required_argument, <span class="literal">nullptr</span>, <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;show_text&quot;</span>, no_argument, <span class="literal">nullptr</span>, <span class="string">&#x27;t&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> show_text = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> fastboot = <span class="literal">false</span>;</span><br><span class="line">std::string locale;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arg;</span><br><span class="line"><span class="type">int</span> option_index;</span><br><span class="line"><span class="keyword">while</span> ((arg = <span class="built_in">getopt_long</span>(args_to_parse.<span class="built_in">size</span>() - <span class="number">1</span>, args_to_parse.<span class="built_in">data</span>(), <span class="string">&quot;&quot;</span>, OPTIONS,</span><br><span class="line">                          &amp;option_index)) != <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (arg) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">      show_text = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>最终会走到<code>start_recovery()</code>，同样这里<code>just_exit</code>也是默认false。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Device::BuiltinAction <span class="title">start_recovery</span><span class="params">(Device* device, <span class="type">const</span> std::vector&lt;std::string&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">option</span> OPTIONS[] = &#123;</span><br><span class="line">...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!just_exit) &#123;</span><br><span class="line">    <span class="comment">// If this is an eng or userdebug build, automatically turn on the text display if no command</span></span><br><span class="line">    <span class="comment">// is specified. Note that this should be called before setting the background to avoid</span></span><br><span class="line">    <span class="comment">// flickering the background image.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_ro_debuggable</span>()) &#123;</span><br><span class="line">      ui-&gt;<span class="built_in">ShowText</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    status = INSTALL_NONE;  <span class="comment">// No command specified</span></span><br><span class="line">    ui-&gt;<span class="built_in">SetBackground</span>(RecoveryUI::NO_COMMAND);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意了，只要是eng or userdebug版本，就直接call <code>-&gt;ShowText</code>也就是show menu了。所以原生user版本才会出现小机器人。</p><p>看下<code>ShowText()</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScreenRecoveryUI::ShowText</span><span class="params">(<span class="type">bool</span> visible)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(updateMutex)</span></span>;</span><br><span class="line">  show_text = visible;</span><br><span class="line">  <span class="keyword">if</span> (show_text) show_text_ever = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">update_screen_locked</span>(); <span class="comment">//tj</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Determine the next action.</span></span><br><span class="line"><span class="comment">//  - If the state is INSTALL_REBOOT, device will reboot into the target as specified in</span></span><br><span class="line"><span class="comment">//    `next_action`.</span></span><br><span class="line"><span class="comment">//  - If the recovery menu is visible, prompt and wait for commands.</span></span><br><span class="line"><span class="comment">//  - If the state is INSTALL_NONE, wait for commands (e.g. in user build, one manually boots</span></span><br><span class="line"><span class="comment">//    into recovery to sideload a package or to wipe the device).</span></span><br><span class="line"><span class="comment">//  - In all other cases, reboot the device. Therefore, normal users will observe the device</span></span><br><span class="line"><span class="comment">//    rebooting a) immediately upon successful finish (INSTALL_SUCCESS); or b) an &quot;error&quot; screen</span></span><br><span class="line"><span class="comment">//    for 5s followed by an automatic reboot.</span></span><br><span class="line"><span class="keyword">if</span> (status != INSTALL_REBOOT) &#123;</span><br><span class="line">  <span class="keyword">if</span> (status == INSTALL_NONE || ui-&gt;<span class="built_in">IsTextVisible</span>()) &#123;</span><br><span class="line">    Device::BuiltinAction temp = <span class="built_in">prompt_and_wait</span>(device, status);</span><br><span class="line">    <span class="keyword">if</span> (temp != Device::NO_ACTION) &#123;</span><br><span class="line">      next_action = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看注释，<code>INSTALL_NONE</code>的状态就是<code>No command</code>，会进入<code>prompt_and_wait()</code>。</p><p>ok，到这里基本清楚了<code>No command</code>的由来。下面主要看下如何才能进入菜单，这里涉及到按键事件处理。</p><p>UI初始化时会有按键探测：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RecoveryUI::Init</span><span class="params">(<span class="type">const</span> std::string&amp; <span class="comment">/* locale */</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ev_init</span>(std::<span class="built_in">bind</span>(&amp;RecoveryUI::OnInputEvent, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2),</span><br><span class="line">          touch_screen_allowed_);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ev_iterate_available_keys</span>(std::<span class="built_in">bind</span>(&amp;RecoveryUI::OnKeyDetected, <span class="keyword">this</span>, std::placeholders::_1));</span><br></pre></td></tr></table></figure><p>一个是<code>OnInputEvent()</code>一个是<code>OnKeyDetected()</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecoveryUI::OnInputEvent</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> epevents)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">input_event</span> ev;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ev_get_input</span>(fd, epevents, &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (ev.type == EV_KEY &amp;&amp; ev.code &lt;= KEY_MAX) &#123; <span class="comment">//tj: here</span></span><br><span class="line">    <span class="keyword">if</span> (touch_screen_allowed_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ev.code == BTN_TOUCH) &#123;</span><br><span class="line">        <span class="comment">// A BTN_TOUCH with value 1 indicates the start of contact (protocol A), with 0 means</span></span><br><span class="line">        <span class="comment">// lifting the contact.</span></span><br><span class="line">        touch_finger_down_ = (ev.value == <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Intentionally ignore BTN_TOUCH and BTN_TOOL_FINGER, which would otherwise trigger</span></span><br><span class="line">      <span class="comment">// additional scrolling (because in ScreenRecoveryUI::ShowFile(), we consider keys other than</span></span><br><span class="line">      <span class="comment">// KEY_POWER and KEY_UP as KEY_DOWN).</span></span><br><span class="line">      <span class="keyword">if</span> (ev.code == BTN_TOUCH || ev.code == BTN_TOOL_FINGER) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ProcessKey</span>(ev.code, ev.value); <span class="comment">//tj: here</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>ProcessKey()</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Processes a key-up or -down event. A key is &quot;registered&quot; when it is pressed and then released,</span></span><br><span class="line"><span class="comment">// with no other keypresses or releases in between. Registered keys are passed to CheckKey() to</span></span><br><span class="line"><span class="comment">// see if it should trigger a visibility toggle, an immediate reboot, or be queued to be processed</span></span><br><span class="line"><span class="comment">// next time the foreground thread wants a key (eg, for the menu).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We also keep track of which keys are currently down so that CheckKey() can call IsKeyPressed()</span></span><br><span class="line"><span class="comment">// to see what other keys are held when a key is registered.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// updown == 1 for key down events; 0 for key up events</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RecoveryUI::ProcessKey</span><span class="params">(<span class="type">int</span> key_code, <span class="type">int</span> updown)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> register_key = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">bool</span> long_press = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br></pre></td></tr></table></figure><p>看注释，一个按键的up和down是registered key。注意<code>We also keep track...</code>，跟踪的是registered key和other keys。</p><p><code>CheckKey()</code>会决定是否要显示，ok，再看代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RecoveryUI::ProcessKey</span><span class="params">(<span class="type">int</span> key_code, <span class="type">int</span> updown)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">bool</span> reboot_enabled = enable_reboot;</span><br><span class="line">  <span class="keyword">if</span> (register_key) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">CheckKey</span>(key_code, long_press)) &#123;</span><br><span class="line">      <span class="keyword">case</span> RecoveryUI::IGNORE:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> RecoveryUI::TOGGLE:</span><br><span class="line">        <span class="built_in">ShowText</span>(!<span class="built_in">IsTextVisible</span>()); <span class="comment">//tj</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>也就是<code>CheckKey()</code>返回的是<code>TOGGLE</code>就会显示菜单，前提不显示菜单(<code>show_text</code>是false)时：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ScreenRecoveryUI::IsTextVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(updateMutex)</span></span>;</span><br><span class="line">  <span class="type">int</span> visible = show_text;</span><br><span class="line">  <span class="keyword">return</span> visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，下来看看到底什么按键才能让<code>No command</code>再进入菜单界面：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">RecoveryUI::KeyAction <span class="title">RecoveryUI::CheckKey</span><span class="params">(<span class="type">int</span> key, <span class="type">bool</span> is_long_press)</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(key_queue_mutex)</span></span>;</span><br><span class="line">    key_long_press = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we have power and volume up keys, that chord is the signal to toggle the text display.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">HasThreeButtons</span>() || (<span class="built_in">HasPowerKey</span>() &amp;&amp; <span class="built_in">HasTouchScreen</span>() &amp;&amp; touch_screen_allowed_)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((key == KEY_VOLUMEUP || key == KEY_UP) &amp;&amp; <span class="built_in">IsKeyPressed</span>(KEY_POWER)) &#123;</span><br><span class="line">      <span class="keyword">return</span> TOGGLE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> RecoveryUI::<span class="built_in">IsKeyPressed</span>(<span class="type">int</span> key) &#123;</span><br><span class="line">  std::lock_guard&lt;std::mutex&gt; <span class="built_in">lg</span>(key_queue_mutex);</span><br><span class="line">  <span class="type">int</span> pressed = key_pressed[key];</span><br><span class="line">  <span class="keyword">return</span> pressed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，你应该知道如何进入了。如果还不知道怎么操作，check below:</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recovery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KPW3软越狱实践</title>
      <link href="/kpw3-sw-jailbreak.html"/>
      <url>/kpw3-sw-jailbreak.html</url>
      
        <content type="html"><![CDATA[<p>这几天酝酿着干一件事，就是越狱Kindle，今天终于完成，要得就是自定义屏保，先上美图：</p><p><img src="http://tjtech.me/usr/uploads/2020/03/1132614266.jpg" alt="kpw3-linkss-mk1.jpg"></p><p>之前买过Kindle 558，x宝购入，美版原装，越狱和固件版本有关，看了多个帖子，这台558固件不支持软越狱，拆机好像可以，我基本上看的网上下载PDF，想立即体验下koreader重排PDF。</p><p>x米最近也出了一款电子书，有背光灯看重的就是PDF重排，599.00，可是PDF体验不行，导入几个PDF唤醒时多次有如下图ANR，这款米的安卓Go系统看来还是没有Kindle系统稳定，直接退了。</p><p><img src="http://tjtech.me/usr/uploads/2020/03/1084847672.png" alt="mird-anr.png"></p><p>Kindle最近出了PW4，纯平防水夜间模式，看了帖子说没PW3阅读体验好，还略贵，综合考虑还是买个PW3，x猫国际649.00，客服问了半天不能指定快递，x宝搜了一把599.00 4G美版官配，加了12快shunfen，再加个19.9外壳，完美:)</p><p>haha，越狱后有暗黑模式，不算太闪啊，赚了。</p><p>我的PW3 5.9.4整个操作过程主要是下面4步，还好没遇到坑：</p><ul><li><strong>Step1: 飞行模式下手动升级到5.9.6.1</strong></li></ul><p>refer: <a href="https://bookfere.com/post/4.html#update_step">手动升级Kindle教程</a></p><ul><li><strong>Step2: 绑定亚马逊帐号</strong></li></ul><p>用路由器不行就用手机的热点试试，登陆后再开飞行模式。</p><ul><li><strong>Step3: 安装并越狱特制固件</strong></li></ul><p>refer: <a href="https://bookfere.com/post/576.html">Kindle Paperwhite 3（5.9.6.1）越狱教程</a></p><ul><li><strong>Step4: 安装插件</strong></li></ul><p>refer: <a href="https://bookfere.com/post/311.html">Kindle 越狱插件资源下载及详细安装步骤</a></p><p>这里有个插件usbnet可以直接wifi登陆，不用插usb，方便啊，基本可以释放usb了，贴个图：</p><p><img src="http://tjtech.me/usr/uploads/2020/03/1407652863.png" alt="kpw3-sftp.png"></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kindle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to install SlickEdit under arm64 Linux</title>
      <link href="/how-to-install-slickedit-under-arm64.html"/>
      <url>/how-to-install-slickedit-under-arm64.html</url>
      
        <content type="html"><![CDATA[<p>有些时候，我们需要在ARM Linux上看代码，Source Insight一直没出Linux版（why?），可以用Wine，不过在ARM上有点复杂，这里主要说下一款叫 <a href="https://www.slickedit.com/">SlickEdit</a> 的代码编辑器，有Linux版本（not free），官方介绍是：</p><blockquote><p>SlickEdit - The most powerful code editor available featuring source analysis (tagging), syntax expansion, beautifiers, beautify while typing, symbol coloring, and source diff.</p></blockquote><p>安装程序是vsinst, it’s for x86-64 like below:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vsinst: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="keyword">for</span> GNU/Linux     2.6.9, not stripped</span><br></pre></td></tr></table></figure><p>my host: arm64 debian.</p><p><strong>Step1: 安装qemu &amp; binfmt-support</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install qemu binfmt-support</span><br></pre></td></tr></table></figure><p><strong>Step2: 添加x86-64架构</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg --add-architecture amd64</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p><strong>Step3: 安装vsinst所需packages</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libc6:amd64 libxt6:amd64</span><br></pre></td></tr></table></figure><p><strong>Step4: 运行vsinst</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./vsinst</span><br></pre></td></tr></table></figure><p>安装过程有个错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu: uncaught target signal 11 (Segmentation fault) - core dumped</span><br></pre></td></tr></table></figure><p>安装成功提示如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*************************************************************</span><br><span class="line">*           INSTALLATION SUCCESSFULLY COMPLETED</span><br><span class="line">*************************************************************</span><br><span class="line"></span><br><span class="line">NOTES:</span><br><span class="line">1. Type &quot;/opt/slickedit-pro2017/bin/vs&quot; to run SlickEdit Pro.</span><br><span class="line">2. You may want to add &quot;/opt/slickedit-pro2017/bin/&quot; to your users&#x27; PATH.</span><br></pre></td></tr></table></figure><p><strong>Step5: 安装vs_exe所需packages</strong></p><p>运行程序是vs_exe:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/slickedit-pro2017/bin/vs_exe: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="keyword">for</span> GNU/Linux 2.6.9, not stripped</span><br></pre></td></tr></table></figure><p>ok, let’s run it, but has below error:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/slickedit-pro2017/bin/vs_exe: error <span class="keyword">while</span> loading shared libraries: libgthread-2.0.so.0: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>安装如下包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libglib2.0-0:amd64</span><br></pre></td></tr></table></figure><p>还要安装以下包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libfreetype6:amd64 libxrender1:amd64 libfontconfig1:amd64 libxext6:amd64 libncurses5:amd64</span><br></pre></td></tr></table></figure><p>到这，slickedit可以跑起来了哈，如下图，就是cpu有点高，有时打开挂了。</p><p><img src="http://tjtech.me/usr/uploads/2020/02/1543992789.png" alt="slickedit-pro.png"></p><h2 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h2><p><a href="https://wiki.debian.org/QemuUserEmulation">https://wiki.debian.org/QemuUserEmulation</a></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> slickedit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Use Beautiful Soup4 to pull weather</title>
      <link href="/pull-weather-via-beautiful-soup.html"/>
      <url>/pull-weather-via-beautiful-soup.html</url>
      
        <content type="html"><![CDATA[<p>Recently, i found i can not get weather forecast from <a href="http://wxdata.weather.com/wxdata">http://wxdata.weather.com/wxdata</a> as below:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">This service is deprecated as of 01/15/2020</span><br></pre></td></tr></table></figure><p>ok, i’m using pywapi-0.3.8 to show weather forecast on screen under raspberry pi. </p><p>A good method instead is using <em>Beautiful Soup</em> which is very useful tool to pull the data although possible speed performance. i think rpi can handle it.</p><p>Yes, i just wrote the similar python lib to compatible with pywapi for part of weather.com. haha, it looks nice… the icon index is same as before, great…</p><p>Although, python is not new to me, i can use it. maybe refactor in further.</p><p>Watch the below picture，same same as before…</p><p><img src="http://tjtech.me/usr/uploads/2020/01/1502570704.jpg" alt="wea.jpg"></p><h2 id="refer-doc"><a href="#refer-doc" class="headerlink" title="refer doc"></a>refer doc</h2><ul><li><a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/">https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/</a></li><li><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/">https://www.crummy.com/software/BeautifulSoup/bs4/doc/</a></li></ul><p>PS: From now, we are experiencing <a href="https://github.com/wuhan2020/wuhan2020"><em>wuhan2020</em>！</a></p>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解决Gmail登录失败时Invalid credentials错误问题</title>
      <link href="/how-to-fix-imap-invalid-credentials-for-gmail.html"/>
      <url>/how-to-fix-imap-invalid-credentials-for-gmail.html</url>
      
        <content type="html"><![CDATA[<p>今天git sendmail(gmail)出现如下错误：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Send this email? ([y]es|[n]o|[q]uit|[a]ll): y</span><br><span class="line">5.7.8 Username and Password not accepted. Learn more at</span><br><span class="line">5.7.8  https://support.google.com/mail/?p=BadCredentials z14sm5898723pgj.43 - gsmtp</span><br></pre></td></tr></table></figure><p>打开Win下一个客户端看了下也有错误:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[11:09:18] IMAP&lt; Invalid credentials (Failure)</span><br><span class="line">** IMAP error on imap.gmail.com: LOGIN error</span><br><span class="line">[11:09:18] IMAP&lt; Error logging in to imap.gmail.com</span><br></pre></td></tr></table></figure><p>以前都是ok的，估计server端问题，可以修改Google账户配置：</p><p>step1: 登录Google账户点击导航栏中<em>Security</em>，如下图：</p><p><img src="http://tjtech.me/usr/uploads/2020/01/1677938053.png" alt="ga-s1.png"></p><p>step2: 页面下方<em>Less secure app access</em>面板打开即可如下图：</p><p><img src="http://tjtech.me/usr/uploads/2020/01/1086771392.png" alt="gc-s2.png"></p><p>ps: 图上是已经打开的。</p><p>wait a min then try again, git sendmail and client are all ok now in my side:)</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux patch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android AB retry count分析</title>
      <link href="/analyze-ab-retry-count-decreasement-under-uefi.html"/>
      <url>/analyze-ab-retry-count-decreasement-under-uefi.html</url>
      
        <content type="html"><![CDATA[<p>A&#x2F;B系统是Android设计给OTA用，前面有文章分析过，只不过是LK下。现在看下QCOM UEFI下对A&#x2F;B retry count是否递减的逻辑。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line"><span class="title function_">FindBootableSlot</span> <span class="params">(Slot *BootableSlot)</span></span><br><span class="line">&#123;</span><br><span class="line">  Unbootable = (BootEntry-&gt;PartEntry.Attributes &amp; PART_ATT_UNBOOTABLE_VAL) &gt;&gt;</span><br><span class="line">               PART_ATT_UNBOOTABLE_BIT;</span><br><span class="line">  BootSuccess = (BootEntry-&gt;PartEntry.Attributes &amp; PART_ATT_SUCCESSFUL_VAL) &gt;&gt;</span><br><span class="line">                PART_ATT_SUCCESS_BIT;</span><br><span class="line">  RetryCount =</span><br><span class="line">      (BootEntry-&gt;PartEntry.Attributes &amp; PART_ATT_MAX_RETRY_COUNT_VAL) &gt;&gt;</span><br><span class="line">      PART_ATT_MAX_RETRY_CNT_BIT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Unbootable == <span class="number">0</span> &amp;&amp; BootSuccess == <span class="number">1</span>) &#123;</span><br><span class="line">    DEBUG (</span><br><span class="line">        (EFI_D_VERBOSE, <span class="string">&quot;Active Slot %s is bootable\n&quot;</span>, BootableSlot-&gt;Suffix));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Unbootable == <span class="number">0</span> &amp;&amp; BootSuccess == <span class="number">0</span> &amp;&amp; RetryCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((!IsABRetryCountDisabled () &amp;&amp;</span><br><span class="line">        !IsBootDevImage ()) &amp;&amp;</span><br><span class="line">      IsABRetryCountUpdateRequired ()</span><br><span class="line">      )&#123;</span><br><span class="line">      RetryCount--; <span class="comment">//tj: here</span></span><br><span class="line">      BootEntry-&gt;PartEntry.Attributes &amp;= ~PART_ATT_MAX_RETRY_COUNT_VAL;</span><br><span class="line">      BootEntry-&gt;PartEntry.Attributes |= RetryCount</span><br><span class="line">                                         &lt;&lt; PART_ATT_MAX_RETRY_CNT_BIT;</span><br><span class="line">      UpdatePartitionAttributes (PARTITION_ATTRIBUTES);</span><br><span class="line">      DEBUG ((EFI_D_INFO, <span class="string">&quot;Active Slot %s is bootable, retry count %ld\n&quot;</span>,</span><br><span class="line">              BootableSlot-&gt;Suffix, RetryCount));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      DEBUG ((EFI_D_INFO, <span class="string">&quot;A/B retry count NOT decremented\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DEBUG ((EFI_D_INFO, <span class="string">&quot;Slot %s is unbootable, trying alternate slot\n&quot;</span>,</span><br><span class="line">            BootableSlot-&gt;Suffix));</span><br><span class="line">    GUARD_OUT (HandleActiveSlotUnbootable ());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果当前槽是可以启动的(<code>Unbootable == 0</code>)而且成功起来过(<code>BootSuccess == 1</code>)就直接启动了，一般都是非第一次系统启动。</p><p>如果可以启动但是没有成功起来过(比如刚刷完机)启动次数还有时：</p><p>case1: 如果A&#x2F;B次数被禁用了，就不减，有个feature宏控制。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AB_RETRYCOUNT_DISABLE</span></span><br><span class="line">BOOLEAN <span class="title function_">IsABRetryCountDisabled</span> <span class="params">(VOID)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">BOOLEAN <span class="title function_">IsABRetryCountDisabled</span> <span class="params">(VOID)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>case2: 如果是<code>IsBootDevImage()</code>，也不减。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOLEAN <span class="title function_">IsBootDevImage</span> <span class="params">(VOID)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> BootDevImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line"><span class="title function_">BootLinux</span> <span class="params">(BootInfo *Info)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (AsciiStrStr (BootParamlistPtr.CmdLine, <span class="string">&quot;root=&quot;</span>)) &#123;</span><br><span class="line">    BootDevImage = TRUE;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>应该是cmdline带了<code>root=</code>，有个提交：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">commit <span class="number">6</span>a54fe1c4a886ea1560fe617dfc975776d3edf97</span><br><span class="line">Author: Channagoud Kadabi &lt;ckadabi@codeaurora.org&gt;</span><br><span class="line">Date:   Fri Jun <span class="number">2</span> <span class="number">17</span>:<span class="number">00</span>:<span class="number">56</span> <span class="number">2017</span> <span class="number">-0700</span></span><br><span class="line"></span><br><span class="line">    QcommodulePkg: BootLib: <span class="keyword">do</span> no decrement retry count on dev images</span><br><span class="line"></span><br><span class="line">    Dev images with custom userspace/ramdisk <span class="keyword">do</span> not have slot successful</span><br><span class="line">    <span class="built_in">set</span>, <span class="keyword">do</span> not decrement retry count <span class="keyword">for</span> such custom images.</span><br><span class="line"></span><br><span class="line">    Change-Id: Ia37e853b40b41bb62c766838d6a7efc4b37f4427</span><br></pre></td></tr></table></figure><p>一般不用。</p><p>case3: if no case1而且no case2，我们根据boot into mode来决定是否递减。</p><p>也就是<code>IsABRetryCountUpdateRequired()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOLEAN <span class="title function_">IsABRetryCountUpdateRequired</span> <span class="params">(VOID)</span></span><br><span class="line">&#123;</span><br><span class="line">  BOOLEAN BatteryStatus;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check power off charging */</span></span><br><span class="line">  TargetPauseForBatteryCharge (&amp;BatteryStatus);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Do not decrement bootable retry count in below states:</span></span><br><span class="line"><span class="comment">     * fastboot, fastbootd, charger, recovery</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">if</span> ((BatteryStatus &amp;&amp;</span><br><span class="line">       IsChargingScreenEnable ()) ||</span><br><span class="line">       BootIntoFastboot ||</span><br><span class="line">       BootIntoRecovery) &#123;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释写的很清楚了，fastboot&#x2F;fastbootd&#x2F;charger&#x2F;recovery state不减。</p><p>note that <code>IsChargingScreenEnable()</code>。</p><p>提下fastbootd是userspace fastboot，是dynamic partition（动态分区，Android Q引入）里的东东。</p><p>Done.</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> A/B </tag>
            
            <tag> uefi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定屏问题分析</title>
      <link href="/analyze-an-issue-about-screen-freeze.html"/>
      <url>/analyze-an-issue-about-screen-freeze.html</url>
      
        <content type="html"><![CDATA[<p>QCOM Android Q平台，现场adb不可用，TP不能用，Kernel 4.x。</p><p>热键进入ramdump mode，导出RAM后check kernel log，发现如下eMMC错误:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[41534.077689] mmc0: Reset 0x4 never completed.</span><br><span class="line">[41534.077715] mmc0: sdhci: ============ SDHCI REGISTER DUMP ===========</span><br><span class="line">[41534.077722] mmc0: sdhci: Sys addr:  0x00000000 | Version:  0x00007202</span><br><span class="line">[41534.077728] mmc0: sdhci: Blk size:  0x00000200 | Blk cnt:  0x00000001</span><br><span class="line">[41534.077733] mmc0: sdhci: Argument:  0x002c0046 | Trn mode: 0x00000013</span><br><span class="line">...</span><br><span class="line">[41534.077814] ----------- VENDOR REGISTER DUMP -----------</span><br><span class="line">[41534.077816] ---- Debug RAM dump ----</span><br><span class="line">[41534.077823] cmdq-host: Debug RAM wrap-around: 0x0000ff80 | Debug RAM overlap: 0x00000596</span><br><span class="line">[41534.077828] cmdq-host: Debug RAM dump [0]: 0x0000014d</span><br><span class="line">[41534.077834] cmdq-host: Debug RAM dump [1]: 0x0000006c</span><br></pre></td></tr></table></figure><p>ok，上code:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* hw clears the bit when it&#x27;s done */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">bool</span> timedout = ktime_after(ktime_get(), timeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(sdhci_readb(host, SDHCI_SOFTWARE_RESET) &amp; mask))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (timedout) &#123;</span><br><span class="line">                pr_err(<span class="string">&quot;%s: Reset 0x%x never completed.\n&quot;</span>, <span class="comment">//tj: here</span></span><br><span class="line">                        mmc_hostname(host-&gt;mmc), (<span class="type">int</span>)mask);</span><br><span class="line">                MMC_TRACE(host-&gt;mmc, <span class="string">&quot;%s: Reset 0x%x never completed\n&quot;</span>,</span><br><span class="line">                                __func__, (<span class="type">int</span>)mask);</span><br><span class="line">                <span class="keyword">if</span> ((host-&gt;quirks2 &amp; SDHCI_QUIRK2_USE_RESET_WORKAROUND)</span><br><span class="line">                        &amp;&amp; host-&gt;ops-&gt;reset_workaround) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!host-&gt;reset_wa_applied) &#123;</span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                 * apply the workaround and issue</span></span><br><span class="line"><span class="comment">                                 * reset again.</span></span><br><span class="line"><span class="comment">                                 */</span></span><br><span class="line">                                host-&gt;ops-&gt;reset_workaround(host, <span class="number">1</span>);</span><br><span class="line">                                host-&gt;reset_wa_applied = <span class="number">1</span>;</span><br><span class="line">                                host-&gt;reset_wa_cnt++;</span><br><span class="line">                                <span class="keyword">goto</span> retry_reset;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                pr_err(<span class="string">&quot;%s: Reset 0x%x failed with workaround\n&quot;</span>,</span><br><span class="line">                                        mmc_hostname(host-&gt;mmc),</span><br><span class="line">                                        (<span class="type">int</span>)mask);</span><br><span class="line">                                <span class="comment">/* clear the workaround */</span></span><br><span class="line">                                host-&gt;ops-&gt;reset_workaround(host, <span class="number">0</span>);</span><br><span class="line">                                host-&gt;reset_wa_applied = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                sdhci_dumpregs(host); <span class="comment">//tj:here</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        udelay(<span class="number">10</span>); <span class="comment">//tj: delay, if not timeout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sdhci_dumpregs</span><span class="params">(<span class="keyword">struct</span> sdhci_host *host)</span></span><br><span class="line">&#123;</span><br><span class="line">        MMC_TRACE(host-&gt;mmc,</span><br><span class="line">                <span class="string">&quot;%s: 0x04=0x%08x 0x06=0x%08x 0x0E=0x%08x 0x30=0x%08x 0x34=0x%08x 0x38=0x%08x\n&quot;</span>,</span><br><span class="line">                __func__,</span><br><span class="line">                sdhci_readw(host, SDHCI_BLOCK_SIZE),</span><br><span class="line">                sdhci_readw(host, SDHCI_BLOCK_COUNT),</span><br><span class="line">                sdhci_readw(host, SDHCI_COMMAND),</span><br><span class="line">                sdhci_readl(host, SDHCI_INT_STATUS),</span><br><span class="line">                sdhci_readl(host, SDHCI_INT_ENABLE),</span><br><span class="line">                sdhci_readl(host, SDHCI_SIGNAL_ENABLE));</span><br><span class="line">        mmc_stop_tracing(host-&gt;mmc);</span><br><span class="line"></span><br><span class="line">        SDHCI_DUMP(<span class="string">&quot;============ SDHCI REGISTER DUMP ===========\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>so，是<code>timedout</code>导致的这个问题，我们追下why timeout。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">ktime_compare</span><span class="params">(<span class="type">const</span> <span class="type">ktime_t</span> cmp1, <span class="type">const</span> <span class="type">ktime_t</span> cmp2)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp1 &lt; cmp2)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cmp1 &gt; cmp2)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ktime_after - Compare if a ktime_t value is bigger than another one.</span></span><br><span class="line"><span class="comment"> * @cmp1:       comparable1</span></span><br><span class="line"><span class="comment"> * @cmp2:       comparable2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: true if cmp1 happened after cmp2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">ktime_after</span><span class="params">(<span class="type">const</span> <span class="type">ktime_t</span> cmp1, <span class="type">const</span> <span class="type">ktime_t</span> cmp2)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> ktime_compare(cmp1, cmp2) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, 说明 <code>cmp1</code>&gt;<code>cmp2</code>。也就是<code>ktime_get()</code> &gt; <code>timeout</code>。把前面的code check下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sdhci_reset</span><span class="params">(<span class="keyword">struct</span> sdhci_host *host, u8 mask)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">ktime_t</span> timeout;</span><br><span class="line"></span><br><span class="line">retry_reset:</span><br><span class="line">        sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mask &amp; SDHCI_RESET_ALL) &#123;</span><br><span class="line">                host-&gt;clock = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">/* Reset-all turns off SD Bus Power */</span></span><br><span class="line">                <span class="keyword">if</span> (host-&gt;quirks2 &amp; SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON)</span><br><span class="line">                        sdhci_runtime_pm_bus_off(host);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Wait max 100 ms */</span></span><br><span class="line">        timeout = ktime_add_ms(ktime_get(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (host-&gt;ops-&gt;check_power_status &amp;&amp; host-&gt;pwr &amp;&amp;</span><br><span class="line">            (mask &amp; SDHCI_RESET_ALL))</span><br><span class="line">                host-&gt;ops-&gt;check_power_status(host, REQ_BUS_OFF);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* clear pending normal/error interrupt status */</span></span><br><span class="line">        sdhci_writel(host, sdhci_readl(host, SDHCI_INT_STATUS),</span><br><span class="line">                        SDHCI_INT_STATUS);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">ktime_t</span> <span class="title function_">ktime_add_ms</span><span class="params">(<span class="type">const</span> <span class="type">ktime_t</span> kt, <span class="type">const</span> u64 msec)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> ktime_add_ns(kt, msec * NSEC_PER_MSEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Add a ktime_t variable and a scalar nanosecond value.</span></span><br><span class="line"><span class="comment"> * res = kt + nsval:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ktime_add_ns(kt, nsval)         ((kt) + (nsval))</span></span><br></pre></td></tr></table></figure><p><code>timeout</code>也就是<code>ktime_get()</code> + 100ms，也就是说过了100ms，SDHCI_SOFTWARE_RESET还没完成，而且也没有走workaround。</p><p>为啥会这样？一开始以为是个体问题，后来发现有app在ms级操作eMMC，就是他了:) although not confirm. rt?</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> freeze screen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android boot state说明</title>
      <link href="/boot-state-in-android.html"/>
      <url>/boot-state-in-android.html</url>
      
        <content type="html"><![CDATA[<p>之前遇到了avb提示”device is corrupt”的问题，涉及boot state。我们先看下官方的说明，目前是Android 10：</p><blockquote><p>After determining the boot state of a device, you need to communicate that state to the user. If the device doesn’t have any issues, then proceed without displaying anything. Verified Boot issues fall into these categories:</p><ul><li>YELLOW: Warning screen for LOCKED devices with custom root of trust set</li><li>ORANGE: Warning screen for UNLOCKED devices</li><li>RED (eio): Warning screen for dm-verity corruption</li><li>RED (no os found): No valid OS found</li></ul></blockquote><p>YELLOW先略过，ORAGE就是当前设备unlocked了，以前也有文章分析过。这里主要看下之前遇到的RED eio state(屏幕打印txt一样)：</p><blockquote><p>dm-verity corruption</p><p>Show a RED eio screen if a valid version of Android is found and the device is currently in the eio dm-verity mode. The user needs to click the power button to continue. If the user hasn’t acknowledged the warning screen within 30 seconds, the device powers off (to protect the screen against burn-in and save power).</p></blockquote><p>如果找到一个有效的Android版本并且当前设备是在eio dm-verity mode时show RED eio screen。</p><p><img src="http://tjtech.me/usr/uploads/2019/11/2847281231.png" alt="android-red-eio-screen.png"></p><p>Android系统有效？eio dm-verity mode是啥？</p><p>先不看code，我们继续看官方相关文档说明：</p><blockquote><p>Verified boot requires cryptographically verifying all executable code and data that is part of the Android version being booted before it is used. This includes the kernel (loaded from the boot partition), the device tree (loaded from the dtbo partition), system partition, vendor partition, and so on.</p><p>Small partitions, such as boot and dtbo, that are read only once are typically verified by loading the entire contents into memory and then calculating its hash. This calculated hash value is then compared to the expected hash value. If the value doesn’t match, Android won’t load. For more details, see Boot Flow.</p><p>Larger partitions that won’t fit into memory (such as, file systems) may use a hash tree where verification is a continuous process happening as data is loaded into memory. In this case, the root hash of the hash tree is calculated during run time and is checked against the expected root hash value. Android includes the dm-verity driver to verify larger partitions. If at some point the calculated root hash doesn’t match the expected root hash value, the data is not used and Android enters an error state. For more details, see dm-verity corruption.</p></blockquote><p>就是说avb会校验数据，小分区boot，dtbo会全部加载到memory去计算hash。大分区如system是用内核的dm-verity来完成。如果有错，会进入一个错误状态，详见dm-verity corruption。这里官方有个link会转到上面提到的RED eio screen。</p><p>啥子？system数据有问题？avbtool等check了下么问题啊，怎么check后面再写篇哈。</p><p>这可是官网说明啊。我们回看上次的root cause log:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">avb_slot_verify.c:657: ERROR: vbmeta_system_a: Image rollback index is less than the stored rollback index.</span><br></pre></td></tr></table></figure><p>uefi下的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX</span><br></pre></td></tr></table></figure><p>我们再看下code:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return codes used in avb_slot_verify(), see that function for</span></span><br><span class="line"><span class="comment"> * documentation for each field.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use avb_slot_verify_result_to_string() to get a textual</span></span><br><span class="line"><span class="comment"> * representation usable for error/debug output.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  AVB_SLOT_VERIFY_RESULT_OK,</span><br><span class="line">  AVB_SLOT_VERIFY_RESULT_ERROR_OOM,</span><br><span class="line">  AVB_SLOT_VERIFY_RESULT_ERROR_IO,</span><br><span class="line">  AVB_SLOT_VERIFY_RESULT_ERROR_VERIFICATION,</span><br><span class="line">  AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX,</span><br><span class="line">  AVB_SLOT_VERIFY_RESULT_ERROR_PUBLIC_KEY_REJECTED,</span><br><span class="line">  AVB_SLOT_VERIFY_RESULT_ERROR_INVALID_METADATA,</span><br><span class="line">  AVB_SLOT_VERIFY_RESULT_ERROR_UNSUPPORTED_VERSION,</span><br><span class="line">  AVB_SLOT_VERIFY_RESULT_ERROR_INVALID_ARGUMENT</span><br><span class="line">&#125; AvbSlotVerifyResult;</span><br></pre></td></tr></table></figure><p>对每个field的解释，注释写的很清楚了，不用grep了，直接看<code>avb_slot_verify_result_to_string</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">avb_slot_verify_result_to_string</span><span class="params">(AvbSlotVerifyResult result)</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">    <span class="keyword">case</span> AVB_SLOT_VERIFY_RESULT_OK:</span><br><span class="line">      ret = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVB_SLOT_VERIFY_RESULT_ERROR_OOM:</span><br><span class="line">      ret = <span class="string">&quot;ERROR_OOM&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVB_SLOT_VERIFY_RESULT_ERROR_IO:</span><br><span class="line">      ret = <span class="string">&quot;ERROR_IO&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVB_SLOT_VERIFY_RESULT_ERROR_VERIFICATION:</span><br><span class="line">      ret = <span class="string">&quot;ERROR_VERIFICATION&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX:</span><br><span class="line">      ret = <span class="string">&quot;ERROR_ROLLBACK_INDEX&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVB_SLOT_VERIFY_RESULT_ERROR_PUBLIC_KEY_REJECTED:</span><br><span class="line">      ret = <span class="string">&quot;ERROR_PUBLIC_KEY_REJECTED&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVB_SLOT_VERIFY_RESULT_ERROR_INVALID_METADATA:</span><br><span class="line">      ret = <span class="string">&quot;ERROR_INVALID_METADATA&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVB_SLOT_VERIFY_RESULT_ERROR_UNSUPPORTED_VERSION:</span><br><span class="line">      ret = <span class="string">&quot;ERROR_UNSUPPORTED_VERSION&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVB_SLOT_VERIFY_RESULT_ERROR_INVALID_ARGUMENT:</span><br><span class="line">      ret = <span class="string">&quot;ERROR_INVALID_ARGUMENT&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">/* Do not add a &#x27;default:&#x27; case here because of -Wswitch. */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    avb_error(<span class="string">&quot;Unknown AvbSlotVerifyResult value.\n&quot;</span>);</span><br><span class="line">    ret = <span class="string">&quot;(unknown)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码看，dm-verity corruption应该是<code>AVB_SLOT_VERIFY_RESULT_ERROR_VERIFICATION</code>，而不是<code>AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX</code>。</p><p>相关code再show出来：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (vbmeta_header.rollback_index &lt; stored_rollback_index) &#123;</span><br><span class="line">  avb_errorv(</span><br><span class="line">      full_partition_name,</span><br><span class="line">      <span class="string">&quot;: Image rollback index is less than the stored rollback index.\n&quot;</span>,</span><br><span class="line">      <span class="literal">NULL</span>);</span><br><span class="line">  ret = AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX;</span><br><span class="line">  <span class="keyword">if</span> (!allow_verification_error) &#123;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>what is <code>rollback_index</code> and what is <code>stored_rollback_index</code> and why need to check the value in avb?</p><p>ok, let’s check Android doc since it’s belong to avb, avb doc must intro:</p><p>一看果然有，叫<em>rollback protection</em>，姑且译成回滚保护：</p><blockquote><p>Rollback protection</p><p>Even with a completely secure update process, it’s possible for a non-persistent Android kernel exploit to manually install an older, more vulnerable version of Android, reboot into the vulnerable version, and then use that Android version to install a persistent exploit. From there the attacker permanently owns the device and can do anything, including disabling updates.</p><p>The protection against this class of attacks is called Rollback Protection. Rollback protection is typically implemented by using tamper-evident storage to record the most recent version of the Android and refusing to boot Android if it’s lower than the recorded version. Versions are typically tracked on a per-partition basis.</p><p>For more details on how AVB handles rollback protections, see the AVB README.</p></blockquote><p>奥。。。防止黑客攻击滴。。。好吧。注意提到用<code>tamper-evident storage</code>来记录最近的Android版本并且拒绝启动比这个版本低的。</p><p>ok，终于对上了，人家就这么设计的。</p><p>这个tamper-evident storage是啥意思呢？对eMMC设备而言，就是RPMB分区，也就是说这个rollback index如果放到RPMB里，就别想再降级用了，RPMB想破解，没那么容易？</p><p>另外，吐槽下google文档和qcom uefi code对不上！大大厂啊。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://source.android.com/security/verifiedboot/boot-flow">https://source.android.com/security/verifiedboot/boot-flow</a></p></li><li><p><a href="https://source.android.com/security/verifiedboot/verified-boot">https://source.android.com/security/verifiedboot/verified-boot</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> avb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓刷机后出现device is corrupt后进入fastboot问题分析</title>
      <link href="/analyze-issue-about-device-is-corrupt-then-goto-fastboot-after-flashing.html"/>
      <url>/analyze-issue-about-device-is-corrupt-then-goto-fastboot-after-flashing.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Android 10.0 + QCOM平台 + uefi，刷完机屏幕提示设备损坏然后进入了fastboot，屏幕提示如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Your device is corrupt. It can&#x27;t be trusted and will not boot...</span><br></pre></td></tr></table></figure><p>一上来会认为刷机有问题？有时候，你的眼睛背叛了你的心。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先，获取串口log，主要部分：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Active Slot _a is bootable, retry count 5</span><br><span class="line">Booting from slot (_a)</span><br><span class="line">Booting Into Mission Mode</span><br><span class="line">Load Image vbmeta_a total time: 2 ms</span><br><span class="line">Load Image vbmeta_system_a total time: 1 ms</span><br><span class="line">avb_slot_verify.c:657: ERROR: vbmeta_system_a: Image rollback index is less than the stored rollback index.</span><br><span class="line">Load Image boot_a total time: 43 ms</span><br><span class="line">Load Image dtbo_a total time: 4 ms</span><br><span class="line">No bootable slots found enter fastboot mode</span><br><span class="line">VB2: boot state: red(3)</span><br><span class="line">//重启</span><br><span class="line">...</span><br><span class="line">Slot _a is unbootable, trying alternate slot</span><br><span class="line">Err: line:1603 FindBootableSlot() status: Load Error</span><br><span class="line">Err: line:1386 LoadImageAndAuth() status: Load Error</span><br><span class="line">LoadImageAndAuth failed: Load Error</span><br><span class="line">Launching fastboot</span><br></pre></td></tr></table></figure><p>有两个问题，一是device corrupt，一是进了fastboot。ok，我们先看avb的一个错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">avb_slot_verify.c:657: ERROR: vbmeta_system_a: Image rollback index is less than the stored rollback index.</span><br></pre></td></tr></table></figure><p>一开始没留意到这个错误，因为正常启动时也有其他avb错误(记得是有)，所以就没注意到这个关键问题。这也告诉我们，该打印error level的才打印error，该打warning的打warning，不要乱打，尤其是release版本，会误导debug，言归正传，看代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> AvbSlotVerifyResult <span class="title function_">load_and_verify_vbmeta</span><span class="params">(</span></span><br><span class="line"><span class="params">    AvbOps* ops,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span>* requested_partitions,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span>* ab_suffix,</span></span><br><span class="line"><span class="params">    <span class="type">bool</span> allow_verification_error,</span></span><br><span class="line"><span class="params">    AvbVBMetaImageFlags toplevel_vbmeta_flags,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> rollback_index_location,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span>* partition_name,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> partition_name_len,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint8_t</span>* expected_public_key,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> expected_public_key_length,</span></span><br><span class="line"><span class="params">    AvbSlotVerifyData* slot_data,</span></span><br><span class="line"><span class="params">    AvbAlgorithmType* out_algorithm_type)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (vbmeta_header.rollback_index &lt; stored_rollback_index) &#123;</span><br><span class="line">    avb_errorv(</span><br><span class="line">        full_partition_name,</span><br><span class="line">        <span class="string">&quot;: Image rollback index is less than the stored rollback index.\n&quot;</span>, <span class="comment">//tj: here</span></span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line">    ret = AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX;</span><br><span class="line">    <span class="keyword">if</span> (!allow_verification_error) &#123;</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">out:</span><br><span class="line">  <span class="comment">/* If |vbmeta_image_data| isn&#x27;t NULL it means that it adopted</span></span><br><span class="line"><span class="comment">   * |vbmeta_buf| so in that case don&#x27;t free it here.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (vbmeta_image_data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vbmeta_buf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      avb_free(vbmeta_buf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (descriptors != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    avb_free(descriptors);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>allow_verification_error</code>就是device unlock，我们是lock，直接<code>goto out</code>了。<code>ret</code>是<code>AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX</code>。这个涉及到avb secure相关，先略过。</p><p>继续看:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AvbSlotVerifyResult <span class="title function_">avb_slot_verify</span><span class="params">(AvbOps* ops,</span></span><br><span class="line"><span class="params">  ...</span></span><br><span class="line"><span class="params">  ret = load_and_verify_vbmeta(ops,</span></span><br><span class="line"><span class="params">                               requested_partitions,</span></span><br><span class="line"><span class="params">                               ab_suffix,</span></span><br><span class="line"><span class="params">                               allow_verification_error,</span></span><br><span class="line"><span class="params">                               <span class="number">0</span> <span class="comment">/* toplevel_vbmeta_flags */</span>,</span></span><br><span class="line"><span class="params">                               <span class="number">0</span> <span class="comment">/* rollback_index_location */</span>,</span></span><br><span class="line"><span class="params">                               <span class="string">&quot;vbmeta&quot;</span>,</span></span><br><span class="line"><span class="params">                               avb_strlen(<span class="string">&quot;vbmeta&quot;</span>),</span></span><br><span class="line"><span class="params">                               <span class="literal">NULL</span> <span class="comment">/* expected_public_key */</span>,</span></span><br><span class="line"><span class="params">                               <span class="number">0</span> <span class="comment">/* expected_public_key_length */</span>,</span></span><br><span class="line"><span class="params">                               slot_data,</span></span><br><span class="line"><span class="params">                               &amp;algorithm_type);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> ((!allow_verification_error &amp;&amp; ret != AVB_SLOT_VERIFY_RESULT_OK) ||</span></span><br><span class="line"><span class="params">      !result_should_continue(ret)) &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">goto</span> fail;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  ...</span></span><br><span class="line"><span class="params">fail:</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (slot_data != <span class="literal">NULL</span>) &#123;</span></span><br><span class="line"><span class="params">    avb_slot_verify_data_free(slot_data);</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> ret;</span></span><br></pre></td></tr></table></figure><p>走<code>goto fail</code>，因为fail所以<code>slot_data</code>仍然是<code>NULL</code>，当前配置是avb 2.0。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STATIC EFI_STATUS</span><br><span class="line"><span class="title function_">LoadImageAndAuthVB2</span> <span class="params">(BootInfo *Info)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">    Result = avb_slot_verify (Ops, (CONST CHAR8 *CONST *)RequestedPartition,</span><br><span class="line">                SlotSuffix, VerifyFlags, VerityFlags, &amp;SlotData);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SlotData == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    Status = EFI_LOAD_ERROR;</span><br><span class="line">    Info-&gt;BootState = RED;  <span class="comment">// tj: here</span></span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">out:</span><br><span class="line">  <span class="keyword">if</span> (Status != EFI_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">if</span> (SlotData != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      avb_slot_verify_data_free (SlotData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Ops != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      AvbOpsFree (Ops);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (UserData != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      avb_free (UserData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (VBData != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      avb_free (VBData);</span><br><span class="line">    &#125;</span><br><span class="line">    Info-&gt;BootState = RED;</span><br><span class="line">    <span class="keyword">if</span> (Info-&gt;MultiSlotBoot) &#123;</span><br><span class="line">      HandleActiveSlotUnbootable ();</span><br><span class="line">      <span class="comment">/* HandleActiveSlotUnbootable should have swapped slots and</span></span><br><span class="line"><span class="comment">       * reboot the device. If no bootable slot found, enter fastboot</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      DEBUG ((EFI_D_WARN, <span class="string">&quot;No bootable slots found enter fastboot mode\n&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       DEBUG ((EFI_D_WARN,</span><br><span class="line">           <span class="string">&quot;Non Multi-slot: Unbootable entering fastboot mode\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DEBUG ((EFI_D_INFO, <span class="string">&quot;VB2: boot state: %a(%d)\n&quot;</span>,  <span class="comment">//tj: here</span></span><br><span class="line">        VbSn[Info-&gt;BootState].name, Info-&gt;BootState)); </span><br><span class="line">  <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>avb_slot_verify</code>出来后，因为<code>SlotData == NULL</code>直接<code>Info-&gt;BootState = RED</code>了。这里有个<code>HandleActiveSlotUnbootable</code>，来看下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EFI_STATUS <span class="title function_">HandleActiveSlotUnbootable</span> <span class="params">(VOID)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/* Mark current Slot as unbootable */</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (FirstBoot &amp;&amp; !TargetBuildVariantUser ()) &#123;</span><br><span class="line">    DEBUG ((EFI_D_VERBOSE, <span class="string">&quot;FirstBoot, skipping slot Unbootable\n&quot;</span>));</span><br><span class="line">    FirstBoot = FALSE;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    BootEntry-&gt;PartEntry.Attributes |=</span><br><span class="line">        (PART_ATT_UNBOOTABLE_VAL) &amp; (~PART_ATT_SUCCESSFUL_VAL);</span><br><span class="line">    UpdatePartitionAttributes (PARTITION_ATTRIBUTES);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EFI_LOAD_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会把当前槽(这里是_a)置为unbootable，我们在fastboot getvar也能看到：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(bootloader) current-slot:a</span><br><span class="line">(bootloader) has-slot:boot:yes</span><br><span class="line">(bootloader) slot-retry-count:b:<span class="number">7</span></span><br><span class="line">(bootloader) slot-unbootable:b:no</span><br><span class="line">(bootloader) slot-successful:b:no</span><br><span class="line">(bootloader) slot-retry-count:a:<span class="number">5</span></span><br><span class="line">(bootloader) slot-unbootable:a:yes <span class="comment">//tj: here</span></span><br><span class="line">(bootloader) slot-successful:a:no</span><br></pre></td></tr></table></figure><p>这里也有log: <code>No bootable slots found enter fastboot mode</code>, then <code>VB2: boot state: red</code>。继续check:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line"><span class="title function_">LoadImageAndAuth</span> <span class="params">(BootInfo *Info)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Slot CurrentSlot = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    GUARD (FindBootableSlot (&amp;CurrentSlot));</span><br><span class="line">    <span class="keyword">if</span> (IsSuffixEmpty (&amp;CurrentSlot)) &#123;</span><br><span class="line">      DEBUG ((EFI_D_ERROR, <span class="string">&quot;No bootable slot\n&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> EFI_LOAD_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">case</span> AVB_1:</span><br><span class="line">    Status = LoadImageAndAuthVB1 (Info);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> AVB_2:</span><br><span class="line">    Status = LoadImageAndAuthVB2 (Info);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (IsUnlocked () &amp;&amp; Status != EFI_SUCCESS) &#123;</span><br><span class="line">    DEBUG ((EFI_D_ERROR, <span class="string">&quot;LoadImageAndAuth failed %r\n&quot;</span>, Status));</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (AVBVersion != AVB_LE) &#123;</span><br><span class="line">    DisplayVerifiedBootScreen (Info);  <span class="comment">//tj: here</span></span><br><span class="line">    DEBUG ((EFI_D_VERBOSE, <span class="string">&quot;Sending Milestone Call\n&quot;</span>));</span><br><span class="line">    Status = Info-&gt;VbIntf-&gt;VBSendMilestone (Info-&gt;VbIntf);</span><br><span class="line">    <span class="keyword">if</span> (Status != EFI_SUCCESS) &#123;</span><br><span class="line">      DEBUG ((EFI_D_ERROR, <span class="string">&quot;Error sending milestone call to TZ\n&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status;</span><br></pre></td></tr></table></figure><p><code>LoadImageAndAuthVB2</code>失败后如果unlock直接返回了，我们这里是lock，会走<code>DisplayVerifiedBootScreen</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STATIC EFI_STATUS</span><br><span class="line"><span class="title function_">DisplayVerifiedBootScreen</span> <span class="params">(BootInfo *Info)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  DEBUG ((EFI_D_VERBOSE, <span class="string">&quot;Boot State is : %d\n&quot;</span>, Info-&gt;BootState));</span><br><span class="line">  <span class="keyword">switch</span> (Info-&gt;BootState) &#123;</span><br><span class="line">  <span class="keyword">case</span> RED:</span><br><span class="line">    Status = DisplayVerifiedBootMenu (DISPLAY_MENU_RED);</span><br><span class="line">    <span class="keyword">if</span> (Status != EFI_SUCCESS) &#123;</span><br><span class="line">      DEBUG ((EFI_D_INFO,</span><br><span class="line">              <span class="string">&quot;Your device is corrupt. It can&#x27;t be trusted and will not boot.&quot;</span></span><br><span class="line">              <span class="string">&quot;\nYour device will shutdown in 30s\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    MicroSecondDelay (<span class="number">30000000</span>);</span><br><span class="line">    ShutdownDevice (); <span class="comment">//tj: here</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>aha…这里显示并复位的。<code>DisplayVerifiedBootMenu</code>这里会显示<code>device is corrupt</code>，code就不贴了。ok，接下来就是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Slot _a is unbootable, trying alternate slot</span><br></pre></td></tr></table></figure><p>是在<code>FindBootableSlot</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line"><span class="title function_">FindBootableSlot</span> <span class="params">(Slot *BootableSlot)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (Unbootable == <span class="number">0</span> &amp;&amp; BootSuccess == <span class="number">1</span>) &#123;</span><br><span class="line">    DEBUG (</span><br><span class="line">        (EFI_D_VERBOSE, <span class="string">&quot;Active Slot %s is bootable\n&quot;</span>, BootableSlot-&gt;Suffix));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Unbootable == <span class="number">0</span> &amp;&amp; BootSuccess == <span class="number">0</span> &amp;&amp; RetryCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((!IsABRetryCountDisabled () &amp;&amp;</span><br><span class="line">        !IsBootDevImage ()) &amp;&amp;</span><br><span class="line">      IsABRetryCountUpdateRequired ()) &#123;</span><br><span class="line">      RetryCount--;</span><br><span class="line">      BootEntry-&gt;PartEntry.Attributes &amp;= ~PART_ATT_MAX_RETRY_COUNT_VAL;</span><br><span class="line">      BootEntry-&gt;PartEntry.Attributes |= RetryCount</span><br><span class="line">                                         &lt;&lt; PART_ATT_MAX_RETRY_CNT_BIT;</span><br><span class="line">      UpdatePartitionAttributes (PARTITION_ATTRIBUTES);</span><br><span class="line">      DEBUG ((EFI_D_INFO, <span class="string">&quot;Active Slot %s is bootable, retry count %ld\n&quot;</span>, <span class="comment">//tj: first boot log</span></span><br><span class="line">              BootableSlot-&gt;Suffix, RetryCount));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      DEBUG ((EFI_D_INFO, <span class="string">&quot;A/B retry count NOT decremented\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DEBUG ((EFI_D_INFO, <span class="string">&quot;Slot %s is unbootable, trying alternate slot\n&quot;</span>, <span class="comment">//tj: second boot log</span></span><br><span class="line">            BootableSlot-&gt;Suffix));</span><br><span class="line">    GUARD_OUT (HandleActiveSlotUnbootable ());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>因为red了，前面已经把<code>Unbootable</code>置为1，So，走了<code>GUARD_OUT (HandleActiveSlotUnbootable ())</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GUARD(code)                                                            \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                         \</span></span><br><span class="line"><span class="meta">    Status = (code);                                                           \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (Status != EFI_SUCCESS) &#123;                                               \</span></span><br><span class="line"><span class="meta">      DEBUG ((EFI_D_ERROR, <span class="string">&quot;Err: line:%d %a() status: %r\n&quot;</span>, __LINE__,         \</span></span><br><span class="line"><span class="meta">              __FUNCTION__, Status));                                          \</span></span><br><span class="line"><span class="meta">      return Status;                                                           \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>有错就直接返回了。<code>HandleActiveSlotUnbootable</code>直接返回<code>EFI_LOAD_ERROR</code>了，其他不可能发生。</p><p><code>FindBootableSlot</code>也在<code>LoadImageAndAuth()</code>，再贴下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  Slot CurrentSlot = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  GUARD (FindBootableSlot (&amp;CurrentSlot));</span><br></pre></td></tr></table></figure><p><code>GUARD</code>直接返回了。继续往前看：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EFI_STATUS EFIAPI  __attribute__ ( (no_sanitize (<span class="string">&quot;safe-stack&quot;</span>)))</span><br><span class="line">LinuxLoaderEntry (IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    BootInfo Info = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    Info.MultiSlotBoot = MultiSlotBoot;</span><br><span class="line">    Info.BootIntoRecovery = BootIntoRecovery;</span><br><span class="line">    Info.BootReasonAlarm = BootReasonAlarm;</span><br><span class="line">    Status = LoadImageAndAuth (&amp;Info); <span class="comment">//tj: here</span></span><br><span class="line">    <span class="keyword">if</span> (Status != EFI_SUCCESS) &#123;</span><br><span class="line">      DEBUG ((EFI_D_ERROR, <span class="string">&quot;LoadImageAndAuth failed: %r\n&quot;</span>, Status));</span><br><span class="line">      <span class="keyword">goto</span> fastboot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BootLinux (&amp;Info);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>yup，<code>LoadImageAndAuth failed</code>, finished!</p><p>So, root cause is why <code>AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX</code> happened，下篇分解:)</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uefi </tag>
            
            <tag> avb </tag>
            
            <tag> ab </tag>
            
            <tag> fastboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 10 metadata 分区说明</title>
      <link href="/metadata-partition-in-android-10.html"/>
      <url>/metadata-partition-in-android-10.html</url>
      
        <content type="html"><![CDATA[<p>参考高通平台Android 10，刷机时发现刷了metadata.img，不刷userdata.img，起不来。</p><p>我们来看下这个分区的由来：</p><blockquote><p>metadata: The metadata partition is used when device is encrypted and is 16MB or larger.</p></blockquote><p>官方的定义如上，设备加密时使用。设备加密有2种：</p><blockquote><p>Android has two methods for device encryption: file-based encryption and full-disk encryption.</p></blockquote><p>file-based是Android 10及以上使用：</p><blockquote><p>Note: Devices running Android 7.0–9 support full-disk encryption. New devices running Android 10 and higher must use file-based encryption.</p></blockquote><p>file-based加密(FBE)仅仅加密的是文件内容和文件名，其他的信息比如文件大小，权限啥的都没有加密，这些东东就是filesystem metadata。</p><blockquote><p>When FBE is used, other information, such as directory layouts, file sizes, permissions, and creation&#x2F;modification times, is not encrypted. Collectively, this is known as filesystem metadata.</p></blockquote><p>另外，metadata加密需要硬件支持。</p><blockquote><p>Android 9 introduces support for metadata encryption where hardware support is present. </p></blockquote><p>这个硬件特性叫<em>inline crypto engine</em>。</p><blockquote><p>To support metadata encryption currently, your hardware needs to support an inline crypto engine</p></blockquote><p>ok。</p><p>这个分区里面放的是啥？来看：</p><blockquote><p>With metadata encryption, a single key present at boot time encrypts whatever content is not encrypted by FBE. This key is protected by Keymaster, which in turn is protected by verified boot.</p></blockquote><blockquote><p>Because nothing in the userdata partition can be read until the metadata encryption key is present, the partition table must set aside a separate partition called the “metadata partition” for storing the keymaster blobs that protect this key.</p></blockquote><p>就是一个key，如果没有这个key，userdata数据不能访问。logcat就有类似找不到这个key的错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01-01 01:56:53.497   519   519 E vold    : No key found in /metadata/vold/metadata_encryption/key</span><br></pre></td></tr></table></figure><p>这个目录fstab指定到keydirectory：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dev/block/bootdevice/by-name/userdata              /data              f2fs        noatime,nosuid,nodev,discard latemount,wait,check,fileencryption=ice,keydirectory=/metadata/vold/metadata_encryption</span><br></pre></td></tr></table></figure><p>ok，我们再来看metadata.img的构成：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Generate metadata image (metadata.img)</span></span><br><span class="line"><span class="comment"># As of now this in empty at build and data is runtime generated only,</span></span><br><span class="line"><span class="comment"># so create an empty fs</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(BOARD_METADATAIMAGE_PARTITION_SIZE)</span>)</span>,)</span><br><span class="line"></span><br><span class="line">TARGET_OUT_METADATA := <span class="variable">$(PRODUCT_OUT)</span>/metadata</span><br><span class="line"></span><br><span class="line">INSTALLED_METADATAIMAGE_TARGET := <span class="variable">$(PRODUCT_OUT)</span>/metadata.img</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> build-metadataimage-target</span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> pretty,&quot;Target metadata fs image: <span class="variable">$(INSTALLED_METADATAIMAGE_TARGET)</span>&quot;)</span></span><br><span class="line">    @mkdir -p <span class="variable">$(TARGET_OUT_METADATA)</span></span><br><span class="line">    <span class="variable">$(hide)</span>PATH=<span class="variable">$(HOST_OUT_EXECUTABLES)</span>:$$&#123;PATH&#125; <span class="variable">$(MKEXTUSERIMG)</span> -s <span class="variable">$(TARGET_OUT_METADATA)</span> <span class="variable">$@</span> ext4 metadata <span class="variable">$(BOARD_METADATAIMAGE_PARTITION_SIZE)</span></span><br><span class="line">    <span class="variable">$(hide)</span> chmod a+r <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure><p>metadata.img就是一个空目录，so，如果刷了这个img，就是擦了key成新设备，没有这个key，userdata数据就读不出来楼，so要对userdata区恢复下。官方说明如下：</p><blockquote><p>Metadata encryption can only be set up when the data partition is first formatted.</p></blockquote><p>版本起来后看下这个目录，是有货的：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/metadata/vold/metadata_encryption/key <span class="comment"># ls -l</span></span><br><span class="line">total 52</span><br><span class="line">-rw------- 1 root root   483 1970-01-01 00:49 encrypted_key</span><br><span class="line">-rw------- 1 root root   455 1970-01-01 00:49 keymaster_key_blob</span><br><span class="line">-rw------- 1 root root 16384 1970-01-01 00:49 secdiscardable</span><br><span class="line">-rw------- 1 root root    10 1970-01-01 00:49 stretching</span><br><span class="line">-rw------- 1 root root     1 1970-01-01 00:49 version</span><br></pre></td></tr></table></figure><p>我们在recovery模式下也能看到恢复出厂时check metadata是否挂载，如果有就erase。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span>* METADATA_ROOT = <span class="string">&quot;/metadata&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WipeData</span><span class="params">(Device* device, <span class="type">bool</span> convert_fbe)</span> </span>&#123;</span><br><span class="line">  RecoveryUI* ui = device-&gt;<span class="built_in">GetUI</span>();</span><br><span class="line">  ui-&gt;<span class="built_in">Print</span>(<span class="string">&quot;\n-- Wiping data...\n&quot;</span>);</span><br><span class="line">  <span class="type">bool</span> success = device-&gt;<span class="built_in">PreWipeData</span>();</span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    success &amp;= <span class="built_in">EraseVolume</span>(DATA_ROOT, ui, convert_fbe);</span><br><span class="line">    <span class="type">bool</span> has_cache = <span class="built_in">volume_for_mount_point</span>(<span class="string">&quot;/cache&quot;</span>) != <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (has_cache) &#123;</span><br><span class="line">      success &amp;= <span class="built_in">EraseVolume</span>(CACHE_ROOT, ui, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">volume_for_mount_point</span>(METADATA_ROOT) != <span class="literal">nullptr</span>) &#123; <span class="comment">//tj: here</span></span><br><span class="line">      success &amp;= <span class="built_in">EraseVolume</span>(METADATA_ROOT, ui, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    success &amp;= device-&gt;<span class="built_in">PostWipeData</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ui-&gt;<span class="built_in">Print</span>(<span class="string">&quot;Data wipe %s.\n&quot;</span>, success ? <span class="string">&quot;complete&quot;</span> : <span class="string">&quot;failed&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外有个宏用来创建这个挂载点：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Define BOARD_USES_METADATA_PARTITION to create metadata mount point in system image</span></span><br><span class="line">BOARD_USES_METADATA_PARTITION := true</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> BOARD_USES_METADATA_PARTITION</span><br><span class="line">  LOCAL_POST_INSTALL_CMD += ; mkdir -p <span class="variable">$(TARGET_ROOT_OUT)</span>/metadata</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://source.android.com/devices/bootloader/partitions-images">https://source.android.com/devices/bootloader/partitions-images</a></li><li><a href="https://source.android.com/security/encryption/metadata">https://source.android.com/security/encryption/metadata</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> metadata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EDK2 Fastboot Flash分析</title>
      <link href="/analyze-fastboot-flash-flow-in-edk2.html"/>
      <url>/analyze-fastboot-flash-flow-in-edk2.html</url>
      
        <content type="html"><![CDATA[<p>这段时间都在忙着port custom features from LK to edk2，搭了个框后主要耗时在custom fastboot download。</p><p>一般我们在<code>fastboot flash xxx_part xxx_part.img</code>时，会先触发一个download cmd完成后再触发一个flash cmd。我们先看下QCOM原生<code>CmdDownload()</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Handle Download Command */</span></span><br><span class="line">STATIC VOID</span><br><span class="line"><span class="title function_">CmdDownload</span> <span class="params">(IN CONST CHAR8 *arg, IN VOID *data, IN UINT32 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  CHAR8 Response[<span class="number">13</span>] = <span class="string">&quot;DATA&quot;</span>;</span><br><span class="line">  UINT32 InitStrLen = AsciiStrLen (<span class="string">&quot;DATA&quot;</span>);</span><br><span class="line">  ...</span><br><span class="line">  gBS-&gt;CopyMem (GetFastbootDeviceData ()-&gt;gTxBuffer, Response,</span><br><span class="line">                <span class="keyword">sizeof</span> (Response));</span><br><span class="line">  mState = ExpectDataState;</span><br><span class="line">  mBytesReceivedSoFar = <span class="number">0</span>;</span><br><span class="line">  GetFastbootDeviceData ()-&gt;UsbDeviceProtocol-&gt;Send (</span><br><span class="line">      ENDPOINT_OUT, <span class="keyword">sizeof</span> (Response), GetFastbootDeviceData ()-&gt;gTxBuffer);</span><br><span class="line">  DEBUG ((EFI_D_VERBOSE, <span class="string">&quot;CmdDownload: Send 12 %a\n&quot;</span>,</span><br><span class="line">          GetFastbootDeviceData ()-&gt;gTxBuffer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下LK的:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cmd_download</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">void</span> *data, <span class="type">unsigned</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line">STACKBUF_DMA_ALIGN(response, MAX_RSP_SIZE);</span><br><span class="line"><span class="type">unsigned</span> len = hex2unsigned(arg);</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">download_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (len &gt; download_max) &#123;</span><br><span class="line">fastboot_fail(<span class="string">&quot;data too large&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>((<span class="type">char</span> *)response, MAX_RSP_SIZE, <span class="string">&quot;DATA%08x&quot;</span>, len);</span><br><span class="line"><span class="keyword">if</span> (usb_if.usb_write(response, <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)response)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Discard the cache contents before starting the download</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">arch_invalidate_cache_range((<span class="type">addr_t</span>) download_base, ROUNDUP(len, CACHE_LINE));</span><br><span class="line"></span><br><span class="line">r = usb_if.usb_read(download_base, len);</span><br><span class="line"><span class="keyword">if</span> ((r &lt; <span class="number">0</span>) || ((<span class="type">unsigned</span>) r != len)) &#123;</span><br><span class="line">fastboot_state = STATE_ERROR;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">download_size = len;</span><br><span class="line">fastboot_okay(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, LK是先<code>usb_write</code>了一个<code>response</code>，然后<code>usb_read</code>数据到<code>download_base</code>。而EDK2只有一个USB Tx操作(就是发送了一个response到host)，另一个跑哪了？</p><p>我们在<code>AcceptData</code>能看到这个<code>usb_read</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STATIC VOID</span><br><span class="line"><span class="title function_">AcceptData</span> <span class="params">(IN UINT64 Size, IN VOID *Data)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">/* Postpone Fastboot Okay until flash completed */</span></span><br><span class="line">    FastbootOkayDelay ();</span><br><span class="line">    mState = ExpectCmdState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    GetFastbootDeviceData ()-&gt;UsbDeviceProtocol-&gt;Send (</span><br><span class="line">        ENDPOINT_IN, GetXfrSize (), (Data + mBytesReceivedSoFar));</span><br><span class="line">    DEBUG ((EFI_D_VERBOSE, <span class="string">&quot;AcceptData: Send %d\n&quot;</span>, GetXfrSize ()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rt, 就是这个<code>Send(ENDPOINT_IN ...)</code>。那谁trigger了这个Accept? 往前看：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">DataReady</span> <span class="params">(IN UINT64 Size, IN VOID *Data)</span></span><br><span class="line">&#123;</span><br><span class="line">  DEBUG ((EFI_D_VERBOSE, <span class="string">&quot;DataReady %d\n&quot;</span>, Size));</span><br><span class="line">  <span class="keyword">if</span> (mState == ExpectCmdState)</span><br><span class="line">    AcceptCmd (Size, (CHAR8 *)Data);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (mState == ExpectDataState)</span><br><span class="line">    AcceptData (Size, Data);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    DEBUG ((EFI_D_ERROR, <span class="string">&quot;DataReady Unknown status received\r\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Process bulk transfer out come for Rx */</span></span><br><span class="line">STATIC EFI_STATUS</span><br><span class="line"><span class="title function_">ProcessBulkXfrCompleteRx</span> <span class="params">(IN USB_DEVICE_TRANSFER_OUTCOME *Uto)</span></span><br><span class="line">&#123;</span><br><span class="line">  EFI_STATUS Status = EFI_SUCCESS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch on the transfer status</span></span><br><span class="line">  <span class="keyword">switch</span> (Uto-&gt;Status) &#123;</span><br><span class="line">  <span class="keyword">case</span> UsbDeviceTransferStatusCompleteOK:</span><br><span class="line">    <span class="keyword">if</span> (FastbootCurrentState () == ExpectDataState)</span><br><span class="line">      DataReady (Uto-&gt;BytesCompleted, FastbootDloadBuffer ());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      DataReady (Uto-&gt;BytesCompleted, Fbd.gRxBuffer);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>注意这里有个<code>usb_read</code>。为什么会放这里？ Think about the last USB operation.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EFI_STATUS <span class="title function_">HandleUsbEvents</span> <span class="params">(VOID)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">      <span class="keyword">if</span> (USB_ENDPOINT_DIRECTION_OUT ==</span><br><span class="line">          USB_INDEX_TO_EPDIR (Payload.TransferOutcome.EndpointIndex)) &#123;</span><br><span class="line"></span><br><span class="line">        Status = ProcessBulkXfrCompleteRx (&amp;Payload.TransferOutcome);</span><br><span class="line">        <span class="keyword">if</span> (EFI_ERROR (Status)) &#123;</span><br><span class="line">          <span class="comment">/* Should not happen, even if it happens we keep waiting for USB to be</span></span><br><span class="line"><span class="comment">           * connected */</span></span><br><span class="line">          DEBUG ((EFI_D_ERROR,</span><br><span class="line">                  <span class="string">&quot;Error, should not happen! Check your USB connection&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Else the direction is from device to host,  process TX */</span></span><br><span class="line">        Status = ProcessBulkXfrCompleteTx (&amp;Payload.TransferOutcome);</span><br></pre></td></tr></table></figure><p><code>HandleUsbEvents()</code>会处理Rx&#x2F;Tx完成event，记住是完成时才handle。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Wait for USB events in tight loop */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  Status = HandleUsbEvents ();</span><br><span class="line">  <span class="keyword">if</span> (EFI_ERROR (Status) &amp;&amp; (Status != EFI_ABORTED)) &#123;</span><br><span class="line">    DEBUG ((EFI_D_ERROR, <span class="string">&quot;Error, failed to handle USB event\n&quot;</span>));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FastbootFatal ()) &#123;</span><br><span class="line">    DEBUG ((EFI_D_ERROR, <span class="string">&quot;Continue detected, Exiting App...\n&quot;</span>));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, just loop USB events。可见USB rx不是一次性读完，而是分块逐步完成。</p><p>这个read完成后host会发个flash cmd，进入<code>CmdFlash()</code>。</p><p><code>CmdFlash()</code>区分sparse格式和non-sparse，Android系统镜像过大就引入了sparse格式：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEBUG ((EFI_D_VERBOSE, <span class="string">&quot;=== Sparse Image Header ===\n&quot;</span>));</span><br><span class="line">DEBUG ((EFI_D_VERBOSE, <span class="string">&quot;magic: 0x%x\n&quot;</span>, sparse_header-&gt;magic));</span><br><span class="line">DEBUG (</span><br><span class="line">    (EFI_D_VERBOSE, <span class="string">&quot;major_version: 0x%x\n&quot;</span>, sparse_header-&gt;major_version));</span><br><span class="line">DEBUG (</span><br><span class="line">    (EFI_D_VERBOSE, <span class="string">&quot;minor_version: 0x%x\n&quot;</span>, sparse_header-&gt;minor_version));</span><br><span class="line">DEBUG ((EFI_D_VERBOSE, <span class="string">&quot;file_hdr_sz: %d\n&quot;</span>, sparse_header-&gt;file_hdr_sz));</span><br><span class="line">DEBUG ((EFI_D_VERBOSE, <span class="string">&quot;chunk_hdr_sz: %d\n&quot;</span>, sparse_header-&gt;chunk_hdr_sz));</span><br><span class="line">DEBUG ((EFI_D_VERBOSE, <span class="string">&quot;blk_sz: %d\n&quot;</span>, sparse_header-&gt;blk_sz));</span><br><span class="line">DEBUG ((EFI_D_VERBOSE, <span class="string">&quot;total_blks: %d\n&quot;</span>, sparse_header-&gt;total_blks));</span><br><span class="line">DEBUG ((EFI_D_VERBOSE, <span class="string">&quot;total_chunks: %d\n&quot;</span>, sparse_header-&gt;total_chunks));</span><br></pre></td></tr></table></figure><p>上面就是它的header，基本就是按chunk来处理:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Start processing the chunks */</span></span><br><span class="line"><span class="keyword">for</span> (SparseImgData.Chunk = <span class="number">0</span>;</span><br><span class="line">     SparseImgData.Chunk &lt; sparse_header-&gt;total_chunks;</span><br><span class="line">     SparseImgData.Chunk++) &#123;</span><br></pre></td></tr></table></figure><p>提下<code>CmdFlash()</code>开头的几个buff:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Handle Flash Command */</span></span><br><span class="line">STATIC VOID</span><br><span class="line"><span class="title function_">CmdFlash</span> <span class="params">(IN CONST CHAR8 *arg, IN VOID *data, IN UINT32 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  ExchangeFlashAndUsbDataBuf ();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">STATIC VOID <span class="title function_">ExchangeFlashAndUsbDataBuf</span> <span class="params">(VOID)</span></span><br><span class="line">&#123;</span><br><span class="line">  VOID *mTmpbuff;</span><br><span class="line"></span><br><span class="line">  mTmpbuff = mUsbDataBuffer;</span><br><span class="line">  mUsbDataBuffer = mFlashDataBuffer;</span><br><span class="line">  mFlashDataBuffer = mTmpbuff;</span><br><span class="line">  mFlashNumDataBytes = mNumDataBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mUsbDataBuffer</code>是host传过来的data by usb intf，RAM地址是这个。<code>mNumDataBytes</code>就是这个data size。</p><p>btw: edk2 fastboot支持并行下载了for sparse img:] 遥想在S corp.时，还搞过这个feature by multi-core…</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uefi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EDK2 Overview</title>
      <link href="/edk2-overview.html"/>
      <url>/edk2-overview.html</url>
      
        <content type="html"><![CDATA[<p>最近在移BL到UEFI, 来大概看下基础。</p><p>UEFI(Unified Extensible Firmware Interface)是Intel提出的一种规范(specification)，由PC BIOS而来，如下图(阿桑的wikipedia打不开？画个txt pic)，介于OS和FW之间，QCOM Android BL似乎用它来代替LK。UEFI is based on EFI。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">        ------</span><br><span class="line">        | OS |</span><br><span class="line">        --/|\--</span><br><span class="line">___________|____________________</span><br><span class="line">extensible firmware interface</span><br><span class="line">___________|____________________</span><br><span class="line">           |</span><br><span class="line">      ----\|/-----</span><br><span class="line">      | Firmware |</span><br><span class="line">      ------------</span><br><span class="line">      | Hardware |</span><br><span class="line">      ------------- </span><br></pre></td></tr></table></figure><p>TianoCore是一种UEFI的开源实现, edk&#x2F;edk2(based on edk)一种开发环境for UEFI，用的tinaocore。</p><p>微软的Project Mu是另一个实现，edk2的变种？</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>edk2里的代码最小组成都是按模块(module)来划分，n个模块可以组成一个包(package)，平台(platform)是一种特殊的package，一般都是编译的入口。</p><p>module有个inf文件描述这个module，package有个dec文件，platform则是dsc文件。还有个fdf文件用作flash用。</p><p>module可以是application，library，or driver。</p><p>Library有个class和instance，class就是一个抽象，instance负责具体实现，不同平台可以定义不同实现。</p><p>Driver只接触了DXE drv, 提供protocol供其他module使用。</p><p>Application和Driver区别是是否退出。</p><p>package之间还可以互相引用，just like C calling eath other.</p><p>另外feature宏用PCD来代替，看个例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[PcdsFixedAtBuild.common]</span><br><span class="line">  # LinuxLoaderCommon</span><br><span class="line">  gQcomTokenSpaceGuid.EnableDisplayMenu|TRUE|BOOLEAN|0x00015005</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line"><span class="title function_">DisplayUnlockMenu</span> <span class="params">(INTN Type, BOOLEAN Value)</span></span><br><span class="line">&#123;</span><br><span class="line">  EFI_STATUS Status = EFI_SUCCESS;</span><br><span class="line">  OPTION_MENU_INFO *OptionMenuInfo;</span><br><span class="line">  OptionMenuInfo = &amp;gMenuInfo;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FixedPcdGetBool (EnableDisplayMenu)) &#123;</span><br><span class="line">    DrawMenuInit ();</span><br></pre></td></tr></table></figure><p>just like Linux kernel <code>IS_ENABLED()</code>，rt?</p><p>plz remember library和pcd都是给module自定义用的。</p><p>makefile在edk2是中间文件了，可以用inf&#x2F;dsc提供的build option来修改。</p><p>ok，就这么多，其他用法看代码足矣。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://uefi.org/">https://uefi.org/</a></li><li><a href="https://www.tianocore.org/">https://www.tianocore.org/</a></li><li><a href="https://github.com/tianocore/tianocore.github.io/wiki">https://github.com/tianocore/tianocore.github.io/wiki</a></li><li>EDK_II Module Writer_s Guide_0_7.pdf</li><li>EDK_II_UserManual_0_7.pdf</li><li>edk-ii-dec-specification.pdf</li><li>edk-ii-dsc-specification.pdf</li><li>edk-ii-inf-specification.pdf</li><li>edk-ii-pcd-specification.pdf</li><li><a href="https://microsoft.github.io/mu/">https://microsoft.github.io/mu/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uefi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux device_{register | unregister}()代码分析</title>
      <link href="/analyze-linux-device-register-code.html"/>
      <url>/analyze-linux-device-register-code.html</url>
      
        <content type="html"><![CDATA[<p>参考内核5.x, 主要关注下资源释放。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * device_register - register a device with the system.</span></span><br><span class="line"><span class="comment"> * @dev: pointer to the device structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This happens in two clean steps - initialize the device</span></span><br><span class="line"><span class="comment"> * and add it to the system. The two steps can be called</span></span><br><span class="line"><span class="comment"> * separately, but this is the easiest and most common.</span></span><br><span class="line"><span class="comment"> * I.e. you should only call the two helpers separately if</span></span><br><span class="line"><span class="comment"> * have a clearly defined need to use and refcount the device</span></span><br><span class="line"><span class="comment"> * before it is added to the hierarchy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For more information, see the kerneldoc for device_initialize()</span></span><br><span class="line"><span class="comment"> * and device_add().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> _Never_ directly free @dev after calling this function, even</span></span><br><span class="line"><span class="comment"> * if it returned an error! Always use put_device() to give up the</span></span><br><span class="line"><span class="comment"> * reference initialized in this function instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">device_register</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">        device_initialize(dev);</span><br><span class="line">        <span class="keyword">return</span> device_add(dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>device_add()可能失败。</p><p>注意有个NOTE，不要直接free @dev，即使device_add() fails，用put_device()取代。</p><p>配对使用的是unregister:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * device_unregister - unregister device from system.</span></span><br><span class="line"><span class="comment"> * @dev: device going away.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We do this in two parts, like we do device_register(). First,</span></span><br><span class="line"><span class="comment"> * we remove it from all the subsystems with device_del(), then</span></span><br><span class="line"><span class="comment"> * we decrement the reference count via put_device(). If that</span></span><br><span class="line"><span class="comment"> * is the final reference count, the device will be cleaned up</span></span><br><span class="line"><span class="comment"> * via device_release() above. Otherwise, the structure will</span></span><br><span class="line"><span class="comment"> * stick around until the final reference to the device is dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">device_unregister</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">        pr_debug(<span class="string">&quot;device: &#x27;%s&#x27;: %s\n&quot;</span>, dev_name(dev), __func__);</span><br><span class="line">        device_del(dev);</span><br><span class="line">        put_device(dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put_device()会decrement reference count，then call device_release() if ref count<br>is final，zero?</p><p>先看几个相关结构成员：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct device - The basic device structure</span></span><br><span class="line"><span class="comment"> * @parent:     The device&#x27;s &quot;parent&quot; device, the device to which it is attached.</span></span><br><span class="line"><span class="comment"> *              In most cases, a parent device is some sort of bus or host</span></span><br><span class="line"><span class="comment"> *              controller. If parent is NULL, the device, is a top-level device,</span></span><br><span class="line"><span class="comment"> *              which is not usually what you want.</span></span><br><span class="line"><span class="comment"> * @p:          Holds the private data of the driver core portions of the device.</span></span><br><span class="line"><span class="comment"> *              See the comment of the struct device_private for detail.</span></span><br><span class="line"><span class="comment"> * @kobj:       A top-level, abstract class from which other classes are derived.</span></span><br><span class="line"><span class="comment"> * @init_name:  Initial name of the device.</span></span><br><span class="line"><span class="comment"> * @type:       The type of device.</span></span><br><span class="line"><span class="comment"> *              This identifies the device type and carries type-specific</span></span><br><span class="line"><span class="comment"> *              information.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct device &#123;</span></span><br><span class="line"><span class="comment">        struct device           *parent;</span></span><br><span class="line"><span class="comment">        struct device_private   *p;</span></span><br><span class="line"><span class="comment">        struct kobject kobj; </span></span><br></pre></td></tr></table></figure><p>注意<code>struct device</code>会有个kobj抽象类。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * put_device - decrement reference count.</span></span><br><span class="line"><span class="comment"> * @dev: device in question.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_device</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* might_sleep(); */</span></span><br><span class="line">        <span class="keyword">if</span> (dev)</span><br><span class="line">                kobject_put(&amp;dev-&gt;kobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kobject_put()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kobject_put() - Decrement refcount for object.</span></span><br><span class="line"><span class="comment"> * @kobj: object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Decrement the refcount, and if 0, call kobject_cleanup().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kobject_put</span><span class="params">(<span class="keyword">struct</span> kobject *kobj)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (kobj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!kobj-&gt;state_initialized)</span><br><span class="line">                        WARN(<span class="number">1</span>, KERN_WARNING</span><br><span class="line">                                <span class="string">&quot;kobject: &#x27;%s&#x27; (%p): is not initialized, yet kobject_put() is being called.\n&quot;</span>,</span><br><span class="line">                             kobject_name(kobj), kobj);</span><br><span class="line">                kref_put(&amp;kobj-&gt;kref, kobject_release);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kref_put()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kref_put - decrement refcount for object.</span></span><br><span class="line"><span class="comment"> * @kref: object.</span></span><br><span class="line"><span class="comment"> * @release: pointer to the function that will clean up the object when the</span></span><br><span class="line"><span class="comment"> *           last reference to the object is released.</span></span><br><span class="line"><span class="comment"> *           This pointer is required, and it is not acceptable to pass kfree</span></span><br><span class="line"><span class="comment"> *           in as this function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Decrement the refcount, and if 0, call release().</span></span><br><span class="line"><span class="comment"> * Return 1 if the object was removed, otherwise return 0.  Beware, if this</span></span><br><span class="line"><span class="comment"> * function returns 0, you still can not count on the kref from remaining in</span></span><br><span class="line"><span class="comment"> * memory.  Only use the return value if you want to see if the kref is now</span></span><br><span class="line"><span class="comment"> * gone, not present.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">kref_put</span><span class="params">(<span class="keyword">struct</span> kref *kref, <span class="type">void</span> (*release)(<span class="keyword">struct</span> kref *kref))</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (refcount_dec_and_test(&amp;kref-&gt;refcount)) &#123;</span><br><span class="line">                release(kref);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>refcount is 0 就call <code>release()</code>也就是<code>kobject_release()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kobject_release</span><span class="params">(<span class="keyword">struct</span> kref *kref)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span> =</span> container_of(kref, <span class="keyword">struct</span> kobject, kref);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_KOBJECT_RELEASE</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> delay = HZ + HZ * (get_random_int() &amp; <span class="number">0x3</span>);</span><br><span class="line">        pr_info(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s, parent %p (delayed %ld)\n&quot;</span>,</span><br><span class="line">                 kobject_name(kobj), kobj, __func__, kobj-&gt;parent, delay);</span><br><span class="line">        INIT_DELAYED_WORK(&amp;kobj-&gt;release, kobject_delayed_cleanup);</span><br><span class="line"></span><br><span class="line">        schedule_delayed_work(&amp;kobj-&gt;release, delay);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        kobject_cleanup(kobj);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kobject_cleanup - free kobject resources.</span></span><br><span class="line"><span class="comment"> * @kobj: object to cleanup</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kobject_cleanup</span><span class="params">(<span class="keyword">struct</span> kobject *kobj)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> *<span class="title">t</span> =</span> get_ktype(kobj);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name = kobj-&gt;name;</span><br><span class="line">...    </span><br><span class="line">        <span class="keyword">if</span> (t &amp;&amp; t-&gt;release) &#123;</span><br><span class="line">                pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): calling ktype release\n&quot;</span>,</span><br><span class="line">                         kobject_name(kobj), kobj);</span><br><span class="line">                t-&gt;release(kobj);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个callback <code>-&gt;release</code>，是<code>struct kobj_type</code>的类型。一般都是在init定义的，rt? 找啊找：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">device_initialize</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">        dev-&gt;kobj.kset = devices_kset;</span><br><span class="line">        kobject_init(&amp;dev-&gt;kobj, &amp;device_ktype); <span class="comment">//tj: here</span></span><br><span class="line">        INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">device_ktype</span> =</span> &#123;</span><br><span class="line">        .release        = device_release,</span><br><span class="line">        .sysfs_ops      = &amp;dev_sysfs_ops,</span><br><span class="line">        .namespace      = device_namespace,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>kobject_init()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kobject_init() - Initialize a kobject structure.</span></span><br><span class="line"><span class="comment"> * @kobj: pointer to the kobject to initialize</span></span><br><span class="line"><span class="comment"> * @ktype: pointer to the ktype for this kobject.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will properly initialize a kobject such that it can then</span></span><br><span class="line"><span class="comment"> * be passed to the kobject_add() call.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After this function is called, the kobject MUST be cleaned up by a call</span></span><br><span class="line"><span class="comment"> * to kobject_put(), not by a call to kfree directly to ensure that all of</span></span><br><span class="line"><span class="comment"> * the memory is cleaned up properly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kobject_init</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> kobj_type *ktype)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> *err_str;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!kobj) &#123;</span><br><span class="line">                err_str = <span class="string">&quot;invalid kobject pointer!&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ktype) &#123;</span><br><span class="line">                err_str = <span class="string">&quot;must have a ktype to be initialized properly!\n&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (kobj-&gt;state_initialized) &#123;</span><br><span class="line">                <span class="comment">/* do not error out as sometimes we can recover */</span></span><br><span class="line">                pr_err(<span class="string">&quot;kobject (%p): tried to init an initialized object, something is seriously wrong.\n&quot;</span>,</span><br><span class="line">                       kobj);</span><br><span class="line">                dump_stack();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        kobject_init_internal(kobj);</span><br><span class="line">        kobj-&gt;ktype = ktype; <span class="comment">//tj: here</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kobject_init_internal</span><span class="params">(<span class="keyword">struct</span> kobject *kobj)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (!kobj)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        kref_init(&amp;kobj-&gt;kref);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kref_init - initialize object.</span></span><br><span class="line"><span class="comment"> * @kref: object in question.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">kref_init</span><span class="params">(<span class="keyword">struct</span> kref *kref)</span></span><br><span class="line">&#123;</span><br><span class="line">        refcount_set(&amp;kref-&gt;refcount, <span class="number">1</span>); <span class="comment">//tj: refcount = 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>drv设置的name其实就是kobj的name，比如devfreq:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dev_set_name(&amp;devfreq-&gt;dev, <span class="string">&quot;devfreq%d&quot;</span>,</span><br><span class="line">atomic_inc_return(&amp;devfreq_no));</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dev_set_name - set a device name</span></span><br><span class="line"><span class="comment"> * @dev: device</span></span><br><span class="line"><span class="comment"> * @fmt: format string for the device&#x27;s name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_set_name</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">        va_list vargs;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">        va_start(vargs, fmt);</span><br><span class="line">        err = kobject_set_name_vargs(&amp;dev-&gt;kobj, fmt, vargs);</span><br><span class="line">        va_end(vargs);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kobject_set_name_vargs() - Set the name of a kobject.</span></span><br><span class="line"><span class="comment"> * @kobj: struct kobject to set the name of</span></span><br><span class="line"><span class="comment"> * @fmt: format string used to build the name</span></span><br><span class="line"><span class="comment"> * @vargs: vargs to format the string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kobject_set_name_vargs</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="type">const</span> <span class="type">char</span> *fmt,</span></span><br><span class="line"><span class="params">                                  va_list vargs)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kobj-&gt;name &amp;&amp; !fmt)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">        kobj-&gt;name = s; <span class="comment">//tj: set kobj-&gt;name</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们回头看t-&gt;release callback: </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * device_release - free device structure.</span></span><br><span class="line"><span class="comment"> * @kobj: device&#x27;s kobject.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is called once the reference count for the object</span></span><br><span class="line"><span class="comment"> * reaches 0. We forward the call to the device&#x27;s release</span></span><br><span class="line"><span class="comment"> * method, which should handle actually freeing the structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> kobject *kobj)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> kobj_to_dev(kobj);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_private</span> *<span class="title">p</span> =</span> dev-&gt;p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Some platform devices are driven without driver attached</span></span><br><span class="line"><span class="comment">         * and managed resources may have been acquired.  Make sure</span></span><br><span class="line"><span class="comment">         * all resources are released.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Drivers still can add resources into device after device</span></span><br><span class="line"><span class="comment">         * is deleted but alive, so release devres here to avoid</span></span><br><span class="line"><span class="comment">         * possible memory leak.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        devres_release_all(dev);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;release)</span><br><span class="line">                dev-&gt;release(dev);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;type &amp;&amp; dev-&gt;type-&gt;release)</span><br><span class="line">                dev-&gt;type-&gt;release(dev);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;class &amp;&amp; dev-&gt;class-&gt;dev_release)</span><br><span class="line">                dev-&gt;class-&gt;dev_release(dev);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                WARN(<span class="number">1</span>, KERN_ERR <span class="string">&quot;Device &#x27;%s&#x27; does not have a release() function, it is broken and must be fixed. See Documentation/kobject.txt.\n&quot;</span>,</span><br><span class="line">                        dev_name(dev));</span><br><span class="line">        kfree(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看到有三个<code>-&gt;release</code> callback check，必须有一个<code>-&gt;release</code>。注意一般drv在这里call kfree()。</p><p><code>kfree(p)</code>来由：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_private_init</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">        dev-&gt;p = kzalloc(<span class="keyword">sizeof</span>(*dev-&gt;p), GFP_KERNEL); <span class="comment">//tj: malloc</span></span><br><span class="line">        <span class="keyword">if</span> (!dev-&gt;p)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        dev-&gt;p-&gt;device = dev;</span><br><span class="line">        klist_init(&amp;dev-&gt;p-&gt;klist_children, klist_children_get,</span><br><span class="line">                   klist_children_put);</span><br><span class="line">        INIT_LIST_HEAD(&amp;dev-&gt;p-&gt;deferred_probe);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看下<code>device_add()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * device_add - add device to device hierarchy.</span></span><br><span class="line"><span class="comment"> * @dev: device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is part 2 of device_register(), though may be called</span></span><br><span class="line"><span class="comment"> * separately _iff_ device_initialize() has been called separately.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This adds @dev to the kobject hierarchy via kobject_add(), adds it</span></span><br><span class="line"><span class="comment"> * to the global and sibling lists for the device, then</span></span><br><span class="line"><span class="comment"> * adds it to the other relevant subsystems of the driver model.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Do not call this routine or device_register() more than once for</span></span><br><span class="line"><span class="comment"> * any device structure.  The driver model core is not designed to work</span></span><br><span class="line"><span class="comment"> * with devices that get unregistered and then spring back to life.</span></span><br><span class="line"><span class="comment"> * (Among other things, it&#x27;s very hard to guarantee that all references</span></span><br><span class="line"><span class="comment"> * to the previous incarnation of @dev have been dropped.)  Allocate</span></span><br><span class="line"><span class="comment"> * and register a fresh new struct device instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> _Never_ directly free @dev after calling this function, even</span></span><br><span class="line"><span class="comment"> * if it returned an error! Always use put_device() to give up your</span></span><br><span class="line"><span class="comment"> * reference instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Rule of thumb is: if device_add() succeeds, you should call</span></span><br><span class="line"><span class="comment"> * device_del() when you want to get rid of it. If device_add() has</span></span><br><span class="line"><span class="comment"> * *not* succeeded, use *only* put_device() to drop the reference</span></span><br><span class="line"><span class="comment"> * count.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">device_add</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">        dev = get_device(dev); <span class="comment">//tj: see below</span></span><br><span class="line">        <span class="keyword">if</span> (!dev)</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!dev-&gt;p) &#123;</span><br><span class="line">                error = device_private_init(dev);</span><br><span class="line">                <span class="keyword">if</span> (error)</span><br><span class="line">                        <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">done:</span><br><span class="line">        put_device(dev);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"> SysEntryError:</span><br><span class="line">...</span><br><span class="line">parent_error:</span><br><span class="line">        put_device(parent);</span><br><span class="line">name_error:</span><br><span class="line">        kfree(dev-&gt;p);</span><br><span class="line">        dev-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get_device - increment reference count for device.</span></span><br><span class="line"><span class="comment"> * @dev: device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This simply forwards the call to kobject_get(), though</span></span><br><span class="line"><span class="comment"> * we do take care to provide for the case that we get a NULL</span></span><br><span class="line"><span class="comment"> * pointer passed in.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> device *<span class="title function_">get_device</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> dev ? kobj_to_dev(kobject_get(&amp;dev-&gt;kobj)) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>so device_add()不管成功失败，都先恢复下ref count via put_device(), 此时ref count恢复成初始值1了，rt?</p><p>如果失败，call put_device()此时应该会call <code>device_release()</code>。</p><p>如果成功了，<code>put_device()</code>放到了unregister里了。</p><p>Done.</p>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> device_register </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>devfreq governor代码分析</title>
      <link href="/analyze-devfreq-governor.html"/>
      <url>/analyze-devfreq-governor.html</url>
      
        <content type="html"><![CDATA[<p>参考内核5.x，代码路径是在drivers&#x2F;devfreq&#x2F;，devfreq的代码定义是：Generic Dynamic Voltage and Frequency Scaling (DVFS) Framework for Non-CPU Devices。而CPU动态调频是drivers&#x2F;cpufreq，devfreq是基于cpufreq而来。</p><p>第一次引入这个特性描述：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">PM: Introduce devfreq: generic DVFS framework with device-specific OPPs</span><br><span class="line"></span><br><span class="line">With OPPs, a device may have multiple operable frequency and voltage</span><br><span class="line">sets. However, there can be multiple possible operable sets and a system</span><br><span class="line">will need to choose one from them. In order to reduce the power</span><br><span class="line">consumption (by reducing frequency and voltage) without affecting the</span><br><span class="line">performance too much, a Dynamic Voltage and Frequency Scaling (DVFS)</span><br><span class="line">scheme may be used.</span><br><span class="line"></span><br><span class="line">This patch introduces the DVFS capability to non-CPU devices with OPPs.</span><br><span class="line">DVFS is a techique whereby the frequency and supplied voltage of a</span><br><span class="line">device is adjusted on-the-fly. DVFS usually sets the frequency as low</span><br><span class="line">as possible with given conditions (such as QoS assurance) and adjusts</span><br><span class="line">voltage according to the chosen frequency in order to reduce power</span><br><span class="line">consumption and heat dissipation.</span><br><span class="line"></span><br><span class="line">The generic DVFS for devices, devfreq, may appear quite similar with</span><br><span class="line">/drivers/cpufreq.  However, cpufreq does not allow to have multiple</span><br><span class="line">devices registered and is not suitable to have multiple heterogenous</span><br><span class="line">devices with different (but simple) governors.</span><br><span class="line"></span><br><span class="line">Normally, DVFS mechanism controls frequency based on the demand for</span><br><span class="line">the device, and then, chooses voltage based on the chosen frequency.</span><br><span class="line">devfreq also controls the frequency based on the governor&#x27;s frequency</span><br><span class="line">recommendation and let OPP pick up the pair of frequency and voltage</span><br><span class="line">based on the recommended frequency. Then, the chosen OPP is passed to</span><br><span class="line">device driver&#x27;s &quot;target&quot; callback.</span><br></pre></td></tr></table></figure><p>OPP是Operating Performance Point缩写，定义如下：</p><blockquote><p>Complex SoCs of today consists of a multiple sub-modules working in conjunction.<br>In an operational system executing varied use cases, not all modules in the SoC<br>need to function at their highest performing frequency all the time. To<br>facilitate this, sub-modules in a SoC are grouped into domains, allowing some<br>domains to run at lower voltage and frequency while other domains run at<br>voltage&#x2F;frequency pairs that are higher.</p><p>The set of discrete tuples consisting of frequency and voltage pairs that<br>the device will support per domain are called Operating Performance Points or<br>OPPs.</p></blockquote><p>简单说比如DDR有2个OPPs，分别是{1.8G, 1.3V}，{1G, 1V}，任君选择。</p><p>ok，基于OOPs，为了降低功耗而又不影响太多性能，DVFS由此而生。</p><p>devfreq和cpufreq的区别就是:</p><blockquote><p>cpufreq does not allow to have multiple devices registered and is not suitable to<br>have multiple heterogenous devices with different (but simple) governors.</p></blockquote><p>devfreq支持不同种类的device，这些device可以拥有不同的governor。这一点cpufreq是不具备的，你看cpufreq都是针对cpuX，governor都是一样一样的。</p><p>另外，devfreq提供了4个基本governor： ondemand&#x2F;performance&#x2F;powersave&#x2F;userspace&#x2F;，注意仅仅作为例子，drivers可以实现自己的governor。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Note that these are given only as basic examples for governors and any devices</span><br><span class="line">with devfreq may implement their own governors with the drivers and use them.</span><br></pre></td></tr></table></figure><p>passive governor是后来加入的，看下提交原因：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">The following governors are independently used for one device driver which don&#x27;t</span><br><span class="line">give the influence to other device drviers and also don&#x27;t receive the effect from</span><br><span class="line">other device drivers.</span><br></pre></td></tr></table></figure><p>ok，下面主要看下devfreq.c governor相关：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devfreq_governor</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[DEVFREQ_NAME_LEN];</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> immutable;</span><br><span class="line"><span class="type">int</span> (*get_target_freq)(<span class="keyword">struct</span> devfreq *this, <span class="type">unsigned</span> <span class="type">long</span> *freq);</span><br><span class="line"><span class="type">int</span> (*event_handler)(<span class="keyword">struct</span> devfreq *devfreq,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> event, <span class="type">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>immutable</code>如果是1就是governor运行时不能再变了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The list of all device-devfreq governors */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(devfreq_governor_list)</span>;</span><br></pre></td></tr></table></figure><p>用devfreq_governor_list来管理governor，比如增加governor:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">devfreq_add_governor</span><span class="params">(<span class="keyword">struct</span> devfreq_governor *governor)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devfreq_governor</span> *<span class="title">g</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devfreq</span> *<span class="title">devfreq</span>;</span></span><br><span class="line"><span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">mutex_lock(&amp;devfreq_list_lock);</span><br><span class="line">g = find_devfreq_governor(governor-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (!IS_ERR(g)) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;%s: governor %s already registered\n&quot;</span>, __func__,</span><br><span class="line">       g-&gt;name);</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err_out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list_add(&amp;governor-&gt;node, &amp;devfreq_governor_list); <span class="comment">//tj: add governor to list</span></span><br></pre></td></tr></table></figure><p>如果check此governor已经注册过了via <code>find_devfreq_governor()</code>，就直接返回了（需要返回error?），新的governor就加到governor list中。继续看：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_for_each_entry(devfreq, &amp;devfreq_list, node) &#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> devfreq-&gt;dev.parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(devfreq-&gt;governor_name, governor-&gt;name,</span><br><span class="line">     DEVFREQ_NAME_LEN)) &#123;</span><br><span class="line"><span class="comment">/* The following should never occur */</span></span><br><span class="line"><span class="keyword">if</span> (devfreq-&gt;governor) &#123;</span><br><span class="line">dev_warn(dev,</span><br><span class="line"> <span class="string">&quot;%s: Governor %s already present\n&quot;</span>,</span><br><span class="line"> __func__, devfreq-&gt;governor-&gt;name);</span><br><span class="line">ret = devfreq-&gt;governor-&gt;event_handler(devfreq,</span><br><span class="line">DEVFREQ_GOV_STOP, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_warn(dev,</span><br><span class="line"> <span class="string">&quot;%s: Governor %s stop = %d\n&quot;</span>,</span><br><span class="line"> __func__,</span><br><span class="line"> devfreq-&gt;governor-&gt;name, ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Fall through */</span></span><br><span class="line">&#125;</span><br><span class="line">devfreq-&gt;governor = governor;</span><br><span class="line">ret = devfreq-&gt;governor-&gt;event_handler(devfreq,</span><br><span class="line">DEVFREQ_GOV_START, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_warn(dev, <span class="string">&quot;%s: Governor %s start=%d\n&quot;</span>,</span><br><span class="line"> __func__, devfreq-&gt;governor-&gt;name,</span><br><span class="line"> ret);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The list of all device-devfreq */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(devfreq_list)</span>;</span><br></pre></td></tr></table></figure><p>扫描<code>devfreq_list</code>，如果在这个list中找到有governor_name的就start this governor，涉及到add device，来看：</p><h2 id="add-devfreq-to-device"><a href="#add-devfreq-to-device" class="headerlink" title="add devfreq to device"></a>add devfreq to device</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devfreq</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devfreq_dev_profile</span> *<span class="title">profile</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">devfreq_governor</span> *<span class="title">governor</span>;</span></span><br><span class="line"><span class="type">char</span> governor_name[DEVFREQ_NAME_LEN];</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>struct devfreq</code>有个成员<code>governor_name[]</code>，还有个pointer <code>governor</code>用来for how to choose freq。不过<code>struct devfreq_governor</code>也有name，so，可以去掉governor_name? 看下相关：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> devfreq *<span class="title function_">devfreq_add_device</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> devfreq_dev_profile *profile,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="type">char</span> *governor_name,</span></span><br><span class="line"><span class="params">   <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">devfreq-&gt;dev.class = devfreq_class;</span><br><span class="line">devfreq-&gt;dev.release = devfreq_dev_release;</span><br><span class="line">devfreq-&gt;profile = profile;</span><br><span class="line"><span class="built_in">strncpy</span>(devfreq-&gt;governor_name, governor_name, DEVFREQ_NAME_LEN);</span><br><span class="line">...</span><br><span class="line">mutex_lock(&amp;devfreq_list_lock);</span><br><span class="line"></span><br><span class="line">governor = try_then_request_governor(devfreq-&gt;governor_name);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(governor)) &#123;</span><br><span class="line">dev_err(dev, <span class="string">&quot;%s: Unable to find governor for the device\n&quot;</span>,</span><br><span class="line">__func__);</span><br><span class="line">err = PTR_ERR(governor);</span><br><span class="line"><span class="keyword">goto</span> err_init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">devfreq-&gt;governor = governor;</span><br><span class="line">err = devfreq-&gt;governor-&gt;event_handler(devfreq, DEVFREQ_GOV_START,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">dev_err(dev, <span class="string">&quot;%s: Unable to start governor for the device\n&quot;</span>,</span><br><span class="line">__func__);</span><br><span class="line"><span class="keyword">goto</span> err_init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list_add(&amp;devfreq-&gt;node, &amp;devfreq_list);</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;devfreq_list_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> devfreq;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>直接copy了passed governor_name to <code>devfreq-&gt;governor_name</code>。在通过<code>try_then_request_governor()</code>找到了一个governor后会start这个governor via callback。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> devfreq_governor *<span class="title function_">try_then_request_governor</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devfreq_governor</span> *<span class="title">governor</span>;</span></span><br><span class="line"><span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ERR_OR_NULL(name)) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;DEVFREQ: %s: Invalid parameters\n&quot;</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">&#125;</span><br><span class="line">WARN(!mutex_is_locked(&amp;devfreq_list_lock),</span><br><span class="line">     <span class="string">&quot;devfreq_list_lock must be locked.&quot;</span>);</span><br><span class="line"></span><br><span class="line">governor = find_devfreq_governor(name);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(governor)) &#123;</span><br><span class="line">mutex_unlock(&amp;devfreq_list_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(name, DEVFREQ_GOV_SIMPLE_ONDEMAND,</span><br><span class="line">     DEVFREQ_NAME_LEN))</span><br><span class="line">err = request_module(<span class="string">&quot;governor_%s&quot;</span>, <span class="string">&quot;simpleondemand&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">err = request_module(<span class="string">&quot;governor_%s&quot;</span>, name);</span><br><span class="line"><span class="comment">/* Restore previous state before return */</span></span><br><span class="line">mutex_lock(&amp;devfreq_list_lock);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> (err &lt; <span class="number">0</span>) ? ERR_PTR(err) : ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">governor = find_devfreq_governor(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> governor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> devfreq_governor *<span class="title function_">find_devfreq_governor</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devfreq_governor</span> *<span class="title">tmp_governor</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ERR_OR_NULL(name)) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;DEVFREQ: %s: Invalid parameters\n&quot;</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">&#125;</span><br><span class="line">WARN(!mutex_is_locked(&amp;devfreq_list_lock),</span><br><span class="line">     <span class="string">&quot;devfreq_list_lock must be locked.&quot;</span>);</span><br><span class="line"></span><br><span class="line">list_for_each_entry(tmp_governor, &amp;devfreq_governor_list, node) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(tmp_governor-&gt;name, name, DEVFREQ_NAME_LEN))</span><br><span class="line"><span class="keyword">return</span> tmp_governor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>so, 必须要先add governor到governor list，add device才能return ok，rt? yes, 但是前提都是built-in governor。如果governor编译成module，那add device先调用，而后add governor在request时调用。</p><p>ok，我们回来再看<code>devfreq_add_governor()</code>剩下来的<code>list_for_each_entry()</code>，再贴下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_for_each_entry(devfreq, &amp;devfreq_list, node) &#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> devfreq-&gt;dev.parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(devfreq-&gt;governor_name, governor-&gt;name,</span><br><span class="line">     DEVFREQ_NAME_LEN)) &#123;</span><br><span class="line"><span class="comment">/* The following should never occur */</span></span><br><span class="line"><span class="keyword">if</span> (devfreq-&gt;governor) &#123;</span><br><span class="line">dev_warn(dev,</span><br><span class="line"> <span class="string">&quot;%s: Governor %s already present\n&quot;</span>,</span><br><span class="line"> __func__, devfreq-&gt;governor-&gt;name);</span><br><span class="line">ret = devfreq-&gt;governor-&gt;event_handler(devfreq,</span><br><span class="line">DEVFREQ_GOV_STOP, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_warn(dev,</span><br><span class="line"> <span class="string">&quot;%s: Governor %s stop = %d\n&quot;</span>,</span><br><span class="line"> __func__,</span><br><span class="line"> devfreq-&gt;governor-&gt;name, ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Fall through */</span></span><br><span class="line">&#125;</span><br><span class="line">devfreq-&gt;governor = governor;</span><br><span class="line">ret = devfreq-&gt;governor-&gt;event_handler(devfreq,</span><br><span class="line">DEVFREQ_GOV_START, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_warn(dev, <span class="string">&quot;%s: Governor %s start=%d\n&quot;</span>,</span><br><span class="line"> __func__, devfreq-&gt;governor-&gt;name,</span><br><span class="line"> ret);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，这里的start governor是给add device中没有找到governor才用的，rt? 这块code貌似有问题，待我提交patch…</p><p>Done.</p>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> devfreq </tag>
            
            <tag> governor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何制作和挂载erofs格式vendor镜像</title>
      <link href="/how-to-make-and-mount-vendor-image-with-erofs.html"/>
      <url>/how-to-make-and-mount-vendor-image-with-erofs.html</url>
      
        <content type="html"><![CDATA[<p>Android P环境，mkfs.erofs is required firstly. Let’s build vendor.img with erofs format.</p><h2 id="build-process-for-vendor-with-ext4"><a href="#build-process-for-vendor-with-ext4" class="headerlink" title="build process for vendor with ext4"></a>build process for vendor with ext4</h2><p>看下vendor image with ext4过程：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">core/main.mk:1111:vendorimage: $(INSTALLED_VENDORIMAGE_TARGET)</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># We just build this directly to the install location.</span></span><br><span class="line">INSTALLED_VENDORIMAGE_TARGET := <span class="variable">$(BUILT_VENDORIMAGE_TARGET)</span></span><br><span class="line"><span class="variable">$(INSTALLED_VENDORIMAGE_TARGET)</span>: <span class="variable">$(INTERNAL_USERIMAGES_DEPS)</span> <span class="variable">$(INTERNAL_VENDORIMAGE_FILES)</span> <span class="variable">$(INSTALLED_FILES_FILE_VENDOR)</span> <span class="variable">$(BUILD_IMAGE_SRCS)</span> <span class="variable">$(DEPMOD)</span> <span class="variable">$(BOARD_VENDOR_KERNEL_MODULES)</span></span><br><span class="line">        $(build-vendorimage-target)</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">BUILT_VENDORIMAGE_TARGET := <span class="variable">$(PRODUCT_OUT)</span>/vendor.img</span><br><span class="line"><span class="keyword">define</span> build-vendorimage-target</span><br><span class="line">  <span class="variable">$(<span class="built_in">call</span> pretty,&quot;Target vendor fs image: <span class="variable">$(INSTALLED_VENDORIMAGE_TARGET)</span>&quot;)</span></span><br><span class="line">  @mkdir -p <span class="variable">$(TARGET_OUT_VENDOR)</span></span><br><span class="line">  @mkdir -p <span class="variable">$(vendorimage_intermediates)</span> &amp;&amp; rm -rf <span class="variable">$(vendorimage_intermediates)</span>/vendor_image_info.txt</span><br><span class="line">  <span class="variable">$(<span class="built_in">call</span> generate-userimage-prop-dictionary, <span class="variable">$(vendorimage_intermediates)</span>/vendor_image_info.txt, skip_fsck=true)</span></span><br><span class="line">  <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(BOARD_VENDOR_KERNEL_MODULES)</span>, \</span></span><br><span class="line"><span class="variable">    $(<span class="built_in">call</span> build-image-kernel-modules,<span class="variable">$(BOARD_VENDOR_KERNEL_MODULES)</span>,<span class="variable">$(TARGET_OUT_VENDOR)</span>,vendor/,$(<span class="built_in">call</span> intermediates-<span class="built_in">dir</span>-for,PACKAGING,depmod_vendor)</span>))</span><br><span class="line">  <span class="variable">$(hide)</span> PATH=<span class="variable">$(<span class="built_in">foreach</span> p,<span class="variable">$(INTERNAL_USERIMAGES_BINARY_PATHS)</span>,<span class="variable">$(p)</span>:)</span>$$PATH \</span><br><span class="line">      build/make/tools/releasetools/build_image.py \</span><br><span class="line">      <span class="variable">$(TARGET_OUT_VENDOR)</span> <span class="variable">$(vendorimage_intermediates)</span>/vendor_image_info.txt <span class="variable">$(INSTALLED_VENDORIMAGE_TARGET)</span> <span class="variable">$(TARGET_OUT)</span></span><br><span class="line">  <span class="variable">$(hide)</span> <span class="variable">$(<span class="built_in">call</span> assert-max-image-size,<span class="variable">$(INSTALLED_VENDORIMAGE_TARGET)</span>,<span class="variable">$(BOARD_VENDORIMAGE_PARTITION_SIZE)</span>)</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure><p>制作img的工具：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(INTERNAL_USERIMAGES_USE_EXT)</span>,true)</span><br><span class="line">INTERNAL_USERIMAGES_DEPS := <span class="variable">$(SIMG2IMG)</span></span><br><span class="line">INTERNAL_USERIMAGES_DEPS += <span class="variable">$(MKEXTUSERIMG)</span> <span class="variable">$(MAKE_EXT4FS)</span> <span class="variable">$(E2FSCK)</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(TARGET_USERIMAGES_USE_F2FS)</span>,true)</span><br><span class="line">INTERNAL_USERIMAGES_DEPS += <span class="variable">$(MKF2FSUSERIMG)</span> <span class="variable">$(MAKE_F2FS)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>工具定义：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./core/config.mk:668:MKEXTUSERIMG := $(HOST_OUT_EXECUTABLES)/mkuserimg_mke2fs.sh</span><br></pre></td></tr></table></figure><p>用build&#x2F;make&#x2F;tools&#x2F;releasetools&#x2F;build_image.py去生成:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BuildImage</span>(<span class="params">in_dir, prop_dict, out_file, target_out=<span class="literal">None</span></span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Build an image to out_file from in_dir with property prop_dict.</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> image_filename == <span class="string">&quot;system.img&quot;</span>:</span><br><span class="line">    mount_point = <span class="string">&quot;system&quot;</span></span><br><span class="line">  <span class="keyword">elif</span> image_filename == <span class="string">&quot;system_other.img&quot;</span>:</span><br><span class="line">    mount_point = <span class="string">&quot;system_other&quot;</span></span><br><span class="line">  <span class="keyword">elif</span> image_filename == <span class="string">&quot;userdata.img&quot;</span>:</span><br><span class="line">    mount_point = <span class="string">&quot;data&quot;</span></span><br><span class="line">  <span class="keyword">elif</span> image_filename == <span class="string">&quot;cache.img&quot;</span>:</span><br><span class="line">    mount_point = <span class="string">&quot;cache&quot;</span></span><br><span class="line">  <span class="keyword">elif</span> image_filename == <span class="string">&quot;vendor.img&quot;</span>:</span><br><span class="line">    mount_point = <span class="string">&quot;vendor&quot;</span></span><br><span class="line">  <span class="keyword">elif</span> image_filename == <span class="string">&quot;oem.img&quot;</span>:</span><br><span class="line">    mount_point = <span class="string">&quot;oem&quot;</span></span><br><span class="line">  <span class="keyword">elif</span> image_filename == <span class="string">&quot;product.img&quot;</span>:</span><br><span class="line">    mount_point = <span class="string">&quot;product&quot;</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;error: unknown image file name &quot;</span>, image_filename, file=sys.stderr)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  image_properties = ImagePropFromGlobalDict(glob_dict, mount_point)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> BuildImage(in_dir, image_properties, out_file, target_out):</span><br></pre></td></tr></table></figure><p>ok，下来就可以添加了。</p><h2 id="add-support-for-erofs-image"><a href="#add-support-for-erofs-image" class="headerlink" title="add support for erofs image"></a>add support for erofs image</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">@@ -1095,6 +1095,11 @@ <span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">filter</span> <span class="variable">$(BOARD_PRODUCTIMAGE_FILE_SYSTEM_TYPE)</span> $(BOARD_VENDORIMAGE_FILE_</span></span><br><span class="line"><span class="variable"> INTERNAL_USERIMAGES_DEPS += <span class="variable">$(MAKE_SQUASHFS)</span> <span class="variable">$(MKSQUASHFSUSERIMG)</span> <span class="variable">$(IMG2SIMG)</span></span></span><br><span class="line"><span class="variable"> endif</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line"><span class="variable">+INTERNAL_USERIMAGES_SPARSE_EROFS_FLAG := -s</span></span><br><span class="line"><span class="variable">+ifneq ($(<span class="built_in">filter</span> <span class="variable">$(BOARD_PRODUCTIMAGE_FILE_SYSTEM_TYPE)</span> <span class="variable">$(BOARD_VENDORIMAGE_FILE_SYSTEM_TYPE)</span> <span class="variable">$(BOARD_SYSTEMIMAGE_FILE_SYSTEM_TYPE)</span>,erofs)</span>,)</span><br><span class="line">+INTERNAL_USERIMAGES_DEPS += <span class="variable">$(MAKE_EROFS)</span> <span class="variable">$(MKEROFSUSERIMG)</span> <span class="variable">$(IMG2SIMG)</span></span><br><span class="line">+<span class="keyword">endif</span></span><br><span class="line">+</span><br><span class="line"> INTERNAL_USERIMAGES_BINARY_PATHS := <span class="variable">$(<span class="built_in">sort</span> $(<span class="built_in">dir</span> <span class="variable">$(INTERNAL_USERIMAGES_DEPS)</span>)</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">ifeq</span> (true,$(PRODUCTS.<span class="variable">$(INTERNAL_PRODUCT)</span>.PRODUCT_SUPPORTS_VERITY))</span><br><span class="line">@@ -1162,6 +1167,7 @@ <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(BOARD_OEMIMAGE_EXTFS_INODE_COUNT)</span>,<span class="variable">$(hide)</span> echo &quot;oem_extfs_inode_count=$(B</span></span><br><span class="line"><span class="variable"> $(<span class="built_in">if</span> <span class="variable">$(BOARD_OEMIMAGE_EXTFS_RSV_PCT)</span>,<span class="variable">$(hide)</span> echo &quot;oem_extfs_rsv_pct=<span class="variable">$(BOARD_OEMIMAGE_EXTFS_RSV_PCT)</span>&quot; &gt;&gt; $(1)</span>)</span><br><span class="line"> <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(INTERNAL_USERIMAGES_SPARSE_EXT_FLAG)</span>,<span class="variable">$(hide)</span> echo &quot;extfs_sparse_flag=<span class="variable">$(INTERNAL_USERIMAGES_SPARSE_EXT_FLAG)</span>&quot; &gt;&gt; $(1)</span>)</span><br><span class="line"> <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(INTERNAL_USERIMAGES_SPARSE_SQUASHFS_FLAG)</span>,<span class="variable">$(hide)</span> echo &quot;squashfs_sparse_flag=<span class="variable">$(INTERNAL_USERIMAGES_SPARSE_SQUASHFS_FLAG)</span>&quot; &gt;&gt; $(1)</span>)</span><br><span class="line">+<span class="variable">$(<span class="built_in">if</span> <span class="variable">$(INTERNAL_USERIMAGES_SPARSE_EROFS_FLAG)</span>,<span class="variable">$(hide)</span> echo &quot;erofs_sparse_flag=<span class="variable">$(INTERNAL_USERIMAGES_SPARSE_EROFS_FLAG)</span>&quot; &gt;&gt; $(1)</span>)</span><br></pre></td></tr></table></figure><p>build&#x2F;make&#x2F;core&#x2F;config.mk:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"> MKF2FSUSERIMG := <span class="variable">$(HOST_OUT_EXECUTABLES)</span>/mkf2fsuserimg.sh</span><br><span class="line">+MAKE_EROFS := <span class="variable">$(HOST_OUT_EXECUTABLES)</span>/mkfs.erofs</span><br><span class="line">+MKEROFSUSERIMG := <span class="variable">$(HOST_OUT_EXECUTABLES)</span>/mkerofsimage.sh</span><br><span class="line"> SIMG2IMG := <span class="variable">$(HOST_OUT_EXECUTABLES)</span>/simg2img<span class="variable">$(HOST_EXECUTABLE_SUFFIX)</span></span><br></pre></td></tr></table></figure><p>build&#x2F;make&#x2F;tools&#x2F;releasetools&#x2F;build_image.py:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@@ -<span class="number">597</span>,<span class="number">6</span> +<span class="number">597</span>,<span class="number">20</span> @@ def BuildImage(<span class="params">in_dir, prop_dict, out_file, target_out=<span class="literal">None</span></span>):</span></span><br><span class="line">     <span class="keyword">if</span> <span class="string">&quot;timestamp&quot;</span> <span class="keyword">in</span> prop_dict:</span><br><span class="line">       build_command.extend([<span class="string">&quot;-T&quot;</span>, <span class="built_in">str</span>(prop_dict[<span class="string">&quot;timestamp&quot;</span>])])</span><br><span class="line">     build_command.extend([<span class="string">&quot;-L&quot;</span>, prop_dict[<span class="string">&quot;mount_point&quot;</span>]])</span><br><span class="line">+  <span class="keyword">elif</span> fs_type.startswith(<span class="string">&quot;erofs&quot;</span>):</span><br><span class="line">+    build_command = [<span class="string">&quot;mkerofsimage.sh&quot;</span>]</span><br><span class="line">+    build_command.extend([in_dir, out_file])</span><br><span class="line">+    <span class="keyword">if</span> <span class="string">&quot;erofs_sparse_flag&quot;</span> <span class="keyword">in</span> prop_dict:</span><br><span class="line">+      build_command.extend([prop_dict[<span class="string">&quot;erofs_sparse_flag&quot;</span>]])</span><br><span class="line">+    build_command.extend([<span class="string">&quot;-m&quot;</span>, prop_dict[<span class="string">&quot;mount_point&quot;</span>]])</span><br><span class="line">+    <span class="keyword">if</span> target_out:</span><br><span class="line">+      build_command.extend([<span class="string">&quot;-d&quot;</span>, target_out])</span><br><span class="line">+    <span class="keyword">if</span> fs_config:</span><br><span class="line">+      build_command.extend([<span class="string">&quot;-C&quot;</span>, fs_config])</span><br><span class="line">+    <span class="keyword">if</span> <span class="string">&quot;selinux_fc&quot;</span> <span class="keyword">in</span> prop_dict:</span><br><span class="line">+      build_command.extend([<span class="string">&quot;-c&quot;</span>, prop_dict[<span class="string">&quot;selinux_fc&quot;</span>]])</span><br><span class="line">+    <span class="keyword">if</span> <span class="string">&quot;erofs_compressor&quot;</span> <span class="keyword">in</span> prop_dict:</span><br><span class="line">+      build_command.extend([<span class="string">&quot;-z&quot;</span>, prop_dict[<span class="string">&quot;erofs_compressor&quot;</span>]])</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;Error: unknown filesystem type &#x27;%s&#x27;&quot;</span> % (fs_type))</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="meta">@@ -<span class="number">704</span>,<span class="number">6</span> +<span class="number">718</span>,<span class="number">7</span> @@ def ImagePropFromGlobalDict(<span class="params">glob_dict, mount_point</span>):</span></span><br><span class="line">   common_props = (</span><br><span class="line">       <span class="string">&quot;extfs_sparse_flag&quot;</span>,</span><br><span class="line">       <span class="string">&quot;squashfs_sparse_flag&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;erofs_sparse_flag&quot;</span>,</span><br><span class="line">       <span class="string">&quot;selinux_fc&quot;</span>,</span><br></pre></td></tr></table></figure><p>system&#x2F;extras添加erofs_utils:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@ubuntu:~/work/code/system/extras/erofs_utils$ <span class="built_in">ls</span></span><br><span class="line">Android.mk  mkerofsimage.sh  mkfs.erofs</span><br></pre></td></tr></table></figure><p>mkerofsimage.sh主要参考ext4,squashfs:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MAKE_EROFS_CMD=<span class="string">&quot;mkfs.erofs <span class="variable">$OUTPUT_FILE</span> <span class="variable">$SRC_DIR</span>/&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$MAKE_EROFS_CMD</span></span><br><span class="line"><span class="variable">$MAKE_EROFS_CMD</span></span><br><span class="line"></span><br><span class="line">SPARSE_SUFFIX=<span class="string">&quot;.sparse&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$SPARSE</span>&quot;</span> = <span class="literal">true</span> ]; <span class="keyword">then</span></span><br><span class="line">    img2simg <span class="variable">$OUTPUT_FILE</span> $OUTPUT_FILE<span class="variable">$SPARSE_SUFFIX</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">exit</span> 4</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">mv</span> $OUTPUT_FILE<span class="variable">$SPARSE_SUFFIX</span> <span class="variable">$OUTPUT_FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>项目启用<code>BOARD_VENDORIMAGE_FILE_SYSTEM_TYPE</code>为erofs, build is ok:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ 99% 7719/7720] Installed file list: out/.../installed-files-vendor.txt</span><br><span class="line">[100% 7720/7720] Target vendor fs image: out/.../vendor.img</span><br><span class="line">...</span><br><span class="line">mkfs.erofs out/.../vendor.img out/.../vendor/</span><br><span class="line">  c_version:           [0.1   Jul  9 2019 03:24:50]</span><br><span class="line">  c_img_path:          [out/.../vendor.img]</span><br><span class="line">  c_src_path:          [out/.../vendor]</span><br><span class="line">  c_dbg_lvl:           [       0]</span><br><span class="line">  c_dry_run:           [       0]</span><br><span class="line">  c_alg_name:          [    none]</span><br><span class="line">  c_compr_maxsz:       [  921600]</span><br><span class="line">  c_compr_lvl:         [       0]</span><br><span class="line">  c_compr_boundary:    [     128]</span><br><span class="line">  c_compr_ratio_limit: [     100]</span><br><span class="line"></span><br><span class="line"><span class="comment">### build completed successfully (04:10 (mm:ss)) ####</span></span><br></pre></td></tr></table></figure><p>QCOM P vendor mount移到了dts下，ext4改为erofs后可以mount ok。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[   <span class="number">11.566421</span>] erofs: mounted on /dev/block/platform/soc/<span class="number">7824900.</span>sdhci/by-name/vendor with ...</span><br><span class="line">[   <span class="number">11.569767</span>] init: [libfs_mgr]__mount(source=/dev/block/platform/soc/<span class="number">7824900.</span>sdhci/by-name/vendor,target=/vendor,type=erofs)=<span class="number">0</span>: Success</span><br></pre></td></tr></table></figure><p>权限问题，待check。</p><p>ps: squashfs也是只读文件系统，提个patch给维护人Phillip，半天不回，算了，懒得看了。。。</p><p>mkerofsimage.sh参考实现：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To call this script, make sure mkfs.erofs is somewhere in PATH</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">usage</span></span>() &#123;</span><br><span class="line"><span class="built_in">cat</span>&lt;&lt;<span class="string">EOT</span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">$&#123;0##*/&#125; SRC_DIR OUTPUT_FILE [-s] [-m MOUNT_POINT] [-d PRODUCT_OUT] [-C FS_CONFIG ] [-c FILE_CONTEXTS] [-z COMPRESSOR]</span></span><br><span class="line"><span class="string">EOT</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;in mkerofsimage.sh PATH=<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 2 ]; <span class="keyword">then</span></span><br><span class="line">    usage</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">SRC_DIR=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$SRC_DIR</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Can not find directory <span class="variable">$SRC_DIR</span>!&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">OUTPUT_FILE=<span class="variable">$2</span></span><br><span class="line"><span class="built_in">shift</span>; <span class="built_in">shift</span></span><br><span class="line"></span><br><span class="line">SPARSE=<span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;-s&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    SPARSE=<span class="literal">true</span></span><br><span class="line">    <span class="built_in">shift</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">MOUNT_POINT=</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;-m&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    MOUNT_POINT=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">shift</span>; <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">PRODUCT_OUT=</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;-d&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    PRODUCT_OUT=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">shift</span>; <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">FS_CONFIG=</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;-C&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    FS_CONFIG=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">shift</span>; <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">FILE_CONTEXTS=</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;-c&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    FILE_CONTEXTS=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">shift</span>; <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">COMPRESSOR=<span class="string">&quot;lz4&quot;</span></span><br><span class="line">COMPRESSOR_OPT=<span class="string">&quot;-Xhc&quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;-z&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    COMPRESSOR=<span class="variable">$2</span></span><br><span class="line">    COMPRESSOR_OPT=</span><br><span class="line">    <span class="built_in">shift</span>; <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">OPT=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$MOUNT_POINT</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  OPT=<span class="string">&quot;<span class="variable">$OPT</span> -mount-point <span class="variable">$MOUNT_POINT</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$PRODUCT_OUT</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  OPT=<span class="string">&quot;<span class="variable">$OPT</span> -product-out <span class="variable">$PRODUCT_OUT</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$FS_CONFIG</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  OPT=<span class="string">&quot;<span class="variable">$OPT</span> -fs-config-file <span class="variable">$FS_CONFIG</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$FILE_CONTEXTS</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  OPT=<span class="string">&quot;<span class="variable">$OPT</span> -context-file <span class="variable">$FILE_CONTEXTS</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">MAKE_EROFS_CMD=<span class="string">&quot;mkfs.erofs <span class="variable">$OUTPUT_FILE</span> <span class="variable">$SRC_DIR</span>/&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$MAKE_EROFS_CMD</span></span><br><span class="line"><span class="variable">$MAKE_EROFS_CMD</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 4</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">SPARSE_SUFFIX=<span class="string">&quot;.sparse&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$SPARSE</span>&quot;</span> = <span class="literal">true</span> ]; <span class="keyword">then</span></span><br><span class="line">    img2simg <span class="variable">$OUTPUT_FILE</span> $OUTPUT_FILE<span class="variable">$SPARSE_SUFFIX</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">exit</span> 4</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">mv</span> $OUTPUT_FILE<span class="variable">$SPARSE_SUFFIX</span> <span class="variable">$OUTPUT_FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erofs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>erofs代码分析:on-disk inode layout</title>
      <link href="/anaylze-on-disk-inode-layout-of-erofs.html"/>
      <url>/anaylze-on-disk-inode-layout-of-erofs.html</url>
      
        <content type="html"><![CDATA[<p>参考staging erofs，on-disk inode layout相关实现是erofs_fs.h + super.c + inode.c。</p><h2 id="data-mappings"><a href="#data-mappings" class="headerlink" title="data mappings"></a>data mappings</h2><p>先看文档介绍：</p><blockquote><p>- Metadata &amp; data could be mixed by design;</p></blockquote><blockquote><p>Different from other read-only file systems, an EROFS volume is designed to be as simple as possible:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">                              |-&gt; aligned with the block size </span><br><span class="line">_____________________________________________________________ </span><br><span class="line">| |SB| | ... | Metadata | ... | Data | Metadata | ... | Data |</span><br><span class="line">|_|__|_|_____|__________|_____|______|__________|_____|______|</span><br><span class="line">0 +1K</span><br></pre></td></tr></table></figure></blockquote><p>What is metadata in fs? refer below from wikipedia:</p><blockquote><p>metadata is data information that provides infor about other data.</p></blockquote><p>erofs super block放到了1K偏移处。<code>superblock_read()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EROFS_SUPER_OFFSET      1024</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">superblock_read</span><span class="params">(<span class="keyword">struct</span> super_block *sb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">erofs_sb_info</span> *<span class="title">sbi</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">erofs_super_block</span> *<span class="title">layout</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> blkszbits;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">bh = sb_bread(sb, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">errln(<span class="string">&quot;cannot read erofs superblock&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sbi = EROFS_SB(sb);</span><br><span class="line">layout = (<span class="keyword">struct</span> erofs_super_block *)((u8 *)bh-&gt;b_data</span><br><span class="line"> + EROFS_SUPER_OFFSET); <span class="comment">// tj: here</span></span><br></pre></td></tr></table></figure><blockquote><p>All data areas should be aligned with the block size, but metadata areas may not. All metadatas can be now observed in two different spaces (views):</p><ol><li><p>Inode metadata space<br>Each valid inode should be aligned with an inode slot, which is a fixed value (32 bytes) and designed to be kept in line with v1 inode size.</p><p>Each inode can be directly found with the following formula:<br>\ \ \ \ \     inode offset &#x3D; meta_blkaddr * block_size + 32 * nid</p></li></ol><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">                            |-&gt; aligned with 8B </span><br><span class="line">                                       |-&gt; followed closely </span><br><span class="line">+ meta_blkaddr blocks                                      |-&gt; another slot </span><br><span class="line"> _____________________________________________________________________ </span><br><span class="line">|  ...   | inode |  xattrs  | extents  | data inline | ... | inode ...</span><br><span class="line">|________|_______|(optional)|(optional)|__(optional)_|_____|__________ </span><br><span class="line">         |-&gt; aligned with the inode slot size</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Xattrs, extents, data inline are followed by the corresponding inode with proper alignes, and they could be optional for different data mappings, <em>currently</em> there are totally 3 valid data mappings supported:<br>     1) flat file data without data inline (no extent);<br>     2) fixed-output size data compression (must have extents);<br>     3) flat file data with tail-end data inline (no extent);</p></blockquote><p>三种inode data mapping:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * erofs inode data mapping:</span></span><br><span class="line"><span class="comment"> * 0 - inode plain without inline data A:</span></span><br><span class="line"><span class="comment"> * inode, [xattrs], ... | ... | no-holed data</span></span><br><span class="line"><span class="comment"> * 1 - inode VLE compression B:</span></span><br><span class="line"><span class="comment"> * inode, [xattrs], extents ... | ...</span></span><br><span class="line"><span class="comment"> * 2 - inode plain with inline data C:</span></span><br><span class="line"><span class="comment"> * inode, [xattrs], last_inline_data, ... | ... | no-holed data</span></span><br><span class="line"><span class="comment"> * 3~7 - reserved</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">EROFS_INODE_LAYOUT_PLAIN,</span><br><span class="line">EROFS_INODE_LAYOUT_COMPRESSION,</span><br><span class="line">EROFS_INODE_LAYOUT_INLINE,</span><br><span class="line">EROFS_INODE_LAYOUT_MAX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="read-super-block"><a href="#read-super-block" class="headerlink" title="read super block"></a>read super block</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">erofs_mount() &gt; erofs_fill_super() &gt; erofs_read_super()</span><br></pre></td></tr></table></figure><p>mount时会call <code>erofs_read_super()</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">erofs_read_super</span><span class="params">(<span class="keyword">struct</span> super_block *sb,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *dev_name,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *data, <span class="type">int</span> silent)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">erofs_sb_info</span> *<span class="title">sbi</span>;</span></span><br><span class="line">sb-&gt;s_fs_info = sbi;</span><br><span class="line">...</span><br><span class="line">err = superblock_read(sb);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> err_sbread;</span><br></pre></td></tr></table></figure><p><code>superblock_read()</code>就是find super block，super block结构赋值来源mkfs.erofs.</p><p>接下来在解析mount选项后会获取root inode给<code>-&gt;s_root</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* get the root inode */</span></span><br><span class="line">inode = erofs_iget(sb, ROOT_NID(sbi), <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(inode)) &#123;</span><br><span class="line">err = PTR_ERR(inode);</span><br><span class="line"><span class="keyword">goto</span> err_iget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!S_ISDIR(inode-&gt;i_mode)) &#123;</span><br><span class="line">errln(<span class="string">&quot;rootino(nid %llu) is not a directory(i_mode %o)&quot;</span>,</span><br><span class="line">      ROOT_NID(sbi), inode-&gt;i_mode);</span><br><span class="line">err = -EINVAL;</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">goto</span> err_iget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sb-&gt;s_root = d_make_root(inode); <span class="comment">//tj: here</span></span><br><span class="line"><span class="keyword">if</span> (!sb-&gt;s_root) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err_iget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果root inode不是目录，那就无效了。</p><h2 id="get-inode"><a href="#get-inode" class="headerlink" title="get inode"></a>get inode</h2><p>主要看下<code>erofs_iget()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode *<span class="title function_">erofs_iget</span><span class="params">(<span class="keyword">struct</span> super_block *sb,</span></span><br><span class="line"><span class="params"> <span class="type">erofs_nid_t</span> nid,</span></span><br><span class="line"><span class="params"> <span class="type">bool</span> isdir)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> erofs_iget_locked(sb, nid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!inode))</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (inode-&gt;i_state &amp; I_NEW) &#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">erofs_vnode</span> *<span class="title">vi</span> =</span> EROFS_V(inode);</span><br><span class="line"></span><br><span class="line">vi-&gt;nid = nid;</span><br><span class="line"></span><br><span class="line">err = fill_inode(inode, isdir);</span><br><span class="line"><span class="keyword">if</span> (likely(!err))</span><br><span class="line">unlock_new_inode(inode);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">iget_failed(inode);</span><br><span class="line">inode = ERR_PTR(err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是call <code>erofs_iget_locked()</code>获取，如果没有get到(几率小)就出错了，如果是<code>I_NEW</code>状态，那就生成一个新inode via <code>fill_inode()</code>。</p><p>64bits及以上平台用<code>iget_locked()</code>，其他用<code>iget5_locked()</code>，两个vfs接口，not care now，lets check <code>fill_inode()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fill_inode</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">int</span> isdir)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">erofs_sb_info</span> *<span class="title">sbi</span> =</span> EROFS_SB(inode-&gt;i_sb);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">erofs_vnode</span> *<span class="title">vi</span> =</span> EROFS_V(inode);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">void</span> *data;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="type">erofs_blk_t</span> blkaddr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ofs;</span><br><span class="line"></span><br><span class="line">trace_erofs_fill_inode(inode, isdir);</span><br><span class="line"></span><br><span class="line">blkaddr = erofs_blknr(iloc(sbi, vi-&gt;nid));</span><br><span class="line">ofs = erofs_blkoff(iloc(sbi, vi-&gt;nid));</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u64 <span class="type">erofs_off_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* data type for filesystem-wide blocks number */</span></span><br><span class="line"><span class="keyword">typedef</span> u32 <span class="type">erofs_blk_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> erofs_blknr(addr)       ((addr) / EROFS_BLKSIZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> erofs_blkoff(addr)      ((addr) % EROFS_BLKSIZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> blknr_to_addr(nr)       ((erofs_off_t)(nr) * EROFS_BLKSIZ)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">erofs_off_t</span> <span class="title function_">iloc</span><span class="params">(<span class="keyword">struct</span> erofs_sb_info *sbi, <span class="type">erofs_nid_t</span> nid)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> blknr_to_addr(sbi-&gt;meta_blkaddr) + (nid &lt;&lt; sbi-&gt;islotbits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按inode metadata view来，<code>-&gt;meta_blkaddr</code>是block number? <code>iloc()</code>负责找到inode address。</p><p>接下来会get inode page, mark to check later.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">page = erofs_get_meta_page(inode-&gt;i_sb, blkaddr, isdir);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(page)) &#123;</span><br><span class="line">errln(<span class="string">&quot;failed to get inode (nid: %llu) page, err %ld&quot;</span>,</span><br><span class="line">      vi-&gt;nid, PTR_ERR(page));</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(page);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">data = page_address(page);</span><br><span class="line"></span><br><span class="line">err = read_inode(inode, data + ofs);</span><br></pre></td></tr></table></figure><p><code>read_inode()</code>会读data(来自inode page)的<code>-&gt;i_advise</code>走inode v1 or v2。没有错误会check是否是inline data。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fill_inline_data</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">int</span> m_pofs)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">erofs_vnode</span> *<span class="title">vi</span> =</span> EROFS_V(inode);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">erofs_sb_info</span> *<span class="title">sbi</span> =</span> EROFS_I_SB(inode);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mode = vi-&gt;datamode;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* fast symlink (following ext4) */</span></span><br><span class="line"><span class="keyword">if</span> (S_ISLNK(inode-&gt;i_mode) &amp;&amp; inode-&gt;i_size &lt; PAGE_SIZE) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>fast symlink看条件就是比较小的inode, rt? inline data是for fast symlink? let’s check mkfs.erofs:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mkfs_relocate_sub_inodes</span><span class="params">(<span class="keyword">struct</span> erofs_vnode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> EROFS_FT_DIR:</span><br><span class="line">        <span class="keyword">case</span> EROFS_FT_SYMLINK:</span><br><span class="line">                unaligned = d-&gt;i_size % EROFS_BLKSIZE;</span><br><span class="line">                nblocks   = d-&gt;i_size / EROFS_BLKSIZE;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (unaligned &gt; erofs_calc_inline_data_size(d) ||</span><br><span class="line">                    (unaligned == <span class="number">0</span> &amp;&amp; nblocks != <span class="number">0</span>)) &#123;</span><br><span class="line">                        d-&gt;i_dmode = EROFS_INODE_LAYOUT_PLAIN;</span><br><span class="line">                        mkfs_rank_inode(d);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (unaligned != <span class="number">0</span>)</span><br><span class="line">                                nblocks++;</span><br><span class="line">                        blkaddr = erofs_alloc_blocks(nblocks);</span><br><span class="line">                        <span class="keyword">if</span> (!blkaddr)</span><br><span class="line">                                <span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">                        d-&gt;i_blkaddr = blkaddr;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        d-&gt;i_dmode        = EROFS_INODE_LAYOUT_INLINE;</span><br><span class="line">                        d-&gt;i_inline_datalen = unaligned;</span><br><span class="line">                        mkfs_rank_inode(d);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (nblocks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                blkaddr = erofs_alloc_blocks(nblocks);</span><br><span class="line">                                <span class="keyword">if</span> (!blkaddr)</span><br><span class="line">                                        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">                                d-&gt;i_blkaddr = blkaddr;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                d-&gt;i_blkaddr = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>EROFS_FT_DIR type的貌似也可以吧。</p><p>Done.</p>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erofs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to build mkfs.erofs for ARM64</title>
      <link href="/how-to-build-mkfs-erofs-for-arm64.html"/>
      <url>/how-to-build-mkfs-erofs-for-arm64.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>mkfs.erofs is a user-space tool to create erofs filesystem images.</p></blockquote><p>erofs是华为为了增强安卓性能提出的自研文件系统，其内核文档提到用户态工具:</p><blockquote><p>The following git tree provides the file system user-space<br>tools under development (ex, formatting tool mkfs.erofs):<br>&gt;&gt; git:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;xiang&#x2F;erofs-utils.git</p></blockquote><p>ok, 先down下来:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://git.kernel.org/pub/scm/linux/kernel/git/xiang/erofs-utils.git</span><br></pre></td></tr></table></figure><p>查看所有分支：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tj@qemu:~/erofs-utils$ git branch -a</span><br><span class="line">  remotes/origin/experimental</span><br><span class="line">  remotes/origin/experimental-dip</span><br><span class="line">  remotes/origin/mkfs-dev</span><br></pre></td></tr></table></figure><p>切到mkfs-dev，其他2个还有问题：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@qemu:~/erofs-utils$ git checkout -b mkfs-dev origin/mkfs-dev</span><br><span class="line">Branch mkfs-dev <span class="built_in">set</span> up to track remote branch mkfs-dev from origin.</span><br><span class="line">Switched to a new branch <span class="string">&#x27;mkfs-dev&#x27;</span></span><br></pre></td></tr></table></figure><p>ok, <code>ls</code>能看到东西了，看下编译介绍：</p><blockquote><p>Note that mkfs.erofs can only be linked statically with lz4 library<br>due to the dependency of experimental lz4hc apis which were added in<br>lz4 1.8.0. Anyway, it’s a good start to begin with building the latest<br>lz4 library statically first. :)</p><p>Dependencies<br> lz4-1.8.0 or above</p><p>How to build with lz4 static library<br>       .&#x2F;configure –with-lz4&#x3D;<lz4 install path><br>\eg. if lz4 lib has been installed into fold of &#x2F;usr&#x2F;local&#x2F;lib<br>       .&#x2F;configure –with-lz4&#x3D;&#x2F;usr&#x2F;local&#x2F;lib &amp;&amp; make<br>On Fedora, static lz4 can be installed using:<br>        yum install lz4-static.x86_64<br>To build you should run this first:<br>        $ .&#x2F;autogen.sh<br>        $ .&#x2F;configure<br>        $ make</p></blockquote><h2 id="build-lz4"><a href="#build-lz4" class="headerlink" title="build lz4"></a>build lz4</h2><p>环境:Ubuntu14.04，下一份lz4 code，要1z4-1.8.0 or above，我down了个1.8.2。</p><p>交叉工具用了aarch64-linux-android-4.9，安卓版本里也有，如果编译lz4 for x86会提示不兼容错误：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">840 /home/tj/crosstools/aarch64-linux-android-4.9/bin/../lib/gcc/aarch64-linux-android/4.9.x-google/../../../../aarch64-linux-android/bin/ld: skipping incompatible /usr/local/lib/liblz4.so when searching <span class="keyword">for</span> -llz4</span><br><span class="line">841 /home/tj/crosstools/aarch64-linux-android-4.9/bin/../lib/gcc/aarch64-linux-android/4.9.x-google/../../../../aarch64-linux-android/bin/ld: skipping incompatible /usr/local/lib/liblz4.a when searching <span class="keyword">for</span> -llz4</span><br><span class="line">843 collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure><p>编译工具参数CC指定为aarch64-linux-android就好，记得把工具链都include到<code>PATH</code>环境变量中。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CC=aarch64-linux-android</span><br></pre></td></tr></table></figure><p>另外还需要个包，如我的N平台：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">prebuilts/ndk/current/platforms/android-21/arch-arm64</span><br></pre></td></tr></table></figure><p>编译时要指定<code>--sysroot</code>，不然编译会报找不到头文件错误：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CFLAGS=<span class="string">&quot;--sysroot=/home/tj/sysroot/arch-arm64/&quot;</span></span><br></pre></td></tr></table></figure><p>then <code>make</code>，then <code>sudo make install</code>会默认装到了&#x2F;usr&#x2F;local&#x2F;下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@qemu:~/lz4-1.8.2$ <span class="built_in">ls</span> -l /usr/local/lib/liblz4.</span><br><span class="line">liblz4.a         liblz4.so        liblz4.so.1      liblz4.so.1.8.2</span><br><span class="line">tj@qemu:~/lz4-1.8.2$ <span class="built_in">ls</span> -l /usr/local/include/lz4</span><br><span class="line">lz4frame.h         lz4frame_static.h  lz4.h              lz4hc.h</span><br></pre></td></tr></table></figure><h2 id="configurate-mkfs-erofs"><a href="#configurate-mkfs-erofs" class="headerlink" title="configurate mkfs.erofs"></a>configurate mkfs.erofs</h2><p>运行<code>autogen.sh</code>没有问题，如何交叉编译找了半天，以为是定义<code>CC</code>，i’m wrong，<code>--help</code>发现:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">System types:</span><br><span class="line">  --build=BUILD     configure <span class="keyword">for</span> building on BUILD [guessed]</span><br><span class="line">  --host=HOST       cross-compile to build programs to run on HOST [BUILD]</span><br></pre></td></tr></table></figure><p>ok, run below:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --host aarch64-linux-android</span><br></pre></td></tr></table></figure><p>会报错：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">checking lz4.h presence... <span class="built_in">yes</span></span><br><span class="line">configure: WARNING: lz4.h: present but cannot be compiled</span><br><span class="line">configure: WARNING: lz4.h:     check <span class="keyword">for</span> missing prerequisite headers?</span><br><span class="line">configure: WARNING: lz4.h: see the Autoconf documentation</span><br><span class="line">configure: WARNING: lz4.h:     section <span class="string">&quot;Present But Cannot Be Compiled&quot;</span></span><br><span class="line">configure: WARNING: lz4.h: proceeding with the compiler<span class="string">&#x27;s result</span></span><br><span class="line"><span class="string">configure: WARNING:     ## --------------------------------------- ##</span></span><br><span class="line"><span class="string">configure: WARNING:     ## Report this to bluce.liguifu@huawei.com ##</span></span><br><span class="line"><span class="string">configure: WARNING:     ## --------------------------------------- ##</span></span><br><span class="line"><span class="string">checking for lz4.h... no</span></span><br><span class="line"><span class="string">checking for LZ4_versionNumber in -llz4... no</span></span><br><span class="line"><span class="string">configure: error: Cannot build without lz4</span></span><br></pre></td></tr></table></figure><p>找不到lz4.h? 试着按如下文档配置：</p><blockquote><p>\eg. if lz4 lib has been installed into fold of &#x2F;usr&#x2F;local&#x2F;lib<br>       .&#x2F;configure –with-lz4&#x3D;&#x2F;usr&#x2F;local&#x2F;lib &amp;&amp; make</p></blockquote><p>运行如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --with-lz4=/usr/local/lib --host aarch64-linux-android</span><br></pre></td></tr></table></figure><p>一样的错误，查了下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@qemu:~/test/erofs-utils$ grep -rn LZ4_VERSION_NUMBER ~/lz4-1.8.2-arm64/</span><br><span class="line">/home/tj/lz4-1.8.2-arm64/lib/lz4.h:98:<span class="comment">#define LZ4_VERSION_NUMBER (LZ4_VERSION_MAJOR *100*100 + LZ4_VERSION_MINOR *100 + LZ4_VERSION_RELEASE)</span></span><br><span class="line">/home/tj/lz4-1.8.2-arm64/lib/lz4.c:493:int LZ4_versionNumber (void) &#123; <span class="built_in">return</span> LZ4_VERSION_NUMBER; &#125;</span><br></pre></td></tr></table></figure><p>都有的啊，路径不对？ 再看看<code>--with-lz4</code>说明：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--with-lz4-include=DIR  LZ4 include directory</span><br><span class="line">--with-lz4-lib=DIR      LZ4 lib directory</span><br><span class="line">--with-lz4=DIR          LZ4 install directory, e.g. /usr/local or /usr</span><br></pre></td></tr></table></figure><p>很明显README有错误嘛，多了个<code>/lib</code>，试试：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --with-lz4=/usr/local --host aarch64-linux-android</span><br></pre></td></tr></table></figure><p>aha… working…</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">checking lz4.h usability... <span class="built_in">yes</span></span><br><span class="line">checking lz4.h presence... <span class="built_in">yes</span></span><br><span class="line">checking <span class="keyword">for</span> lz4.h... <span class="built_in">yes</span></span><br><span class="line">checking <span class="keyword">for</span> LZ4_versionNumber <span class="keyword">in</span> -llz4... <span class="built_in">yes</span></span><br><span class="line">checking that generated files are newer than configure... <span class="keyword">done</span></span><br><span class="line">configure: creating ./config.status</span><br><span class="line">config.status: creating Makefile</span><br><span class="line">config.status: creating mkfs/Makefile</span><br><span class="line">config.status: creating config.h</span><br><span class="line">config.status: executing depfiles commands</span><br><span class="line">config.status: executing libtool commands</span><br></pre></td></tr></table></figure><p>前面提到的sysroot如果不加，还会出现如下错误：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">configure:3411: checking whether the C compiler works</span><br><span class="line"> 82 configure:3433: aarch64-linux-android-gcc    conftest.c  &gt;&amp;5</span><br><span class="line"> 83 /home/tj/crosstools/aarch64-linux-android-4.9/bin/../lib/gcc/aarch64-linux-android/4.9.x-google/../../../../aarch64-linux-android/bin/ld: cannot find crtbegin_dynamic.o: No such file or directory</span><br><span class="line"> 84 /home/tj/crosstools/aarch64-linux-android-4.9/bin/../lib/gcc/aarch64-linux-android/4.9.x-google/../../../../aarch64-linux-android/bin/ld: cannot find -lc</span><br><span class="line"> 85 /home/tj/crosstools/aarch64-linux-android-4.9/bin/../lib/gcc/aarch64-linux-android/4.9.x-google/../../../../aarch64-linux-android/bin/ld: cannot find -ldl</span><br><span class="line"> 86 /home/tj/crosstools/aarch64-linux-android-4.9/bin/../lib/gcc/aarch64-linux-android/4.9.x-google/../../../../aarch64-linux-android/bin/ld: cannot find crtend_android.o: No such file or directory</span><br><span class="line"> 87 collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure><h2 id="build-mkfs-erofs"><a href="#build-mkfs-erofs" class="headerlink" title="build mkfs.erofs"></a>build mkfs.erofs</h2><p>有个错误：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs_file.c: In <span class="keyword">function</span> <span class="string">&#x27;erofs_compress_file&#x27;</span>:</span><br><span class="line">mkfs_file.c:600:2: error: implicit declaration of <span class="keyword">function</span> <span class="string">&#x27;rpl_malloc&#x27;</span> [-Werror=implicit-function-declaration]</span><br><span class="line">  inode-&gt;i_inline_data = malloc(EROFS_BLKSIZE);</span><br><span class="line">  ^</span><br><span class="line">mkfs_file.c:600:23: error: assignment makes pointer from <span class="built_in">integer</span> without a cast [-Werror]</span><br><span class="line">  inode-&gt;i_inline_data = malloc(EROFS_BLKSIZE);</span><br><span class="line">                       ^</span><br><span class="line">mkfs_file.c: In <span class="keyword">function</span> <span class="string">&#x27;erofs_init_compress_context&#x27;</span>:</span><br><span class="line">mkfs_file.c:874:17: error: assignment makes pointer from <span class="built_in">integer</span> without a cast [-Werror]</span><br><span class="line">  ctx-&gt;cc_srcbuf = malloc(erofs_cfg.c_compr_maxsz);</span><br><span class="line">                 ^</span><br><span class="line">mkfs_file.c:875:17: error: assignment makes pointer from <span class="built_in">integer</span> without a cast [-Werror]</span><br><span class="line">  ctx-&gt;cc_dstbuf = malloc(erofs_cfg.c_compr_maxsz * 2);</span><br><span class="line">                 ^</span><br><span class="line">cc1: all warnings being treated as errors</span><br><span class="line">make[2]: *** [mkfs_erofs-mkfs_file.o] Error 1</span><br></pre></td></tr></table></figure><p>把configure.ac里的<code>AC_FUNC_MALLOC</code>去掉就ok了(见参考文档):</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Checks for library functions.</span><br><span class="line">#AC_FUNC_MALLOC </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@qemu:~/erofs-utils/mkfs$ <span class="built_in">ls</span></span><br><span class="line">erofs_cache.c       erofs_config.c  erofs_io.c     Makefile     mkfs_erofs-erofs_cache.o       mkfs_erofs-erofs_lz4hc.o  mkfs_erofs-mkfs_main.o  mkfs_inode.h</span><br><span class="line">erofs_cache.h       erofs_config.h  erofs_io.h     Makefile.am  mkfs_erofs-erofs_compressor.o  mkfs_erofs.h              mkfs_file.c             mkfs_main.c</span><br><span class="line">erofs_compressor.c  erofs_debug.h   erofs_lz4hc.c  Makefile.<span class="keyword">in</span>  mkfs_erofs-erofs_config.o      mkfs_erofs-mkfs_file.o    mkfs_file.h</span><br><span class="line">erofs_compressor.h  erofs_error.h   erofs_lz4hc.h  mkfs.erofs   mkfs_erofs-erofs_io.o          mkfs_erofs-mkfs_inode.o   mkfs_inode.c</span><br><span class="line">tj@qemu:~/erofs-utils/mkfs$ </span><br><span class="line">tj@qemu:~/erofs-utils/mkfs$ file mkfs.erofs </span><br><span class="line">mkfs.erofs: ELF 64-bit LSB  executable, ARM aarch64, version 1 (SYSV), dynamically linked (uses shared libs), not stripped</span><br></pre></td></tr></table></figure><p>好像还有个PAGE_SIZE重定义的，just remove.</p><h2 id="run-mkfs-erofs"><a href="#run-mkfs-erofs" class="headerlink" title="run mkfs.erofs"></a>run mkfs.erofs</h2><p>push到设备中，提示有错误：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/ <span class="comment"># /data/mkfs.erofs</span></span><br><span class="line"><span class="string">&quot;/data/mkfs.erofs&quot;</span>: error: Android 5.0 and later only support position-independe</span><br><span class="line">nt executables (-fPIE).</span><br></pre></td></tr></table></figure><p>查了下要加入<code>-fPIE -pie</code>，也就是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CFLAGS=<span class="string">&quot;--sysroot=/home/tj/sysroot/arch-arm64/ -fPIE -pie&quot;</span></span><br></pre></td></tr></table></figure><p>重新编下运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/data <span class="comment"># ./mkfs.erofs</span></span><br><span class="line">mkfs.erofs 0.1   May 30 2019 02:32:33</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">    [-z &lt;compr_algri&gt;] [-d &lt;dbglvl&gt;]</span><br><span class="line">    [target path] [<span class="built_in">source</span> directory]</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://lists.gnu.org/archive/html/automake/2003-05/msg00020.html">https://lists.gnu.org/archive/html/automake/2003-05/msg00020.html</a></li></ul><p>Done.</p>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erofs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何测试cpufreq setpolicy driver</title>
      <link href="/how-to-test-kernel-with-intel_pstate-cpufreq-drv.html"/>
      <url>/how-to-test-kernel-with-intel_pstate-cpufreq-drv.html</url>
      
        <content type="html"><![CDATA[<p>上一篇说过有个cpufreq setpolicy patch涉及验证，qemu intel_pstate是不行了，主要是不支持<code>X86_FEATURE_HWP</code> or <code>X86_FEATURE_APERFMPERF</code>，只能在物理机上测试了。</p><p>我的本本是E40(一代i3)，用了有点久了也不支持，intel_pstate是for SandyBridge arch，Intel从二代 i3+的U都开始支持了。查了下X230支持，xbao淘了一台二手96新with hdd + 4G RAM + i5-3320M，还阔以，1.5K, 买回来后升级到sata3 ssd 240G(for Win8.1,秒开), msata ssd 120G(for linux), feel great:)</p><p>秀下sata3 ssd benchmark：</p><p><img src="http://tjtech.me/usr/uploads/2019/05/3133858907.png" alt="tj-x230-ssd-benchmark.png"></p><p>OK。 接下来主要是测试过程，开机进入grub选command line，比如我的hd0就2个区: msdos2 + msdos3，bzImage和ramdisk.gz放到了msdos3区(D盘)x86目录下，可以用ls, ls&#x2F;(hd0,xx)看看：</p><p>step1: 加载内核</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub&gt; linux (hd0,msdos3)/x86/bzImage</span><br></pre></td></tr></table></figure><p>step2: 加载ramdisk</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub&gt; initrd (hd0,msdos3)/x86/ramdisk.gz</span><br></pre></td></tr></table></figure><p>step3: 启动启动启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub&gt; boot</span><br></pre></td></tr></table></figure><p>哈启动ok，确认下<code>dmesg | grep pstate</code>会show <code>Intel P-state driver initial...</code>。</p>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpufreq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用QEMU运行x86 kernel</title>
      <link href="/how-to-run-kernel-in-qemu-for-x86_64.html"/>
      <url>/how-to-run-kernel-in-qemu-for-x86_64.html</url>
      
        <content type="html"><![CDATA[<p>最近在提交cpufreq patch，稍微有点逻辑改动的Rafael都要你test, test。有个改动涉及setpolicy driver，要验证，第一印象就是用qemu。</p><p>让我们来看下如何搭环境(initrd&#x3D;ramdisk):</p><p>my linux server(xeon) for building can not access internet，also vb under win is not. install qemu deb offline has too many dependens, forget it, let admin apt-get qemu(qemu-system-x86_64), it’s done.</p><p>I have already download the linux-pm git repo, below operations r based on this code.</p><h2 id="kernel编译"><a href="#kernel编译" class="headerlink" title="kernel编译"></a>kernel编译</h2><p>1.generate .config</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make O=out_x86_64/ x86_64_defconfig</span><br></pre></td></tr></table></figure><p>btw: gcc is default for x86_64 in xeon.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@bsvr:/sys/devices/system/cpu/cpu0/cpufreq$ file /usr/bin/gcc</span><br><span class="line">/usr/bin/gcc: symbolic <span class="built_in">link</span> to `gcc-4.8<span class="string">&#x27; </span></span><br><span class="line"><span class="string">tj@bsvr:/sys/devices/system/cpu/cpu0/cpufreq$ file /usr/bin/gcc-4.8 </span></span><br><span class="line"><span class="string">/usr/bin/gcc-4.8: ELF 64-bit LSB  executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=fd10e59c8b3fd9ff72ecb1586fa83be45e339f7b, stripped</span></span><br></pre></td></tr></table></figure><p>2.make</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make O=out_x86_64/ bzImage -j8</span><br></pre></td></tr></table></figure><p>遇到了错误：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">You are building kernel with non-retpoline compiler.</span><br><span class="line">Please update your compiler.</span><br><span class="line">make[1]: *** [checkbin] Error 1</span><br></pre></td></tr></table></figure><p>直接disable RETPOLINE：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arch/x86/Kconfig:</span><br><span class="line"> config RETPOLINE</span><br><span class="line">        bool &quot;Avoid speculative indirect branches in kernel&quot;</span><br><span class="line">-   default y</span><br><span class="line">+ default n</span><br></pre></td></tr></table></figure><p>继续又错：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error: Cannot generate ORC metadata <span class="keyword">for</span> CONFIG_UNWINDER_ORC=y, please install libelf-dev, libelf-devel or elfutils-libelf-devel</span><br></pre></td></tr></table></figure><p>我们用menuconfig</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make O=out_x86_64/ menuconfig </span><br></pre></td></tr></table></figure><p>改选Frame pointer…</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Kernel hacking &gt; Choose kernel unwinder  -&gt; select Frame pointer unwinder</span><br></pre></td></tr></table></figure><p>设置ramdisk size为65536 (64MB)</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Device Drivers &gt; Block dev &gt; &lt;*&gt; RAM block device support &gt; ()Default RAM disk size</span><br></pre></td></tr></table></figure><p>then building is ok.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Kernel: <span class="built_in">arch</span>/x86/boot/bzImage is ready  (<span class="comment">#1)</span></span><br><span class="line"></span><br><span class="line">tj@bsvr:~/work/kernel/linux-pm$ file out_x86_64/arch/x86/boot/bzImage </span><br><span class="line">out_x86_64/arch/x86/boot/bzImage: x86 boot sector</span><br></pre></td></tr></table></figure><h2 id="building-busybox"><a href="#building-busybox" class="headerlink" title="building busybox"></a>building busybox</h2><p>1.generate config</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make defconfig</span><br></pre></td></tr></table></figure><p>2.静态编译</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Busybox setting &gt; --- Build Options &gt; [*] Build Busybox as a static</span><br></pre></td></tr></table></figure><p>3.building</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure><p>没有幺蛾子，it’s ok</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  LINK    busybox_unstripped</span><br><span class="line">Static linking against glibc, can<span class="string">&#x27;t use --gc-sections</span></span><br><span class="line"><span class="string">Trying libraries: crypt m</span></span><br><span class="line"><span class="string"> Library crypt is not needed, excluding it</span></span><br><span class="line"><span class="string"> Library m is needed, can&#x27;</span>t exclude it (yet)</span><br><span class="line">Final <span class="built_in">link</span> with: m</span><br></pre></td></tr></table></figure><p>btw: my bb version: busybox-1.27.1</p><p>4.install</p><p>安装到指定目录for later usage:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make CONFIG_PREFIX=~/work/kernel/qemu/x86_64/busybox_install/ install</span><br></pre></td></tr></table></figure><p>进去看下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@bsvr:~/work/kernel/qemu/x86_64/busybox_install$ <span class="built_in">ls</span> -l</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 2 tj tj 4096 Apr 30 12:30 bin</span><br><span class="line">lrwxrwxrwx 1 tj tj   11 Apr 30 12:30 linuxrc -&gt; bin/busybox</span><br><span class="line">drwxrwxr-x 2 tj tj 4096 Apr 30 12:30 sbin</span><br><span class="line">drwxrwxr-x 4 tj tj 4096 Apr 30 12:30 usr</span><br></pre></td></tr></table></figure><p>有个linuxrc文件，link到了2.5M的bin&#x2F;busybox，其他都是link。。。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@bsvr:/work/tj/kernel/qemu/x86_64/busybox_install/bin$ <span class="built_in">ls</span> -lh</span><br><span class="line">total 2.5M</span><br><span class="line">lrwxrwxrwx 1 tj tj    7 Apr 30 12:30 ash -&gt; busybox</span><br><span class="line">lrwxrwxrwx 1 tj tj    7 Apr 30 12:30 <span class="built_in">base64</span> -&gt; busybox</span><br><span class="line">-rwxr-xr-x 1 tj tj 2.5M Apr 30 12:30 busybox</span><br><span class="line">lrwxrwxrwx 1 tj tj    7 Apr 30 12:30 <span class="built_in">cat</span> -&gt; busybox</span><br><span class="line">lrwxrwxrwx 1 tj tj    7 Apr 30 12:30 chattr -&gt; busybox</span><br><span class="line">lrwxrwxrwx 1 tj tj    7 Apr 30 12:30 <span class="built_in">chgrp</span> -&gt; busybox</span><br><span class="line">lrwxrwxrwx 1 tj tj    7 Apr 30 12:30 <span class="built_in">chmod</span> -&gt; busybox</span><br><span class="line">lrwxrwxrwx 1 tj tj    7 Apr 30 12:30 <span class="built_in">chown</span> -&gt; busybox</span><br><span class="line">lrwxrwxrwx 1 tj tj    7 Apr 30 12:30 conspy -&gt; busybox</span><br><span class="line">lrwxrwxrwx 1 tj tj    7 Apr 30 12:30 <span class="built_in">cp</span> -&gt; busybox</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="制作ramdisk"><a href="#制作ramdisk" class="headerlink" title="制作ramdisk"></a>制作ramdisk</h2><p>这里参考别人了，hurry up，不过需要有root权限，只能cp到vb ubuntu下，得压缩后再cp，不然link全部变了real file了，几百M。</p><p>另外不要在vb下share的挂载点操作，cp到外面，比如Downloads:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@tj-u1404:~/Downloads/mk_ramdisk$ <span class="built_in">ls</span></span><br><span class="line">busybox_install  etc  mk_ramdisk.sh</span><br></pre></td></tr></table></figure><p>ok，run mk_ramdisk.h, then show below if successful:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Allocating group tables: <span class="keyword">done</span>                            </span><br><span class="line">Writing inode tables: <span class="keyword">done</span>                            </span><br><span class="line">Creating journal (4096 blocks): <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">tj@tj-u1404:~/Downloads/mk_ramdisk$ <span class="built_in">ls</span></span><br><span class="line">tj@tj-u1404:~/Downloads/mk_ramdisk$ <span class="built_in">ls</span></span><br><span class="line">busybox_install  etc  mk_ramdisk.sh  ramdisk  ramdisk.gz  rootfs  tmpfs</span><br><span class="line">tj@tj-u1404:~/Downloads/mk_ramdisk$ </span><br><span class="line">tj@tj-u1404:~/Downloads/mk_ramdisk$ <span class="built_in">ls</span> -lh ramdisk.gz </span><br><span class="line">-rw-rw-r-- 1 tj tj 1.5M Apr 30 03:17 ramdisk.gz</span><br></pre></td></tr></table></figure><h2 id="运行qemu-x86-64"><a href="#运行qemu-x86-64" class="headerlink" title="运行qemu x86_64"></a>运行qemu x86_64</h2><p>cp到一个目录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@bsvr:~/work/kernel/qemu/x86_64$ <span class="built_in">ls</span></span><br><span class="line">busybox_install  busybox_install.tar  bzImage  ramdisk.gz  run.sh</span><br></pre></td></tr></table></figure><p>run.sh:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@bsvr:~/work/kernel/qemu/x86_64$ <span class="built_in">cat</span> run.sh </span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -smp 2 \</span><br><span class="line">  -m 512M \</span><br><span class="line">  -kernel ./bzImage \</span><br><span class="line">  -nographic \</span><br><span class="line">  -append <span class="string">&quot;root=/dev/ram0 rw rootfstype=ext4 console=ttyS0 init=/linuxrc&quot;</span> \</span><br><span class="line">  -initrd ./ramdisk.gz</span><br><span class="line">tj@bsvr:~/work/kernel/qemu/x86_64$ </span><br></pre></td></tr></table></figure><p>see below, haha:)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[    4.472432] ifconfig (1082) used greatest stack depth: 13824 bytes left</span><br><span class="line"></span><br><span class="line">Please press Enter to activate this console. </span><br></pre></td></tr></table></figure><p>but no cpufreq:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@x86 cpu1]<span class="comment"># ls</span></span><br><span class="line">cache             driver            node0             subsystem</span><br><span class="line">crash_notes       firmware_node     online            topology</span><br><span class="line">crash_notes_size  hotplug           power             uevent</span><br><span class="line">[root@x86 cpu1]<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>退出ctl-A + x</p><h2 id="check-for-intel-pstate"><a href="#check-for-intel-pstate" class="headerlink" title="check for intel_pstate"></a>check for intel_pstate</h2><p>intel_pstate用的就是setpolicy driver。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@x86 cpu1]# dmesg | grep &quot;intel&quot;</span><br><span class="line">[    2.214309] intel_pstate: CPU ID not supported</span><br></pre></td></tr></table></figure><p>nd, 不支持，看下代码需要硬件feature支持:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">intel_pstate_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">x86_cpu_id</span> *<span class="title">id</span>;</span></span><br><span class="line"><span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (no_load)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">id = x86_match_cpu(hwp_support_ids);</span><br><span class="line"><span class="keyword">if</span> (id) &#123;</span><br><span class="line">copy_cpu_funcs(&amp;core_funcs);</span><br><span class="line"><span class="keyword">if</span> (!no_hwp) &#123;</span><br><span class="line">hwp_active++;</span><br><span class="line">hwp_mode_bdw = id-&gt;driver_data;</span><br><span class="line">intel_pstate.attr = hwp_cpufreq_attrs;</span><br><span class="line"><span class="keyword">goto</span> hwp_cpu_matched;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">id = x86_match_cpu(intel_pstate_cpu_ids);</span><br><span class="line"><span class="keyword">if</span> (!id) &#123;</span><br><span class="line">pr_info(<span class="string">&quot;CPU ID not supported\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy_cpu_funcs((<span class="keyword">struct</span> pstate_funcs *)id-&gt;driver_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ICPU(model, policy) \</span></span><br><span class="line"><span class="meta">&#123; X86_VENDOR_INTEL, 6, model, X86_FEATURE_APERFMPERF,\</span></span><br><span class="line"><span class="meta">(unsigned long)&amp;policy &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">x86_cpu_id</span> <span class="title">intel_pstate_cpu_ids</span>[] =</span> &#123;</span><br><span class="line">ICPU(INTEL_FAM6_SANDYBRIDGE, core_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_SANDYBRIDGE_X,core_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_ATOM_SILVERMONT,silvermont_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_IVYBRIDGE,core_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_HASWELL_CORE,core_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_BROADWELL_CORE,core_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_IVYBRIDGE_X,core_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_HASWELL_X,core_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_HASWELL_ULT,core_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_HASWELL_GT3E,core_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_BROADWELL_GT3E,core_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_ATOM_AIRMONT,airmont_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_SKYLAKE_MOBILE,core_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_BROADWELL_X,core_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_SKYLAKE_DESKTOP,core_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_BROADWELL_XEON_D,core_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_XEON_PHI_KNL,knl_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_XEON_PHI_KNM,knl_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_ATOM_GOLDMONT,core_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_ATOM_GOLDMONT_PLUS,     core_funcs),</span><br><span class="line">ICPU(INTEL_FAM6_SKYLAKE_X,core_funcs),</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICPU_HWP(model, hwp_mode) \</span></span><br><span class="line"><span class="meta">&#123; X86_VENDOR_INTEL, 6, model, X86_FEATURE_HWP, hwp_mode &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">x86_cpu_id</span> <span class="title">hwp_support_ids</span>[] __<span class="title">initconst</span> =</span> &#123;</span><br><span class="line">ICPU_HWP(INTEL_FAM6_BROADWELL_X, INTEL_PSTATE_HWP_BROADWELL),</span><br><span class="line">ICPU_HWP(INTEL_FAM6_BROADWELL_XEON_D, INTEL_PSTATE_HWP_BROADWELL),</span><br><span class="line">ICPU_HWP(X86_MODEL_ANY, <span class="number">0</span>),</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>X86_FEATURE_HWP</code> or <code>X86_FEATURE_APERFMPERF</code>，QEMU(x86_64)本身就不支持，即使host支持也不行，歇菜，还有个x86模拟器叫Bochs以后看了，先用real pc…</p><h2 id="refer-doc"><a href="#refer-doc" class="headerlink" title="refer doc"></a>refer doc</h2><ul><li><a href="https://www.cnblogs.com/pengdonglin137/p/6442598.html">https://www.cnblogs.com/pengdonglin137/p/6442598.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPUFreq policy代码分析</title>
      <link href="/analyze-cpufreq-policy.html"/>
      <url>/analyze-cpufreq-policy.html</url>
      
        <content type="html"><![CDATA[<p>参考4.9，主要了解几个结构成员：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> &#123;</span></span><br><span class="line"><span class="comment">/* CPUs sharing clock, require sw coordination */</span></span><br><span class="line"><span class="type">cpumask_var_t</span>cpus;<span class="comment">/* Online CPUs only */</span></span><br><span class="line"><span class="type">cpumask_var_t</span>related_cpus; <span class="comment">/* Online + Offline CPUs */</span></span><br><span class="line"><span class="type">cpumask_var_t</span>real_cpus; <span class="comment">/* Related and present */</span></span><br><span class="line">...</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>policy; <span class="comment">/* see above */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>last_policy; <span class="comment">/* policy before unplug */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span>*<span class="title">governor</span>;</span> <span class="comment">/* see below */</span></span><br><span class="line"><span class="type">void</span>*governor_data;</span><br><span class="line"><span class="type">char</span>last_governor[CPUFREQ_NAME_LEN]; <span class="comment">/* last governor used */</span></span><br></pre></td></tr></table></figure><p>offline有两种情况：逻辑offline和物理offline(for NUMA arch)。<code>related_cpus</code>里的offline就有这两个，而<code>real_cpus</code>必须是物理存在的所有CPU。</p><p>看下文档描述： </p><blockquote><p>SMP systems normally have same clock source for a group of cpus. For these the<br>.init() would be called only once for the first online cpu. Here the .init()<br>routine must initialize policy-&gt;cpus with mask of all possible cpus (Online +<br>Offline) that share the clock. Then the core would copy this mask onto<br>policy-&gt;related_cpus and will reset policy-&gt;cpus to carry only online cpus.</p></blockquote><p>driver会初始化<code>-&gt;cpus</code>，core会copy到<code>-&gt;related_cpus</code>上，比如高通平台：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> <span class="title">msm_cpufreq_driver</span> =</span> &#123;</span><br><span class="line">...</span><br><span class="line">.init= msm_cpufreq_init,</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> msm_cpufreq_init(<span class="keyword">struct</span> cpufreq_policy *policy)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In some SoC, some cores are clocked by same source, and their</span></span><br><span class="line"><span class="comment"> * frequencies can not be changed independently. Find all other</span></span><br><span class="line"><span class="comment"> * CPUs that share same clock, and mark them as controlled by</span></span><br><span class="line"><span class="comment"> * same policy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">for_each_possible_cpu(cpu)</span><br><span class="line"><span class="keyword">if</span> (cpu_clk[cpu] == cpu_clk[policy-&gt;cpu])</span><br><span class="line">cpumask_set_cpu(cpu, policy-&gt;cpus);</span><br></pre></td></tr></table></figure><p>所有的cpu core共用同一个clock，所以共用一个调频策略。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cpufreq_online</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (new_policy) &#123;</span><br><span class="line"><span class="comment">/* related_cpus should at least include policy-&gt;cpus. */</span></span><br><span class="line">cpumask_copy(policy-&gt;related_cpus, policy-&gt;cpus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bringing CPU online时会copy。 CPU offline时会clear这个cpus。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cpufreq_offline</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">&quot;%s: unregistering CPU %u\n&quot;</span>, __func__, cpu);</span><br><span class="line"></span><br><span class="line">policy = cpufreq_cpu_get_raw(cpu);</span><br><span class="line"><span class="keyword">if</span> (!policy) &#123;</span><br><span class="line">pr_debug(<span class="string">&quot;%s: No cpu_data found\n&quot;</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">down_write(&amp;policy-&gt;rwsem);</span><br><span class="line"><span class="keyword">if</span> (has_target())</span><br><span class="line">cpufreq_stop_governor(policy);</span><br><span class="line"></span><br><span class="line">cpumask_clear_cpu(cpu, policy-&gt;cpus); <span class="comment">//tj: here</span></span><br></pre></td></tr></table></figure><p><code>real_cpus</code>的引入是为了cpufeq symlink，我们在每个cpu的节点下能看到cpufreq这个symlink：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/sys/devices/system/cpu/cpu0 <span class="comment"># ls -l</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 6 root root    0 2009-01-03 06:40 cache</span><br><span class="line">lrwxrwxrwx 1 root root    0 1970-04-05 05:56 cpufreq -&gt; ../cpufreq/policy0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/sys/devices/system/cpu/cpufreq/policy0 <span class="comment"># ls -l</span></span><br><span class="line">total 0</span><br><span class="line">-r--r--r-- 1 root   root   4096 2009-01-03 06:41 affected_cpus</span><br><span class="line">-r-------- 1 root   root   4096 2009-01-03 06:41 cpuinfo_cur_freq</span><br><span class="line">-r--r--r-- 1 root   root   4096 2019-01-30 16:43 cpuinfo_max_freq</span><br><span class="line">-r--r--r-- 1 root   root   4096 2009-01-03 06:41 cpuinfo_min_freq</span><br><span class="line">-r--r--r-- 1 root   root   4096 2009-01-03 06:41 cpuinfo_transition_latency</span><br><span class="line">-r--r--r-- 1 root   root   4096 2009-01-03 06:41 related_cpus</span><br><span class="line">-r--r--r-- 1 root   root   4096 2019-01-30 16:43 scaling_available_frequencies</span><br><span class="line">-r--r--r-- 1 root   root   4096 2009-01-03 06:41 scaling_available_governors</span><br><span class="line">-r--r--r-- 1 root   root   4096 2009-01-03 06:41 scaling_cur_freq</span><br><span class="line">-r--r--r-- 1 root   root   4096 2009-01-03 06:41 scaling_driver</span><br><span class="line">-rw-r--r-- 1 root   root   4096 2008-12-31 16:00 scaling_governor</span><br><span class="line">-rw-rw-r-- 1 system system 4096 1970-04-05 05:56 scaling_max_freq</span><br><span class="line">-rw-rw-r-- 1 system system 4096 2008-12-31 16:00 scaling_min_freq</span><br><span class="line">-rw-r--r-- 1 root   root   4096 2009-01-03 06:41 scaling_setspeed</span><br></pre></td></tr></table></figure><p>为什么要创建policy0？然后所有cpu的cpufreq symlink过去？原因：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 96bdda61f58b70431bbe8a3e49794c8210f7691b</span><br><span class="line">Author: Viresh Kumar &lt;viresh.kumar@linaro.org&gt;</span><br><span class="line">Date:   Thu Oct 15 21:35:24 2015 +0530</span><br><span class="line"></span><br><span class="line">    cpufreq: create cpu/cpufreq/policyX directories</span><br><span class="line">    </span><br><span class="line">    The cpufreq sysfs interface had been a bit inconsistent as one of the</span><br><span class="line">    CPUs for a policy had a real directory within its sysfs &#x27;cpuX&#x27; directory</span><br><span class="line">    and all other CPUs had links to it. That also made the code a bit</span><br><span class="line">    complex as we need to take care of moving the sysfs directory if the CPU</span><br><span class="line">    containing the real directory is getting physically hot-unplugged.</span><br><span class="line">    </span><br><span class="line">    Solve this by creating &#x27;policyX&#x27; directories (per-policy) in</span><br><span class="line">    /sys/devices/system/cpu/cpufreq/ directory, where X is the CPU for which</span><br><span class="line">    the policy was first created.</span><br></pre></td></tr></table></figure><p>ok，就是为了简化代码逻辑，在policy初始化分配时创建：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> cpufreq_policy *<span class="title function_">cpufreq_policy_alloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!zalloc_cpumask_var(&amp;policy-&gt;real_cpus, GFP_KERNEL))</span><br><span class="line"><span class="keyword">goto</span> err_free_rcpumask;</span><br><span class="line"></span><br><span class="line">ret = kobject_init_and_add(&amp;policy-&gt;kobj, &amp;ktype_cpufreq,</span><br><span class="line">   cpufreq_global_kobject, <span class="string">&quot;policy%u&quot;</span>, cpu);</span><br></pre></td></tr></table></figure><p><code>real_cpus</code>就是offline物理存在的related_cpus，这个link仅仅存在于<code>real_cpus</code>下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_cpu_dev_symlink</span><span class="params">(<span class="keyword">struct</span> cpufreq_policy *policy, <span class="type">unsigned</span> <span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> get_cpu_device(cpu);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dev)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cpumask_test_and_set_cpu(cpu, policy-&gt;real_cpus)) <span class="comment">//tj: set if not</span></span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>在CPU online时在<code>related_cpus</code>下add link，此时都是从driver init而来都是物理存在的:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cpufreq_online</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (new_policy) &#123;</span><br><span class="line">policy-&gt;user_policy.min = policy-&gt;min;</span><br><span class="line">policy-&gt;user_policy.max = policy-&gt;max;</span><br><span class="line"></span><br><span class="line">for_each_cpu(j, policy-&gt;related_cpus) &#123;</span><br><span class="line">per_cpu(cpufreq_cpu_data, j) = policy;</span><br><span class="line">add_cpu_dev_symlink(policy, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在remove这个cpu时clear这个<code>real_cpus</code> mask:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cpufreq_remove_dev</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> subsys_interface *sif)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cpu = dev-&gt;id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span> =</span> per_cpu(cpufreq_cpu_data, cpu);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!policy)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cpu_online(cpu))</span><br><span class="line">cpufreq_offline(cpu);</span><br><span class="line"></span><br><span class="line">cpumask_clear_cpu(cpu, policy-&gt;real_cpus);</span><br><span class="line">remove_cpu_dev_symlink(policy, dev);</span><br></pre></td></tr></table></figure><p>ok，继续看：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span>policy; <span class="comment">/* see above */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span>*<span class="title">governor</span>;</span> <span class="comment">/* see below */</span></span><br></pre></td></tr></table></figure><p><code>policy</code>是留给<code>-&gt;setpolicy</code> driver用的，<code>governor</code>是给<code>-&gt;target || &gt;target_index</code> driver用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If (cpufreq_driver-&gt;target) exists, the -&gt;governor decides what frequency</span></span><br><span class="line"><span class="comment"> * within the limits is used. If (cpufreq_driver-&gt;setpolicy&gt; exists, these</span></span><br><span class="line"><span class="comment"> * two generic policies are available:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPUFREQ_POLICY_POWERSAVE(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPUFREQ_POLICY_PERFORMANCE(2)</span></span><br></pre></td></tr></table></figure><p>解析governor string时赋值：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cpufreq_parse_governor - parse a governor string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cpufreq_parse_governor</span><span class="params">(<span class="type">char</span> *str_governor, <span class="type">unsigned</span> <span class="type">int</span> *policy,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> cpufreq_governor **governor)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err = -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cpufreq_driver-&gt;setpolicy) &#123;</span><br><span class="line"><span class="keyword">if</span> (!strncasecmp(str_governor, <span class="string">&quot;performance&quot;</span>, CPUFREQ_NAME_LEN)) &#123;</span><br><span class="line">*policy = CPUFREQ_POLICY_PERFORMANCE;</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strncasecmp(str_governor, <span class="string">&quot;powersave&quot;</span>,</span><br><span class="line">CPUFREQ_NAME_LEN)) &#123;</span><br><span class="line">*policy = CPUFREQ_POLICY_POWERSAVE;</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>一是初始化policy会set:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cpufreq_init_policy</span><span class="params">(<span class="keyword">struct</span> cpufreq_policy *policy)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* Use the default policy if there is no last_policy. */</span></span><br><span class="line"><span class="keyword">if</span> (cpufreq_driver-&gt;setpolicy) &#123;</span><br><span class="line"><span class="keyword">if</span> (policy-&gt;last_policy)</span><br><span class="line">new_policy.policy = policy-&gt;last_policy;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cpufreq_parse_governor(gov-&gt;name, &amp;new_policy.policy,</span><br><span class="line">       <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个是sysfs store_scaling_governor会call。</p><p>ok，而governor应该就是for <code>-&gt;target</code> || <code>-&gt;target_index</code> driver。可用的scaling governor:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/sys/devices/system/cpu/cpufreq/policy0 <span class="comment"># cat scaling_available_governor</span></span><br><span class="line">conservative ondemand userspace powersave performance schedutil</span><br></pre></td></tr></table></figure><p>通过core提供的cpufreq_register_governor注册到core。4.9高通平台默认的schedutil (check it later)。</p><p><code>last_policy</code>和<code>last_governor</code>是给热插拔用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cpufreq_offline</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (policy_is_inactive(policy)) &#123;</span><br><span class="line"><span class="keyword">if</span> (has_target())</span><br><span class="line"><span class="built_in">strncpy</span>(policy-&gt;last_governor, policy-&gt;governor-&gt;name,</span><br><span class="line">CPUFREQ_NAME_LEN);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">policy-&gt;last_policy = policy-&gt;policy;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">policy_is_inactive</span><span class="params">(<span class="keyword">struct</span> cpufreq_policy *policy)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cpumask_empty(policy-&gt;cpus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">has_target</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cpufreq_driver-&gt;target_index || cpufreq_driver-&gt;target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inactive policy就是这个策略的<code>-&gt;cpus</code>都下线喽。</p><p>Done.</p>]]></content>
      
      
      <categories>
          
          <category> perf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpufreq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPUFreq boost代码分析</title>
      <link href="/analyze-cpufreq-boost.html"/>
      <url>/analyze-cpufreq-boost.html</url>
      
        <content type="html"><![CDATA[<p>参考4.9内核，还是先看文档描述：</p><blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Some CPUs support a functionality to raise the operating frequency of<br>some cores in a multi-core package if certain conditions apply, mostly<br>if the whole chip is not fully utilized and below it’s intended thermal<br>budget. The decision about boost disable&#x2F;enable is made either at hardware<br>(e.g. x86) or software (e.g ARM).<br>On Intel CPUs this is called “Turbo Boost”, AMD calls it “Turbo-Core”,<br>in technical documentation “Core performance boost”. In Linux we use<br>the term “boost” for convenience.</p></blockquote><p>有些多核CPU系统中支持提高操作频率， 由硬件or软件来决定，Linux用boost来表示这个功能。一般ARM(Exynos)使用的是SW，x86使用的是HW。</p><p>有个boost开关用户可以控制禁用使能：</p><blockquote><p>To allow the user to toggle the boosting functionality, the cpufreq core<br>driver exports a sysfs knob to enable or disable it. There is a file:<br>&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;boost</p></blockquote><p>ok，来看相关代码，路径在drivers&#x2F;cpufreq&#x2F;：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">cpufreq_boost_supported</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> likely(cpufreq_driver) &amp;&amp; cpufreq_driver-&gt;set_boost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果支持提高频率，drv就要配置<code>-&gt;set_boost</code>，可以看到acpi-cpufreq.c配了，还有一处是cpufreq.c里也配了，分别看下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">acpi_cpufreq_boost_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (boot_cpu_has(X86_FEATURE_CPB) || boot_cpu_has(X86_FEATURE_IDA)) &#123;</span><br><span class="line">                msrs = msrs_alloc();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!msrs)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                acpi_cpufreq_driver.set_boost = set_boost;</span><br><span class="line">                acpi_cpufreq_driver.boost_enabled = boost_state(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可见是x86 hw本身就支持，只要满足feature: <code>X86_FEATURE_CPB</code> or <code>X86_FEATURE_IDA</code>，默认禁用(<code>boost_enabled</code>&#x3D;0)。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">acpi_cpufreq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        acpi_cpufreq_boost_init();</span><br><span class="line"></span><br><span class="line">        ret = cpufreq_register_driver(&amp;acpi_cpufreq_driver);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">late_initcall(acpi_cpufreq_init);</span><br></pre></td></tr></table></figure><p>acpi drv在注册到core前就定下了。还有一处在core里：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cpufreq_enable_boost_support</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cpufreq_driver)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cpufreq_boost_supported())</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        cpufreq_driver-&gt;set_boost = cpufreq_boost_set_sw; <span class="comment">//tj: here</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This will get removed on driver unregister */</span></span><br><span class="line">        <span class="keyword">return</span> create_boost_sysfs_file();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(cpufreq_enable_boost_support);</span><br></pre></td></tr></table></figure><p>cpufreq-dt.c会call：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cpufreq_init</span><span class="params">(<span class="keyword">struct</span> cpufreq_policy *policy)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">/* Support turbo/boost mode */</span></span><br><span class="line">        <span class="keyword">if</span> (policy_has_boost_freq(policy)) &#123;</span><br><span class="line">                <span class="comment">/* This gets disabled by core on driver unregister */</span></span><br><span class="line">                ret = cpufreq_enable_boost_support();</span><br><span class="line">                <span class="keyword">if</span> (ret)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> <span class="title">dt_cpufreq_driver</span> =</span> &#123;</span><br><span class="line">        .flags = CPUFREQ_STICKY | CPUFREQ_NEED_INITIAL_FREQ_CHECK,</span><br><span class="line">        .verify = cpufreq_generic_frequency_table_verify,</span><br><span class="line">        .target_index = set_target,</span><br><span class="line">        .get = cpufreq_generic_get,</span><br><span class="line">        .init = cpufreq_init,</span><br></pre></td></tr></table></figure><p>是挂到了<code>-&gt;init</code>中去设置<code>-&gt;set_boost</code>，从名字看应该是sw boost。判断是否支持：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">policy_has_boost_freq</span><span class="params">(<span class="keyword">struct</span> cpufreq_policy *policy)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span> *<span class="title">pos</span>, *<span class="title">table</span> =</span> policy-&gt;freq_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!table)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">cpufreq_for_each_valid_entry(pos, table)</span><br><span class="line"><span class="keyword">if</span> (pos-&gt;flags &amp; CPUFREQ_BOOST_FREQ)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和频率表的生成(<code>CPUFREQ_BOOST_FREQ</code>)有关。跟下这个flag：cpufreq目录下没有，opengrok搜了下有：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/kernel/msm-4.9/drivers/base/power/opp/</span><br><span class="line">H A Dcpu.c85 freq_table[i].flags = CPUFREQ_BOOST_FREQ;</span><br></pre></td></tr></table></figure><p>opp是啥？和pm有关：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dev_pm_opp_init_cpufreq_table() - create a cpufreq table for a device</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">int dev_pm_opp_init_cpufreq_table(struct device *dev,</span></span><br><span class="line"><span class="comment">                                  struct cpufreq_frequency_table **table)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">                /* Is Boost/turbo opp ? */</span></span><br><span class="line">                <span class="keyword">if</span> (dev_pm_opp_is_turbo(opp))</span><br><span class="line">                        freq_table[i].flags = CPUFREQ_BOOST_FREQ;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><code>dev_pm_opp_is_turbo()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">dev_pm_opp_is_turbo</span><span class="params">(<span class="keyword">struct</span> dev_pm_opp *opp)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp</span> *<span class="title">tmp_opp</span>;</span></span><br><span class="line"></span><br><span class="line">        opp_rcu_lockdep_assert();</span><br><span class="line"></span><br><span class="line">        tmp_opp = rcu_dereference(opp);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR_OR_NULL(tmp_opp) || !tmp_opp-&gt;available) &#123;</span><br><span class="line">                pr_err(<span class="string">&quot;%s: Invalid parameters\n&quot;</span>, __func__);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmp_opp-&gt;turbo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取决于<code>-&gt;turbo</code>，是从设备树而来:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">new_opp-&gt;turbo = of_property_read_bool(np, <span class="string">&quot;turbo-mode&quot;</span>);</span><br></pre></td></tr></table></figure><p>搜了下三星的Exynos会用到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">arch</span>/arm/boot/dts/exynos4412.dtsi:137:turbo-mode;</span><br></pre></td></tr></table></figure><p>翻了下git log原来就是三星加的software boost for exynos arch，只不过后来放到了cpufreq-dt.c中，流程上放到了register之后。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dt_cpufreq_probe</span><br><span class="line">     |-&gt; cpufreq_register_driver</span><br><span class="line">               |-&gt; cpufreq_driver-&gt;init(cpufreq_init)</span><br></pre></td></tr></table></figure><p>register里还有个创建sysfs boost的，可见是给前文的hardware(x86) boost用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cpufreq_register_driver</span><span class="params">(<span class="keyword">struct</span> cpufreq_driver *driver_data)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (cpufreq_boost_supported()) &#123;</span><br><span class="line">ret = create_boost_sysfs_file();</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err_null_driver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外如果boost使能了，boost freq也是min&#x2F;max的备选：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cpufreq_frequency_table_cpuinfo</span><span class="params">(<span class="keyword">struct</span> cpufreq_policy *policy,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> cpufreq_frequency_table *table)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">cpufreq_for_each_valid_entry(pos, table) &#123;</span><br><span class="line">freq = pos-&gt;frequency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!cpufreq_boost_enabled() <span class="comment">//tj: here</span></span><br><span class="line">    &amp;&amp; (pos-&gt;flags &amp; CPUFREQ_BOOST_FREQ))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">&quot;table entry %u: %u kHz\n&quot;</span>, (<span class="type">int</span>)(pos - table), freq);</span><br><span class="line"><span class="keyword">if</span> (freq &lt; min_freq)</span><br><span class="line">min_freq = freq;</span><br><span class="line"><span class="keyword">if</span> (freq &gt; max_freq)</span><br><span class="line">max_freq = freq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">policy-&gt;min = policy-&gt;cpuinfo.min_freq = min_freq;</span><br><span class="line">policy-&gt;max = policy-&gt;cpuinfo.max_freq = max_freq;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sysfs的<code>scaling_available</code>是不包含boost freq的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * show_scaling_available_frequencies - show available normal frequencies for</span></span><br><span class="line"><span class="comment"> * the specified CPU</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">scaling_available_frequencies_show</span><span class="params">(<span class="keyword">struct</span> cpufreq_policy *policy,</span></span><br><span class="line"><span class="params">  <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> show_available_freqs(policy, buf, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">cpufreq_attr_available_freq(scaling_available);</span><br><span class="line">EXPORT_SYMBOL_GPL(cpufreq_freq_attr_scaling_available_freqs);</span><br></pre></td></tr></table></figure><p><code>scaling_boost</code>是show boost freq:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * show_available_boost_freqs - show available boost frequencies for</span></span><br><span class="line"><span class="comment"> * the specified CPU</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">scaling_boost_frequencies_show</span><span class="params">(<span class="keyword">struct</span> cpufreq_policy *policy,</span></span><br><span class="line"><span class="params">      <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> show_available_freqs(policy, buf, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">cpufreq_attr_available_freq(scaling_boost);</span><br></pre></td></tr></table></figure><p>来看下<code>show_available_freqs</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">show_available_freqs</span><span class="params">(<span class="keyword">struct</span> cpufreq_policy *policy, <span class="type">char</span> *buf,</span></span><br><span class="line"><span class="params">    <span class="type">bool</span> show_boost)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">ssize_t</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span> *<span class="title">pos</span>, *<span class="title">table</span> =</span> policy-&gt;freq_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!table)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">cpufreq_for_each_valid_entry(pos, table) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * show_boost = true and driver_data = BOOST freq</span></span><br><span class="line"><span class="comment"> * display BOOST freqs</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * show_boost = false and driver_data = BOOST freq</span></span><br><span class="line"><span class="comment"> * show_boost = true and driver_data != BOOST freq</span></span><br><span class="line"><span class="comment"> * continue - do not display anything</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * show_boost = false and driver_data != BOOST freq</span></span><br><span class="line"><span class="comment"> * display NON BOOST freqs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (show_boost ^ (pos-&gt;flags &amp; CPUFREQ_BOOST_FREQ))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">count += <span class="built_in">sprintf</span>(&amp;buf[count], <span class="string">&quot;%d &quot;</span>, pos-&gt;frequency);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>driver_data</code>指的就是<code>CPUFREQ_BOOST_FREQ</code>这个flag了，所以逻辑就是：</p><ul><li>当显示boost freq时看cpufreq table有没有boost freq，如果有就显示；</li><li>当显示normal freq时就是从cpufreq table中过滤boost freq。</li></ul><p>Done.</p>]]></content>
      
      
      <categories>
          
          <category> perf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpufreq </tag>
            
            <tag> boost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux CPUFreq Subsystem Overview</title>
      <link href="/linux-cpufreq-subsystem-overview.html"/>
      <url>/linux-cpufreq-subsystem-overview.html</url>
      
        <content type="html"><![CDATA[<p>参考4.9，CPUFreq即CPU Frequency scaling或者CPU performance scaling，允许你运行时改变CPU clock speed.</p><p>文档路径: .&#x2F;Documentation&#x2F;cpu-freq&#x2F;，先来看几个概念：</p><blockquote><p>Some CPU frequency scaling-capable processor switch between various<br>frequencies and operating voltages “on the fly” without any kernel or<br>user involvement. This guarantees very fast switching to a frequency<br>which is high enough to serve the user’s needs, but low enough to save<br>power.</p><h2 id="2-1-Policy"><a href="#2-1-Policy" class="headerlink" title="2.1 Policy"></a>2.1 Policy</h2><p>On these systems, all you can do is select the lower and upper<br>frequency limit as well as whether you want more aggressive<br>power-saving or more instantly available processing power.</p></blockquote><p>有些CPU不需要由kernel控制直接切换频率，这种切换快速但耗电。在这种系统中，用户就配个max&#x2F;min freq即可,，可以看到被wrap到了policy中。在代码里就是<code>-&gt;setpolicy</code>，后面在看。</p><blockquote><h2 id="2-2-Governor"><a href="#2-2-Governor" class="headerlink" title="2.2 Governor"></a>2.2 Governor</h2><p>On all other cpufreq implementations, these boundaries still need to<br>be set. Then, a “governor” must be selected. Such a “governor” decides<br>what speed the processor shall run within the boundaries. One such<br>“governor” is the “userspace” governor. This one allows the user - or<br>a yet-to-implement userspace program - to decide what specific speed<br>the processor shall run at. </p></blockquote><p>而其他系统就是由kernel控制了，kernel要选择一个governor，由这个governor来控制，同时也要设置max&#x2F;min频率。在代码里不需要用<code>-&gt;setpolicy</code>了，取代的是<code>-&gt;target</code> or <code>-&gt;target_index</code>。显然这个系统会save more power相比<code>-&gt;setpolicy</code>。</p><p>这个governor应该分成2大类，一类主要静态调频成最大(performance) or 最小(powersave)，其他都是给动态调频用，比如4.9内核高通手机平台用的schedutil，文档有个流程图很清晰：</p><blockquote><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">CPU can be set to switch independently   |         CPU can only be set </span><br><span class="line">      within specific &quot;limits&quot;           |       to specific frequencies</span><br><span class="line"></span><br><span class="line">                                 &quot;CPUfreq policy&quot;</span><br><span class="line">                consists of frequency limits (policy-&gt;&#123;min,max&#125;)</span><br><span class="line">                     and CPUfreq governor to be used</span><br><span class="line">                         /                    \</span><br><span class="line">                        /                      \</span><br><span class="line">                       /                       the cpufreq governor decides</span><br><span class="line">                      /                        (dynamically or statically)</span><br><span class="line">                     /                         what target_freq to set within</span><br><span class="line">                    /                          the limits of policy-&gt;&#123;min,max&#125;</span><br><span class="line">                   /                                \</span><br><span class="line">                  /                                  \</span><br><span class="line">        Using the -&gt;setpolicy call,              Using the -&gt;target/target_index call,</span><br><span class="line">            the limits and the                    the frequency closest</span><br><span class="line">             &quot;policy&quot; is set.                     to target_freq is set.</span><br><span class="line">                                                  It is assured that it</span><br><span class="line">                                                  is within policy-&gt;&#123;min,max&#125;</span><br></pre></td></tr></table></figure></blockquote><p>另外，有些cpufreq sysfs经常用到，来看几个有疑问的：</p><blockquote><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cpuinfo_cur_freq :              Current frequency of the CPU as obtained from</span><br><span class="line">                                the hardware, in KHz. This is the frequency</span><br><span class="line">                                the CPU actually runs at.</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">scaling_cur_freq :              Current frequency of the CPU as determined by</span><br><span class="line">                                the governor and cpufreq core, in KHz. This is</span><br><span class="line">                                the frequency the kernel thinks the CPU runs</span><br><span class="line">                                at.</span><br></pre></td></tr></table></figure></blockquote><p>可见<code>cpuinfo_cur_freq</code>是从硬件读出来的，<code>scaling_cur_freq</code>由governor决定。看下相关代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * show_cpuinfo_cur_freq - current CPU frequency as detected by hardware</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">show_cpuinfo_cur_freq</span><span class="params">(<span class="keyword">struct</span> cpufreq_policy *policy,</span></span><br><span class="line"><span class="params"><span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cur_freq = __cpufreq_get(policy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cur_freq)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%u\n&quot;</span>, cur_freq);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;unknown&gt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> __cpufreq_get(<span class="keyword">struct</span> cpufreq_policy *policy)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ret_freq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!cpufreq_driver-&gt;get)</span><br><span class="line"><span class="keyword">return</span> ret_freq;</span><br><span class="line"></span><br><span class="line">ret_freq = cpufreq_driver-&gt;get(policy-&gt;cpu);</span><br></pre></td></tr></table></figure><p>比如QCOM:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> <span class="title">msm_cpufreq_driver</span> =</span> &#123;</span><br><span class="line">...</span><br><span class="line">.get= msm_cpufreq_get_freq,</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> msm_cpufreq_get_freq(<span class="type">unsigned</span> <span class="type">int</span> cpu)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> clk_get_rate(cpu_clk[cpu]) / <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，直接从<code>cpu_clk</code>而来。再看下scaling_cur_freq:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">show_scaling_cur_freq</span><span class="params">(<span class="keyword">struct</span> cpufreq_policy *policy, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cpufreq_driver &amp;&amp; cpufreq_driver-&gt;setpolicy &amp;&amp; cpufreq_driver-&gt;get)</span><br><span class="line">ret = <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%u\n&quot;</span>, cpufreq_driver-&gt;get(policy-&gt;cpu));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%u\n&quot;</span>, policy-&gt;cur);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>竟然用了<code>cpufreq_driver-&gt;get</code>，这个不是从硬件获取的么，可以直接看cpuinfo啊，原来是为了某些用户态工具？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit c034b02e213d271b98c45c4a7b54af8f69aaac1e</span><br><span class="line">Author: Dirk Brandewie &lt;dirk.j.brandewie@intel.com&gt;</span><br><span class="line">Date:   Mon Oct 13 08:37:40 2014 -0700</span><br><span class="line"></span><br><span class="line">    cpufreq: expose scaling_cur_freq sysfs file for set_policy() drivers</span><br><span class="line">    </span><br><span class="line">    Currently the core does not expose scaling_cur_freq for set_policy()</span><br><span class="line">    drivers this breaks some userspace monitoring tools.</span><br><span class="line">    Change the core to expose this file for all drivers and if the</span><br><span class="line">    set_policy() driver supports the get() callback use it to retrieve the</span><br><span class="line">    current frequency.</span><br></pre></td></tr></table></figure><p>不过<code>set_policy</code> driver也属于CPUFreq scaling，加上也合理。</p><p>来看两个max&#x2F;min freq：</p><blockquote><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">scaling_min_freq and </span><br><span class="line">scaling_max_freq                show the current &quot;policy limits&quot; (in </span><br><span class="line">                                kHz). By echoing new values into these</span><br><span class="line">                                files, you can change these limits.</span><br><span class="line">                                NOTE: when setting a policy you need to</span><br><span class="line">                                first set scaling_max_freq, then</span><br><span class="line">                                scaling_min_freq.</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cpuinfo_min_freq :              this file shows the minimum operating</span><br><span class="line">                                frequency the processor can run at(in kHz) </span><br><span class="line">cpuinfo_max_freq :              this file shows the maximum operating</span><br><span class="line">                                frequency the processor can run at(in kHz)</span><br></pre></td></tr></table></figure></blockquote><p>看代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> show_one(file_name, object)\</span></span><br><span class="line"><span class="meta">static ssize_t show_##file_name\</span></span><br><span class="line"><span class="meta">(struct cpufreq_policy *policy, char *buf)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">return sprintf(buf, <span class="string">&quot;%u\n&quot;</span>, policy-&gt;object);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line">show_one(cpuinfo_min_freq, cpuinfo.min_freq);</span><br><span class="line">show_one(cpuinfo_max_freq, cpuinfo.max_freq);</span><br><span class="line">show_one(scaling_min_freq, min);</span><br><span class="line">show_one(scaling_max_freq, max);</span><br></pre></td></tr></table></figure><p><code>cpufreq_table_validate_and_show()</code>会detect这个cpuinfo_min&#x2F;max_freq，同时设置scaling_min&#x2F;max_freq成一样的值：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cpufreq_frequency_table_cpuinfo</span><span class="params">(<span class="keyword">struct</span> cpufreq_policy *policy,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> cpufreq_frequency_table *table)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span> *<span class="title">pos</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> min_freq = ~<span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_freq = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> freq;</span><br><span class="line"></span><br><span class="line">cpufreq_for_each_valid_entry(pos, table) &#123;</span><br><span class="line">freq = pos-&gt;frequency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!cpufreq_boost_enabled()</span><br><span class="line">    &amp;&amp; (pos-&gt;flags &amp; CPUFREQ_BOOST_FREQ))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">&quot;table entry %u: %u kHz\n&quot;</span>, (<span class="type">int</span>)(pos - table), freq);</span><br><span class="line"><span class="keyword">if</span> (freq &lt; min_freq)</span><br><span class="line">min_freq = freq;</span><br><span class="line"><span class="keyword">if</span> (freq &gt; max_freq)</span><br><span class="line">max_freq = freq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">policy-&gt;min = policy-&gt;cpuinfo.min_freq = min_freq;</span><br><span class="line">policy-&gt;max = policy-&gt;cpuinfo.max_freq = max_freq;</span><br></pre></td></tr></table></figure><p>table一般从dt中配置，scaling_min&#x2F;max_freq可以修改这个节点设置成新的policy：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">store_one(scaling_min_freq, min);</span><br><span class="line">store_one(scaling_max_freq, max);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * policy : current policy.</span></span><br><span class="line"><span class="comment"> * new_policy: policy to be set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cpufreq_set_policy</span><span class="params">(<span class="keyword">struct</span> cpufreq_policy *policy,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> cpufreq_policy *new_policy)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span> *<span class="title">old_gov</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">&quot;setting new policy for CPU %u: %u - %u kHz\n&quot;</span>,</span><br><span class="line"> new_policy-&gt;cpu, new_policy-&gt;min, new_policy-&gt;max);</span><br></pre></td></tr></table></figure><p>ok。 目前CPUFreq子系统分成3层：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">| scaling governor ---------------&gt;  such as: cpufreq_performance.c</span><br><span class="line">|------------------+</span><br><span class="line">|   the core       ----------------&gt; cpufreq.c + freq_table.c</span><br><span class="line">|------------------+</span><br><span class="line">| scaling driver   ----------------&gt; such as: cpufreq-dt.c</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure><p>高版本有变更描述，挪到Documentation&#x2F;admin-guide&#x2F;pm&#x2F;cpufreq.rst：</p><blockquote><h1 id="CPU-Performance-Scaling-in-Linux"><a href="#CPU-Performance-Scaling-in-Linux" class="headerlink" title="CPU Performance Scaling in Linux"></a>CPU Performance Scaling in Linux</h1><p>The Linux kernel supports CPU performance scaling by means of the <code>CPUFreq</code><br>(CPU Frequency scaling) subsystem that consists of three layers of code: the<br>core, scaling governors and scaling drivers.</p></blockquote><p>Done.</p>]]></content>
      
      
      <categories>
          
          <category> perf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpufreq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux CMA代码分析</title>
      <link href="/essential-analysis-of-linux-cma-code.html"/>
      <url>/essential-analysis-of-linux-cma-code.html</url>
      
        <content type="html"><![CDATA[<p>CMA全称Contiguous Memory Allocator，是Linux内核的连续内存分配器，最近就遇到一个因CMA分配失败导致的camera功能异常，log如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;6&gt;[ 3371.081458] alloc_contig_range: [8fa00, 8ff00) PFNs busy</span><br><span class="line">&lt;6&gt;[ 3371.081481] alloc_contig_range: [8fa00, 90000) PFNs busy</span><br><span class="line">&lt;6&gt;[ 3371.191527] alloc_contig_range: [8f800, 8fd00) PFNs busy</span><br><span class="line">&lt;6&gt;[ 3371.191568] alloc_contig_range: [8f900, 8fe00) PFNs busy</span><br><span class="line">&lt;6&gt;[ 3371.191619] cma: cma_alloc: alloc failed, req-size: 1280 pages, ret: -16</span><br></pre></td></tr></table></figure><p>主要代码在mm&#x2F;cma.c, cma_debug.c里，高通平台Kernel 4.9，先看下CMA结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cma</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>   base_pfn;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>   count;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>   *bitmap;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> order_per_bit; <span class="comment">/* Order of pages represented by one bit */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>    <span class="title">lock</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA_DEBUGFS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">mem_head</span>;</span></span><br><span class="line"><span class="type">spinlock_t</span> mem_head_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>base_pfn</code>就是cma区域的base page frame number，<code>count</code>是cma size in page，cma area用<code>bitmap</code>来管理，每个bit代表多少页用<code>order_per_bit</code>来表示，<code>lock</code>就是访问bitmap互斥用了。</p><p>另外还有2个全局：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">cma</span> <span class="title">cma_areas</span>[<span class="title">MAX_CMA_AREAS</span>];</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> cma_area_count;</span><br></pre></td></tr></table></figure><p>很容易理解，cma区域有cma_area_count个，每个区域是cma_areas，最大8个。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * There is always at least global CMA area and a few optional</span></span><br><span class="line"><span class="comment"> * areas configured in kernel .config.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA_AREAS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CMA_AREAS(1 + CONFIG_CMA_AREAS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CMA_AREAS(0)</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config CMA_AREAS</span><br><span class="line">        int &quot;Maximum count of the CMA areas&quot;</span><br><span class="line">        depends on CMA </span><br><span class="line">        default 7</span><br><span class="line">        help</span><br><span class="line">          CMA allows to create CMA areas for particular purpose, mainly,</span><br><span class="line">          used as device private area. This parameter sets the maximum</span><br><span class="line">          number of CMA area in the system.</span><br><span class="line"></span><br><span class="line">          If unsure, leave the default value &quot;7&quot;.</span><br></pre></td></tr></table></figure><p>看下初始化：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cma_init_reserved_mem() - create custom contiguous area from reserved memory</span></span><br><span class="line"><span class="comment"> * @base: Base address of the reserved area</span></span><br><span class="line"><span class="comment"> * @size: Size of the reserved area (in bytes),</span></span><br><span class="line"><span class="comment"> * @order_per_bit: Order of pages represented by one bit on bitmap.</span></span><br><span class="line"><span class="comment"> * @name: The name of the area. If this parameter is NULL, the name of</span></span><br><span class="line"><span class="comment"> *        the area will be set to &quot;cmaN&quot;, where N is a running counter of</span></span><br><span class="line"><span class="comment"> *        used areas.</span></span><br><span class="line"><span class="comment"> * @res_cma: Pointer to store the created cma region.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function creates custom contiguous area from already reserved memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">cma_init_reserved_mem</span><span class="params">(<span class="type">phys_addr_t</span> base, <span class="type">phys_addr_t</span> size,</span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> <span class="type">int</span> order_per_bit,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> cma **res_cma)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each reserved area must be initialised later, when more kernel</span></span><br><span class="line"><span class="comment"> * subsystems (like slab allocator) are available.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cma = &amp;cma_areas[cma_area_count];</span><br><span class="line"><span class="keyword">if</span> (name) &#123;</span><br><span class="line">cma-&gt;name = name;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cma-&gt;name = kasprintf(GFP_KERNEL, <span class="string">&quot;cma%d\n&quot;</span>, cma_area_count);</span><br><span class="line"><span class="keyword">if</span> (!cma-&gt;name)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line">cma-&gt;base_pfn = PFN_DOWN(base);</span><br><span class="line">cma-&gt;count = size &gt;&gt; PAGE_SHIFT; <span class="comment">//tj: cma area size in pages</span></span><br><span class="line">cma-&gt;order_per_bit = order_per_bit;</span><br><span class="line">*res_cma = cma;</span><br><span class="line">cma_area_count++;</span><br><span class="line">totalcma_pages += (size / PAGE_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会有两个caller，一个是<code>early_init_fdt_scan_reserved_mem()</code>，一个是<code>dma_contiguous_reserve()</code>，都是从<code>setup_arch()</code>而来，看下arm64的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">arm64_memblock_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Register the kernel text, kernel data, initrd, and initial</span></span><br><span class="line"><span class="comment">         * pagetables with memblock.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        memblock_reserve(__pa_symbol(_text), _end - _text);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_INITRD</span></span><br><span class="line">        <span class="keyword">if</span> (initrd_start) &#123;</span><br><span class="line">                memblock_reserve(initrd_start, initrd_end - initrd_start);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* the generic initrd code expects virtual addresses */</span></span><br><span class="line">                initrd_start = __phys_to_virt(initrd_start);</span><br><span class="line">                initrd_end = __phys_to_virt(initrd_end);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        early_init_fdt_scan_reserved_mem(); <span class="comment">//tj: caller </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 4GB maximum for 32-bit only capable devices */</span></span><br><span class="line">        <span class="keyword">if</span> (IS_ENABLED(CONFIG_ZONE_DMA))</span><br><span class="line">                arm64_dma_phys_limit = max_zone_dma_phys();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                arm64_dma_phys_limit = PHYS_MASK + <span class="number">1</span>;</span><br><span class="line">        high_memory = __va(memblock_end_of_DRAM() - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        dma_contiguous_reserve(arm64_dma_phys_limit);<span class="comment">//tj: caller</span></span><br></pre></td></tr></table></figure><p>设备树保留最后会调用<code>rmem_cma_setup()</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">rmem_cma_setup</span><span class="params">(<span class="keyword">struct</span> reserved_mem *rmem)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">phys_addr_t</span> align = PAGE_SIZE &lt;&lt; max(MAX_ORDER - <span class="number">1</span>, pageblock_order);</span><br><span class="line"><span class="type">phys_addr_t</span> mask = align - <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> node = rmem-&gt;fdt_node;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cma</span> *<span class="title">cma</span>;</span></span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!of_get_flat_dt_prop(node, <span class="string">&quot;reusable&quot;</span>, <span class="literal">NULL</span>) ||</span><br><span class="line">    of_get_flat_dt_prop(node, <span class="string">&quot;no-map&quot;</span>, <span class="literal">NULL</span>))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((rmem-&gt;base &amp; mask) || (rmem-&gt;size &amp; mask)) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;Reserved memory: incorrect alignment of CMA region\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = cma_init_reserved_mem(rmem-&gt;base, rmem-&gt;size, <span class="number">0</span>, rmem-&gt;name, &amp;cma); <span class="comment">//tj:here</span></span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;Reserved memory: unable to setup CMA region\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Architecture specific contiguous memory fixup. */</span></span><br><span class="line">dma_contiguous_early_fixup(rmem-&gt;base, rmem-&gt;size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (of_get_flat_dt_prop(node, <span class="string">&quot;linux,cma-default&quot;</span>, <span class="literal">NULL</span>))</span><br><span class="line">dma_contiguous_set_default(cma);</span><br><span class="line"></span><br><span class="line">rmem-&gt;ops = &amp;rmem_cma_ops;</span><br><span class="line">rmem-&gt;priv = cma;</span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">&quot;Reserved memory: created CMA memory pool at %pa, size %ld MiB\n&quot;</span>,</span><br><span class="line">&amp;rmem-&gt;base, (<span class="type">unsigned</span> <span class="type">long</span>)rmem-&gt;size / SZ_1M);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一处调用from dma:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dma_contiguous_reserve() - reserve area(s) for contiguous memory handling</span></span><br><span class="line"><span class="comment"> * @limit: End address of the reserved memory (optional, 0 for any).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function reserves memory from early allocator. It should be</span></span><br><span class="line"><span class="comment"> * called by arch specific code once the early allocator (memblock or bootmem)</span></span><br><span class="line"><span class="comment"> * has been activated and all other subsystems have already allocated/reserved</span></span><br><span class="line"><span class="comment"> * memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">dma_contiguous_reserve</span><span class="params">(<span class="type">phys_addr_t</span> limit)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">phys_addr_t</span> selected_size = <span class="number">0</span>;</span><br><span class="line">        <span class="type">phys_addr_t</span> selected_base = <span class="number">0</span>;</span><br><span class="line">        <span class="type">phys_addr_t</span> selected_limit = limit;</span><br><span class="line">        <span class="type">bool</span> fixed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        pr_debug(<span class="string">&quot;%s(limit %08lx)\n&quot;</span>, __func__, (<span class="type">unsigned</span> <span class="type">long</span>)limit);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size_cmdline != <span class="number">-1</span>) &#123;</span><br><span class="line">                selected_size = size_cmdline;</span><br><span class="line">                selected_base = base_cmdline;</span><br><span class="line">                selected_limit = min_not_zero(limit_cmdline, limit);</span><br><span class="line">                <span class="keyword">if</span> (base_cmdline + size_cmdline == limit_cmdline)</span><br><span class="line">                        fixed = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA_SIZE_SEL_MBYTES</span></span><br><span class="line">                selected_size = size_bytes;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_CMA_SIZE_SEL_PERCENTAGE)</span></span><br><span class="line">                selected_size = cma_early_percent_memory();</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_CMA_SIZE_SEL_MIN)</span></span><br><span class="line">                selected_size = min(size_bytes, cma_early_percent_memory());</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_CMA_SIZE_SEL_MAX)</span></span><br><span class="line">                selected_size = max(size_bytes, cma_early_percent_memory());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (selected_size &amp;&amp; !dma_contiguous_default_area) &#123;</span><br><span class="line">                pr_debug(<span class="string">&quot;%s: reserving %ld MiB for global area\n&quot;</span>, __func__,</span><br><span class="line">                         (<span class="type">unsigned</span> <span class="type">long</span>)selected_size / SZ_1M);</span><br><span class="line"></span><br><span class="line">                dma_contiguous_reserve_area(selected_size, selected_base,</span><br><span class="line">                                            selected_limit,</span><br><span class="line">                                            &amp;dma_contiguous_default_area,</span><br><span class="line">                                            fixed);</span><br><span class="line">        &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA_SIZE_MBYTES</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMA_SIZE_MBYTES CONFIG_CMA_SIZE_MBYTES</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMA_SIZE_MBYTES 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cma</span> *<span class="title">dma_contiguous_default_area</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Default global CMA area size can be defined in kernel&#x27;s .config.</span></span><br><span class="line"><span class="comment"> * This is useful mainly for distro maintainers to create a kernel</span></span><br><span class="line"><span class="comment"> * that works correctly for most supported systems.</span></span><br><span class="line"><span class="comment"> * The size can be set in bytes or as a percentage of the total memory</span></span><br><span class="line"><span class="comment"> * in the system.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Users, who want to set the size of global CMA area for their system</span></span><br><span class="line"><span class="comment"> * should use cma= kernel parameter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">phys_addr_t</span> size_bytes = (<span class="type">phys_addr_t</span>)CMA_SIZE_MBYTES * SZ_1M;</span><br><span class="line"><span class="type">static</span> <span class="type">phys_addr_t</span> size_cmdline = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>默认的global CMA大小是16M:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if  DMA_CMA</span><br><span class="line">comment &quot;Default contiguous memory area size:&quot;</span><br><span class="line"></span><br><span class="line">config CMA_SIZE_MBYTES</span><br><span class="line">        int &quot;Size in Mega Bytes&quot;</span><br><span class="line">        depends on !CMA_SIZE_SEL_PERCENTAGE</span><br><span class="line">        default 0 if X86 </span><br><span class="line">        default 16</span><br><span class="line">        help</span><br><span class="line">          Defines the size (in MiB) of the default memory area for Contiguous</span><br><span class="line">          Memory Allocator.  If the size of 0 is selected, CMA is disabled by</span><br><span class="line">          default, but it can be enabled by passing cma=size[MG] to the kernel.</span><br></pre></td></tr></table></figure><p>继续看：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __init <span class="title function_">dma_contiguous_reserve_area</span><span class="params">(<span class="type">phys_addr_t</span> size, <span class="type">phys_addr_t</span> base,</span></span><br><span class="line"><span class="params">       <span class="type">phys_addr_t</span> limit, <span class="keyword">struct</span> cma **res_cma,</span></span><br><span class="line"><span class="params">       <span class="type">bool</span> fixed)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = cma_declare_contiguous(base, size, limit, <span class="number">0</span>, <span class="number">0</span>, fixed,</span><br><span class="line"><span class="string">&quot;reserved&quot;</span>, res_cma);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __init <span class="title function_">cma_declare_contiguous</span><span class="params">(<span class="type">phys_addr_t</span> base,</span></span><br><span class="line"><span class="params"><span class="type">phys_addr_t</span> size, <span class="type">phys_addr_t</span> limit,</span></span><br><span class="line"><span class="params"><span class="type">phys_addr_t</span> alignment, <span class="type">unsigned</span> <span class="type">int</span> order_per_bit,</span></span><br><span class="line"><span class="params"><span class="type">bool</span> fixed, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> cma **res_cma)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* Reserve memory */</span></span><br><span class="line"><span class="keyword">if</span> (fixed) &#123;</span><br><span class="line"><span class="keyword">if</span> (memblock_is_region_reserved(base, size) ||</span><br><span class="line">    memblock_reserve(base, size) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ret = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">phys_addr_t</span> addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * All pages in the reserved area must come from the same zone.</span></span><br><span class="line"><span class="comment"> * If the requested region crosses the low/high memory boundary,</span></span><br><span class="line"><span class="comment"> * try allocating from high memory first and fall back to low</span></span><br><span class="line"><span class="comment"> * memory in case of failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (base &lt; highmem_start &amp;&amp; limit &gt; highmem_start) &#123;</span><br><span class="line">addr = memblock_alloc_range(size, alignment,</span><br><span class="line">    highmem_start, limit,</span><br><span class="line">    MEMBLOCK_NONE);</span><br><span class="line">limit = highmem_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!addr) &#123;</span><br><span class="line">addr = memblock_alloc_range(size, alignment, base,</span><br><span class="line">    limit,</span><br><span class="line">    MEMBLOCK_NONE);</span><br><span class="line"><span class="keyword">if</span> (!addr) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kmemleak scans/reads tracked objects for pointers to other</span></span><br><span class="line"><span class="comment"> * objects but this address isn&#x27;t mapped and accessible</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">kmemleak_ignore_phys(addr);</span><br><span class="line">base = addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = cma_init_reserved_mem(base, size, order_per_bit, name, res_cma);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">&quot;Reserved %ld MiB at %pa\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)size / SZ_1M,</span><br><span class="line">&amp;base);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>可见，是通过memblock来保留内存的。</p><p>还有个初始化接口是<code>cma_active_area()</code>，挂在<code>do_one_initcall()</code>上：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">cma_activate_area</span><span class="params">(<span class="keyword">struct</span> cma *cma)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> bitmap_size = BITS_TO_LONGS(cma_bitmap_maxno(cma)) * <span class="keyword">sizeof</span>(<span class="type">long</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> base_pfn = cma-&gt;base_pfn, pfn = base_pfn;</span><br><span class="line"><span class="type">unsigned</span> i = cma-&gt;count &gt;&gt; pageblock_order;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line"></span><br><span class="line">cma-&gt;bitmap = kzalloc(bitmap_size, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!cma-&gt;bitmap)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">cma_bitmap_maxno</span><span class="params">(<span class="keyword">struct</span> cma *cma)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cma-&gt;count &gt;&gt; cma-&gt;order_per_bit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先申请bitmap大小，cma area size in pages就是<code>cma-&gt;count</code>，cma area size in bits就是<code>cma-&gt;count &gt;&gt; order_per_bit</code>，cma area size in pageblock就是<code>cma-&gt;count &gt;&gt; pageblock_order</code>，rt?</p><p>下来按pageblock初始化：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zone = page_zone(pfn_to_page(pfn));</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> j;</span><br><span class="line"></span><br><span class="line">base_pfn = pfn;</span><br><span class="line"><span class="keyword">for</span> (j = pageblock_nr_pages; j; --j, pfn++) &#123;</span><br><span class="line">WARN_ON_ONCE(!pfn_valid(pfn));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * alloc_contig_range requires the pfn range</span></span><br><span class="line"><span class="comment"> * specified to be in the same zone. Make this</span></span><br><span class="line"><span class="comment"> * simple by forcing the entire CMA resv range</span></span><br><span class="line"><span class="comment"> * to be in the same zone.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (page_zone(pfn_to_page(pfn)) != zone)</span><br><span class="line"><span class="keyword">goto</span> not_in_zone;</span><br><span class="line">&#125;</span><br><span class="line">init_cma_reserved_pageblock(pfn_to_page(base_pfn));</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br></pre></td></tr></table></figure><p>主要接口是<code>init_cma_reserved_pageblock()</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line"><span class="comment">/* Free whole pageblock and set its migration type to MIGRATE_CMA. */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">init_cma_reserved_pageblock</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> i = pageblock_nr_pages;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">p</span> =</span> page;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123; </span><br><span class="line">                __ClearPageReserved(p);</span><br><span class="line">                set_page_count(p, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (++p, --i);</span><br><span class="line"></span><br><span class="line">        set_pageblock_migratetype(page, MIGRATE_CMA);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pageblock_order &gt;= MAX_ORDER) &#123;</span><br><span class="line">                i = pageblock_nr_pages;</span><br><span class="line">                p = page;</span><br><span class="line">                <span class="keyword">do</span> &#123; </span><br><span class="line">                        set_page_refcounted(p);</span><br><span class="line">                        __free_pages(p, MAX_ORDER - <span class="number">1</span>);</span><br><span class="line">                        p += MAX_ORDER_NR_PAGES;</span><br><span class="line">                &#125; <span class="keyword">while</span> (i -= MAX_ORDER_NR_PAGES);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set_page_refcounted(page);</span><br><span class="line">                __free_pages(page, pageblock_order);</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        adjust_managed_page_count(page, pageblock_nr_pages);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>能看出来会设置pageblock migrate type为<code>MIGRATE_CMA</code>，然后用<code>__free_pages</code>去释放，涉及buddy分配器，以后看。</p><p>来看分配接口：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cma_alloc() - allocate pages from contiguous area</span></span><br><span class="line"><span class="comment"> * @cma:   Contiguous memory region for which the allocation is performed.</span></span><br><span class="line"><span class="comment"> * @count: Requested number of pages.</span></span><br><span class="line"><span class="comment"> * @align: Requested alignment of pages (in PAGE_SIZE order).</span></span><br><span class="line"><span class="comment"> * @gfp_mask:  GFP mask to use during compaction</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function allocates part of contiguous memory on specific</span></span><br><span class="line"><span class="comment"> * contiguous memory area.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">cma_alloc</span><span class="params">(<span class="keyword">struct</span> cma *cma, <span class="type">size_t</span> count, <span class="type">unsigned</span> <span class="type">int</span> align,</span></span><br><span class="line"><span class="params">       <span class="type">gfp_t</span> gfp_mask)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">mutex_lock(&amp;cma-&gt;lock);</span><br><span class="line">bitmap_no = bitmap_find_next_zero_area_off(cma-&gt;bitmap,</span><br><span class="line">bitmap_maxno, start, bitmap_count, mask,</span><br><span class="line">offset);</span><br><span class="line"><span class="keyword">if</span> (bitmap_no &gt;= bitmap_maxno) &#123;</span><br><span class="line">mutex_unlock(&amp;cma-&gt;lock);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">bitmap_set(cma-&gt;bitmap, bitmap_no, bitmap_count);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * It&#x27;s safe to drop the lock here. We&#x27;ve marked this region for</span></span><br><span class="line"><span class="comment"> * our exclusive use. If the migration fails we will take the</span></span><br><span class="line"><span class="comment"> * lock again and unmark it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mutex_unlock(&amp;cma-&gt;lock);</span><br><span class="line"></span><br><span class="line">pfn = cma-&gt;base_pfn + (bitmap_no &lt;&lt; cma-&gt;order_per_bit);</span><br><span class="line">mutex_lock(&amp;cma_mutex);</span><br><span class="line">ret = alloc_contig_range(pfn, pfn + count, MIGRATE_CMA,</span><br><span class="line"> gfp_mask);</span><br><span class="line">mutex_unlock(&amp;cma_mutex);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">page = pfn_to_page(pfn);</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//tj: 分配成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cma_clear_bitmap(cma, pfn, count);</span><br><span class="line"><span class="keyword">if</span> (ret != -EBUSY)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">&quot;%s(): memory range at %p is busy, retrying\n&quot;</span>,</span><br><span class="line"> __func__, pfn_to_page(pfn));</span><br><span class="line"><span class="comment">/* try again with a bit different memory target */</span></span><br><span class="line">start = bitmap_no + mask + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (ret &amp;&amp; !(gfp_mask &amp; __GFP_NOWARN)) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;%s: alloc failed, req-size: %zu pages, ret: %d\n&quot;</span>,</span><br><span class="line">__func__, count, ret);</span><br><span class="line">cma_debug_show_areas(cma);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要调用<code>alloc_contig_range()</code>来分配，分配成功会set bitmap，释放接口<code>cma_release()</code>主要call <code>free_contig_range()</code>来释放并clear bitmap。</p><p>遇到失败的可以放开<code>cma_debug_show_areas()</code>来看下，会打印可用pages，可以调大size试试。</p><p>另外，debugfs里path是<code>/sys/kernel/debug/cma</code>，比如default 16M global cma area：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/sys/kernel/debug/cma/cma-reserved <span class="comment"># ls</span></span><br><span class="line">alloc base_pfn bitmap count free maxchunk order_per_bit used</span><br></pre></td></tr></table></figure><p>这里的bitmap貌似没啥意义!?</p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cma </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android P重启卡死问题分析</title>
      <link href="/analyze-stuck-on-reboot-under-android-p.html"/>
      <url>/analyze-stuck-on-reboot-under-android-p.html</url>
      
        <content type="html"><![CDATA[<p>最近遇到重启卡死的问题，有的是黑屏，有的是定屏在”正在重新启动”adb可用，高通平台。</p><p>抓下logcat能发现如下log：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ShutdownThread: Rebooting, reason: null</span><br></pre></td></tr></table></figure><p>代码在：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;power&#x2F;ShutdownThread.java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (reboot) &#123;</span><br><span class="line">    Log.i(TAG, <span class="string">&quot;Rebooting, reason: &quot;</span> + reason);</span><br><span class="line">    PowerManagerService.lowLevelReboot(reason);</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;Reboot failed, will attempt shutdown instead&quot;</span>);</span><br><span class="line">    reason = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;power&#x2F;PowerManagerService.java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Low-level function to reboot the device. On success, this</span></span><br><span class="line"><span class="comment"> * function doesn&#x27;t return. If more than 20 seconds passes from</span></span><br><span class="line"><span class="comment"> * the time a reboot is requested, this method returns.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reason code to pass to the kernel (e.g. &quot;recovery&quot;), or null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lowLevelReboot</span><span class="params">(String reason)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (reason == <span class="literal">null</span>) &#123;</span><br><span class="line">        reason = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the reason is &quot;quiescent&quot;, it means that the boot process should proceed</span></span><br><span class="line">    <span class="comment">// without turning on the screen/lights.</span></span><br><span class="line">    <span class="comment">// The &quot;quiescent&quot; property is sticky, meaning that any number</span></span><br><span class="line">    <span class="comment">// of subsequent reboots should honor the property until it is reset.</span></span><br><span class="line">    <span class="keyword">if</span> (reason.equals(PowerManager.REBOOT_QUIESCENT)) &#123;</span><br><span class="line">        sQuiescent = <span class="literal">true</span>;</span><br><span class="line">        reason = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reason.endsWith(<span class="string">&quot;,&quot;</span> + PowerManager.REBOOT_QUIESCENT)) &#123;</span><br><span class="line">        sQuiescent = <span class="literal">true</span>;</span><br><span class="line">        reason = reason.substring(<span class="number">0</span>,</span><br><span class="line">                reason.length() - PowerManager.REBOOT_QUIESCENT.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reason.equals(PowerManager.REBOOT_RECOVERY)</span><br><span class="line">            || reason.equals(PowerManager.REBOOT_RECOVERY_UPDATE)) &#123;</span><br><span class="line">        reason = <span class="string">&quot;recovery&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sQuiescent) &#123;</span><br><span class="line">        <span class="comment">// Pass the optional &quot;quiescent&quot; argument to the bootloader to let it know</span></span><br><span class="line">        <span class="comment">// that it should not turn the screen/lights on.</span></span><br><span class="line">        reason = reason + <span class="string">&quot;,quiescent&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    SystemProperties.set(<span class="string">&quot;sys.powerctl&quot;</span>, <span class="string">&quot;reboot,&quot;</span> + reason); <span class="comment">//tj: trigger reboot</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">20</span> * <span class="number">1000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;    </span><br><span class="line">    Slog.wtf(TAG, <span class="string">&quot;Unexpected return from lowLevelReboot!&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>通过设置属性<code>sys.powerctl</code>来重启，属性设置会走HandlePropertySet -&gt; PropertySet -&gt; property_changed(init.cpp)：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">property_changed</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If the property is sys.powerctl, we bypass the event queue and immediately handle it.</span></span><br><span class="line">    <span class="comment">// This is to ensure that init will always and immediately shutdown/reboot, regardless of</span></span><br><span class="line">    <span class="comment">// if there are other pending events to process or if init is waiting on an exec service or</span></span><br><span class="line">    <span class="comment">// waiting on a property.</span></span><br><span class="line">    <span class="comment">// In non-thermal-shutdown case, &#x27;shutdown&#x27; trigger will be fired to let device specific</span></span><br><span class="line">    <span class="comment">// commands to be executed.</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;sys.powerctl&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// Despite the above comment, we can&#x27;t call HandlePowerctlMessage() in this function,</span></span><br><span class="line">        <span class="comment">// because it modifies the contents of the action queue, which can cause the action queue</span></span><br><span class="line">        <span class="comment">// to get into a bad state if this function is called from a command being executed by the</span></span><br><span class="line">        <span class="comment">// action queue.  Instead we set this flag and ensure that shutdown happens before the next</span></span><br><span class="line">        <span class="comment">// command is run in the main init loop.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> once property service is removed from init, this will never happen from a builtin,</span></span><br><span class="line">        <span class="comment">// but rather from a callback from the property service socket, in which case this hack can</span></span><br><span class="line">        <span class="comment">// go away.</span></span><br><span class="line">        shutdown_command = value;</span><br><span class="line">        do_shutdown = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>init.cpp的<code>main()</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// By default, sleep until something happens.</span></span><br><span class="line">    <span class="type">int</span> epoll_timeout_ms = <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (do_shutdown &amp;&amp; !shutting_down) &#123;</span><br><span class="line">        do_shutdown = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">HandlePowerctlMessage</span>(shutdown_command)) &#123;</span><br><span class="line">            shutting_down = <span class="literal">true</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><p>HandlePowerctlMessage():</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HandlePowerctlMessage</span><span class="params">(<span class="type">const</span> std::string&amp; command)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cmd = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; cmd_params = <span class="built_in">Split</span>(command, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    std::string reboot_target = <span class="string">&quot;&quot;</span>; </span><br><span class="line">    <span class="type">bool</span> run_fsck = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> command_invalid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmd_params.<span class="built_in">size</span>() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        command_invalid = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd_params[<span class="number">0</span>] == <span class="string">&quot;shutdown&quot;</span>) &#123;</span><br><span class="line">        cmd = ANDROID_RB_POWEROFF;</span><br><span class="line">        <span class="keyword">if</span> (cmd_params.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cmd_params[<span class="number">1</span>] == <span class="string">&quot;userrequested&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// The shutdown reason is PowerManager.SHUTDOWN_USER_REQUESTED.</span></span><br><span class="line">                <span class="comment">// Run fsck once the file system is remounted in read-only mode.</span></span><br><span class="line">                run_fsck = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd_params[<span class="number">1</span>] == <span class="string">&quot;thermal&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// Turn off sources of heat immediately.</span></span><br><span class="line">                <span class="built_in">TurnOffBacklight</span>();</span><br><span class="line">                <span class="comment">// run_fsck is false to avoid delay</span></span><br><span class="line">                cmd = ANDROID_RB_THERMOFF;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd_params[<span class="number">0</span>] == <span class="string">&quot;reboot&quot;</span>) &#123;</span><br><span class="line">        cmd = ANDROID_RB_RESTART2;</span><br><span class="line">        <span class="keyword">if</span> (cmd_params.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            reboot_target = cmd_params[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// When rebooting to the bootloader notify the bootloader writing</span></span><br><span class="line">            <span class="comment">// also the BCB.</span></span><br><span class="line">            <span class="keyword">if</span> (reboot_target == <span class="string">&quot;bootloader&quot;</span>) &#123;</span><br><span class="line">                std::string err;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">write_reboot_bootloader</span>(&amp;err)) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;reboot-bootloader: Error writing &quot;</span></span><br><span class="line">                                  <span class="string">&quot;bootloader_message: &quot;</span></span><br><span class="line">                               &lt;&lt; err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If there is an additional parameter, pass it along</span></span><br><span class="line">            <span class="keyword">if</span> ((cmd_params.<span class="built_in">size</span>() == <span class="number">3</span>) &amp;&amp; cmd_params[<span class="number">2</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                reboot_target += <span class="string">&quot;,&quot;</span> + cmd_params[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        command_invalid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (command_invalid) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;powerctl: unrecognized command &#x27;&quot;</span> &lt;&lt; command &lt;&lt; <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Clear action queue and start shutdown trigger&quot;</span>;</span><br><span class="line">    ActionManager::<span class="built_in">GetInstance</span>().<span class="built_in">ClearQueue</span>();</span><br><span class="line">    <span class="comment">// Queue shutdown trigger first</span></span><br><span class="line">    ActionManager::<span class="built_in">GetInstance</span>().<span class="built_in">QueueEventTrigger</span>(<span class="string">&quot;shutdown&quot;</span>);</span><br><span class="line">    <span class="comment">// Queue built-in shutdown_done</span></span><br><span class="line">    <span class="keyword">auto</span> shutdown_handler = [cmd, command, reboot_target, run_fsck](<span class="type">const</span> BuiltinArguments&amp;) &#123;</span><br><span class="line">        <span class="built_in">DoReboot</span>(cmd, command, reboot_target, run_fsck);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Success</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    ActionManager::<span class="built_in">GetInstance</span>().<span class="built_in">QueueBuiltinAction</span>(shutdown_handler, <span class="string">&quot;shutdown_done&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip wait for prop if it is in progress</span></span><br><span class="line">    <span class="built_in">ResetWaitForProp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear EXEC flag if there is one pending</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : ServiceList::<span class="built_in">GetInstance</span>()) &#123;</span><br><span class="line">        s-&gt;<span class="built_in">UnSetExec</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LOG(INFO) &lt;&lt; &quot;Clear action queue and start shutdown trigger&quot;</code>这句log(check dmesg)有时有，有时没有？继续看<code>DoReboot</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoReboot</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">const</span> std::string&amp; reason, <span class="type">const</span> std::string&amp; rebootTarget,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">bool</span> runFsck)</span> </span>&#123;</span><br><span class="line">    Timer t;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Reboot start, reason: &quot;</span> &lt;&lt; reason &lt;&lt; <span class="string">&quot;, rebootTarget: &quot;</span> &lt;&lt; rebootTarget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure last reboot reason is reduced to canonical</span></span><br><span class="line">    <span class="comment">// alias reported in bootloader or system boot reason.</span></span><br><span class="line">    <span class="type">size_t</span> skip = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(ERR) &lt;&lt; <span class="string">&quot;[YL] Reboot start, reason: &quot;</span> &lt;&lt; reason &lt;&lt; <span class="string">&quot;, rebootTarget: &quot;</span> &lt;&lt; rebootTarget;</span><br><span class="line">    std::vector&lt;std::string&gt; reasons = <span class="built_in">Split</span>(reason, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (reasons.<span class="built_in">size</span>() &gt;= <span class="number">2</span> &amp;&amp; reasons[<span class="number">0</span>] == <span class="string">&quot;reboot&quot;</span> &amp;&amp;</span><br><span class="line">        (reasons[<span class="number">1</span>] == <span class="string">&quot;recovery&quot;</span> || reasons[<span class="number">1</span>] == <span class="string">&quot;bootloader&quot;</span> || reasons[<span class="number">1</span>] == <span class="string">&quot;cold&quot;</span> ||</span><br><span class="line">         reasons[<span class="number">1</span>] == <span class="string">&quot;hard&quot;</span> || reasons[<span class="number">1</span>] == <span class="string">&quot;warm&quot;</span>)) &#123;</span><br><span class="line">        skip = <span class="built_in">strlen</span>(<span class="string">&quot;reboot,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">property_set</span>(LAST_REBOOT_REASON_PROPERTY, reason.<span class="built_in">c_str</span>() + skip);</span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> is_thermal_shutdown = cmd == ANDROID_RB_THERMOFF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> shutdown_timeout = <span class="number">0</span>ms;</span><br><span class="line">    <span class="keyword">if</span> (!SHUTDOWN_ZERO_TIMEOUT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_thermal_shutdown) &#123;</span><br><span class="line">            <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> thermal_shutdown_timeout = <span class="number">3</span>;</span><br><span class="line">            shutdown_timeout = std::chrono::<span class="built_in">seconds</span>(thermal_shutdown_timeout);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> shutdown_timeout_default = <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">auto</span> shutdown_timeout_property = android::base::<span class="built_in">GetUintProperty</span>(</span><br><span class="line">                <span class="string">&quot;ro.build.shutdown_timeout&quot;</span>, shutdown_timeout_default);</span><br><span class="line">            shutdown_timeout = std::chrono::<span class="built_in">seconds</span>(shutdown_timeout_property);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Shutdown timeout: &quot;</span> &lt;&lt; shutdown_timeout.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ms&quot;</span>;</span><br></pre></td></tr></table></figure><p>奇怪，<code>Reboot start, reason</code>和<code>Shutdown timeout</code>这两句log也不是每次都有？这里有个属性<code>LAST_REBOOT_REASON_PROPERTY</code>会记录重启原因:</p><figure class="highlight h"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Properties */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANDROID_RB_PROPERTY <span class="string">&quot;sys.powerctl&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Android reboot reason stored in this property */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_REBOOT_REASON_PROPERTY <span class="string">&quot;persist.sys.boot.reason&quot;</span></span></span><br></pre></td></tr></table></figure><p>复现了一次抓到如下log，是通过adb reboot压测的:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[   36.255358] init: Received sys.powerctl=&#x27;reboot,adb&#x27; from pid: 2491 (/system/bin/adbd)</span><br><span class="line">[   36.255533] init: Clear action queue and start shutdown trigger</span><br><span class="line">[   36.255731] init: processing action (shutdown_done) from (&lt;Builtin Action&gt;:0)</span><br><span class="line">[   36.255759] init: Reboot start, reason: reboot,adb, rebootTarget: adb</span><br><span class="line">[   36.291254] init: Shutdown timeout: 6000 ms</span><br><span class="line">[   36.291385] init: Could not start shutdown critical service &#x27;chre&#x27;: Cannot find &#x27;/vendor/bin/chre&#x27;: No such file or directory</span><br><span class="line">[   36.292815] init: starting service &#x27;blank_screen&#x27;...</span><br><span class="line">[   36.294620] init: terminating init services</span><br><span class="line">[   36.294804] init: Sending signal 15 to service &#x27;gx_fpd&#x27; (pid 3714) process group...</span><br><span class="line">[   36.295203] init: Sending signal 15 to service &#x27;trustonic-daemon&#x27; (pid 3295) process group...</span><br></pre></td></tr></table></figure><p>继续跟下代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// keep debugging tools until non critical ones are all gone.</span></span><br><span class="line"><span class="type">const</span> std::set&lt;std::string&gt; kill_after_apps&#123;<span class="string">&quot;tombstoned&quot;</span>, <span class="string">&quot;logd&quot;</span>, <span class="string">&quot;adbd&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// watchdogd is a vendor specific component but should be alive to complete shutdown safely.</span></span><br><span class="line"><span class="type">const</span> std::set&lt;std::string&gt; to_starts&#123;<span class="string">&quot;watchdogd&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : ServiceList::<span class="built_in">GetInstance</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (kill_after_apps.<span class="built_in">count</span>(s-&gt;<span class="built_in">name</span>())) &#123;</span><br><span class="line">        s-&gt;<span class="built_in">SetShutdownCritical</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (to_starts.<span class="built_in">count</span>(s-&gt;<span class="built_in">name</span>())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> result = s-&gt;<span class="built_in">Start</span>(); !result) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Could not start shutdown &#x27;to_start&#x27; service &#x27;&quot;</span> &lt;&lt; s-&gt;<span class="built_in">name</span>()</span><br><span class="line">                       &lt;&lt; <span class="string">&quot;&#x27;: &quot;</span> &lt;&lt; result.<span class="built_in">error</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;<span class="built_in">SetShutdownCritical</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;<span class="built_in">IsShutdownCritical</span>()) &#123;</span><br><span class="line">        <span class="comment">// Start shutdown critical service if not started.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> result = s-&gt;<span class="built_in">Start</span>(); !result) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Could not start shutdown critical service &#x27;&quot;</span> &lt;&lt; s-&gt;<span class="built_in">name</span>()</span><br><span class="line">                       &lt;&lt; <span class="string">&quot;&#x27;: &quot;</span> &lt;&lt; result.<span class="built_in">error</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remaining operations (specifically fsck) may take a substantial duration</span></span><br><span class="line"><span class="keyword">if</span> (cmd == ANDROID_RB_POWEROFF || is_thermal_shutdown) &#123;</span><br><span class="line">    <span class="built_in">TurnOffBacklight</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Service* bootAnim = ServiceList::<span class="built_in">GetInstance</span>().<span class="built_in">FindService</span>(<span class="string">&quot;bootanim&quot;</span>);</span><br><span class="line">Service* surfaceFlinger = ServiceList::<span class="built_in">GetInstance</span>().<span class="built_in">FindService</span>(<span class="string">&quot;surfaceflinger&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (bootAnim != <span class="literal">nullptr</span> &amp;&amp; surfaceFlinger != <span class="literal">nullptr</span> &amp;&amp; surfaceFlinger-&gt;<span class="built_in">IsRunning</span>()) &#123;</span><br><span class="line">    <span class="comment">// will not check animation class separately</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; service : ServiceList::<span class="built_in">GetInstance</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (service-&gt;<span class="built_in">classnames</span>().<span class="built_in">count</span>(<span class="string">&quot;animation&quot;</span>)) service-&gt;<span class="built_in">SetShutdownCritical</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先保留几个critical service，比如tombstoned, logd, adbd, watchdogd。接下来会terminate所有的服务除了这几个critical:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// optional shutdown step</span></span><br><span class="line"><span class="comment">// 1. terminate all services except shutdown critical ones. wait for delay to finish</span></span><br><span class="line"><span class="keyword">if</span> (shutdown_timeout &gt; <span class="number">0</span>ms) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;terminating init services&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ask all services to terminate except shutdown critical ones.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : ServiceList::<span class="built_in">GetInstance</span>().<span class="built_in">services_in_shutdown_order</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;<span class="built_in">IsShutdownCritical</span>()) s-&gt;<span class="built_in">Terminate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> service_count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Only wait up to half of timeout here</span></span><br><span class="line">    <span class="keyword">auto</span> termination_wait_timeout = shutdown_timeout / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (t.<span class="built_in">duration</span>() &lt; termination_wait_timeout) &#123;</span><br><span class="line">        <span class="built_in">ReapAnyOutstandingChildren</span>();</span><br><span class="line"></span><br><span class="line">        service_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : ServiceList::<span class="built_in">GetInstance</span>()) &#123;</span><br><span class="line">            <span class="comment">// Count the number of services running except shutdown critical.</span></span><br><span class="line">            <span class="comment">// Exclude the console as it will ignore the SIGTERM signal</span></span><br><span class="line">            <span class="comment">// and not exit.</span></span><br><span class="line">            <span class="comment">// Note: SVC_CONSOLE actually means &quot;requires console&quot; but</span></span><br><span class="line">            <span class="comment">// it is only used by the shell.</span></span><br><span class="line">            <span class="keyword">if</span> (!s-&gt;<span class="built_in">IsShutdownCritical</span>() &amp;&amp; s-&gt;<span class="built_in">pid</span>() != <span class="number">0</span> &amp;&amp; (s-&gt;<span class="built_in">flags</span>() &amp; SVC_CONSOLE) == <span class="number">0</span>) &#123;</span><br><span class="line">                service_count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (service_count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// All terminable services terminated. We can exit early.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait a bit before recounting the number or running services.</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">50</span>ms);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Terminating running services took &quot;</span> &lt;&lt; t</span><br><span class="line">              &lt;&lt; <span class="string">&quot; with remaining services:&quot;</span> &lt;&lt; service_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会有个等待超时时间<code>termination_wait_timeout</code>，调大些？继续看:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// minimum safety steps before restarting</span></span><br><span class="line"><span class="comment">// 2. kill all services except ones that are necessary for the shutdown sequence.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : ServiceList::<span class="built_in">GetInstance</span>().<span class="built_in">services_in_shutdown_order</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s-&gt;<span class="built_in">IsShutdownCritical</span>()) s-&gt;<span class="built_in">Stop</span>(); <span class="comment">//tj: stop non critical</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ReapAnyOutstandingChildren</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. send volume shutdown to vold</span></span><br><span class="line">Service* voldService = ServiceList::<span class="built_in">GetInstance</span>().<span class="built_in">FindService</span>(<span class="string">&quot;vold&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (voldService != <span class="literal">nullptr</span> &amp;&amp; voldService-&gt;<span class="built_in">IsRunning</span>()) &#123;</span><br><span class="line">    <span class="built_in">ShutdownVold</span>();</span><br><span class="line">    voldService-&gt;<span class="built_in">Stop</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;vold not running, skipping vold shutdown&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logcat stopped here</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : ServiceList::<span class="built_in">GetInstance</span>().<span class="built_in">services_in_shutdown_order</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (kill_after_apps.<span class="built_in">count</span>(s-&gt;<span class="built_in">name</span>())) s-&gt;<span class="built_in">Stop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后才stop了logcat, adbd等服务。ok，定屏adb不能连的那肯定走到下面去了。下面就是umount:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. sync, try umount, and optionally run fsck for user shutdown</span></span><br><span class="line">&#123;</span><br><span class="line">    Timer sync_timer;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;sync() before umount...&quot;</span>;</span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;sync() before umount took&quot;</span> &lt;&lt; sync_timer;</span><br><span class="line">&#125;</span><br><span class="line">UmountStat stat = <span class="built_in">TryUmountAndFsck</span>(runFsck, shutdown_timeout - t.<span class="built_in">duration</span>());</span><br><span class="line"><span class="comment">// Follow what linux shutdown is doing: one more sync with little bit delay</span></span><br><span class="line">&#123;</span><br><span class="line">    Timer sync_timer;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;sync() after umount...&quot;</span>;</span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;sync() after umount took&quot;</span> &lt;&lt; sync_timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">KillAllProcesses</span><span class="params">()</span> </span>&#123; android::base::<span class="built_in">WriteStringToFile</span>(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;/proc/sysrq-trigger&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try umounting all emulated file systems R/W block device cfile systems.</span></span><br><span class="line"><span class="comment"> * This will just try umount and give it up if it fails.</span></span><br><span class="line"><span class="comment"> * For fs like ext4, this is ok as file system will be marked as unclean shutdown</span></span><br><span class="line"><span class="comment"> * and necessary check can be done at the next reboot.</span></span><br><span class="line"><span class="comment"> * For safer shutdown, caller needs to make sure that</span></span><br><span class="line"><span class="comment"> * all processes / emulated partition for the target fs are all cleaned-up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * return true when umount was successful. false when timed out.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> UmountStat <span class="title">TryUmountAndFsck</span><span class="params">(<span class="type">bool</span> runFsck, std::chrono::milliseconds timeout)</span> </span>&#123;</span><br><span class="line">    Timer t;</span><br><span class="line">    std::vector&lt;MountEntry&gt; block_devices;</span><br><span class="line">    std::vector&lt;MountEntry&gt; emulated_devices;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runFsck &amp;&amp; !<span class="built_in">FindPartitionsToUmount</span>(&amp;block_devices, &amp;emulated_devices, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> UMOUNT_STAT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UmountStat stat = <span class="built_in">UmountPartitions</span>(timeout - t.<span class="built_in">duration</span>());</span><br><span class="line">    <span class="keyword">if</span> (stat != UMOUNT_STAT_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;umount timeout, last resort, kill all and try&quot;</span>;</span><br><span class="line">        <span class="type">bool</span> dumpUmountDebugInfo = <span class="built_in">property_get_bool</span>(<span class="string">&quot;persist.sys.dumpUmountDebugInfo&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (dumpUmountDebugInfo) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DUMP_ON_UMOUNT_FAILURE) <span class="built_in">DumpUmountDebuggingInfo</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">KillAllProcesses</span>();</span><br><span class="line">        <span class="comment">// even if it succeeds, still it is timeout and do not run fsck with all processes killed</span></span><br><span class="line">        UmountStat st = <span class="built_in">UmountPartitions</span>(<span class="number">0</span>ms);</span><br><span class="line">        <span class="keyword">if</span> (dumpUmountDebugInfo) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((st != UMOUNT_STAT_SUCCESS) &amp;&amp; DUMP_ON_UMOUNT_FAILURE)</span><br><span class="line">                 <span class="built_in">DumpUmountDebuggingInfo</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们这里是reboot，不走fsck，<code>sync() before umount</code>这个log也是看不到的。很有可能就是卡在umount里了？</p><p>又复现一次：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[   92.971658] scm: secure world has been busy for 1 second!</span><br><span class="line">[   94.331640] scm_call failed: func id 0x7300fa01, ret: -12, syscall returns: 0x0, 0x0, 0x0</span><br><span class="line">[   97.454185] init: Terminating running services took 6023ms with remaining services:3</span><br><span class="line">[   97.454293] init: Sending signal 9 to service &#x27;gx_fpd&#x27; (pid 4944) process group...</span><br><span class="line">[   97.680210] libprocessgroup: Failed to kill process cgroup uid 1000 pid 4944 in 225ms, 1 processes remain</span><br><span class="line">[   97.680392] init: Sending signal 9 to service &#x27;trustonic-daemon&#x27; (pid 3315) process group...</span><br><span class="line">[   97.905801] libprocessgroup: Failed to kill process cgroup uid 1000 pid 3315 in 225ms, 1 processes remain</span><br><span class="line">[   97.905980] init: Sending signal 9 to service &#x27;vendor.per_mgr&#x27; (pid 561) process group...</span><br><span class="line">[   97.914897] libprocessgroup: Successfully killed process cgroup uid 1000 pid 561 in 8ms</span><br><span class="line">[   97.915339] init: Service &#x27;vendor.per_mgr&#x27; (pid 561) received signal 9</span><br><span class="line">[   97.951903] vdc: Waited 0ms for vold</span><br><span class="line">[   97.952039] binder: 483:487 transaction failed 29189/-22, size 88-0 line 3017</span><br><span class="line">[  101.601745] Trustonic TEE: wait_mcp_notification: No answer after 10s</span><br></pre></td></tr></table></figure><p>这里我们加大过timeout，仍然不起作用，有个gx_fpd杀不掉？ps看下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/ <span class="comment"># ps -A | grep fpd</span></span><br><span class="line">system        4944     1   19768   6844 __qseecom_process_incomplete_cmd 0 S gx_fpd</span><br><span class="line">fpd</span><br><span class="line">xxx:/ <span class="comment"># ps -A | grep trustonic-daemon</span></span><br><span class="line">xxx:/ <span class="comment"># ps -A | grep 3315</span></span><br><span class="line">system        3315     1       0      0 0                   0 Z [mcDriverDaemon]</span><br><span class="line">xxx:/ <span class="comment"># ps -A | grep Z</span></span><br><span class="line">USER           PID  PPID     VSZ    RSS WCHAN            ADDR S NAME</span><br><span class="line"></span><br><span class="line">system        3315     1       0      0 0                   0 Z [mcDriverDaemon]</span><br><span class="line"></span><br><span class="line">root          5094     1       0      0 0                   0 Z [vdc]</span><br></pre></td></tr></table></figure><p>Z？ 都僵尸了？后来发现指纹没接，接上去重启压测上千次暂未复现。</p><p>还有复现的log，这个是用apk做的reboot，log都有限:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;14&gt;[   86.307908] init: Received sys.powerctl=&#x27;reboot,&#x27; from pid: 1368 (system_server)</span><br><span class="line">&lt;14&gt;[   86.308048] init: Clear action queue and start shutdown trigger</span><br><span class="line">&lt;14&gt;[   86.308278] init: processing action (shutdown_done) from (&lt;Builtin Action&gt;:0)</span><br><span class="line">&lt;14&gt;[   86.308300] init: Reboot start, reason: reboot,, rebootTarget:</span><br></pre></td></tr></table></figure><p>对于无adb定屏的问题，发现google有一笔<a href="https://android-review.googlesource.com/c/platform/system/core/+/872492">patch</a>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reland &quot;init: Reboot after timeout passes during reboot&quot;</span><br><span class="line"></span><br><span class="line">We&#x27;re experiencing issues where unmount is forcing the device to be</span><br><span class="line">stuck permanently, so it&#x27;s better to have this shutdownt thread with a</span><br><span class="line">long timeout (30s) and a potential kernel panic if it fails than a</span><br><span class="line">stuck device.</span><br></pre></td></tr></table></figure><p>这里<code>a potential kernel panic</code>指的啥？抛了个reboot线程来执行，如果reboot线程卡住超时，init就复位了。</p><p>这笔改动目前状态是合入冲突，我拿过来合入，暂未复现。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Merge Conflict 872492: Reland &quot;init: Reboot after timeout passes during reboot&quot;</span><br></pre></td></tr></table></figure><p>Done.</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提交Linux内核补丁遇坑说明</title>
      <link href="/tips-about-submitting-linux-kernel-patch-under-windows.html"/>
      <url>/tips-about-submitting-linux-kernel-patch-under-windows.html</url>
      
        <content type="html"><![CDATA[<p>最近主要在Win7下提交pstore补丁，遇到的坑说明下：</p><h2 id="腾讯企业邮箱"><a href="#腾讯企业邮箱" class="headerlink" title="腾讯企业邮箱"></a>腾讯企业邮箱</h2><p>客户端发送ok的竟然在LKML邮件列表搜不到提交。</p><p>maintainer说miss message-id，看了下邮件源码，有message-id啊，如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Message-ID: &lt;201902062125366715715@xxx.com&gt;+A43ECD8F93303CB9</span><br></pre></td></tr></table></figure><p>看看其他提交，后面那个+感觉不对，再看Message-ID的标准定义：</p><blockquote><ol start="2"><li><p>Message-ID formatting<br>As defined in [NEWS], a message ID consists of two parts, a local part and a domain, separated by an at-sign and enclosed in angle brackets:</p><p>message-id &#x3D; “&lt;” local-part “@” domain “&gt;”</p></li></ol></blockquote><p>应该就是格式错误导致丢失了，具体参考:</p><ul><li><a href="https://www.jwz.org/doc/mid.html#NEWS">https://www.jwz.org/doc/mid.html#NEWS</a></li><li><a href="https://tools.ietf.org/html/rfc2392">https://tools.ietf.org/html/rfc2392</a></li></ul><p>用网页版正常，不过不能发patch了。</p><h2 id="阿里云邮箱"><a href="#阿里云邮箱" class="headerlink" title="阿里云邮箱"></a>阿里云邮箱</h2><p>alipapa提示不能发送到达LKML?</p><h2 id="Claws-mail-for-Windows"><a href="#Claws-mail-for-Windows" class="headerlink" title="Claws mail for Windows"></a>Claws mail for Windows</h2><p>Claws mail是内核推荐的GUI MUA，不过insert file会有encoding为:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Content-Transfer-Encoding: quoted-printable</span><br></pre></td></tr></table></figure><p>主要是patch第一行引起如下，用git send-mail就没这个问题。</p><figure class="highlight patch"><table><tr><td class="code"><pre><span class="line">From 08ac260f36b4c11eb33fa58466462a5e1027bdb3 Mon Sep 17 00:00:00 2001</span><br></pre></td></tr></table></figure><p>不知道会不会影响接收encoding，一般都是8bits or 7bits。</p><p>另外，如果新增account后不能show folder，要把用户下面的目录删了重来：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\tj\AppData\Roaming\Claws-mail</span><br></pre></td></tr></table></figure><p>maybe需要右击账号选择”Rebuild folder tree”。</p><p>further, 这个目录下有个clawsrc文件，主要是hidden configuration。</p><h2 id="Gmail客户端使用"><a href="#Gmail客户端使用" class="headerlink" title="Gmail客户端使用"></a>Gmail客户端使用</h2><p>一开始客户端总是连接不上，从log看是”Invalid credentials”，大多数人都遇到了，官方的troubleshoot也给了guide:</p><blockquote><p>Allow less secure apps: If you don’t use 2-Step Verification, you might need to <a href="https://support.google.com/accounts/answer/6010255">allow less secure apps to access your account</a>.</p></blockquote><h2 id="Windows上提交"><a href="#Windows上提交" class="headerlink" title="Windows上提交"></a>Windows上提交</h2><ul><li>gitconfig的email可以是公司的，最好和发送补丁的mail帐号一样.</li><li>用git for win send-mail发送patch, IMAP用gmail.com(要FQ网络) or其他(163.com?).</li><li>讨论patch用claws mail for win.</li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux patch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android P使能用户态LMK说明</title>
      <link href="/how-to-enable-userspace-lmk-under-android-p.html"/>
      <url>/how-to-enable-userspace-lmk-under-android-p.html</url>
      
        <content type="html"><![CDATA[<p>先看<a href="https://source.android.com/devices/tech/perf/lmkd">官方介绍</a>：</p><blockquote><h2 id="如何改用用户空间-lmkd"><a href="#如何改用用户空间-lmkd" class="headerlink" title="如何改用用户空间 lmkd"></a>如何改用用户空间 lmkd</h2><p>从 Android 9 开始，用户空间 lmkd 会在未检测到内核 lowmemorykiller 驱动程序时激活。请注意，用户空间 lmkd 要求内核支持内存 cgroup。因此，要改用用户空间 lmkd，您应使用以下配置设置编译内核：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;CONFIG_ANDROID_LOW_MEMORY_KILLER=n</span><br><span class="line">&gt;CONFIG_MEMCG=y</span><br><span class="line">&gt;CONFIG_MEMCG_SWAP=y</span><br></pre></td></tr></table></figure></blockquote><p>这里以高通平台为例说明，内核版本4.9，默认使能内核态，minfree调节真是呆板，直接使用AMS计算的，改用用户态，看样子内核态lmk逐渐不用了。</p><p>高通平台修改过lmkd，增加了一个属性：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">has_inkernel_module = !access(INKERNEL_MINFREE_PATH, W_OK);</span><br><span class="line">use_inkernel_interface = has_inkernel_module &amp;&amp; !enable_userspace_lmk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (use_inkernel_interface) &#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;Using in-kernel low memory killer interface&quot;</span>);</span><br><span class="line"></span><br><span class="line">enable_userspace_lmk =</span><br><span class="line">    property_get_bool(<span class="string">&quot;ro.lmk.enable_userspace_lmk&quot;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>所以高通平台下不用关心<code>CONFIG_ANDROID_LOW_MEMORY_KILLER</code>，只要添加属性<code>ro.lmk.enable_userspace_lmk</code>为true即可，策略一般选择杀死内存最大的，然后使能内核memcg:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">CONFIG_MEMCG=y</span><br><span class="line">CONFIG_MEMCG_SWAP=y</span><br></pre></td></tr></table></figure><p>但是，竟然起不来，从log看出来是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No kernel memory.pressure_level support</span><br></pre></td></tr></table></figure><p>代码在：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mpfd = open(MEMCG_SYSFS_PATH <span class="string">&quot;memory.pressure_level&quot;</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line"><span class="keyword">if</span> (mpfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;No kernel memory.pressure_level support (errno=%d)&quot;</span>, errno);</span><br><span class="line">    <span class="keyword">goto</span> err_open_mpfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看样子路径找不到，想想8.0的添加记得是在kernel cmdline里添加如下配置:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">androidboot.memcg=true</span><br></pre></td></tr></table></figure><p>ok，加入后果然成功了，有个属性：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ro.boot.memcg]: [<span class="literal">true</span>]</span><br></pre></td></tr></table></figure><p>这个属性的代码在system&#x2F;core&#x2F;init&#x2F;init.cpp：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set memcg property based on kernel cmdline argument</span></span><br><span class="line"><span class="type">bool</span> memcg_enabled = android::base::<span class="built_in">GetBoolProperty</span>(<span class="string">&quot;ro.boot.memcg&quot;</span>,<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (memcg_enabled) &#123;</span><br><span class="line">   <span class="comment">// root memory control cgroup</span></span><br><span class="line">   <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/memcg&quot;</span>, <span class="number">0700</span>);</span><br><span class="line">   <span class="built_in">chown</span>(<span class="string">&quot;/dev/memcg&quot;</span>,AID_ROOT,AID_SYSTEM);</span><br><span class="line">   <span class="built_in">mount</span>(<span class="string">&quot;none&quot;</span>, <span class="string">&quot;/dev/memcg&quot;</span>, <span class="string">&quot;cgroup&quot;</span>, <span class="number">0</span>, <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">   <span class="comment">// app mem cgroups, used by activity manager, lmkd and zygote</span></span><br><span class="line">   <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/memcg/apps/&quot;</span>,<span class="number">0755</span>);</span><br><span class="line">   <span class="built_in">chown</span>(<span class="string">&quot;/dev/memcg/apps/&quot;</span>,AID_SYSTEM,AID_SYSTEM);</span><br><span class="line">   <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/memcg/system&quot;</span>,<span class="number">0550</span>);</span><br><span class="line">   <span class="built_in">chown</span>(<span class="string">&quot;/dev/memcg/system&quot;</span>,AID_SYSTEM,AID_SYSTEM);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>找了半天没发现<code>ro.boot.memcg</code>怎么根据<code>androidboot.memcg</code>设置的，想了想应该是拼接的，如果给你实现你怎么做？具体设置是在：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">import_kernel_nv</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; value, <span class="type">bool</span> for_emulator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (for_emulator) &#123;</span><br><span class="line">        <span class="comment">// In the emulator, export any kernel option with the &quot;ro.kernel.&quot; prefix.</span></span><br><span class="line">        <span class="built_in">property_set</span>(<span class="string">&quot;ro.kernel.&quot;</span> + key, value);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="string">&quot;qemu&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">strlcpy</span>(qemu, value.<span class="built_in">c_str</span>(), <span class="built_in">sizeof</span>(qemu));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (android::base::<span class="built_in">StartsWith</span>(key, <span class="string">&quot;androidboot.&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">property_set</span>(<span class="string">&quot;ro.boot.&quot;</span> + key.<span class="built_in">substr</span>(<span class="number">12</span>), value); <span class="comment">//tj: here</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里设置了<code>ro.boot.memcg</code>为true，来自init main里会解析kernel cmdline:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If arguments are passed both on the command line and in DT,</span></span><br><span class="line"><span class="comment">// properties set in DT always have priority over the command-line ones.</span></span><br><span class="line"><span class="built_in">process_kernel_dt</span>();</span><br><span class="line"><span class="built_in">process_kernel_cmdline</span>();</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">process_kernel_cmdline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The first pass does the common stuff, and finds if we are in qemu.</span></span><br><span class="line">    <span class="comment">// The second pass is only necessary for qemu to export all kernel params</span></span><br><span class="line">    <span class="comment">// as properties.</span></span><br><span class="line">    <span class="built_in">import_kernel_cmdline</span>(<span class="literal">false</span>, import_kernel_nv);</span><br><span class="line">    <span class="keyword">if</span> (qemu[<span class="number">0</span>]) <span class="built_in">import_kernel_cmdline</span>(<span class="literal">true</span>, import_kernel_nv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Done.</p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lmkd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在Windows上提交Android补丁程序</title>
      <link href="/how-to-sumbit-patch-to-android.html"/>
      <url>/how-to-sumbit-patch-to-android.html</url>
      
        <content type="html"><![CDATA[<p>Google在提交Android补丁程序时有说明前提条件：</p><blockquote><h1 id="提交补丁程序"><a href="#提交补丁程序" class="headerlink" title="提交补丁程序"></a>提交补丁程序</h1><p>本页介绍向 AOSP 提交补丁程序的完整流程，包括使用 Gerrit 查看和跟踪更改。</p><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>   您需要先<a href="https://source.android.com/source/initializing.html">初始化编译环境</a>、<a href="https://source.android.com/source/downloading.html">下载源代码</a>、<a href="https://android.googlesource.com/new-password">创建密码</a>并按照密码生成器页面中的说明操作，然后再按照本页中的说明操作。</p></blockquote><p>编译环境要使用Linux或Mac OS，目前不支持在Windows下编译。下载源代码没有提及具体操作系统，只提了repo工具。进入创建密码页面竟然有脚本命令支持Windows user，说明Windows上可以提交patch？只是Google没有正面说而已。</p><p>现在有的在Win上办公，Linux服务器编译用无上网权限，有FQ网络。那么随之而来的需求就是能不能在Windows下提交补丁，不用虚拟Linux， 而且仅仅下载需要的project了？答案是肯定的，来看下具体流程。</p><h2 id="安装repo-for-Windows"><a href="#安装repo-for-Windows" class="headerlink" title="安装repo for Windows"></a>安装repo for Windows</h2><p>下载地址：<a href="https://github.com/esrlabs/git-repo">https://github.com/esrlabs/git-repo</a></p><h2 id="安装git-for-Windows"><a href="#安装git-for-Windows" class="headerlink" title="安装git for Windows"></a>安装git for Windows</h2><p>官方下载慢，taobao mirror下载较快：<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p><p>我装的版本:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git version</span><br><span class="line">git version 2.17.1.windows.2</span><br></pre></td></tr></table></figure><p>git版本过高后面repo init可能会报gpg错误。</p><h2 id="安装python-for-Windows"><a href="#安装python-for-Windows" class="headerlink" title="安装python for Windows"></a>安装python for Windows</h2><p>装python 2.7，全部装好后:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ repo version</span><br><span class="line">repo version v0.4.20</span><br><span class="line">       (from https://github.com/esrlabs/git-repo)</span><br><span class="line">repo launcher version 1.25</span><br><span class="line">       (from D:\prj\Tools\git-repo-stable\repo)</span><br><span class="line">git version 2.17.1.windows.2</span><br><span class="line">Python 2.7.13 (v2.7.13:a06454b1afa1, Dec 17 2016, 20:42:59) [MSC v.1500 32 bit (Intel)]</span><br></pre></td></tr></table></figure><p>找不到命令的记得加到windows环境变量中。</p><h2 id="下载projects"><a href="#下载projects" class="headerlink" title="下载projects"></a>下载projects</h2><p>打开git bash，创建空目录：如<code>D:\gitandroid</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tj@tj MINGW32 /d/gitandroid</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/d/gitandroid</span><br></pre></td></tr></table></figure><p>先repo init同官方，然后下载你改动所在project，比如vold, 打开.repo&#x2F;manifest.xml:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">path</span>=<span class="string">&quot;system/vold&quot;</span> <span class="attr">name</span>=<span class="string">&quot;platform/system/vold&quot;</span> <span class="attr">groups</span>=<span class="string">&quot;pdk&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo <span class="built_in">sync</span> platform/system/vold</span><br></pre></td></tr></table></figure><p>linux版repo sync可能不用带platform。你也可以加上<code>-j</code>。</p><p>另外需要下载tools&#x2F;repohooks：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">path</span>=<span class="string">&quot;tools/repohooks&quot;</span> <span class="attr">name</span>=<span class="string">&quot;platform/tools/repohooks&quot;</span> <span class="attr">groups</span>=<span class="string">&quot;adt-infra,cts,developers,motodev,pdk,tools,tradefed&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo <span class="built_in">sync</span> platform/tools/repohooks</span><br></pre></td></tr></table></figure><p>不然提交会报如下错误：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ERROR: Couldn&#x27;t find repo hook: &quot;D:\gitandroid\tools\repohooks\pre-upload.py&quot;</span><br></pre></td></tr></table></figure><h2 id="创建密码"><a href="#创建密码" class="headerlink" title="创建密码"></a>创建密码</h2><p>需要Google账号登录，这个密码验证会保存在.gitcookies文件里，Win上路径在环境变量USERPROFILE里，比如我的用户目录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\tj</span><br></pre></td></tr></table></figure><p>直接copy powershell脚本到cmd里执行生成的.gitcookies有换行问题，比较好的办法是把powershell脚本拷贝到bat文本里，执行这个bat就ok了。</p><h2 id="修改验证"><a href="#修改验证" class="headerlink" title="修改验证"></a>修改验证</h2><p>先新建一个repo分支：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo start vold --all</span><br></pre></td></tr></table></figure><p>check branch:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ repo branch</span><br><span class="line">*p vold                      | <span class="keyword">in</span> all projects</span><br></pre></td></tr></table></figure><p>分支建好后，和一般git使用一样：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add</span><br><span class="line">git commit -s [--amend]</span><br></pre></td></tr></table></figure><p>挪到linux，确保编译功能ok。</p><h2 id="提交补丁"><a href="#提交补丁" class="headerlink" title="提交补丁"></a>提交补丁</h2><ul><li>upload without verify</li></ul><p><code>repo upload</code>如果有verify错误需要加<code>--no-verify</code>。</p><ul><li>select agreements in gerrit</li></ul><p>提交前先选择协议种类，不然会报如下错：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tj@tj MINGW32 /d/gitandroid</span><br><span class="line">$ repo upload --no-verify</span><br><span class="line">Upload project system/vold/ to remote branch master:</span><br><span class="line">  branch vold ( 1 commit, Thu Jan 3 14:20:27 2019 +0800):</span><br><span class="line">         9d6cc18b cryptfs: Add error messages when remove dm-crypt device is failed</span><br><span class="line">to https://android-review.googlesource.com/ (y/N)? y</span><br><span class="line">fatal: remote error: No Contributor Agreement on file for user ...</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">[FAILED] system/vold/    vold            (Upload failed)</span><br></pre></td></tr></table></figure><p>gerrit上设置Agreements，Android CLA选不上，选了Google CLA填了个人信息等，填完了后浏览设置多了个Google CLA如下：</p><blockquote><p>Agreements</p><p>NameDescription<br>Google CLAGoogle Contributor License Agreement<br>New Contributor Agreement</p></blockquote><p>继续提交就ok了：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tj@tj MINGW32 /d/gitandroid</span><br><span class="line">$ repo upload --no-verify</span><br><span class="line">Upload project system/vold/ to remote branch master:</span><br><span class="line">  branch vold ( 1 commit, Thu Jan 3 14:20:27 2019 +0800):</span><br><span class="line">         9d6cc18b cryptfs: Add error messages when remove dm-crypt device is failed</span><br><span class="line">to https://android-review.googlesource.com/ (y/N)? y</span><br><span class="line">remote: Processing changes: refs: 1, new: 1, done</span><br><span class="line">remote:</span><br><span class="line">remote: SUCCESS</span><br><span class="line">remote:</span><br><span class="line">remote: New Changes:</span><br><span class="line">remote:   https://android-review.googlesource.com/c/platform/system/vold/+/860430 cryptfs: Add error messages when remove dm-crypt device is failed</span><br><span class="line">To https://android-review.googlesource.com/platform/system/vold</span><br><span class="line"> * [new branch]      vold -&gt; refs/for/master</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">[OK    ] system/vold/    vold</span><br></pre></td></tr></table></figure><p>这个时候到gerrit你的changes就能看到提交了，加人review吧。</p><p>1st submit, hapi…</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://source.android.com/setup/contribute/submit-patches">https://source.android.com/setup/contribute/submit-patches</a></li><li><a href="https://source.android.com/setup/build/downloading.html">https://source.android.com/setup/build/downloading.html</a></li><li><a href="https://source.android.com/setup/develop/repo.html">https://source.android.com/setup/develop/repo.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android patch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pstore ramoops读写分析</title>
      <link href="/analyze-linux-pstore-read-and-write.html"/>
      <url>/analyze-linux-pstore-read-and-write.html</url>
      
        <content type="html"><![CDATA[<p>pstore读写接口分别是<code>ramoops_pstore_read()</code>和<code>ramoops_pstore_write_buf()</code>，参考代码kernel4.9:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ramoops_context</span> <span class="title">oops_cxt</span> =</span> &#123;</span><br><span class="line">.pstore = &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.name= <span class="string">&quot;ramoops&quot;</span>,</span><br><span class="line">.open= ramoops_pstore_open,</span><br><span class="line">.read= ramoops_pstore_read,</span><br><span class="line">.write_buf= ramoops_pstore_write_buf,</span><br><span class="line">.write_buf_user= ramoops_pstore_write_buf_user, </span><br><span class="line">.erase= ramoops_pstore_erase,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们先看write，pstore是写了后才有读出。</p><p><code>ramoops_pstore_write_buf</code>会call <code>persistent_ram_write</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> notrace <span class="title function_">ramoops_pstore_write_buf</span><span class="params">(<span class="keyword">enum</span> pstore_type_id type,</span></span><br><span class="line"><span class="params">    <span class="keyword">enum</span> kmsg_dump_reason reason,</span></span><br><span class="line"><span class="params">    u64 *id, <span class="type">unsigned</span> <span class="type">int</span> part,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *buf,</span></span><br><span class="line"><span class="params">    <span class="type">bool</span> compressed, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> pstore_info *psi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ramoops_context</span> *<span class="title">cxt</span> =</span> psi-&gt;data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">persistent_ram_zone</span> *<span class="title">prz</span>;</span></span><br><span class="line"><span class="type">size_t</span> hlen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == PSTORE_TYPE_CONSOLE) &#123;</span><br><span class="line"><span class="keyword">if</span> (!cxt-&gt;cprz)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">persistent_ram_write(cxt-&gt;cprz, buf, size);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>backend ramoops write:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> notrace <span class="title function_">persistent_ram_write</span><span class="params">(<span class="keyword">struct</span> persistent_ram_zone *prz,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">void</span> *s, <span class="type">unsigned</span> <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> rem;</span><br><span class="line"><span class="type">int</span> c = count;</span><br><span class="line"><span class="type">size_t</span> start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(c &gt; prz-&gt;buffer_size)) &#123;</span><br><span class="line">s += c - prz-&gt;buffer_size;</span><br><span class="line">c = prz-&gt;buffer_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buffer_size_add(prz, c);</span><br><span class="line"></span><br><span class="line">start = buffer_start_add(prz, c);</span><br><span class="line"></span><br><span class="line">rem = prz-&gt;buffer_size - start;</span><br><span class="line"><span class="keyword">if</span> (unlikely(rem &lt; c)) &#123;</span><br><span class="line">persistent_ram_update(prz, s, start, rem);</span><br><span class="line">s += rem;</span><br><span class="line">c -= rem;</span><br><span class="line">start = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">persistent_ram_update(prz, s, start, c);</span><br><span class="line"></span><br><span class="line">persistent_ram_update_header_ecc(prz);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看样子是在确定buffer大小和地址后call <code>persistent_ram_update</code>来写buffer，我们先看下<code>buffer_size_add</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* increase the size counter until it hits the max size */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">buffer_size_add</span><span class="params">(<span class="keyword">struct</span> persistent_ram_zone *prz, <span class="type">size_t</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> old;</span><br><span class="line"><span class="type">size_t</span> new;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(prz-&gt;flags &amp; PRZ_FLAG_NO_LOCK))</span><br><span class="line">raw_spin_lock_irqsave(&amp;prz-&gt;buffer_lock, flags);</span><br><span class="line"></span><br><span class="line">old = <span class="type">atomic_read</span>(&amp;prz-&gt;buffer-&gt;size);</span><br><span class="line"><span class="keyword">if</span> (old == prz-&gt;buffer_size)</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">new = old + a;</span><br><span class="line"><span class="keyword">if</span> (new &gt; prz-&gt;buffer_size)</span><br><span class="line">new = prz-&gt;buffer_size;</span><br><span class="line"><span class="type">atomic_set</span>(&amp;prz-&gt;buffer-&gt;size, new); <span class="comment">//设置prz-&gt;buffer-&gt;size</span></span><br></pre></td></tr></table></figure><p>再看下<code>buffer_start_add</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* increase and wrap the start pointer, returning the old value */</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">buffer_start_add</span><span class="params">(<span class="keyword">struct</span> persistent_ram_zone *prz, <span class="type">size_t</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> old;</span><br><span class="line"><span class="type">int</span> new;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(prz-&gt;flags &amp; PRZ_FLAG_NO_LOCK))</span><br><span class="line">raw_spin_lock_irqsave(&amp;prz-&gt;buffer_lock, flags);</span><br><span class="line"></span><br><span class="line">old = <span class="type">atomic_read</span>(&amp;prz-&gt;buffer-&gt;start);</span><br><span class="line">new = old + a;</span><br><span class="line"><span class="keyword">while</span> (unlikely(new &gt;= prz-&gt;buffer_size))</span><br><span class="line">new -= prz-&gt;buffer_size;</span><br><span class="line"><span class="type">atomic_set</span>(&amp;prz-&gt;buffer-&gt;start, new); <span class="comment">//设置prz-&gt;buffer-&gt;start</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> old;</span><br></pre></td></tr></table></figure><p>这里就有几个疑问了:</p><ol><li><code>prz-&gt;buffer</code>的<code>-&gt;size</code>和<code>-&gt;start</code>初始值如何定义的？</li><li>What is <code>prz-&gt;buffer-&gt;start</code>, <code>prz-&gt;buffer-&gt;start</code>, <code>prz-&gt;buffer_size</code>？</li></ol><p>问题1：prz init时会call <code>persistent_ram_zap</code>初始化为0:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">persistent_ram_zap</span><span class="params">(<span class="keyword">struct</span> persistent_ram_zone *prz)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">atomic_set</span>(&amp;prz-&gt;buffer-&gt;start, <span class="number">0</span>);</span><br><span class="line"><span class="type">atomic_set</span>(&amp;prz-&gt;buffer-&gt;size, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>问题2：ram在分配时会设置<code>prz-&gt;buffer_size</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">persistent_ram_buffer_map</span><span class="params">(<span class="type">phys_addr_t</span> start, <span class="type">phys_addr_t</span> size,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> persistent_ram_zone *prz, <span class="type">int</span> memtype)</span></span><br><span class="line">&#123;</span><br><span class="line">prz-&gt;paddr = start;</span><br><span class="line">prz-&gt;size = size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pfn_valid(start &gt;&gt; PAGE_SHIFT))</span><br><span class="line">prz-&gt;vaddr = persistent_ram_vmap(start, size, memtype);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">prz-&gt;vaddr = persistent_ram_iomap(start, size, memtype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!prz-&gt;vaddr) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;%s: Failed to map 0x%llx pages at 0x%llx\n&quot;</span>, __func__,</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)size, (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)start);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prz-&gt;buffer = prz-&gt;vaddr + offset_in_page(start);</span><br><span class="line">prz-&gt;buffer_size = size - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> persistent_ram_buffer); <span class="comment">//tj: 这里设置</span></span><br></pre></td></tr></table></figure><p>这里<code>size</code>就是每个zone配置的大小:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err = ramoops_init_prz(dev, cxt, &amp;cxt-&gt;cprz, &amp;paddr,</span><br><span class="line">       cxt-&gt;console_size, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>-&gt;buffer</code>偏移了<code>start</code>，所以应该是zone的开头保留了一个<code>persistent_ram_buffer</code>大小：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">persistent_ram_buffer</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span>    sig;</span><br><span class="line"><span class="type">atomic_t</span>    start;</span><br><span class="line"><span class="type">atomic_t</span>    size;</span><br><span class="line"><span class="type">uint8_t</span>     data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个data[0]后面才是如console message等。回过头来再看<code>persistent_ram_write</code>就通了。</p><p>再来看read，read是在pstore文件系统准备好就开始：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ramoops_probe -&gt; pstore_register -&gt; pstore_get_records (if pstore is mounted) -&gt; (psi-&gt;read)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">ramoops_pstore_read</span><span class="params">(u64 *id, <span class="keyword">enum</span> pstore_type_id *type,</span></span><br><span class="line"><span class="params">   <span class="type">int</span> *count, <span class="keyword">struct</span> timespec *time,</span></span><br><span class="line"><span class="params">   <span class="type">char</span> **buf, <span class="type">bool</span> *compressed,</span></span><br><span class="line"><span class="params">   <span class="type">ssize_t</span> *ecc_notice_size,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> pstore_info *psi)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* Find the next valid persistent_ram_zone for DMESG */</span></span><br><span class="line"><span class="keyword">while</span> (cxt-&gt;dump_read_cnt &lt; cxt-&gt;max_dump_cnt &amp;&amp; !prz) &#123;</span><br><span class="line">prz = ramoops_get_next_prz(cxt-&gt;przs, &amp;cxt-&gt;dump_read_cnt,</span><br><span class="line">   cxt-&gt;max_dump_cnt, id, type,</span><br><span class="line">   PSTORE_TYPE_DMESG, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!prz_ok(prz))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">header_length = ramoops_read_kmsg_hdr(persistent_ram_old(prz),</span><br><span class="line">      time, compressed);</span><br><span class="line"><span class="comment">/* Clear and skip this DMESG record if it has no valid header */</span></span><br><span class="line"><span class="keyword">if</span> (!header_length) &#123;</span><br><span class="line">persistent_ram_free_old(prz);</span><br><span class="line">persistent_ram_zap(prz);</span><br><span class="line">prz = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!prz_ok(prz))</span><br><span class="line">prz = ramoops_get_next_prz(&amp;cxt-&gt;cprz, &amp;cxt-&gt;console_read_cnt,</span><br><span class="line">   <span class="number">1</span>, id, type, PSTORE_TYPE_CONSOLE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!prz_ok(prz))</span><br><span class="line">prz = ramoops_get_next_prz(&amp;cxt-&gt;fprz, &amp;cxt-&gt;ftrace_read_cnt,</span><br><span class="line">   <span class="number">1</span>, id, type, PSTORE_TYPE_FTRACE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!prz_ok(prz))</span><br><span class="line">prz = ramoops_get_next_prz(&amp;cxt-&gt;mprz, &amp;cxt-&gt;pmsg_read_cnt,</span><br><span class="line">   <span class="number">1</span>, id, type, PSTORE_TYPE_PMSG, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!prz_ok(prz))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//tj: 一个也没有找到</span></span><br></pre></td></tr></table></figure><p>扫描整个pstore ram区域，通过call <code>ramoops_get_next_prz</code>来找到一个有效的persist ram zone。</p><p>看下<code>ramoops_get_next_pr</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> persistent_ram_zone *</span><br><span class="line"><span class="title function_">ramoops_get_next_prz</span><span class="params">(<span class="keyword">struct</span> persistent_ram_zone *przs[], uint *c, uint max,</span></span><br><span class="line"><span class="params">     u64 *id,</span></span><br><span class="line"><span class="params">     <span class="keyword">enum</span> pstore_type_id *typep, <span class="keyword">enum</span> pstore_type_id type,</span></span><br><span class="line"><span class="params">     <span class="type">bool</span> update)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">persistent_ram_zone</span> *<span class="title">prz</span>;</span></span><br><span class="line"><span class="type">int</span> i = (*c)++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &gt;= max)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">prz = przs[i];</span><br><span class="line"><span class="keyword">if</span> (!prz)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Update old/shadowed buffer. */</span></span><br><span class="line"><span class="keyword">if</span> (update)</span><br><span class="line">persistent_ram_save_old(prz);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!persistent_ram_old_size(prz))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">*typep = type;</span><br><span class="line">*id = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> prz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>console没有update，看下<code>persistent_ram_old_size</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">persistent_ram_old_size</span><span class="params">(<span class="keyword">struct</span> persistent_ram_zone *prz)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> prz-&gt;old_log_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>old_log_size</code>要非0才能找到，在<code>persistent_ram_save_old</code>会保存：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">persistent_ram_save_old</span><span class="params">(<span class="keyword">struct</span> persistent_ram_zone *prz)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">persistent_ram_buffer</span> *<span class="title">buffer</span> =</span> prz-&gt;buffer;</span><br><span class="line"><span class="type">size_t</span> size = buffer_size(prz);</span><br><span class="line"><span class="type">size_t</span> start = buffer_start(prz);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!size)</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">//tj: 只有写过这里才会pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!prz-&gt;old_log) &#123;</span><br><span class="line">persistent_ram_ecc_old(prz);</span><br><span class="line">prz-&gt;old_log = kmalloc(size, GFP_KERNEL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!prz-&gt;old_log) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;failed to allocate buffer\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prz-&gt;old_log_size = size; <span class="comment">//tj: 这里保存</span></span><br><span class="line">memcpy_fromio(prz-&gt;old_log, &amp;buffer-&gt;data[start], size - start);</span><br><span class="line">memcpy_fromio(prz-&gt;old_log + size - start, &amp;buffer-&gt;data[<span class="number">0</span>], start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，这里<code>old_log_size</code>就是由<code>buffer_size</code>而来。console在下面保留的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">persistent_ram_post_init</span><span class="params">(<span class="keyword">struct</span> persistent_ram_zone *prz, u32 sig,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> persistent_ram_ecc_info *ecc_info)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = persistent_ram_init_ecc(prz, ecc_info);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">sig ^= PERSISTENT_RAM_SIG;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (prz-&gt;buffer-&gt;sig == sig) &#123;</span><br><span class="line"><span class="keyword">if</span> (buffer_size(prz) &gt; prz-&gt;buffer_size ||</span><br><span class="line">    buffer_start(prz) &gt; buffer_size(prz))</span><br><span class="line">pr_info(<span class="string">&quot;found existing invalid buffer, size %zu, start %zu\n&quot;</span>,</span><br><span class="line">buffer_size(prz), buffer_start(prz));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">pr_debug(<span class="string">&quot;found existing buffer, size %zu, start %zu\n&quot;</span>,</span><br><span class="line"> buffer_size(prz), buffer_start(prz));</span><br><span class="line">persistent_ram_save_old(prz); <span class="comment">//tj: 找到就保存</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>有些时候，我们需要在kernel起来查看bootloader log，这里提供linux修改部分(基于4.9)参考，我本地验证ok：</p>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ramoops </tag>
            
            <tag> pstore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android P下SD卡用作Phone Storage失败分析与解决</title>
      <link href="/fix-an-issue-abt-sdcard-for-phone-storage.html"/>
      <url>/fix-an-issue-abt-sdcard-for-phone-storage.html</url>
      
        <content type="html"><![CDATA[<p>我觉得Android SD卡就是个坑啊! 为啥这样说，因为Google自家的Pixel就没有SD卡槽。之前就有过使用sdcardfs(Google版)的SD卡删除文件后未释放的问题，查过小米一加手机都有这个问题，华为手机没有这个问题因为华为有自研sdcardfs，Google直到9.0框架层才修复。现在9.0对SD卡安装除了用作portable storage之外，又新增了作为Phone Storage用，因为9.0默认data区是强制加密的，这个phone storage就是和这个手机绑定了，相当于emmc变大了，说白了9.0的系统你可以买个出厂是32G的，然后你再买个128G+ SD，然后比性价:]但是这个功能Google今年11月才修复，高通平台当然也没更新。</p><p>ok，我们来看具体问题：就是点击phone storage后要format，format一段进度后进Setting看不到SD卡，format失败了？check logcat。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11-03 15:48:22.557   485   488 D vold    : Disk at 179:64 changed</span><br><span class="line">11-03 15:48:22.558   485   488 V vold    : /system/bin/sgdisk</span><br><span class="line">11-03 15:48:22.558   485   488 V vold    :     --android-dump</span><br><span class="line">11-03 15:48:22.558   485   488 V vold    :     /dev/block/vold/disk:179,64</span><br><span class="line">11-03 15:48:22.615   485   488 V vold    : DISK gpt B435862C-D079-4626-9E4D-73F40042A710</span><br><span class="line">11-03 15:48:22.615   485   488 V vold    :     </span><br><span class="line">11-03 15:48:22.615   485   488 V vold    : PART 1 19A710A2-B3CA-11E4-B026-10604B889DCF 4E9FA227-F812-4540-A451-80C2E6FD63B9 android_meta</span><br><span class="line">11-03 15:48:22.615   485   488 V vold    :     </span><br><span class="line">11-03 15:48:22.615   485   488 V vold    : PART 2 193D1EA4-B3CA-11E4-B075-10604B889DCF BA78EBA0-F6AA-47FE-85BD-506BC96A25E7 android_expand</span><br><span class="line">11-03 15:48:22.615   485   488 V vold    :     </span><br><span class="line">11-03 15:48:22.617   485   488 D vold    : Found key for GUID ba78eba0f6aa47fe85bd506bc96a25e7</span><br><span class="line">11-03 15:48:22.617   485   488 D vold    : Device just partitioned; silently formatting</span><br><span class="line">11-03 15:48:22.619   485   488 E Cryptfs : Cannot remove dm-crypt device</span><br><span class="line">11-03 15:48:22.628   485   488 I Cryptfs : Extra parameters for dm_crypt: </span><br><span class="line">11-03 15:48:22.629   485   488 I Cryptfs : target_type = crypt </span><br><span class="line">11-03 15:48:22.629   485   488 I Cryptfs : real_blk_name = /dev/block/vold/private:179,66, extra_params = </span><br><span class="line">11-03 15:48:22.637   485   488 D vold    : Resolved auto to f2fs</span><br><span class="line">11-03 15:48:22.637   485   488 V vold    : /system/bin/make_f2fs</span><br><span class="line">11-03 15:48:22.637   485   488 V vold    :     -f    </span><br><span class="line">11-03 15:48:22.637   485   488 V vold    :     -d1   </span><br><span class="line">11-03 15:48:22.637   485   488 V vold    :     -O    </span><br><span class="line">11-03 15:48:22.637   485   488 V vold    :     quota </span><br><span class="line">11-03 15:48:22.637   485   488 V vold    :     -O    </span><br><span class="line">11-03 15:48:22.637   485   488 V vold    :     verity</span><br><span class="line">11-03 15:48:22.638   485   488 V vold    :     /dev/block/dm-3</span><br><span class="line">11-03 15:48:22.644  2964  6447 I ActivityManager: Killing 6074:flipboard.boxer.app/u0a114 (adj 906): empty #17</span><br><span class="line">11-03 15:48:22.657   485   488 E vold    : private:179,66 failed to format: No such device or address //tj: here</span><br></pre></td></tr></table></figure><p>最后一行还真是format失败，ok，check code，能发现vold下PublicVolume.cpp和PrivateVolume.cpp都有，真正走的是PrivateVolume:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">PrivateVolume::doFormat</span><span class="params">(<span class="type">const</span> std::string&amp; fsType)</span> </span>&#123;</span><br><span class="line">    std::string resolvedFsType = fsType;</span><br><span class="line">    <span class="keyword">if</span> (fsType == <span class="string">&quot;auto&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// For now, assume that all MMC devices are flash-based SD cards, and</span></span><br><span class="line">        <span class="comment">// give everyone else ext4 because sysfs rotational isn&#x27;t reliable.</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">major</span>(mRawDevice) == kMajorBlockMmc) &amp;&amp; f2fs::<span class="built_in">IsSupported</span>()) &#123;</span><br><span class="line">            resolvedFsType = <span class="string">&quot;f2fs&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolvedFsType = <span class="string">&quot;ext4&quot;</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Resolved auto to &quot;</span> &lt;&lt; resolvedFsType;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolvedFsType == <span class="string">&quot;ext4&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> change reported mountpoint once we have better selinux support</span></span><br><span class="line">        <span class="keyword">if</span> (ext4::<span class="built_in">Format</span>(mDmDevPath, <span class="number">0</span>, <span class="string">&quot;/data&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; failed to format&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> -EIO;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resolvedFsType == <span class="string">&quot;f2fs&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f2fs::<span class="built_in">Format</span>(mDmDevPath)) &#123;</span><br><span class="line">            <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; failed to format&quot;</span>; <span class="comment">//tj: here</span></span><br><span class="line">            <span class="keyword">return</span> -EIO;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; unsupported filesystem &quot;</span> &lt;&lt; fsType;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>竟然会用f2fs。跟下来源：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Disk::createPrivateVolume</span><span class="params">(<span class="type">dev_t</span> device, <span class="type">const</span> std::string&amp; partGuid)</span> </span>&#123;</span><br><span class="line">    std::string normalizedGuid;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NormalizeHex</span>(partGuid, normalizedGuid)) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Invalid GUID &quot;</span> &lt;&lt; partGuid;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    std::string keyRaw;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ReadFileToString</span>(<span class="built_in">BuildKeyPath</span>(normalizedGuid), &amp;keyRaw)) &#123;</span><br><span class="line">        <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Failed to load key for GUID &quot;</span> &lt;&lt; normalizedGuid;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Found key for GUID &quot;</span> &lt;&lt; normalizedGuid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> vol = std::<span class="built_in">shared_ptr</span>&lt;VolumeBase&gt;(<span class="keyword">new</span> <span class="built_in">PrivateVolume</span>(device, keyRaw));</span><br><span class="line">    <span class="keyword">if</span> (mJustPartitioned) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Device just partitioned; silently formatting&quot;</span>;</span><br><span class="line">        vol-&gt;<span class="built_in">setSilent</span>(<span class="literal">true</span>);</span><br><span class="line">        vol-&gt;<span class="built_in">create</span>();</span><br><span class="line">        vol-&gt;format(<span class="string">&quot;auto&quot;</span>); <span class="comment">//tj: here</span></span><br><span class="line">        vol-&gt;<span class="built_in">destroy</span>();</span><br><span class="line">        vol-&gt;<span class="built_in">setSilent</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    mVolumes.<span class="built_in">push_back</span>(vol);</span><br><span class="line">    vol-&gt;<span class="built_in">setDiskId</span>(<span class="built_in">getId</span>());</span><br><span class="line">    vol-&gt;<span class="built_in">setPartGuid</span>(partGuid);</span><br><span class="line">    vol-&gt;<span class="built_in">create</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，再往上就是volume manager了，这篇不关心。这个问题format失败的原因是No such device，来看下<code>vol-&gt;create()</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">PrivateVolume::doCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CreateDeviceNode</span>(mRawDevPath, mRawDevice)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (mKeyRaw.<span class="built_in">size</span>() != <span class="built_in">cryptfs_get_keysize</span>()) &#123;</span><br><span class="line">      <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; Raw keysize &quot;</span> &lt;&lt; mKeyRaw.<span class="built_in">size</span>() &lt;&lt;</span><br><span class="line">          <span class="string">&quot; does not match crypt keysize &quot;</span> &lt;&lt; <span class="built_in">cryptfs_get_keysize</span>();</span><br><span class="line">      <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recover from stale vold by tearing down any old mappings</span></span><br><span class="line">    <span class="built_in">cryptfs_revert_ext_volume</span>(<span class="built_in">getId</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> figure out better SELinux labels for private volumes</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* key = (<span class="type">unsigned</span> <span class="type">char</span>*) mKeyRaw.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">char</span> crypto_blkdev[MAXPATHLEN];</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">cryptfs_setup_ext_volume</span>(<span class="built_in">getId</span>().<span class="built_in">c_str</span>(), mRawDevPath.<span class="built_in">c_str</span>(),</span><br><span class="line">            key, crypto_blkdev);</span><br><span class="line">    mDmDevPath = crypto_blkdev;</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; failed to setup cryptfs&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vold先删掉这个外部设备(private:179,66):</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called by vold when it&#x27;s asked to unmount an encrypted external</span></span><br><span class="line"><span class="comment"> * storage volume.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cryptfs_revert_ext_volume</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* label)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">delete_crypto_blk_dev</span>((<span class="type">char</span>*) label);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>delete_crypto_blk_dev</code>之前分析过，Google忘了加error log了，我们加上看到：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E Cryptfs : Cannot remove dm-crypt device private:179,66: No such device or address</span><br></pre></td></tr></table></figure><p>没这个设备，因为没有其他创建。</p><p><code>doCreate</code>没对<code>cryptfs_revert_ext_volume</code>成功与否处理，如果是busy是不是有异常了？继续看：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called by vold when it&#x27;s asked to mount an encrypted external</span></span><br><span class="line"><span class="comment"> * storage volume. The incoming partition has no crypto header/footer,</span></span><br><span class="line"><span class="comment"> * as any metadata is been stored in a separate, small partition.  We</span></span><br><span class="line"><span class="comment"> * assume it must be using our same crypt type and keysize.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * out_crypto_blkdev must be MAXPATHLEN.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cryptfs_setup_ext_volume</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* label, <span class="type">const</span> <span class="type">char</span>* real_blkdev,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* key, <span class="type">char</span>* out_crypto_blkdev)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">create_crypto_blk_dev</span>(&amp;ext_crypt_ftr, key, real_blkdev, out_crypto_blkdev, label, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">create_crypto_blk_dev</span><span class="params">(<span class="keyword">struct</span> crypt_mnt_ftr* crypt_ftr, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* master_key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> <span class="type">char</span>* real_blk_name, <span class="type">char</span>* crypto_blk_name, <span class="type">const</span> <span class="type">char</span>* name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">uint32_t</span> flags)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="built_in">ioctl_init</span>(io, DM_CRYPT_BUF_SIZE, name, <span class="number">0</span>);</span><br><span class="line">    err = <span class="built_in">ioctl</span>(fd, DM_DEV_CREATE, io);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">SLOGE</span>(<span class="string">&quot;Cannot create dm-crypt device %s: %s\n&quot;</span>, name, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the device status, in particular, the name of it&#x27;s device file */</span></span><br><span class="line">    <span class="built_in">ioctl_init</span>(io, DM_CRYPT_BUF_SIZE, name, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ioctl</span>(fd, DM_DEV_STATUS, io)) &#123;</span><br><span class="line">        <span class="built_in">SLOGE</span>(<span class="string">&quot;Cannot retrieve dm-crypt device status\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    minor = (io-&gt;dev &amp; <span class="number">0xff</span>) | ((io-&gt;dev &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xfff00</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(crypto_blk_name, MAXPATHLEN, <span class="string">&quot;/dev/block/dm-%u&quot;</span>, minor);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    load_count = <span class="built_in">load_crypto_mapping_table</span>(crypt_ftr, master_key, real_blk_name, name, fd,</span><br><span class="line">                                           extra_params);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Resume this device to activate it */</span></span><br><span class="line">    <span class="built_in">ioctl_init</span>(io, DM_CRYPT_BUF_SIZE, name, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ioctl</span>(fd, DM_DEV_SUSPEND, io)) &#123;</span><br><span class="line">        <span class="built_in">SLOGE</span>(<span class="string">&quot;Cannot resume the dm-crypt device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We made it here with no errors.  Woot! */</span></span><br><span class="line">    retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">  <span class="built_in">close</span>(fd);   <span class="comment">/* If fd is &lt;0 from a failed open call, it&#x27;s safe to just ignore the close error */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>奇怪，没有发现ioctl错误，为啥create完了没这个dm设备？难道又是delay问题？看下log:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11-03 15:48:22.629   485   488 I Cryptfs : real_blk_name = /dev/block/vold/private:179,66, extra_params = </span><br><span class="line">11-03 15:48:22.657   485   488 E vold    : private:179,66 failed to format: No such device or address //tj: here</span><br></pre></td></tr></table></figure><p>差了～20ms不够？有这个可能。和高通确认他们也不知道，翻了下googlesource，竟然有个<a href="https://android.googlesource.com/platform/system/vold/+/cfe3972f2d31ae0bfc33b0d9d84ea08d1cb55589">提交</a>和这个很像：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wait for dm device to be ready before format</span><br><span class="line"></span><br><span class="line">It can sometimes take a moment for the dm-device to appear after</span><br><span class="line">creation, causing operations on it such as formatting to fail.</span><br><span class="line">Ensure the device exists before create_crypto_blk_dev returns.</span><br><span class="line"></span><br><span class="line">Test: adb sm set-virtual-disk true and format as adoptable.</span><br><span class="line">Bug: 117586466</span><br><span class="line">Change-Id: Id8f571b551f50fc759e78d917e4ac3080e926722</span><br><span class="line">Merged-In: Id8f571b551f50fc759e78d917e4ac3080e926722</span><br></pre></td></tr></table></figure><p>ok，合入后还是看不到SD卡，不过format正常了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I make_f2fs: Info: format successful</span><br></pre></td></tr></table></figure><p>你说是不是坑。继续看log，发现有如下错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11-26 04:13:35.941   510  1686 E cutils  : Failed to chown(/mnt/expand/0f64cdaf-640b-4a01-9432-03a80985bcdf, 0, 0): I/O error</span><br><span class="line">11-26 04:13:35.926     0     0 E goodix_fp soc: fpsensor: Selected &#x27;fpsensor_reset_active&#x27;</span><br><span class="line">11-26 04:13:35.931     0     0 W gf      : gf_ioctl, exit</span><br><span class="line">11-26 04:13:35.948     0     0 E         : Quota error (device dm-1): qtree_read_dquot: Can&#x27;t read quota structure for id 0</span><br><span class="line">11-26 04:13:35.941   510  1686 E vold    : private:179,66 failed to create mount point /mnt/expand/0f64cdaf-640b-4a01-9432-03a80985bcdf: I/O error</span><br></pre></td></tr></table></figure><p>ok，看来是mount失败了，啥玩意？I&#x2F;O error？filesystem的问题？我们先看下vold chown相关code:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">PrivateVolume::doMount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">readMetadata</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; failed to read metadata&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    mPath = <span class="built_in">StringPrintf</span>(<span class="string">&quot;/mnt/expand/%s&quot;</span>, mFsUuid.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">setPath</span>(mPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">PrepareDir</span>(mPath, <span class="number">0700</span>, AID_ROOT, AID_ROOT)) &#123;</span><br><span class="line">        <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; failed to create mount point &quot;</span> &lt;&lt; mPath; <span class="comment">//tj: here</span></span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">PrepareDir</span><span class="params">(<span class="type">const</span> std::string&amp; path, <span class="type">mode_t</span> mode, <span class="type">uid_t</span> uid, <span class="type">gid_t</span> gid)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(kSecurityLock)</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* cpath = path.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* secontext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (sehandle) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">selabel_lookup</span>(sehandle, &amp;secontext, cpath, S_IFDIR)) &#123;</span><br><span class="line">            <span class="built_in">setfscreatecon</span>(secontext);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">fs_prepare_dir</span>(cpath, mode, uid, gid); <span class="comment">//tj: here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (secontext) &#123;</span><br><span class="line">        <span class="built_in">setfscreatecon</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">freecon</span>(secontext);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> OK; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fs_prepare_dir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">mode_t</span> mode, <span class="type">uid_t</span> uid, <span class="type">gid_t</span> gid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fs_prepare_path_impl</span>(path, mode, uid, gid, <span class="comment">/*allow_fixup*/</span> <span class="number">1</span>, <span class="comment">/*prepare_as_dir*/</span> <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fs_prepare_path_impl</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">mode_t</span> mode, <span class="type">uid_t</span> uid, <span class="type">gid_t</span> gid,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> allow_fixup, <span class="type">int</span> prepare_as_dir)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">fixup:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">chmod</span>(path, mode)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Failed to chmod(%s, %d): %s&quot;</span>, path, mode, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">chown</span>(path, uid, gid)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Failed to chown(%s, %d, %d): %s&quot;</span>, path, uid, gid, <span class="built_in">strerror</span>(errno)); <span class="comment">//tj: here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后chown进的是system&#x2F;core&#x2F;libcutils&#x2F;fs.cpp，一看就和文件系统有关，我手动敲了下chown没问题，但是chgrp有如下异常：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chgrp</span>: <span class="string">&#x27;media/&#x27;</span> to <span class="string">&#x27;(null):root&#x27;</span>: I/O error by cmd</span><br></pre></td></tr></table></figure><p>像是设备找不到，能看到vold private其实还支持ext4，那让我们用ext4吧，果然没这个问题，这里MSM内核4.9 f2fs待查。</p><p>btw: setting对64G+识别size有问题，64G-没问题，丢给app看了:]</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SD </tag>
            
            <tag> storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pstore ramoops overview</title>
      <link href="/analyze-pstore-ramoops-in-android-kernel.html"/>
      <url>/analyze-pstore-ramoops-in-android-kernel.html</url>
      
        <content type="html"><![CDATA[<p>pstore就是persistent store，是一种内存文件系统，提供了一种机制用来存储一些有用的信息，最初是给带non-volatile storage的设备使用，用来debug system crash，存储的是kernel panic&#x2F;oops日志，后面引入了ramoops作为backend，加入了存储kernel console log，Android平台又加入存储了user-space的pmsg。</p><p>ok，下面具体分析，参考代码是kernel 4.9：</p><p>先看下pstore内核配置：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-<span class="variable">$(CONFIG_PSTORE)</span> += pstore.o</span><br><span class="line"></span><br><span class="line">pstore-objs += inode.o platform.o</span><br><span class="line">pstore-<span class="variable">$(CONFIG_PSTORE_FTRACE)</span>  += ftrace.o</span><br><span class="line"></span><br><span class="line">pstore-<span class="variable">$(CONFIG_PSTORE_PMSG)</span>    += pmsg.o</span><br><span class="line"></span><br><span class="line">ramoops-objs += ram.o ram_core.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_PSTORE_RAM)</span>        += ramoops.o</span><br></pre></td></tr></table></figure><p><code>CONFIG_PSTORE</code>机制相关代码：inode.c + platform.c，看下配置说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config PSTORE</span><br><span class="line">        tristate &quot;Persistent store support&quot;</span><br><span class="line">        default n</span><br><span class="line">        help</span><br><span class="line">           This option enables generic access to platform level</span><br><span class="line">           persistent storage via &quot;pstore&quot; filesystem that can </span><br><span class="line">           be mounted as /dev/pstore.  Only useful if you have</span><br><span class="line">           a platform level driver that registers with pstore to</span><br><span class="line">           provide the data, so you probably should just go say &quot;Y&quot; </span><br><span class="line">           (or &quot;M&quot;) to a platform specific persistent store driver</span><br><span class="line">           (e.g. ACPI_APEI on X86) which will select this for you.</span><br><span class="line">           If you don&#x27;t have a platform persistent store driver,</span><br><span class="line">           say N.</span><br></pre></td></tr></table></figure><p>这里<code>Only useful</code>说的就是开启pstore必须要提供一个<code>persistent store driver</code>，比如<code>ACPI_APEI on X86</code>，这个就是最初的non-volatile storage driver，代码路径在：drivers&#x2F;acpi&#x2F;apei&#x2F;erst.c。</p><p>而现在取代的基本都是ramoops driver，也就是<code>CONFIG_PSTORE_RAM</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config PSTORE_RAM</span><br><span class="line">        tristate &quot;Log panic/oops to a RAM buffer&quot;</span><br><span class="line">        depends on PSTORE</span><br><span class="line">        depends on HAS_IOMEM</span><br><span class="line">        depends on HAVE_MEMBLOCK</span><br><span class="line">        select REED_SOLOMON</span><br><span class="line">        select REED_SOLOMON_ENC8</span><br><span class="line">        select REED_SOLOMON_DEC8</span><br><span class="line">        help</span><br><span class="line">          This enables panic and oops messages to be logged to a circular</span><br><span class="line">          buffer in RAM where it can be read back at some later point.</span><br><span class="line"></span><br><span class="line">          Note that for historical reasons, the module will be named</span><br><span class="line">          &quot;ramoops.ko&quot;.</span><br><span class="line"></span><br><span class="line">          For more information, see Documentation/ramoops.txt.</span><br></pre></td></tr></table></figure><p>相关代码：ram.c + ram_core.c。</p><p><code>CONFIG_PSTORE</code> + <code>CONFIG_PSTORE_RAM</code>是核心框代码，<code>CONFIG_PSTORE_CONSOLE</code>主要是不管是不是crash都保存all kernel message：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config PSTORE_PMSG</span><br><span class="line">        bool &quot;Log user space messages&quot;</span><br><span class="line">        depends on PSTORE</span><br><span class="line">        help</span><br><span class="line">          When the option is enabled, pstore will export a character</span><br><span class="line">          interface /dev/pmsg0 to log user space messages. On reboot</span><br><span class="line">          data can be retrieved from /sys/fs/pstore/pmsg-ramoops-[ID].</span><br><span class="line"></span><br><span class="line">          If unsure, say N.</span><br></pre></td></tr></table></figure><p>下面主要看下这3个宏相关代码。</p><p>pstore文件系统位置在：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/ <span class="comment"># ls /sys/fs/pstore</span></span><br><span class="line">console-ramoops-0 dmesg-ramoops-0</span><br></pre></td></tr></table></figure><p>console开头就是all kernel message，而dmesg开头的就是crash记录的了，代码在inode.c <code>pstore_mkfile</code>里：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Make a regular file in the root directory of our file system.</span></span><br><span class="line"><span class="comment"> * Load it up with &quot;size&quot; bytes of data from &quot;buf&quot;.</span></span><br><span class="line"><span class="comment"> * Set the mtime &amp; ctime to the date that this record was originally stored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pstore_mkfile</span><span class="params">(<span class="keyword">enum</span> pstore_type_id type, <span class="type">char</span> *psname, u64 id, <span class="type">int</span> count,</span></span><br><span class="line"><span class="params">  <span class="type">char</span> *data, <span class="type">bool</span> compressed, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> timespec time, <span class="keyword">struct</span> pstore_info *psi)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> PSTORE_TYPE_DMESG: <span class="comment">//tj: crash log</span></span><br><span class="line">scnprintf(name, <span class="keyword">sizeof</span>(name), <span class="string">&quot;dmesg-%s-%lld%s&quot;</span>,</span><br><span class="line">  psname, id, compressed ? <span class="string">&quot;.enc.z&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PSTORE_TYPE_CONSOLE: <span class="comment">//tj: all kernel messages</span></span><br><span class="line">scnprintf(name, <span class="keyword">sizeof</span>(name), <span class="string">&quot;console-%s-%lld&quot;</span>, psname, id);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>ramoops负责把message write到某个ram区域上，platform负责从ram读取存到&#x2F;sys&#x2F;fs&#x2F;pstore，ok，先来看机制代码platform.c：</p><p>backend需要用<code>pstore_register</code>来注册：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * platform specific persistent storage driver registers with</span></span><br><span class="line"><span class="comment"> * us here. If pstore is already mounted, call the platform</span></span><br><span class="line"><span class="comment"> * read function right away to populate the file system. If not</span></span><br><span class="line"><span class="comment"> * then the pstore mount code will call us later to fill out</span></span><br><span class="line"><span class="comment"> * the file system.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pstore_register</span><span class="params">(<span class="keyword">struct</span> pstore_info *psi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span> =</span> psi-&gt;owner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (backend &amp;&amp; <span class="built_in">strcmp</span>(backend, psi-&gt;name))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;pstore_lock);</span><br><span class="line"><span class="keyword">if</span> (psinfo) &#123;</span><br><span class="line">spin_unlock(&amp;pstore_lock);</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!psi-&gt;write)</span><br><span class="line">psi-&gt;write = pstore_write_compat;</span><br><span class="line"><span class="keyword">if</span> (!psi-&gt;write_buf_user)</span><br><span class="line">psi-&gt;write_buf_user = pstore_write_buf_user_compat;</span><br><span class="line">psinfo = psi;</span><br><span class="line">mutex_init(&amp;psinfo-&gt;read_mutex);</span><br><span class="line">spin_unlock(&amp;pstore_lock);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Update the module parameter backend, so it is visible</span></span><br><span class="line"><span class="comment"> * through /sys/module/pstore/parameters/backend</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">backend = psi-&gt;name;</span><br><span class="line"></span><br><span class="line">module_put(owner);</span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">&quot;Registered %s as persistent store backend\n&quot;</span>, psi-&gt;name);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pstore_lock just protects &quot;psinfo&quot; during</span></span><br><span class="line"><span class="comment"> * calls to pstore_register()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_SPINLOCK</span><span class="params">(pstore_lock)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pstore_info</span> *<span class="title">psinfo</span>;</span></span><br></pre></td></tr></table></figure><p><code>backend</code>判断确保一次只能有一个并记录了全局<code>psinfo</code>。</p><p>看下结构体<code>pstore_info</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pstore_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span>*<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">char</span>*name;</span><br><span class="line"><span class="type">spinlock_t</span>buf_lock;<span class="comment">/* serialize access to &#x27;buf&#x27; */</span></span><br><span class="line"><span class="type">char</span>*buf;</span><br><span class="line"><span class="type">size_t</span>bufsize;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span><span class="title">read_mutex</span>;</span><span class="comment">/* serialize open/read/close */</span></span><br><span class="line"><span class="type">int</span>flags;</span><br><span class="line"><span class="type">int</span>(*open)(<span class="keyword">struct</span> pstore_info *psi);</span><br><span class="line"><span class="type">int</span>(*close)(<span class="keyword">struct</span> pstore_info *psi);</span><br><span class="line"><span class="type">ssize_t</span>(*read)(u64 *id, <span class="keyword">enum</span> pstore_type_id *type,</span><br><span class="line"><span class="type">int</span> *count, <span class="keyword">struct</span> timespec *time, <span class="type">char</span> **buf,</span><br><span class="line"><span class="type">bool</span> *compressed, <span class="type">ssize_t</span> *ecc_notice_size,</span><br><span class="line"><span class="keyword">struct</span> pstore_info *psi);</span><br><span class="line"><span class="type">int</span>(*write)(<span class="keyword">enum</span> pstore_type_id type,</span><br><span class="line"><span class="keyword">enum</span> kmsg_dump_reason reason, u64 *id,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> part, <span class="type">int</span> count, <span class="type">bool</span> compressed,</span><br><span class="line"><span class="type">size_t</span> size, <span class="keyword">struct</span> pstore_info *psi);</span><br><span class="line"><span class="type">int</span>(*write_buf)(<span class="keyword">enum</span> pstore_type_id type,</span><br><span class="line"><span class="keyword">enum</span> kmsg_dump_reason reason, u64 *id,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> part, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">bool</span> compressed,</span><br><span class="line"><span class="type">size_t</span> size, <span class="keyword">struct</span> pstore_info *psi);</span><br><span class="line"><span class="type">int</span>(*write_buf_user)(<span class="keyword">enum</span> pstore_type_id type,</span><br><span class="line"><span class="keyword">enum</span> kmsg_dump_reason reason, u64 *id,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> part, <span class="type">const</span> <span class="type">char</span> __user *buf,</span><br><span class="line"><span class="type">bool</span> compressed, <span class="type">size_t</span> size, <span class="keyword">struct</span> pstore_info *psi);</span><br><span class="line"><span class="type">int</span>(*erase)(<span class="keyword">enum</span> pstore_type_id type, u64 id,</span><br><span class="line"><span class="type">int</span> count, <span class="keyword">struct</span> timespec time,</span><br><span class="line"><span class="keyword">struct</span> pstore_info *psi);</span><br><span class="line"><span class="type">void</span>*data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>name</code>就是backend的name了。</p><p><code>*write</code>和<code>*write_buf_user</code>如果backend没有给出会有个默认compat func，最终都走的<code>*write_buf</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!psi-&gt;write)</span><br><span class="line">psi-&gt;write = pstore_write_compat;</span><br><span class="line"><span class="keyword">if</span> (!psi-&gt;write_buf_user)</span><br><span class="line">psi-&gt;write_buf_user = pstore_write_buf_user_compat;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pstore_write_compat</span><span class="params">(<span class="keyword">enum</span> pstore_type_id type,</span></span><br><span class="line"><span class="params">       <span class="keyword">enum</span> kmsg_dump_reason reason,</span></span><br><span class="line"><span class="params">       u64 *id, <span class="type">unsigned</span> <span class="type">int</span> part, <span class="type">int</span> count,</span></span><br><span class="line"><span class="params">       <span class="type">bool</span> compressed, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">       <span class="keyword">struct</span> pstore_info *psi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> psi-&gt;write_buf(type, reason, id, part, psinfo-&gt;buf, compressed,</span><br><span class="line">     size, psi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pstore_write_buf_user_compat</span><span class="params">(<span class="keyword">enum</span> pstore_type_id type,</span></span><br><span class="line"><span class="params">       <span class="keyword">enum</span> kmsg_dump_reason reason,</span></span><br><span class="line"><span class="params">       u64 *id, <span class="type">unsigned</span> <span class="type">int</span> part,</span></span><br><span class="line"><span class="params">       <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">       <span class="type">bool</span> compressed, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">       <span class="keyword">struct</span> pstore_info *psi)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">ret = psi-&gt;write_buf(type, reason, id, part, psinfo-&gt;buf,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续pstore注册：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pstore_is_mounted())</span><br><span class="line">pstore_get_records(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果pstore已经mounted，那就创建并填充文件by <code>pstore_get_records</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read all the records from the persistent store. Create</span></span><br><span class="line"><span class="comment"> * files in our filesystem.  Don&#x27;t warn about -EEXIST errors</span></span><br><span class="line"><span class="comment"> * when we are re-scanning the backing store looking to add new</span></span><br><span class="line"><span class="comment"> * error records.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pstore_get_records</span><span class="params">(<span class="type">int</span> quiet)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pstore_info</span> *<span class="title">psi</span> =</span> psinfo; <span class="comment">//tj: global psinfo</span></span><br><span class="line">...</span><br><span class="line">mutex_lock(&amp;psi-&gt;read_mutex);</span><br><span class="line"><span class="keyword">if</span> (psi-&gt;open &amp;&amp; psi-&gt;open(psi))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((size = psi-&gt;read(&amp;id, &amp;type, &amp;count, &amp;time, &amp;buf, &amp;compressed,</span><br><span class="line"> &amp;ecc_notice_size, psi)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (compressed &amp;&amp; (type == PSTORE_TYPE_DMESG)) &#123;</span><br><span class="line"><span class="keyword">if</span> (big_oops_buf)</span><br><span class="line">unzipped_len = pstore_decompress(buf,</span><br><span class="line">big_oops_buf, size,</span><br><span class="line">big_oops_buf_sz);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unzipped_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ecc_notice_size)</span><br><span class="line"><span class="built_in">memcpy</span>(big_oops_buf + unzipped_len,</span><br><span class="line">       buf + size, ecc_notice_size);</span><br><span class="line">kfree(buf);</span><br><span class="line">buf = big_oops_buf;</span><br><span class="line">size = unzipped_len;</span><br><span class="line">compressed = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pr_err(<span class="string">&quot;decompression failed;returned %d\n&quot;</span>,</span><br><span class="line">       unzipped_len);</span><br><span class="line">compressed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">rc = pstore_mkfile(type, psi-&gt;name, id, count, buf,</span><br><span class="line">   compressed, size + ecc_notice_size,</span><br><span class="line">   time, psi);</span><br><span class="line"><span class="keyword">if</span> (unzipped_len &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* Free buffer other than big oops */</span></span><br><span class="line">kfree(buf);</span><br><span class="line">buf = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">unzipped_len = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (rc &amp;&amp; (rc != -EEXIST || !quiet))</span><br><span class="line">failed++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (psi-&gt;close)</span><br><span class="line">psi-&gt;close(psi);</span><br><span class="line">out:</span><br><span class="line">mutex_unlock(&amp;psi-&gt;read_mutex);</span><br></pre></td></tr></table></figure><p>if needed，call <code>pstore_decompress</code>解压然后创建pstore文件by vfs接口<code>pstore_mkfile</code>。</p><p>pstore注册接下来是按类别分别注册：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (psi-&gt;flags &amp; PSTORE_FLAGS_DMESG)</span><br><span class="line">pstore_register_kmsg();</span><br><span class="line"><span class="keyword">if</span> (psi-&gt;flags &amp; PSTORE_FLAGS_CONSOLE)</span><br><span class="line">pstore_register_console();</span><br><span class="line"><span class="keyword">if</span> (psi-&gt;flags &amp; PSTORE_FLAGS_FTRACE)</span><br><span class="line">pstore_register_ftrace();</span><br><span class="line"><span class="keyword">if</span> (psi-&gt;flags &amp; PSTORE_FLAGS_PMSG)</span><br><span class="line">pstore_register_pmsg();</span><br></pre></td></tr></table></figure><p><code>psi-&gt;flags</code>仍是由backend决定，只看<code>pstore_register_kmsg</code>和<code>pstore_register_console</code>。</p><p>pstore panic log注册：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmsg_dumper</span> <span class="title">pstore_dumper</span> =</span> &#123;</span><br><span class="line">.dump = pstore_dump,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Register with kmsg_dump to save last part of console log on panic.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pstore_register_kmsg</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">kmsg_dump_register(&amp;pstore_dumper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pstore_dump</code>最终会call backend的write，直接用全局psinfo。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * callback from kmsg_dump. (s2,l2) has the most recently</span></span><br><span class="line"><span class="comment"> * written bytes, older bytes are in (s1,l1). Save as much</span></span><br><span class="line"><span class="comment"> * as we can from the end of the buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pstore_dump</span><span class="params">(<span class="keyword">struct</span> kmsg_dumper *dumper,</span></span><br><span class="line"><span class="params"><span class="keyword">enum</span> kmsg_dump_reason reason)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">ret = psinfo-&gt;write(PSTORE_TYPE_DMESG, reason, &amp;id, part,</span><br><span class="line">    oopscount, compressed, total_len, psinfo);</span><br></pre></td></tr></table></figure><p><code>kmsg_dump_register</code>是内核一种增加log dumper方法，called when kernel oopses or panic。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(dump_list)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmsg_dump_register - register a kernel log dumper.</span></span><br><span class="line"><span class="comment"> * @dumper: pointer to the kmsg_dumper structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Adds a kernel log dumper to the system. The dump callback in the</span></span><br><span class="line"><span class="comment"> * structure will be called when the kernel oopses or panics and must be</span></span><br><span class="line"><span class="comment"> * set. Returns zero on success and %-EINVAL or %-EBUSY otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kmsg_dump_register</span><span class="params">(<span class="keyword">struct</span> kmsg_dumper *dumper)</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmsg_dump - dump kernel log to kernel message dumpers.</span></span><br><span class="line"><span class="comment"> * @reason: the reason (oops, panic etc) for dumping</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Call each of the registered dumper&#x27;s dump() callback, which can</span></span><br><span class="line"><span class="comment"> * retrieve the kmsg records with kmsg_dump_get_line() or</span></span><br><span class="line"><span class="comment"> * kmsg_dump_get_buffer().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kmsg_dump</span><span class="params">(<span class="keyword">enum</span> kmsg_dump_reason reason)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_for_each_entry_rcu(dumper, &amp;dump_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">...</span><br><span class="line">                <span class="comment">/* invoke dumper which will iterate over records */</span></span><br><span class="line">                dumper-&gt;dump(dumper, reason);  <span class="comment">//tj: call pstore_dump</span></span><br></pre></td></tr></table></figure><p>such as panic:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *      panic - halt the system</span></span><br><span class="line"><span class="comment"> *      @fmt: The text string to print</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Display a message, then perform cleanups.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      This function never returns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">/* Call flush even twice. It tries harder with a single online CPU */</span></span><br><span class="line">        printk_nmi_flush_on_panic();</span><br><span class="line">        kmsg_dump(KMSG_DUMP_PANIC);</span><br></pre></td></tr></table></figure><p>pstore console 注册：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">console</span> <span class="title">pstore_console</span> =</span> &#123;</span><br><span class="line">.name= <span class="string">&quot;pstore&quot;</span>,</span><br><span class="line">.write= pstore_console_write,</span><br><span class="line">.flags= CON_PRINTBUFFER | CON_ENABLED | CON_ANYTIME,</span><br><span class="line">.index= <span class="number">-1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pstore_register_console</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">register_console(&amp;pstore_console);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-&gt;write</code>最终也会call backend write:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PSTORE_CONSOLE</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pstore_console_write</span><span class="params">(<span class="keyword">struct</span> console *con, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">unsigned</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *e = s + c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (s &lt; e) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">u64 id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c &gt; psinfo-&gt;bufsize)</span><br><span class="line">c = psinfo-&gt;bufsize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oops_in_progress) &#123;</span><br><span class="line"><span class="keyword">if</span> (!spin_trylock_irqsave(&amp;psinfo-&gt;buf_lock, flags))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">spin_lock_irqsave(&amp;psinfo-&gt;buf_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(psinfo-&gt;buf, s, c);</span><br><span class="line">psinfo-&gt;write(PSTORE_TYPE_CONSOLE, <span class="number">0</span>, &amp;id, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, c, psinfo);  <span class="comment">// tj: here</span></span><br><span class="line">spin_unlock_irqrestore(&amp;psinfo-&gt;buf_lock, flags);</span><br><span class="line">s += c;</span><br><span class="line">c = e - s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok。下面来看下RAM backend: ramoops，先看probe:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ramoops_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;pdev-&gt;dev;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ramoops_platform_data</span> *<span class="title">pdata</span> =</span> dev-&gt;platform_data;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pdata-&gt;mem_size || (!pdata-&gt;record_size &amp;&amp; !pdata-&gt;console_size &amp;&amp;</span><br><span class="line">!pdata-&gt;ftrace_size &amp;&amp; !pdata-&gt;pmsg_size)) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;The memory size and the record/console size must be &quot;</span></span><br><span class="line"><span class="string">&quot;non-zero\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> fail_out;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">cxt-&gt;size = pdata-&gt;mem_size;</span><br><span class="line">cxt-&gt;phys_addr = pdata-&gt;mem_address;</span><br><span class="line">cxt-&gt;memtype = pdata-&gt;mem_type;</span><br><span class="line">cxt-&gt;record_size = pdata-&gt;record_size;</span><br><span class="line">cxt-&gt;console_size = pdata-&gt;console_size;</span><br><span class="line">cxt-&gt;ftrace_size = pdata-&gt;ftrace_size;</span><br><span class="line">cxt-&gt;pmsg_size = pdata-&gt;pmsg_size;</span><br><span class="line">cxt-&gt;dump_oops = pdata-&gt;dump_oops;</span><br><span class="line">cxt-&gt;ecc_info = pdata-&gt;ecc_info;</span><br></pre></td></tr></table></figure><p><code>pdata</code>应该来源<code>ramoops_register_dummy</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ramoops_register_dummy</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">pr_info(<span class="string">&quot;using module parameters\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">dummy_data = kzalloc(<span class="keyword">sizeof</span>(*dummy_data), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!dummy_data) &#123;</span><br><span class="line">pr_info(<span class="string">&quot;could not allocate pdata\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dummy_data-&gt;mem_size = mem_size;</span><br><span class="line">dummy_data-&gt;mem_address = mem_address;</span><br><span class="line">dummy_data-&gt;mem_type = mem_type;</span><br><span class="line">dummy_data-&gt;record_size = record_size;</span><br><span class="line">dummy_data-&gt;console_size = ramoops_console_size;</span><br><span class="line">dummy_data-&gt;ftrace_size = ramoops_ftrace_size;</span><br><span class="line">dummy_data-&gt;pmsg_size = ramoops_pmsg_size;</span><br><span class="line">dummy_data-&gt;dump_oops = dump_oops;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For backwards compatibility ramoops.ecc=1 means 16 bytes ECC</span></span><br><span class="line"><span class="comment"> * (using 1 byte for ECC isn&#x27;t much of use anyway).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dummy_data-&gt;ecc_info.ecc_size = ramoops_ecc == <span class="number">1</span> ? <span class="number">16</span> : ramoops_ecc;</span><br><span class="line"></span><br><span class="line">dummy = platform_device_register_data(<span class="literal">NULL</span>, <span class="string">&quot;ramoops&quot;</span>, <span class="number">-1</span>,</span><br><span class="line">dummy_data, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ramoops_platform_data));</span><br></pre></td></tr></table></figure><p>有几个可配参数:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ramoops platform data</span></span><br><span class="line"><span class="comment"> * @mem_sizememory size for ramoops</span></span><br><span class="line"><span class="comment"> * @mem_addressphysical memory address to contain ramoops</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ramoops_platform_data</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>mem_size;  </span><br><span class="line"><span class="type">phys_addr_t</span>mem_address; </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>mem_type;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>record_size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>console_size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>ftrace_size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>pmsg_size;</span><br><span class="line"><span class="type">int</span>dump_oops;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">persistent_ram_ecc_info</span> <span class="title">ecc_info</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有个结构表示了ramoops的context:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ramoops_context</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">persistent_ram_zone</span> **<span class="title">przs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">persistent_ram_zone</span> *<span class="title">cprz</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">persistent_ram_zone</span> *<span class="title">fprz</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">persistent_ram_zone</span> *<span class="title">mprz</span>;</span></span><br><span class="line"><span class="type">phys_addr_t</span> phys_addr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> memtype;</span><br><span class="line"><span class="type">size_t</span> record_size;</span><br><span class="line"><span class="type">size_t</span> console_size;</span><br><span class="line"><span class="type">size_t</span> ftrace_size;</span><br><span class="line"><span class="type">size_t</span> pmsg_size;</span><br><span class="line"><span class="type">int</span> dump_oops;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">persistent_ram_ecc_info</span> <span class="title">ecc_info</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_dump_cnt;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dump_write_cnt;</span><br><span class="line"><span class="comment">/* _read_cnt need clear on ramoops_pstore_open */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dump_read_cnt;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> console_read_cnt;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ftrace_read_cnt;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> pmsg_read_cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pstore_info</span> <span class="title">pstore</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>ramoops_probe</code>时也是把ramoops_platform_data的成员赋给了context对应的。要了解具体含义，继续probe:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">paddr = cxt-&gt;phys_addr;</span><br><span class="line"></span><br><span class="line">dump_mem_sz = cxt-&gt;size - cxt-&gt;console_size - cxt-&gt;ftrace_size</span><br><span class="line">- cxt-&gt;pmsg_size;</span><br><span class="line">err = ramoops_init_przs(dev, cxt, &amp;paddr, dump_mem_sz);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> fail_out;</span><br><span class="line"></span><br><span class="line">err = ramoops_init_prz(dev, cxt, &amp;cxt-&gt;cprz, &amp;paddr,</span><br><span class="line">       cxt-&gt;console_size, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> fail_init_cprz;</span><br><span class="line"></span><br><span class="line">err = ramoops_init_prz(dev, cxt, &amp;cxt-&gt;fprz, &amp;paddr, cxt-&gt;ftrace_size,</span><br><span class="line">       LINUX_VERSION_CODE);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> fail_init_fprz;</span><br><span class="line"></span><br><span class="line">err = ramoops_init_prz(dev, cxt, &amp;cxt-&gt;mprz, &amp;paddr, cxt-&gt;pmsg_size, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> fail_init_mprz;</span><br><span class="line"></span><br><span class="line">cxt-&gt;pstore.data = cxt;</span><br></pre></td></tr></table></figure><p>可见，是逐个init每个persistant ram zone，size一共有4段：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dump_mem_sz + cxt-&gt;console_size + cxt-&gt;ftrace_size + cxt-&gt;pmsg_size = cxt-&gt;size</span><br></pre></td></tr></table></figure><p>so <code>mem_size</code>就是总大小了，<code>mem_address</code>是ramoops的物理地址，<code>record_size</code>再看下oops&#x2F;panic ram：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ramoops_init_przs</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> ramoops_context *cxt,</span></span><br><span class="line"><span class="params">     <span class="type">phys_addr_t</span> *paddr, <span class="type">size_t</span> dump_mem_sz)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err = -ENOMEM;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!cxt-&gt;record_size)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*paddr + dump_mem_sz - cxt-&gt;phys_addr &gt; cxt-&gt;size) &#123;</span><br><span class="line">dev_err(dev, <span class="string">&quot;no room for dumps\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cxt-&gt;max_dump_cnt = dump_mem_sz / cxt-&gt;record_size;</span><br><span class="line"><span class="keyword">if</span> (!cxt-&gt;max_dump_cnt)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br></pre></td></tr></table></figure><p>ok <code>dump_mem_size</code>大小的区域分成<code>max_dump_cnt</code>个，每个记录大小是<code>record_size</code>。</p><p>接着会call <code>persistent_ram_new</code>来分配内存给这个ram zone。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cxt-&gt;max_dump_cnt; i++) &#123;</span><br><span class="line">cxt-&gt;przs[i] = persistent_ram_new(*paddr, cxt-&gt;record_size, <span class="number">0</span>,</span><br><span class="line">  &amp;cxt-&gt;ecc_info,</span><br><span class="line">  cxt-&gt;memtype, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>console&#x2F;ftrace&#x2F;pmsg ram zone同上分配。</p><p>最后处理flags并注册pstore:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cxt-&gt;pstore.flags = PSTORE_FLAGS_DMESG; <span class="comment">//tj: 默认dump oops/panic</span></span><br><span class="line"><span class="keyword">if</span> (cxt-&gt;console_size)</span><br><span class="line">cxt-&gt;pstore.flags |= PSTORE_FLAGS_CONSOLE;</span><br><span class="line"><span class="keyword">if</span> (cxt-&gt;ftrace_size)</span><br><span class="line">cxt-&gt;pstore.flags |= PSTORE_FLAGS_FTRACE;</span><br><span class="line"><span class="keyword">if</span> (cxt-&gt;pmsg_size)</span><br><span class="line">cxt-&gt;pstore.flags |= PSTORE_FLAGS_PMSG;</span><br><span class="line"></span><br><span class="line">err = pstore_register(&amp;cxt-&gt;pstore);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;registering with pstore failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> fail_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看下ramoops pstore的定义的callback，他们通过全局<code>psinfo</code>而来：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ramoops_context</span> <span class="title">oops_cxt</span> =</span> &#123;</span><br><span class="line">.pstore = &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.name= <span class="string">&quot;ramoops&quot;</span>,</span><br><span class="line">.open= ramoops_pstore_open,</span><br><span class="line">.read= ramoops_pstore_read, <span class="comment">//tj: psi-&gt;read</span></span><br><span class="line">.write_buf= ramoops_pstore_write_buf, <span class="comment">//tj: for non pmsg</span></span><br><span class="line">.write_buf_user= ramoops_pstore_write_buf_user, <span class="comment">//tj: for pmsg</span></span><br><span class="line">.erase= ramoops_pstore_erase,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pstore RAM backend是通过persistent ram(ram_core.c)来处理，这个persist ram来源Android, mark to check later.</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">commit cddb8751c80348df75149f44fc3bf38d3dd1f3e6</span><br><span class="line">Author: Anton Vorontsov &lt;anton.vorontsov@linaro.org&gt;</span><br><span class="line">Date:   Thu May 17 00:15:08 2012 -0700</span><br><span class="line"></span><br><span class="line">    staging: android: persistent_ram: Move to fs/pstore/ram_core.c</span><br><span class="line">    </span><br><span class="line">    This is a first step for adding ECC support for pstore RAM backend: we</span><br><span class="line">    will use the persistent_ram routines, kindly provided by Google.</span><br><span class="line">    </span><br><span class="line">    Basically, persistent_ram is a set of helper routines to deal with the</span><br><span class="line">    [optionally] ECC-protected persistent ram regions.</span><br><span class="line">    </span><br><span class="line">    A bit of Makefile, Kconfig and header files adjustments were needed</span><br><span class="line">    because of the move.</span><br><span class="line">    </span><br><span class="line">    Signed-off-by: Anton Vorontsov &lt;anton.vorontsov@linaro.org&gt;</span><br><span class="line">    Acked-by: Kees Cook &lt;keescook@chromium.org&gt;</span><br><span class="line">    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ramoops </tag>
            
            <tag> pstore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android平台OEM解锁分析</title>
      <link href="/analyze-oem-unlocking-under-android.html"/>
      <url>/analyze-oem-unlocking-under-android.html</url>
      
        <content type="html"><![CDATA[<p>一般安卓fastboot刷机需要unlock device，也叫unlock bootloader，我想多半和lock&#x2F;unlock在bootloader中实现有关，ok，下面就来看下相关代码，参考高通平台P LK。</p><p><code>device_info</code>中记录了是否解锁，有两个：<code>is_unlocked</code>, <code>is_unlock_critical</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> device_info device = &#123;DEVICE_MAGIC,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,&#123;<span class="number">0</span>&#125;,&#123;<span class="number">0</span>&#125;,&#123;<span class="number">0</span>&#125;,<span class="number">1</span>,&#123;<span class="number">0</span>&#125;,<span class="number">0</span>,&#123;<span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> magic[DEVICE_MAGIC_SIZE];</span><br><span class="line"><span class="type">bool</span> is_unlocked; <span class="comment">//tj: here</span></span><br><span class="line"><span class="type">bool</span> is_tampered;</span><br><span class="line"><span class="type">bool</span> is_unlock_critical; <span class="comment">//tj: here</span></span><br><span class="line"><span class="type">bool</span> charger_screen_enabled;</span><br><span class="line"><span class="type">char</span> display_panel[MAX_PANEL_ID_LEN];</span><br><span class="line"><span class="type">char</span> bootloader_version[MAX_VERSION_LEN];</span><br><span class="line"><span class="type">char</span> radio_version[MAX_VERSION_LEN];</span><br><span class="line"><span class="type">bool</span> verity_mode; <span class="comment">// 1 = enforcing, 0 = logging</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">unlock_type</span> &#123;</span></span><br><span class="line">UNLOCK = <span class="number">0</span>,</span><br><span class="line">UNLOCK_CRITICAL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>刷机代码有提到区别：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(BOARD_AVB_ENABLE)</span>,true)</span><br><span class="line">  VERIFIED_BOOT_2 := VERIFIED_BOOT_2=1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  VERIFIED_BOOT_2 := VERIFIED_BOOT_2=0</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p><code>BOARD_AVB_ENABLE</code>就是Android Verified Boot, 官方介绍: <a href="https://source.android.google.cn/security/verifiedboot/avb">https://source.android.google.cn/security/verifiedboot/avb</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cmd_flash_mmc</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">void</span> *data, <span class="type">unsigned</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VERIFIED_BOOT || VERIFIED_BOOT_2</span></span><br><span class="line"><span class="keyword">if</span> (target_build_variant_user())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* if device is locked:</span></span><br><span class="line"><span class="comment"> * common partition will not allow to be flashed</span></span><br><span class="line"><span class="comment"> * critical partition will allow to flash image.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span>(!device.is_unlocked &amp;&amp; !critical_flash_allowed(arg)) &#123;</span><br><span class="line">fastboot_fail(<span class="string">&quot;Partition flashing is not allowed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* if device critical is locked:</span></span><br><span class="line"><span class="comment"> * common partition will allow to be flashed</span></span><br><span class="line"><span class="comment"> * critical partition will not allow to flash image.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (VB_M &lt;= target_get_vb_version() &amp;&amp;</span><br><span class="line">!device.is_unlock_critical &amp;&amp;</span><br><span class="line">critical_flash_allowed(arg)) &#123;</span><br><span class="line">fastboot_fail(<span class="string">&quot;Critical partition flashing is not allowed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>看下<code>critical_flash_allowed</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *critical_flash_allowed_ptn[] = &#123;</span><br><span class="line"><span class="string">&quot;aboot&quot;</span>,</span><br><span class="line"><span class="string">&quot;rpm&quot;</span>,</span><br><span class="line"><span class="string">&quot;tz&quot;</span>,</span><br><span class="line"><span class="string">&quot;sbl&quot;</span>,</span><br><span class="line"><span class="string">&quot;sdi&quot;</span>,</span><br><span class="line"><span class="string">&quot;sbl1&quot;</span>,</span><br><span class="line"><span class="string">&quot;xbl&quot;</span>,</span><br><span class="line"><span class="string">&quot;hyp&quot;</span>,</span><br><span class="line"><span class="string">&quot;pmic&quot;</span>,</span><br><span class="line"><span class="string">&quot;bootloader&quot;</span>,</span><br><span class="line"><span class="string">&quot;devinfo&quot;</span>,</span><br><span class="line"><span class="string">&quot;partition&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">critical_flash_allowed</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * entry)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (entry == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(critical_flash_allowed_ptn); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(entry, critical_flash_allowed_ptn[i]))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>userdebug刷机不care这个unlock。</p><p><code>read_device_info</code>会对这两个lock赋值，前提是只要分区里magic不是<code>DEVICE_MAGIC</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(info-&gt;magic, DEVICE_MAGIC, DEVICE_MAGIC_SIZE))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(info-&gt;magic, DEVICE_MAGIC, DEVICE_MAGIC_SIZE);</span><br><span class="line"><span class="keyword">if</span> (is_secure_boot_enable()) &#123;</span><br><span class="line">info-&gt;is_unlocked = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VERIFIED_BOOT || VERIFIED_BOOT_2</span></span><br><span class="line"><span class="keyword">if</span> (VB_M &lt;= target_get_vb_version())</span><br><span class="line">info-&gt;is_unlock_critical = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">info-&gt;is_unlocked = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VERIFIED_BOOT || VERIFIED_BOOT_2</span></span><br><span class="line"><span class="keyword">if</span> (VB_M &lt;= target_get_vb_version())</span><br><span class="line">info-&gt;is_unlock_critical = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">info-&gt;is_tampered = <span class="number">0</span>;</span><br><span class="line">info-&gt;charger_screen_enabled = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VERIFIED_BOOT || VERIFIED_BOOT_2</span></span><br><span class="line"><span class="keyword">if</span> (VB_M &lt;= target_get_vb_version())</span><br><span class="line">info-&gt;verity_mode = <span class="number">1</span>; <span class="comment">//enforcing by default</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">write_device_info(info); <span class="comment">//tj: 写入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当产品release后一般都是secure boot，可见都是lock的，这个标记写到哪里了？看<code>write_device_info</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tj: for emmc </span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_RPMB_FOR_DEVINFO</span></span><br><span class="line"><span class="keyword">if</span> (VB_M &lt;= target_get_vb_version() &amp;&amp;</span><br><span class="line">is_secure_boot_enable()) &#123;</span><br><span class="line"><span class="keyword">if</span>((write_device_info_rpmb((<span class="type">void</span>*) info, PAGE_SIZE)) &lt; <span class="number">0</span>)</span><br><span class="line">ASSERT(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">write_device_info_mmc(info);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">write_device_info_mmc(info);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">free</span>(info);</span><br></pre></td></tr></table></figure><p>高通平台默认没有用<code>USE_RPMB_FOR_DEVINFO</code>，一般用的是devinfo分区来存放这两个lock标记:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_device_info_mmc</span><span class="params">(device_info *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (devinfo_present)</span><br><span class="line">index = partition_get_index(<span class="string">&quot;devinfo&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">index = partition_get_index(<span class="string">&quot;aboot&quot;</span>);</span><br><span class="line"></span><br><span class="line">ptn = partition_get_offset(index);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (devinfo_present)</span><br><span class="line">ret = mmc_write(ptn, device_info_sz, (<span class="type">void</span> *)info_buf);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = mmc_write((ptn + size - device_info_sz), device_info_sz, (<span class="type">void</span> *)info_buf);</span><br></pre></td></tr></table></figure><p>可见，就写在devinfo分区开始处, 如果没有devinfo分区，那就放到aboot分区最后。</p><p>一般还会有个标记判断是否允许解锁，就是<code>is_allow_unlock</code>，这个标记写在config or frq分区：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> frp_ptns[<span class="number">2</span>][<span class="number">8</span>] = &#123;<span class="string">&quot;config&quot;</span>,<span class="string">&quot;frp&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_allow_oem_unlock</span><span class="params">(<span class="type">bool</span> allow_unlock)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">index = partition_get_index(frp_ptns[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (index == INVALID_PTN)</span><br><span class="line">&#123;</span><br><span class="line">index = partition_get_index(frp_ptns[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (index == INVALID_PTN)</span><br><span class="line">&#123;</span><br><span class="line">dprintf(CRITICAL, <span class="string">&quot;Neither &#x27;%s&#x27; nor &#x27;%s&#x27; partition found\n&quot;</span>, frp_ptns[<span class="number">0</span>],frp_ptns[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ptn = partition_get_offset(index);</span><br><span class="line">ptn_size = partition_get_size(index);</span><br><span class="line">offset = ptn_size - blocksize;</span><br><span class="line">mmc_set_lun(partition_get_lun(index));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mmc_read(ptn + offset, (<span class="type">void</span> *)buf, blocksize))</span><br><span class="line">&#123;</span><br><span class="line">dprintf(CRITICAL, <span class="string">&quot;Reading MMC failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般分区表里是config分区，写在最后一个block的最后一个byte。</p><p>有时会遇到如下错误：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fastboot oem unlock-go</span><br><span class="line">...</span><br><span class="line">FAILED &lt;remote: oem unlock is not allowed)</span><br></pre></td></tr></table></figure><p>就是这个标记了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cmd_oem_unlock_go</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">void</span> *data, <span class="type">unsigned</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!device.is_unlocked) &#123;</span><br><span class="line"><span class="keyword">if</span>(!is_allow_unlock) &#123;</span><br><span class="line">fastboot_fail(<span class="string">&quot;oem unlock is not allowed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setting开发者选项里有个”打开OEM解锁”，其实就是这个标记，让我们确认下：</p><p>packages&#x2F;apps&#x2F;Settings&#x2F;src&#x2F;com&#x2F;android&#x2F;settings&#x2F;development&#x2F;OemUnlockPreferenceController.java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOemUnlockConfirmed</span><span class="params">()</span> &#123;</span><br><span class="line">    mOemLockManager.setOemUnlockAllowedByUser(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;service&#x2F;oemlock&#x2F;OemLockManager.java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Sets whether the user has allowed this device to be unlocked.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All actors involved must agree for OEM unlock to be possible.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allowed Whether the device should be allowed to be unlocked.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException if the user is not allowed to unlock the device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #isOemUnlockAllowedByUser()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequiresPermission(android.Manifest.permission.MANAGE_USER_OEM_UNLOCK_STATE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOemUnlockAllowedByUser</span><span class="params">(<span class="type">boolean</span> allowed)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mService.setOemUnlockAllowedByUser(allowed);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;oemlock&#x2F;OemLockService.java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The user has the final say so if they allow unlock, then the device allows the bootloader</span></span><br><span class="line"><span class="comment">// to OEM unlock it.</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOemUnlockAllowedByUser</span><span class="params">(<span class="type">boolean</span> allowedByUser)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ActivityManager.isUserAMonkey()) &#123;</span><br><span class="line">        <span class="comment">// Prevent a monkey from changing this</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    enforceManageUserOemUnlockPermission();</span><br><span class="line">    enforceUserIsAdmin();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">token</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOemUnlockAllowedByAdmin()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Admin does not allow OEM unlock&quot;</span>);</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mOemLock.isOemUnlockAllowedByCarrier()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Carrier does not allow OEM unlock&quot;</span>);</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        mOemLock.setOemUnlockAllowedByDevice(allowedByUser);</span><br><span class="line">        setPersistentDataBlockOemUnlockAllowedBit(allowedByUser);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(token);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>check <code>setPersistentDataBlockOemUnlockAllowedBit</code>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Always synchronize the OemUnlockAllowed bit to the FRP partition, which</span></span><br><span class="line"><span class="comment"> * is used to erase FRP information on a unlockable device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setPersistentDataBlockOemUnlockAllowedBit</span><span class="params">(<span class="type">boolean</span> allowed)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">PersistentDataBlockManagerInternal</span> <span class="variable">pdbmi</span></span><br><span class="line">            <span class="operator">=</span> LocalServices.getService(PersistentDataBlockManagerInternal.class);</span><br><span class="line">    <span class="comment">// if mOemLock is PersistentDataBlockLock, then the bit should have already been set</span></span><br><span class="line">    <span class="keyword">if</span> (pdbmi != <span class="literal">null</span> &amp;&amp; !(mOemLock <span class="keyword">instanceof</span> PersistentDataBlockLock)) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Update OEM Unlock bit in pst partition to &quot;</span> + allowed);</span><br><span class="line">        pdbmi.forceOemUnlockEnabled(allowed);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, 其实这里已经能看出来是和分区(frp)打交道了，继续跟：</p><p>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;PersistentDataBlockService.java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forceOemUnlockEnabled</span><span class="params">(<span class="type">boolean</span> enabled)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        doSetOemUnlockEnabledLocked(enabled);</span><br><span class="line">        computeAndWriteDigestLocked();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSetOemUnlockEnabledLocked</span><span class="params">(<span class="type">boolean</span> enabled)</span> &#123;</span><br><span class="line">       FileOutputStream outputStream;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           outputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(mDataBlockFile));</span><br><span class="line">       &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">           Slog.e(TAG, <span class="string">&quot;partition not available&quot;</span>, e); </span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// tj: 找到这个config分区并写入1 or 0</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> outputStream.getChannel();</span><br><span class="line"></span><br><span class="line">           channel.position(getBlockDeviceSize() - <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">           <span class="type">ByteBuffer</span> <span class="variable">data</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1</span>);</span><br><span class="line">           data.put(enabled ? (<span class="type">byte</span>) <span class="number">1</span> : (<span class="type">byte</span>) <span class="number">0</span>); </span><br><span class="line">           data.flip();</span><br><span class="line">           channel.write(data);</span><br><span class="line">           outputStream.flush();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           Slog.e(TAG, <span class="string">&quot;unable to access persistent partition&quot;</span>, e); </span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           SystemProperties.set(OEM_UNLOCK_PROP, enabled ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;0&quot;</span>);</span><br><span class="line">           IoUtils.closeQuietly(outputStream);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>mDataBlockFile</code>是啥？文件开头：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersistentDataBlockService</span> <span class="keyword">extends</span> <span class="title class_">SystemService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> PersistentDataBlockService.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PERSISTENT_DATA_BLOCK_PROP</span> <span class="operator">=</span> <span class="string">&quot;ro.frp.pst&quot;</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersistentDataBlockService</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">        mContext = context;</span><br><span class="line">        mDataBlockFile = SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP);</span><br><span class="line">        mBlockDeviceSize = -<span class="number">1</span>; <span class="comment">// Load lazily</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看下这个属性：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/ <span class="comment"># getprop ro.frp.pst</span></span><br><span class="line">/dev/block/bootdevice/by-name/config</span><br></pre></td></tr></table></figure><p>就是config分区嘛，和bootloader对应上了，找到这个分区后然后把<code>enable</code>写进去, clear :]</p><p>是否allow unlock有个属性可以看：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/ <span class="comment"># getprop | grep oem_unlock</span></span><br><span class="line">[sys.oem_unlock_allowed]: [0]</span><br></pre></td></tr></table></figure><p>我们再看下启动时<code>aboot_init</code> call <code>read_device_info</code>对lock的处理：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_RPMB_FOR_DEVINFO</span></span><br><span class="line"><span class="keyword">if</span> (VB_M &lt;= target_get_vb_version() &amp;&amp;</span><br><span class="line">is_secure_boot_enable()) &#123;</span><br><span class="line"><span class="keyword">if</span>((read_device_info_rpmb((<span class="type">void</span>*) info, PAGE_SIZE)) &lt; <span class="number">0</span>)</span><br><span class="line">ASSERT(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">read_device_info_mmc(info);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">read_device_info_mmc(info);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(info-&gt;magic, DEVICE_MAGIC, DEVICE_MAGIC_SIZE))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(info-&gt;magic, DEVICE_MAGIC, DEVICE_MAGIC_SIZE);</span><br><span class="line"><span class="keyword">if</span> (is_secure_boot_enable()) &#123;</span><br><span class="line">info-&gt;is_unlocked = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VERIFIED_BOOT || VERIFIED_BOOT_2</span></span><br><span class="line"><span class="keyword">if</span> (VB_M &lt;= target_get_vb_version())</span><br><span class="line">info-&gt;is_unlock_critical = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">info-&gt;is_unlocked = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VERIFIED_BOOT || VERIFIED_BOOT_2</span></span><br><span class="line"><span class="keyword">if</span> (VB_M &lt;= target_get_vb_version())</span><br><span class="line">info-&gt;is_unlock_critical = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">info-&gt;is_tampered = <span class="number">0</span>;</span><br><span class="line">info-&gt;charger_screen_enabled = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VERIFIED_BOOT || VERIFIED_BOOT_2</span></span><br><span class="line"><span class="keyword">if</span> (VB_M &lt;= target_get_vb_version())</span><br><span class="line">info-&gt;verity_mode = <span class="number">1</span>; <span class="comment">//enforcing by default</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">write_device_info(info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(dev, info, <span class="keyword">sizeof</span>(device_info));</span><br><span class="line"><span class="built_in">free</span>(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在从devinfo分区获取magic看是否对得上，如果对不上就给个默认的，secure boot默认就是lock了, non secure boot就默认unlock。对不上比如你擦了这个devinfo or第一次烧录，对的上只有写过这个magic，memcmp返回0进不去。</p><p>当然也可以保留magic恢复lock标记：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fastboot oem lock</span><br></pre></td></tr></table></figure><p>allow unlock默认是0，擦了后是0，所以erase config没用，你得进系统setting勾选 or 做个allow unlock的img刷进去也行。</p><p><code>is_unlock_critical</code>开关命令：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;flashing lock_critical&quot;</span>, cmd_flashing_lock_critical&#125;,</span><br><span class="line">&#123;<span class="string">&quot;flashing unlock_critical&quot;</span>, cmd_flashing_unlock_critical&#125;,</span><br><span class="line">...</span><br><span class="line"><span class="type">void</span> <span class="title function_">cmd_flashing_lock_critical</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">void</span> *data, <span class="type">unsigned</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line">set_device_unlock(UNLOCK_CRITICAL, FALSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cmd_flashing_unlock_critical</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">void</span> *data, <span class="type">unsigned</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line">set_device_unlock(UNLOCK_CRITICAL, TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unlock状态查询命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\&gt;fastboot oem device-info</span><br><span class="line">...</span><br><span class="line">(bootloader)    Device tampered: <span class="literal">false</span></span><br><span class="line">(bootloader)    Device unlocked: <span class="literal">true</span></span><br><span class="line">(bootloader)    Device critical unlocked: <span class="literal">true</span></span><br><span class="line">(bootloader)    Charger screen enabled: <span class="literal">false</span></span><br><span class="line">(bootloader)    Display panel:</span><br><span class="line">OKAY [  0.054s]</span><br><span class="line">finished. total time: 0.055s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unlock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高通平台AB系统刷机说明</title>
      <link href="/how-to-flash-in-ab-system-for-msm.html"/>
      <url>/how-to-flash-in-ab-system-for-msm.html</url>
      
        <content type="html"><![CDATA[<p>A&#x2F;B系统是Google推的一种OTA升级方法，就是为了方便，简单说就是多了个备份区，升级时写备份区然后尝试从备份区启动，如果启动ok，就把备份区作为主区，遥想当年ROS平台bootloader就有这么个东东。</p><p>这里不关心OTA流程，我们关心的是A&#x2F;B系统分区选择相关，A&#x2F;B下刷机要不要带_a, _b。</p><p>ok，先让我们看下官方对分区选择说明：</p><blockquote><p>A&#x2F;B system updates use two sets of partitions referred to as <em>slots</em> (normally slot A and slot B). The system runs from the <em>current</em> slot while the partitions in the <em>unused</em> slot are not accessed by the running system during normal operation.</p><p>Each slot has a <em>bootable</em> attribute that states whether the slot contains a correct system from which the device can boot. </p><p>Each slot also has a <em>successful</em> attribute set by the user space, which is relevant only if the slot is also bootable. A successful slot should be able to boot, run, and update itself. A bootable slot that was not marked as successful (after several attempts were made to boot from it) should be marked as unbootable by the bootloader, including changing the active slot to another bootable slot (normally to the slot running immediately before the attempt to boot into the new, active one). </p></blockquote><p>高通在LK下对A&#x2F;B支持的文件是: ab_partition_parser.c，来看下当fastboot刷机时LK是如何解析的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find index of parition in array of partition entries</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition_get_index</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> input_string_length = <span class="built_in">strlen</span>(name);</span><br><span class="line"><span class="type">unsigned</span> n;</span><br><span class="line"><span class="type">int</span> curr_slot = INVALID;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *suffix_curr_actv_slot = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span> *curr_suffix = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( partition_count &gt;= NUM_PARTITIONS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> INVALID_PTN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*We iterate through the parition entries list,</span></span><br><span class="line"><span class="comment">to find the partition with active slot suffix.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; partition_count; n++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>((<span class="type">const</span> <span class="type">char</span>*)name, (<span class="type">const</span> <span class="type">char</span> *)partition_entries[n].name,</span><br><span class="line">input_string_length))</span><br><span class="line">&#123;</span><br><span class="line">curr_suffix = (<span class="type">char</span> *)(partition_entries[n].name+input_string_length);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* if partition_entries.name is NULL terminated return the index */</span></span><br><span class="line"><span class="keyword">if</span> (*curr_suffix == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> n; <span class="comment">// tj: 完全一致名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (partition_multislot_is_supported())</span><br><span class="line">&#123;</span><br><span class="line">curr_slot = partition_find_active_slot();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If suffix string matches with current active slot suffix return index */</span></span><br><span class="line"><span class="keyword">if</span> (curr_slot != INVALID)</span><br><span class="line">&#123;</span><br><span class="line">suffix_curr_actv_slot = SUFFIX_SLOT(curr_slot);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>((<span class="type">const</span> <span class="type">char</span> *)curr_suffix, suffix_curr_actv_slot,</span><br><span class="line"><span class="built_in">strlen</span>(suffix_curr_actv_slot)))</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* No valid active slot */</span></span><br><span class="line"><span class="keyword">return</span> INVALID_PTN;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> INVALID_PTN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要在分区表里找到这个name，如果完全一致那就是这个分区，对有ab分区的，找到active slot:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This function returns the most priority and active slot,</span></span><br><span class="line"><span class="comment">also you need to update the global state seperately.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition_find_active_slot</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (boot_priority = MAX_PRIORITY;</span><br><span class="line">boot_priority &gt; <span class="number">0</span>; boot_priority--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Search valid boot slot with highest priority */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; AB_SUPPORTED_SLOTS; i++)</span><br><span class="line">&#123;</span><br><span class="line">current_priority = slot_priority(partition_entries, boot_slot_index[i]);</span><br><span class="line">current_active_bit = slot_is_active(partition_entries, boot_slot_index[i]);</span><br><span class="line">current_bootable_bit = slot_is_bootable(partition_entries, boot_slot_index[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Count number of slots with all attributes as zero */</span></span><br><span class="line"><span class="keyword">if</span> ( !current_priority &amp;&amp;</span><br><span class="line">!current_active_bit &amp;&amp;</span><br><span class="line">current_bootable_bit)</span><br><span class="line">&#123;</span><br><span class="line">count ++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，忽略non active, non bootable, non priority的slot，对首次烧录都是non的给个default: <code>SLOT_A</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* All slots are zeroed, this is first bootup */</span></span><br><span class="line"><span class="comment">/* Marking and trying SLOT 0 as default */</span></span><br><span class="line"><span class="keyword">if</span> (count == AB_SUPPORTED_SLOTS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Update the priority of the boot slot */</span></span><br><span class="line">partition_activate_slot(SLOT_A);</span><br><span class="line"></span><br><span class="line">active_slot = SLOT_A;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is required to mark all bits as active,</span></span><br><span class="line"><span class="comment">for fresh boot post fresh flash */</span></span><br><span class="line">mark_all_partitions_active(active_slot);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到<code>partition_get_index</code>，它会返回这个active slot的partition index。</p><p>也就是说，如果我们敲入了flash system，其实烧录的就是system active slot。唯一例外就是boot分区:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmd_flash_mmc_img</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">void</span> *data, <span class="type">unsigned</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">index = partition_get_index(pname);</span><br><span class="line">ptn = partition_get_offset(index);</span><br><span class="line"><span class="keyword">if</span>(ptn == <span class="number">0</span>) &#123;</span><br><span class="line">fastboot_fail(<span class="string">&quot;partition table doesn&#x27;t exist&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(pname, <span class="string">&quot;boot&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;boot&quot;</span>))</span><br><span class="line">|| !<span class="built_in">strcmp</span>(pname, <span class="string">&quot;recovery&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>((<span class="type">void</span> *)data, BOOT_MAGIC, BOOT_MAGIC_SIZE)) &#123;</span><br><span class="line">fastboot_fail(<span class="string">&quot;image is not a boot image&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reset multislot_partition attributes in case of flashing boot */</span></span><br><span class="line"><span class="keyword">if</span> (partition_multislot_is_supported())</span><br><span class="line">&#123;</span><br><span class="line">partition_reset_attributes(index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释写的很清楚，如果要烧boot，就要复位这个active slot分区的属性:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Function: To reset partition attributes</span></span><br><span class="line"><span class="comment">This function reset partition_priority, retry_count</span></span><br><span class="line"><span class="comment">and clear successful and bootable bits.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">partition_reset_attributes</span><span class="params">(<span class="type">unsigned</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">partition_entry</span> *<span class="title">partition_entries</span> =</span></span><br><span class="line">partition_get_partition_entries();</span><br><span class="line"></span><br><span class="line">partition_entries[index].attribute_flag |= (PART_ATT_PRIORITY_VAL |</span><br><span class="line">PART_ATT_MAX_RETRY_COUNT_VAL);</span><br><span class="line"></span><br><span class="line">partition_entries[index].attribute_flag &amp;= ((~PART_ATT_SUCCESSFUL_VAL) &amp;</span><br><span class="line">(~PART_ATT_UNBOOTABLE_VAL));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!attributes_updated)</span><br><span class="line">attributes_updated = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make attributes persistant */</span></span><br><span class="line">partition_mark_active_slot(active_slot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见把分区表里这个index的分区属性全部clear了，比如变成了non bootable，non successful，这样在前面的<code>partition_find_active_slot</code>就找不到这个active slot， 比如当前active slot是slot a, 敲入flash boot后，boot_a内容更新了但是不再是active了。此时fastboot reboot到底走不走boot_a要看boot_b是不是active，所以保险起见，还是boot_a[b]都烧入，rt?</p><p>有人会问如何判断系统用了A&#x2F;B，我想有一种方法就是在fastboot看下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\&gt;fastboot getvar all</span><br><span class="line">...</span><br><span class="line">(bootloader) slot-count:2</span><br><span class="line">(bootloader) current-slot:a</span><br><span class="line">(bootloader) slot-retry-count:b:0</span><br><span class="line">(bootloader) slot-success:b:No</span><br><span class="line">(bootloader) slot-active:b:No</span><br><span class="line">(bootloader) slot-unbootable:b:No</span><br><span class="line">(bootloader) slot-retry-count:a:6</span><br><span class="line">(bootloader) slot-success:a:Yes</span><br><span class="line">(bootloader) slot-active:a:Yes</span><br><span class="line">(bootloader) slot-unbootable:a:No</span><br><span class="line">(bootloader) has-slot:userdata: No</span><br><span class="line">(bootloader) has-slot:vendor: Yes</span><br><span class="line">(bootloader) has-slot:system: Yes</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Google对刷机时间的说明：</p><blockquote><p>Does flashing two system partitions increase factory flashing time?<br>No. Pixel didn’t increase in system image size (it merely divided the space across two partitions).</p></blockquote><p>so，出厂刷机没必要_a&#x2F;_b都刷，rt?</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> A/B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析解决安卓启动一直卡在加密界面的问题</title>
      <link href="/fix-an-issue-about-always-stuck-on-encrypting.html"/>
      <url>/fix-an-issue-about-always-stuck-on-encrypting.html</url>
      
        <content type="html"><![CDATA[<p>Android P刷机后第一次启动停在了加密界面，提示如下:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Wait while your phone is being encrypted.</span><br></pre></td></tr></table></figure><p>这里是data分区在加密，system&#x2F;vold&#x2F;cryptsfs.cpp负责，先看看logcat过滤Cryptfs:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01-28 04:50:11.003 D/Cryptfs (  497): Just asked init to shut down class main</span><br><span class="line">01-28 04:50:14.245 I/Cryptfs (  497): Using scrypt with keymaster for cryptfs KDF</span><br><span class="line">01-28 04:50:14.698 I/Cryptfs (  497): Signing safely-padded object</span><br><span class="line">01-28 04:50:15.660 I/Cryptfs (  497): Using scrypt with keymaster for cryptfs KDF</span><br><span class="line">01-28 04:50:16.113 I/Cryptfs (  497): Signing safely-padded object</span><br><span class="line">01-28 04:50:16.941 D/Cryptfs (  497): Just triggered post_fs_data</span><br><span class="line">01-28 04:50:17.085 D/Cryptfs (  497): post_fs_data done</span><br><span class="line">01-28 04:50:18.440 I/Cryptfs (  497): Signing safely-padded object</span><br><span class="line">01-28 04:50:18.997 I/Cryptfs (  497): Extra parameters for dm_crypt: fde_enabled ice</span><br><span class="line">01-28 04:50:18.997 I/Cryptfs (  497): target_type = req-crypt</span><br><span class="line">01-28 04:50:18.997 I/Cryptfs (  497): real_blk_name = /dev/block/bootdevice/by-name/userdata, extra_params = fde_enabled ice</span><br><span class="line">01-28 04:50:19.085 D/Cryptfs (  497): Just triggered restart_min_framework</span><br><span class="line">01-28 04:50:19.085 I/Cryptfs (  497): Using scrypt with keymaster for cryptfs KDF</span><br><span class="line">12-31 16:00:00.870 E/Cryptfs (  497): Cannot remove dm-crypt device</span><br><span class="line">12-31 16:00:00.875 I/Cryptfs (  497): cryptfs_check_passwd</span><br><span class="line">12-31 16:00:00.876 D/Cryptfs (  497): crypt_ftr-&gt;fs_size = 43900863</span><br><span class="line">12-31 16:00:00.876 I/Cryptfs (  497): Using scrypt with keymaster for cryptfs KDF</span><br><span class="line">12-31 16:00:01.336 I/Cryptfs (  497): Signing safely-padded object</span><br><span class="line">12-31 16:00:02.237 E/Cryptfs (  497): Cannot create dm-crypt device userdata: Device or resource busy</span><br><span class="line">12-31 16:00:02.237 E/Cryptfs (  497): Error creating decrypted block device</span><br><span class="line">12-31 16:00:02.237 E/Cryptfs (  497): Encrypted filesystem not validated, abortin</span><br></pre></td></tr></table></figure><p>有几处错误:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12-31 16:00:00.870 E/Cryptfs (  497): Cannot remove dm-crypt device</span><br><span class="line">12-31 16:00:02.237 E/Cryptfs (  497): Cannot create dm-crypt device userdata: Device or resource busy</span><br><span class="line">12-31 16:00:02.237 E/Cryptfs (  497): Error creating decrypted block device</span><br><span class="line">12-31 16:00:02.237 E/Cryptfs (  497): Encrypted filesystem not validated, abortin</span><br></pre></td></tr></table></figure><p>找到相关代码:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">delete_crypto_blk_dev</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="type">char</span> buffer[DM_CRYPT_BUF_SIZE];</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">dm_ioctl</span> *io;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line">  <span class="type">int</span> retries = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/device-mapper&quot;</span>, O_RDWR|O_CLOEXEC)) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="built_in">SLOGE</span>(<span class="string">&quot;Cannot open device-mapper\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  io = (<span class="keyword">struct</span> dm_ioctl *) buffer;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ioctl_init</span>(io, DM_CRYPT_BUF_SIZE, name, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ioctl</span>(fd, DM_DEV_REMOVE, io)) &#123;</span><br><span class="line">    <span class="built_in">SLOGE</span>(<span class="string">&quot;Cannot remove dm-crypt device\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We made it here with no errors.  Woot! */</span></span><br><span class="line">  retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">  <span class="built_in">close</span>(fd);    <span class="comment">/* If fd is &lt;0 from a failed open call, it&#x27;s safe to just ignore the close error */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DM_DEV_REMOVE</code>执行错误，对应kernel是在drivers&#x2F;md&#x2F;dm-ioctl.c的<code>dev_remove</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dev_remove</span><span class="params">(<span class="keyword">struct</span> dm_ioctl *param, <span class="type">size_t</span> param_size)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hash_cell</span> *<span class="title">hc</span>;</span> </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mapped_device</span> *<span class="title">md</span>;</span> </span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dm_table</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">        down_write(&amp;_hash_lock);</span><br><span class="line">        hc = __find_device_hash_cell(param);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hc) &#123;</span><br><span class="line">                DMDEBUG_LIMIT(<span class="string">&quot;device doesn&#x27;t appear to be in the dev hash table.&quot;</span>);</span><br><span class="line">                up_write(&amp;_hash_lock);</span><br><span class="line">                <span class="keyword">return</span> -ENXIO;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        md = hc-&gt;md;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*   </span></span><br><span class="line"><span class="comment">         * Ensure the device is not open and nothing further can open it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        r = dm_lock_for_deletion(md, !!(param-&gt;flags &amp; DM_DEFERRED_REMOVE), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r == -EBUSY &amp;&amp; param-&gt;flags &amp; DM_DEFERRED_REMOVE) &#123;</span><br><span class="line">                        up_write(&amp;_hash_lock);</span><br><span class="line">                        dm_put(md);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;    </span><br><span class="line">                DMDEBUG_LIMIT(<span class="string">&quot;unable to remove open device %s&quot;</span>, hc-&gt;name);</span><br><span class="line">                up_write(&amp;_hash_lock);</span><br><span class="line">                dm_put(md);</span><br><span class="line">                <span class="keyword">return</span> r; <span class="comment">//tj: fail</span></span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        t = __hash_remove(hc);</span><br><span class="line">        up_write(&amp;_hash_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t) &#123;</span><br><span class="line">                dm_sync_table(md);</span><br><span class="line">                dm_table_destroy(t);</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        param-&gt;flags &amp;= ~DM_DEFERRED_REMOVE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!dm_kobject_uevent(md, KOBJ_REMOVE, param-&gt;event_nr))</span><br><span class="line">                param-&gt;flags |= DM_UEVENT_GENERATED_FLAG;</span><br><span class="line"></span><br><span class="line">        dm_put(md);</span><br><span class="line">        dm_destroy(md);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码看fail只有我标注fail的那里，进<code>dm_lock_for_deletion</code>里看下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Guarantees nothing is using the device before it&#x27;s deleted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dm_lock_for_deletion</span><span class="params">(<span class="keyword">struct</span> mapped_device *md, <span class="type">bool</span> mark_deferred, <span class="type">bool</span> only_deferred)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        spin_lock(&amp;_minor_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dm_open_count(md)) &#123;</span><br><span class="line">                r = -EBUSY;</span><br><span class="line">                <span class="keyword">if</span> (mark_deferred)</span><br><span class="line">                        set_bit(DMF_DEFERRED_REMOVE, &amp;md-&gt;flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (only_deferred &amp;&amp; !test_bit(DMF_DEFERRED_REMOVE, &amp;md-&gt;flags))</span><br><span class="line">                r = -EEXIST;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">                set_bit(DMF_DELETING, &amp;md-&gt;flags);</span><br><span class="line"></span><br><span class="line">        spin_unlock(&amp;_minor_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有一种可能就是返回<code>-EBUSY</code>，rt? 谁打开userdata分区？没改啥流程啊，提问QCOM让在QCOM参考机上测试，如果复现再提，还指出了如下错误:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01-06 20:36:44.037   490   493 D vold    : Disk at 253:2 changed</span><br><span class="line">01-06 20:36:44.037   490   670 D vold    : cryptfs_enable_inplace(/dev/block/dm-2, /dev/block/bootdevice/by-name/userdata, 43900863, 0x7017efe900, 43900863, 0, 1)</span><br><span class="line">01-06 20:36:44.037   490   670 D vold    : Opening/dev/block/bootdevice/by-name/userdata</span><br><span class="line">01-06 20:36:44.037   490   670 D vold    : Opening/dev/block/dm-2</span><br><span class="line">01-06 20:36:44.037   490   670 E vold    : Error opening crypto_blkdev /dev/block/dm-2 for ext4 inplace encrypt, retrying: No such file or directory</span><br></pre></td></tr></table></figure><p>回头来看，他应该不熟悉加密流程，这是vold正常打印，我们是ext4，<code>cryptfs_enable_inplace</code>会call <code>cryptfs_enable_inplace_ext4</code>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">cryptfs_enable_inplace_ext4</span><span class="params">(<span class="type">char</span>* crypto_blkdev, <span class="type">char</span>* real_blkdev, <span class="type">off64_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">off64_t</span>* size_already_done, <span class="type">off64_t</span> tot_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">off64_t</span> previously_encrypted_upto,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">bool</span> set_progress_properties)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Opening&quot;</span> &lt;&lt; crypto_blkdev;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_HW_DISK_ENCRYPTION) &amp;&amp; defined(CONFIG_HW_DISK_ENCRYPT_PERF)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// Wait until the block device appears.  Re-use the mount retry values since it is reasonable.</span></span><br><span class="line">    <span class="keyword">while</span> ((data.cryptofd = <span class="built_in">open</span>(crypto_blkdev, O_WRONLY|O_CLOEXEC)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--retries) &#123;</span><br><span class="line">            <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Error opening crypto_blkdev &quot;</span> &lt;&lt; crypto_blkdev   <span class="comment">//tj: retry here</span></span><br><span class="line">                        &lt;&lt; <span class="string">&quot; for ext4 inplace encrypt, retrying&quot;</span>;</span><br><span class="line">            <span class="built_in">sleep</span>(RETRY_MOUNT_DELAY_SECONDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Error opening crypto_blkdev &quot;</span> &lt;&lt; crypto_blkdev</span><br><span class="line">                        &lt;&lt; <span class="string">&quot; for ext4 inplace encrypt&quot;</span>;</span><br><span class="line">            rc = ENABLE_INPLACE_ERR_DEV;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看到出错是有可能的，要”Wait util the block device appears”。</p><p>我们再回来看下出问题的logcat上下文:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12-31 16:00:00.863 D/vold    (  497): Found matching PID 968</span><br><span class="line">12-31 16:00:00.863 W/vold    (  497): Skipping due to root namespace</span><br><span class="line">12-31 16:00:00.863 D/vold    (  497): Found matching PID 970</span><br><span class="line">12-31 16:00:00.863 W/vold    (  497): Skipping due to root namespace</span><br><span class="line">12-31 16:00:00.863 D/vold    (  497): Found matching PID 1078</span><br><span class="line">12-31 16:00:00.863 W/vold    (  497): Skipping due to root namespace</span><br><span class="line">12-31 16:00:00.863 D/vold    (  497): Found matching PID 1288</span><br><span class="line">12-31 16:00:00.864 I/vold    (  497): Encrypting group 167</span><br><span class="line">12-31 16:00:00.869 I/vold    (  497): Encrypted to sector 2686390272</span><br><span class="line">12-31 16:00:00.870 D/vold    (  497): cryptfs_enable_inplace_ext4 success</span><br><span class="line">12-31 16:00:00.870 E/Cryptfs (  497): Cannot remove dm-crypt device</span><br><span class="line">12-31 16:00:00.875 I/Cryptfs (  497): cryptfs_check_passwd</span><br></pre></td></tr></table></figure><p>再看下正常的logcat上下文：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12-31 16:00:00.881   496   496 D vold    : Remounting 10001 as mode none</span><br><span class="line">...</span><br><span class="line">12-31 16:00:01.941   496   664 D vold    : cryptfs_enable_inplace_ext4 success</span><br><span class="line">...</span><br><span class="line">12-31 16:00:02.107   496   664 I Cryptfs : cryptfs_check_passwd</span><br></pre></td></tr></table></figure><p>没有看出什么明显异常，”元芳 你怎么看?”</p><p>其实已经怀疑一个地方了后面再说，除了这个就是流程是不是有问题？说不定我司改了啥我不知道？其实Google&#x2F;vold在这里就没有处理remove失败的情况，这点不够健壮，rt?</p><p>我们来看加密是如何来的：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">VoldNativeService.cpp:fdeEnable-&gt;fdeEnableInternal -&gt;</span><br><span class="line">cryptfs.cpp:cryptfs_enable -&gt; cryptfs_enable_internal -&gt; cryptfs_enable_all_volumes -&gt; </span><br><span class="line">EncryptInplace.cpp:cryptfs_enable_inplace -&gt; cryptfs_enable_inplace_ext4</span><br></pre></td></tr></table></figure><p>有个可执行文件vdc会call vold的<code>fdeEnable</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">0</span>] == <span class="string">&quot;cryptfs&quot;</span> &amp;&amp; args[<span class="number">1</span>] == <span class="string">&quot;enablecrypto&quot;</span>) &#123;</span><br><span class="line">    <span class="type">int</span> passwordType = android::os::IVold::PASSWORD_TYPE_DEFAULT;</span><br><span class="line">    <span class="type">int</span> encryptionFlags = android::os::IVold::ENCRYPTION_FLAG_NO_UI;</span><br><span class="line">    <span class="built_in">checkStatus</span>(vold-&gt;<span class="built_in">fdeEnable</span>(passwordType, <span class="string">&quot;&quot;</span>, encryptionFlags));</span><br></pre></td></tr></table></figure><p>参数<code>enablecrypto</code>传入是通过vdc.rc:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># One shot invocation to encrypt unencrypted volumes</span><br><span class="line">on encrypt</span><br><span class="line">    start surfaceflinger</span><br><span class="line">    exec - root -- /system/bin/vdc --wait cryptfs enablecrypto  //here</span><br><span class="line">    # vold will set vold.decrypt to trigger_restart_framework (default</span><br><span class="line">    # encryption)</span><br></pre></td></tr></table></figure><p>那这个脚本是怎么trigger的？以前我们分析过其他问题是也提到过是init通过queue来的，具体是在.&#x2F;system&#x2F;core&#x2F;init&#x2F;builtins.cpp：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Queue event based on fs_mgr return code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * code: return code of fs_mgr_mount_all</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function might request a reboot, in which case it will</span></span><br><span class="line"><span class="comment"> * not return.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * return code is processed based on input code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> Result&lt;Success&gt; <span class="title">queue_fs_event</span><span class="params">(<span class="type">int</span> code)</span> </span>&#123;</span><br><span class="line">    std::string bootmode = <span class="built_in">GetProperty</span>(<span class="string">&quot;ro.bootmode&quot;</span>, <span class="string">&quot;&quot;</span>); </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(bootmode.<span class="built_in">c_str</span>(), <span class="string">&quot;ffbm&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;ffbm&quot;</span>)) == <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;ffbm mode, not start class main\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Success</span>();</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_NEEDS_ENCRYPTION) &#123;</span><br><span class="line">        ActionManager::<span class="built_in">GetInstance</span>().<span class="built_in">QueueEventTrigger</span>(<span class="string">&quot;encrypt&quot;</span>); <span class="comment">//here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Success</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_MIGHT_BE_ENCRYPTED) &#123;</span><br></pre></td></tr></table></figure><p>看注释应该是<code>fs_mgr_mount_all</code>要返回<code>FS_MGR_MNTALL_DEV_NEEDS_ENCRYPTION</code>就会触发加密。</p><p>意思就是需要加密你就加密吧，往前追就是<code>do_mount_all</code>了:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mount_all &lt;fstab&gt; [ &lt;path&gt; ]* [--&lt;options&gt;]*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function might request a reboot, in which case it will</span></span><br><span class="line"><span class="comment"> * not return.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> Result&lt;Success&gt; <span class="title">do_mount_all</span><span class="params">(<span class="type">const</span> BuiltinArguments&amp; args)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    std::string prop_name = <span class="string">&quot;ro.boottime.init.mount_all.&quot;</span>s + prop_post_fix;</span><br><span class="line">    android::base::Timer t;</span><br><span class="line">    <span class="keyword">auto</span> mount_fstab_return_code = <span class="built_in">mount_fstab</span>(fstabfile, mount_mode);</span><br><span class="line">    <span class="keyword">if</span> (!mount_fstab_return_code) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Error</span>() &lt;&lt; <span class="string">&quot;mount_fstab() failed &quot;</span> &lt;&lt; mount_fstab_return_code.<span class="built_in">error</span>();</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">property_set</span>(prop_name, std::<span class="built_in">to_string</span>(t.<span class="built_in">duration</span>().<span class="built_in">count</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (import_rc) &#123;</span><br><span class="line">        <span class="comment">/* Paths of .rc files are specified at the 2nd argument and beyond */</span></span><br><span class="line">        <span class="built_in">import_late</span>(args.args, <span class="number">2</span>, path_arg_end);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queue_event) &#123;</span><br><span class="line">        <span class="comment">/* queue_fs_event will queue event based on mount_fstab return code</span></span><br><span class="line"><span class="comment">         * and return processed return code*/</span></span><br><span class="line">        <span class="keyword">auto</span> queue_fs_result = <span class="built_in">queue_fs_event</span>(*mount_fstab_return_code);</span><br><span class="line">        <span class="keyword">if</span> (!queue_fs_result) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Error</span>() &lt;&lt; <span class="string">&quot;queue_fs_event() failed: &quot;</span> &lt;&lt; queue_fs_result.<span class="built_in">error</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Success</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先走<code>mount_fstab</code>，再按照结果处理, <code>mount_fstab</code>会call <code>fs_mgr_mount_all</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* When multiple fstab records share the same mount_point, it will</span></span><br><span class="line"><span class="comment"> * try to mount each one in turn, and ignore any duplicates after a</span></span><br><span class="line"><span class="comment"> * first successful mount.</span></span><br><span class="line"><span class="comment"> * Returns -1 on error, and  FS_MGR_MNTALL_* otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fs_mgr_mount_all</span><span class="params">(<span class="keyword">struct</span> fstab *fstab, <span class="type">int</span> mount_mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br></pre></td></tr></table></figure><p>可见，应该就是按fstab里的条目来依次mount，继续看：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mret = <span class="built_in">mount_with_alternatives</span>(fstab, i, &amp;last_idx_inspected, &amp;attempted_idx);</span><br><span class="line">i = last_idx_inspected;</span><br><span class="line">mount_errno = errno;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Deal with encryptability. */</span></span><br><span class="line"><span class="keyword">if</span> (!mret) &#123;</span><br><span class="line">    <span class="type">int</span> status = <span class="built_in">handle_encryptable</span>(&amp;fstab-&gt;recs[attempted_idx]);</span><br></pre></td></tr></table></figure><p><code>mount_with_alternatives</code>是正常的mount，如果返回0没有错误，会check 是否具备加密能力：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check to see if a mountable volume has encryption requirements</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">handle_encryptable</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> fstab_rec* rec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* If this is block encryptable, need to trigger encryption */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">needs_block_encryption</span>(rec)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">umount</span>(rec-&gt;mount_point) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> FS_MGR_MNTALL_DEV_NEEDS_ENCRYPTION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PWARNING &lt;&lt; <span class="string">&quot;Could not umount &quot;</span> &lt;&lt; rec-&gt;mount_point</span><br><span class="line">                     &lt;&lt; <span class="string">&quot; - allow continue unencrypted&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> FS_MGR_MNTALL_DEV_NOT_ENCRYPTED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>check <code>needs_block_encryption</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">needs_block_encryption</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> fstab_rec* rec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (android::base::<span class="built_in">GetBoolProperty</span>(<span class="string">&quot;ro.vold.forceencryption&quot;</span>, <span class="literal">false</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">fs_mgr_is_encryptable</span>(rec))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (rec-&gt;fs_mgr_flags &amp; MF_FORCECRYPT) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">flag_list</span> fs_mgr_flags[] = &#123;</span><br><span class="line">...</span><br><span class="line">    &#123;<span class="string">&quot;forceencrypt=&quot;</span>, MF_FORCECRYPT&#125;,</span><br></pre></td></tr></table></figure><p>fstab里会加入forceencrypt：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#&lt;src&gt;                                      &lt;mnt_point&gt;  &lt;type&gt;  &lt;mnt_flags and options&gt;                     &lt;fs_mgr_flags&gt;</span><br><span class="line">/dev/block/bootdevice/by-name/system        /            ext4    ro,barrier=1,discard                        wait,slotselect,avb</span><br><span class="line">/dev/block/bootdevice/by-name/userdata      /data        ext4    noatime,nosuid,nodev,barrier=1,noauto_da_alloc,discard  wait,forceencrypt=footer,quota,reservedsize=128M</span><br></pre></td></tr></table></figure><p>clear, rt?</p><p>ok, 为了帮助确认分析问题，我放开了kernel dm debug，加入了ioctl cmd log，另外vold remove那里加入了delay和retry，竟然ok了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    0.000000] device-mapper: init: will configure 1 devices</span><br><span class="line">[    1.263421] device-mapper: uevent: version 1.0.3</span><br><span class="line">[    1.263580] device-mapper: ioctl: 4.35.0-ioctl (2016-06-23) initialised: dm-devel@redhat.com</span><br><span class="line">[    1.263787] device-mapper: req-crypt: dm-req-crypt successfully initalized.\x0a</span><br><span class="line">[    3.607087] device-mapper: init: attempting early device configuration.</span><br><span class="line">[    3.607101] device-mapper: init DEBUG: parsed 1 targets</span><br><span class="line">[    3.607768] device-mapper: init DEBUG: created device &#x27;253:0&#x27;</span><br><span class="line">[    3.607786] device-mapper: init: adding target &#x27;0 5643752 verity 1 PART...</span><br><span class="line">[    3.608872] device-mapper: init: dm-0 is ready</span><br><span class="line">[    3.789844] device-mapper: ioctl: [tj] cmd=3</span><br><span class="line">[    3.790567] device-mapper: ioctl: [tj] cmd=7</span><br><span class="line">[    3.790852] device-mapper: ioctl: [tj] cmd=9</span><br><span class="line">[    3.791799] device-mapper: ioctl: [tj] cmd=6</span><br><span class="line">[   10.834008] device-mapper: ioctl: [tj] cmd=2</span><br><span class="line">[   22.435064] device-mapper: ioctl: [tj] cmd=3</span><br><span class="line">[   22.436824] device-mapper: ioctl: [tj] cmd=7</span><br><span class="line">[   22.437049] device-mapper: ioctl: [tj] cmd=9</span><br><span class="line">[   22.437073] device-mapper: req-crypt DEBUG: dm-req-crypt Constructor.\x0a</span><br><span class="line">[   22.437189] device-mapper: req-crypt: req_crypt_ctr: Mapping block_device /dev/block/bootdevice/by-name/userdata to dm-req-crypt ok!\x0a</span><br><span class="line">[   22.437775] device-mapper: ioctl: [tj] cmd=6</span><br><span class="line">[   30.346430] device-mapper: ioctl: [tj] cmd=4</span><br><span class="line">[   30.346443] device-mapper: ioctl: unable to remove open device userdata</span><br><span class="line">[   31.346680] device-mapper: ioctl: [tj] cmd=4</span><br><span class="line">[   31.347242] device-mapper: req-crypt DEBUG: dm-req-crypt Destructor.\x0a</span><br><span class="line">[   32.843243] device-mapper: ioctl: [tj] cmd=3</span><br><span class="line">[   32.845567] device-mapper: ioctl: [tj] cmd=7</span><br><span class="line">[   32.845850] device-mapper: ioctl: [tj] cmd=9</span><br><span class="line">[   32.845881] device-mapper: req-crypt DEBUG: dm-req-crypt Constructor.\x0a</span><br><span class="line">[   32.846010] device-mapper: req-crypt: req_crypt_ctr: Mapping block_device /dev/block/bootdevice/by-name/userdata to dm-req-crypt ok!\x0a</span><br><span class="line">[   32.846667] device-mapper: ioctl: [tj] cmd=6</span><br></pre></td></tr></table></figure><p>其中cmd&#x3D;4是remove, 可见第一次失败，第二次ok了!。cmd 3,7,9,6是一个create_crypto_blk_dev里，最早那一组3 7 9 6应该是cmdline传上来的avb相关，也就是’253:0’。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/dev/block <span class="comment"># ls -l dm*</span></span><br><span class="line">brw------- 1 root root 253,   0 1970-01-06 21:29 dm-0 //system, should be dm-verity</span><br><span class="line">brw------- 1 root root 253,   1 1970-01-06 21:29 dm-1 //vendor, should be dm-verity</span><br><span class="line">brw------- 1 root root 253,   2 2008-12-31 16:00 dm-2 //userdata, dm-crypt</span><br></pre></td></tr></table></figure><p>所以Google原生这里异常处理我觉得应该是有问题的，具体patch如下：</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android AB系统recovery镜像构建分析</title>
      <link href="/analyze-recovery-build-under-ab-system.html"/>
      <url>/analyze-recovery-build-under-ab-system.html</url>
      
        <content type="html"><![CDATA[<p>A&#x2F;B系统是Google推的一种方便OTA升级版本的特性，好像是N就开始了。之前有好几个问题都是异常进recovery的，不过A&#x2F;B系统里已经去掉recovery分区了，不再编译recovery.img，那系统是怎么进的recovery？带着这个问题来看下。</p><p>先看看Google对recovery的介绍：</p><blockquote><p>recovery: The recovery partition stores the recovery image, booted during the OTA process. If the device supports A&#x2F;B updates, recovery can be a RAM disk contained in the boot image rather than a separate image.</p></blockquote><p>说的很清楚，recovery已经不作为独立的image存在，而是包含在boot image里。</p><p>看下makefile:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(ENABLE_AB)</span>, true)</span><br><span class="line"><span class="comment"># A/B related defines</span></span><br><span class="line">AB_OTA_UPDATER := true</span><br><span class="line"><span class="comment"># Full A/B partiton update set</span></span><br><span class="line"><span class="comment"># AB_OTA_PARTITIONS := xbl rpm tz hyp pmic modem abl boot keymaster cmnlib cmnlib64 system bluetooth</span></span><br><span class="line"><span class="comment"># Subset A/B partitions for Android-only image update</span></span><br><span class="line">AB_OTA_PARTITIONS ?= boot system</span><br><span class="line">BOARD_BUILD_SYSTEM_ROOT_IMAGE := true</span><br><span class="line">TARGET_NO_RECOVERY := true</span><br><span class="line">BOARD_USES_RECOVERY_AS_BOOT := true</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">BOARD_RECOVERYIMAGE_PARTITION_SIZE := 0x04000000</span><br><span class="line">BOARD_CACHEIMAGE_FILE_SYSTEM_TYPE := ext4</span><br><span class="line">BOARD_CACHEIMAGE_PARTITION_SIZE := 268435456</span><br><span class="line">TARGET_RECOVERY_UPDATER_LIBS += librecovery_updater_msm</span><br><span class="line"><span class="comment"># Enable System As Root even for non-A/B from P onwards</span></span><br><span class="line">BOARD_BUILD_SYSTEM_ROOT_IMAGE := true</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>A&#x2F;B系统定义了<code>TARGET_NO_RECOVERY</code>去recovery，<code>BOARD_USES_RECOVERY_AS_BOOT</code>意思就是build recovery作为boot image.</p><p>再看看这个宏的管控下都做了什么:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (,<span class="variable">$(<span class="built_in">filter</span> true, <span class="variable">$(TARGET_NO_KERNEL)</span> <span class="variable">$(TARGET_NO_RECOVERY)</span>)</span>)</span><br><span class="line">INSTALLED_RECOVERYIMAGE_TARGET := <span class="variable">$(PRODUCT_OUT)</span>/recovery.img</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">INSTALLED_RECOVERYIMAGE_TARGET :=</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Recovery image</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recovery image exists if we are building recovery, or building recovery as boot.</span></span><br><span class="line"><span class="keyword">ifneq</span> (,<span class="variable">$(INSTALLED_RECOVERYIMAGE_TARGET)</span><span class="variable">$(<span class="built_in">filter</span> true,<span class="variable">$(BOARD_USES_RECOVERY_AS_BOOT)</span>)</span>)</span><br></pre></td></tr></table></figure><p>有独立的recovery.img or BOARD_USES_RECOVERY_AS_BOOT&#x3D;true都进来。</p><p>继续看：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">INTERNAL_RECOVERYIMAGE_FILES := <span class="variable">$(<span class="built_in">filter</span> <span class="variable">$(TARGET_RECOVERY_OUT)</span>/%, \</span></span><br><span class="line"><span class="variable">    <span class="variable">$(ALL_DEFAULT_INSTALLED_MODULES)</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TARGET_COPY_OUT_RECOVERY := recovery</span><br><span class="line">...</span><br><span class="line">TARGET_RECOVERY_OUT := <span class="variable">$(PRODUCT_OUT)</span>/<span class="variable">$(TARGET_COPY_OUT_RECOVERY)</span></span><br><span class="line">TARGET_RECOVERY_ROOT_OUT := <span class="variable">$(TARGET_RECOVERY_OUT)</span>/root</span><br></pre></td></tr></table></figure><p>obj下能看到recovery目录，里面只有root。</p><p>继续看:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">recovery_kernel := <span class="variable">$(INSTALLED_KERNEL_TARGET)</span> <span class="comment"># same as a non-recovery system</span></span><br><span class="line">recovery_ramdisk := <span class="variable">$(PRODUCT_OUT)</span>/ramdisk-recovery.img</span><br></pre></td></tr></table></figure><p>recovery_kernel用的就是那kernel:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(TARGET_NO_KERNEL)</span>)</span>,true)</span><br><span class="line">  INSTALLED_KERNEL_TARGET := <span class="variable">$(PRODUCT_OUT)</span>/kernel</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  INSTALLED_KERNEL_TARGET :=</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>继续看：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">INTERNAL_RECOVERYIMAGE_ARGS := \</span><br><span class="line">        <span class="variable">$(<span class="built_in">addprefix</span> --second ,<span class="variable">$(INSTALLED_2NDBOOTLOADER_TARGET)</span>)</span> \</span><br><span class="line">        --kernel <span class="variable">$(recovery_kernel)</span> \</span><br><span class="line">        --ramdisk <span class="variable">$(recovery_ramdisk)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Assumes this has already been stripped</span></span><br><span class="line"><span class="keyword">ifdef</span> INTERNAL_KERNEL_CMDLINE</span><br><span class="line">  INTERNAL_RECOVERYIMAGE_ARGS += --cmdline <span class="string">&quot;<span class="variable">$(INTERNAL_KERNEL_CMDLINE)</span>&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifdef</span> BOARD_KERNEL_BASE</span><br><span class="line">  INTERNAL_RECOVERYIMAGE_ARGS += --base <span class="variable">$(BOARD_KERNEL_BASE)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifdef</span> BOARD_KERNEL_PAGESIZE</span><br><span class="line">  INTERNAL_RECOVERYIMAGE_ARGS += --pagesize <span class="variable">$(BOARD_KERNEL_PAGESIZE)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifdef</span> BOARD_INCLUDE_RECOVERY_DTBO</span><br><span class="line">  INTERNAL_RECOVERYIMAGE_ARGS += --recovery_dtbo <span class="variable">$(BOARD_PREBUILT_DTBOIMAGE)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>定义了许多参数, 接下来进入重要时刻, 咳咳:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $(1): output file</span></span><br><span class="line"><span class="keyword">define</span> build-recoveryimage-target</span><br><span class="line">  <span class="comment"># Making recovery image</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里有许多hide你可以放开看看。是谁在call <code>build-recoveryimage-target</code>？在下面:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">NSTALLED_BOOTIMAGE_TARGET := <span class="variable">$(PRODUCT_OUT)</span>/boot.img</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(BOARD_USES_RECOVERY_AS_BOOT)</span>,true)</span><br><span class="line">...</span><br><span class="line"><span class="variable">$(INSTALLED_BOOTIMAGE_TARGET)</span>: <span class="variable">$(MKBOOTFS)</span> <span class="variable">$(MKBOOTIMG)</span> <span class="variable">$(MINIGZIP)</span> <span class="variable">$(ADBD)</span> \</span><br><span class="line">                <span class="variable">$(INSTALLED_RAMDISK_TARGET)</span> \</span><br><span class="line">                <span class="variable">$(INTERNAL_RECOVERYIMAGE_FILES)</span> \</span><br><span class="line">                <span class="variable">$(recovery_initrc)</span> <span class="variable">$(recovery_sepolicy)</span> <span class="variable">$(recovery_kernel)</span> \</span><br><span class="line">                <span class="variable">$(INSTALLED_2NDBOOTLOADER_TARGET)</span> \</span><br><span class="line">                <span class="variable">$(recovery_build_props)</span> <span class="variable">$(recovery_resource_deps)</span> \</span><br><span class="line">                <span class="variable">$(recovery_fstab)</span> \</span><br><span class="line">                <span class="variable">$(RECOVERY_INSTALL_OTA_KEYS)</span> \</span><br><span class="line">                <span class="variable">$(INSTALLED_VENDOR_DEFAULT_PROP_TARGET)</span> \</span><br><span class="line">                <span class="variable">$(BOARD_RECOVERY_KERNEL_MODULES)</span> \</span><br><span class="line">                <span class="variable">$(DEPMOD)</span></span><br><span class="line">                <span class="variable">$(<span class="built_in">call</span> pretty,&quot;Target boot image from recovery: <span class="variable">$@</span>&quot;)</span></span><br><span class="line">                <span class="variable">$(<span class="built_in">call</span> build-recoveryimage-target, <span class="variable">$@</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>接下来的基本上是给独立image用的了:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(INSTALLED_RECOVERYIMAGE_TARGET)</span>: <span class="variable">$(MKBOOTFS)</span> <span class="variable">$(MKBOOTIMG)</span> <span class="variable">$(MINIGZIP)</span> <span class="variable">$(ADBD)</span> \</span><br><span class="line">                <span class="variable">$(INSTALLED_RAMDISK_TARGET)</span> \</span><br><span class="line">                <span class="variable">$(INSTALLED_BOOTIMAGE_TARGET)</span> \</span><br><span class="line">                <span class="variable">$(INTERNAL_RECOVERYIMAGE_FILES)</span> \</span><br><span class="line">                <span class="variable">$(recovery_initrc)</span> <span class="variable">$(recovery_sepolicy)</span> <span class="variable">$(recovery_kernel)</span> \</span><br><span class="line">                <span class="variable">$(INSTALLED_2NDBOOTLOADER_TARGET)</span> \</span><br><span class="line">                <span class="variable">$(recovery_build_props)</span> <span class="variable">$(recovery_resource_deps)</span> \</span><br><span class="line">                <span class="variable">$(recovery_fstab)</span> \</span><br><span class="line">                <span class="variable">$(RECOVERY_INSTALL_OTA_KEYS)</span> \</span><br><span class="line">                <span class="variable">$(INSTALLED_VENDOR_DEFAULT_PROP_TARGET)</span> \</span><br><span class="line">                <span class="variable">$(BOARD_RECOVERY_KERNEL_MODULES)</span> \</span><br><span class="line">                <span class="variable">$(DEPMOD)</span></span><br><span class="line">                <span class="variable">$(<span class="built_in">call</span> build-recoveryimage-target, <span class="variable">$@</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifdef</span> RECOVERY_RESOURCE_ZIP</span><br><span class="line"><span class="variable">$(RECOVERY_RESOURCE_ZIP)</span>: <span class="variable">$(INSTALLED_RECOVERYIMAGE_TARGET)</span> | <span class="variable">$(ZIPTIME)</span></span><br><span class="line">        <span class="variable">$(hide)</span> mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">        <span class="variable">$(hide)</span> find <span class="variable">$(TARGET_RECOVERY_ROOT_OUT)</span>/res -type f | sort | zip -0qrjX <span class="variable">$@</span> -@</span><br><span class="line">        $(remove-timestamps-from-package)</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: recoveryimage-nodeps</span></span><br><span class="line"><span class="section">recoveryimage-nodeps:</span></span><br><span class="line">        @echo <span class="string">&quot;make <span class="variable">$@</span>: ignoring dependencies&quot;</span></span><br><span class="line">        <span class="variable">$(<span class="built_in">call</span> build-recoveryimage-target, <span class="variable">$(INSTALLED_RECOVERYIMAGE_TARGET)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="comment"># INSTALLED_RECOVERYIMAGE_TARGET not defined</span></span><br><span class="line">RECOVERY_RESOURCE_ZIP :=</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: recoveryimage</span></span><br><span class="line"><span class="section">recoveryimage: <span class="variable">$(INSTALLED_RECOVERYIMAGE_TARGET)</span> <span class="variable">$(RECOVERY_RESOURCE_ZIP)</span></span></span><br></pre></td></tr></table></figure><p>那bootable&#x2F;recovery下的代码是编译成什么的了？</p><p>来看Android.mk:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># recovery (static executable)</span></span><br><span class="line"><span class="comment"># ===============================</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES := \</span><br><span class="line">    adb_install.cpp \</span><br><span class="line">    device.cpp \</span><br><span class="line">    fuse_sdcard_provider.cpp \</span><br><span class="line">    recovery.cpp \</span><br><span class="line">    roots.cpp \</span><br><span class="line">    rotate_logs.cpp \</span><br><span class="line">    screen_ui.cpp \</span><br><span class="line">    ui.cpp \</span><br><span class="line">    vr_ui.cpp \</span><br><span class="line">    wear_ui.cpp \</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := recovery</span><br></pre></td></tr></table></figure><p>恢复模式的”Can’t load Android System”就在recovery.cpp里，很明显是编译成recovery可执行文件，具体在obj目录能找到:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./recovery/root/sbin/recovery</span><br></pre></td></tr></table></figure><p>应该是放到recovery_ramdisk里了，这个ramdisk是怎么生成了的，其实就是上面提到的<code>build-recoveryimage-target</code>:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TARGET_RECOVERY_ROOT_OUT := <span class="variable">$(TARGET_RECOVERY_OUT)</span>/root</span><br><span class="line">...</span><br><span class="line"><span class="variable">$(hide)</span> <span class="variable">$(MKBOOTFS)</span> -d <span class="variable">$(TARGET_OUT)</span> <span class="variable">$(TARGET_RECOVERY_ROOT_OUT)</span> | <span class="variable">$(MINIGZIP)</span> &gt; <span class="variable">$(recovery_ramdisk)</span></span><br></pre></td></tr></table></figure><p>可见TARGET_RECOVERY_ROOT_OUT就是ramdisk的来源。</p><p>very clear, ehe…</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recovery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android启动时在加密界面后进恢复模式分析</title>
      <link href="/analyze-reboot-to-recovery-when-encrpt-under-android.html"/>
      <url>/analyze-reboot-to-recovery-when-encrpt-under-android.html</url>
      
        <content type="html"><![CDATA[<p>异常进recovery前面已经分析过主要是persist进程crash too many，所以导致进恢复模式，显示”Can’t load Android system”。</p><p>现在又出现这个恢复界面，是在刷完版本第一次开机加密时进入，看离线logcat，竟然没有”FACTORY_RESET”记录，难道和加密有关？</p><p>上OpenGrok搜下prompt_and_wipe_data:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/bootable/recovery/</span><br><span class="line">H A Drecovery.cpp96 &#123; &quot;prompt_and_wipe_data&quot;, no_argument, NULL, 0 &#125;,</span><br><span class="line">149 * --prompt_and_wipe_data - prompt the user that data is corrupt,</span><br><span class="line">764 static bool prompt_and_wipe_data(Device* device) &#123; function </span><br><span class="line">1486 &#125; else if (option == &quot;prompt_and_wipe_data&quot;) &#123;</span><br><span class="line">1631 if (!prompt_and_wipe_data(device)) &#123;</span><br><span class="line">/system/core/init/</span><br><span class="line">H A Dbuiltins.cpp263 &quot;--prompt_and_wipe_data&quot;,</span><br><span class="line">/frameworks/base/core/java/android/os/</span><br><span class="line">H A DRecoverySystem.java902 bootCommand(context, null, &quot;--prompt_and_wipe_data&quot;, reasonArg, localeArg);</span><br></pre></td></tr></table></figure><p>除了java外，还有system也会call，实际上是两处：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./core/init/builtins.cpp:291:                &#123;<span class="string">&quot;--prompt_and_wipe_data&quot;</span>, <span class="string">&quot;--reason=set_policy_failed:&quot;</span>s + args[1]&#125;);</span><br><span class="line">./core/init/builtins.cpp:1004:                reboot_into_recovery(&#123;<span class="string">&quot;--prompt_and_wipe_data&quot;</span>, <span class="string">&quot;--reason=&quot;</span>s + reboot_reason&#125;);</span><br></pre></td></tr></table></figure><p>看下code：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (<span class="built_in">e4crypt_is_native</span>()) &#123;</span><br><span class="line">                <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Rebooting into recovery, reason: &quot;</span> &lt;&lt; reboot_reason;</span><br><span class="line">                <span class="built_in">reboot_into_recovery</span>(&#123;<span class="string">&quot;--prompt_and_wipe_data&quot;</span>, <span class="string">&quot;--reason=&quot;</span>s + reboot_reason&#125;);</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">e4crypt_is_native</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">e4crypt_set_directory_policy</span>(args[<span class="number">1</span>].<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">reboot_into_recovery</span>(</span><br><span class="line">                &#123;<span class="string">&quot;--prompt_and_wipe_data&quot;</span>, <span class="string">&quot;--reason=set_policy_failed:&quot;</span>s + args[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>log里没有发现”Rebooting into recovery, reason: “ ，lets check <code>e4crypt_is_native</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">e4crypt_is_native</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="built_in">property_get</span>(<span class="string">&quot;ro.crypto.type&quot;</span>, value, <span class="string">&quot;none&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">strcmp</span>(value, <span class="string">&quot;file&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统属性<code>ro.crypto.type</code>要是file才会触发，看下项目的：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/ <span class="comment"># getprop ro.crypto.type</span></span><br><span class="line">block</span><br></pre></td></tr></table></figure><p>很明显不是嘛，我去，那是什么导致进入的？有个线索是recovery log会记录reason，reason会保存到cache分区，来看bootable&#x2F;recovery.cpp:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;reason is [%s]\n&quot;</span>, reason);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">copy_logs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Always write to pmsg, this allows the OTA logs to be caught in logcat -L</span></span><br><span class="line">    <span class="built_in">copy_log_file_to_pmsg</span>(TEMPORARY_LOG_FILE, LAST_LOG_FILE);</span><br><span class="line">    <span class="built_in">copy_log_file_to_pmsg</span>(TEMPORARY_INSTALL_FILE, LAST_INSTALL_FILE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can do nothing for now if there&#x27;s no /cache partition.</span></span><br><span class="line">    <span class="keyword">if</span> (!has_cache) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ensure_path_mounted</span>(LAST_LOG_FILE);</span><br><span class="line">    <span class="built_in">ensure_path_mounted</span>(LAST_KMSG_FILE);</span><br><span class="line">    <span class="built_in">rotate_logs</span>(LAST_LOG_FILE, LAST_KMSG_FILE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy logs to cache so the system can find out what happened.</span></span><br><span class="line">    <span class="built_in">copy_log_file</span>(TEMPORARY_LOG_FILE, LOG_FILE, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">copy_log_file</span>(TEMPORARY_LOG_FILE, LAST_LOG_FILE, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">copy_log_file</span>(TEMPORARY_INSTALL_FILE, LAST_INSTALL_FILE, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">save_kernel_log</span>(LAST_KMSG_FILE);</span><br></pre></td></tr></table></figure><p>但是我们启用了OTA A&#x2F;B系统把cache分区移除了，其实google在A&#x2F;B启用后对cache分区的要求是可选的：</p><blockquote><p>cache: The cache partition stores temporary data and is optional if a device uses A&#x2F;B updates. The cache partition doesn’t need to be writable from the bootloader, only erasable. The size depends on the device type and the availability of space on userdata. Currently 50MB-100MB should be ok.</p></blockquote><p>目前9.0 recovery log默认还是存在cache分区的，所以建议在A&#x2F;B使能后保留cache分区，当然你把log存储path改到&#x2F;data&#x2F;misc&#x2F;recovery也行，参考README.md:</p><blockquote><h2 id="Running-the-manual-tests"><a href="#Running-the-manual-tests" class="headerlink" title="Running the manual tests"></a>Running the manual tests</h2><p><code>recovery-refresh</code> and <code>recovery-persist</code> executables exist only on systems without<br>&#x2F;cache partition. And we need to follow special steps to run tests for them.</p></blockquote><p>看下recovery-persist.cpp:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *LAST_LOG_FILE = <span class="string">&quot;/data/misc/recovery/last_log&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *LAST_KMSG_FILE = <span class="string">&quot;/data/misc/recovery/last_kmsg&quot;</span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">logsave</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">log_id_t</span> <span class="comment">/* logId */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">char</span> <span class="comment">/* prio */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *filename,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span> * <span class="comment">/* arg */</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">destination</span><span class="params">(<span class="string">&quot;/data/misc/&quot;</span>)</span></span>;</span><br><span class="line">    destination += filename;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * TBD: Future location to move content from</span></span><br><span class="line"><span class="comment">         * /cache/recovery to /data/misc/recovery/</span></span><br><span class="line"><span class="comment">         */</span></span><br></pre></td></tr></table></figure><p>so, 没有cache分区可以转到&#x2F;data&#x2F;misc&#x2F;recovery下。</p><p>懒得改了，这个问题在user版本下出现，对应的userdebug死活出不来，没有log没有证据啊。换个新的userdebug版本竟然出现了，adb还在，赶紧抓下，发现还是persist process crash too many导致的。</p><p>为了帮助定位问题，其实可以在屏幕上把reason打出来, rt?</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recovery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Analyze an issue about &amp;quot;Can&#39;t load Android system&amp;quot;</title>
      <link href="/analyze-an-issue-about-can-not-load-android-system.html"/>
      <url>/analyze-an-issue-about-can-not-load-android-system.html</url>
      
        <content type="html"><![CDATA[<p>Android 9.0启动中异常进入recovery界面，提示”Can’t load Android system”, 只有两个菜单选项try again + factory reset。</p><p>framework同事没看，那我来吧，还是先跟下代码。</p><p>bootable&#x2F;recovery:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">prompt_and_wipe_data</span><span class="params">(Device* device)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Use a single string and let ScreenRecoveryUI handles the wrapping.</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> headers[] = &#123;</span><br><span class="line">    <span class="string">&quot;Can&#x27;t load Android system. Your data may be corrupt. &quot;</span></span><br><span class="line">    <span class="string">&quot;If you continue to get this message, you may need to &quot;</span></span><br><span class="line">    <span class="string">&quot;perform a factory data reset and erase all user data &quot;</span></span><br><span class="line">    <span class="string">&quot;stored on this device.&quot;</span>,</span><br><span class="line">    <span class="literal">nullptr</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> items[] = &#123;</span><br><span class="line">    <span class="string">&quot;Try again&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Factory data reset&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span> </span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">int</span> chosen_item = <span class="built_in">get_menu_selection</span>(headers, items, <span class="literal">true</span>, <span class="number">0</span>, device);</span><br><span class="line">    <span class="keyword">if</span> (chosen_item != <span class="number">1</span>) &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Just reboot, no wipe; not a failure, user asked for it</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ask_to_wipe_data</span>(device)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">wipe_data</span>(device);</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>framework&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;RecoverySystem.java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** &#123;<span class="doctag">@hide</span>&#125; */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rebootPromptAndWipeUserData</span><span class="params">(Context context, String reason)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">reasonArg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">if</span> (!TextUtils.isEmpty(reason)) &#123;</span><br><span class="line">         reasonArg = <span class="string">&quot;--reason=&quot;</span> + sanitizeArg(reason);</span><br><span class="line">     &#125;    </span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> <span class="type">String</span> <span class="variable">localeArg</span> <span class="operator">=</span> <span class="string">&quot;--locale=&quot;</span> + Locale.getDefault().toString();</span><br><span class="line">     bootCommand(context, <span class="literal">null</span>, <span class="string">&quot;--prompt_and_wipe_data&quot;</span>, reasonArg, localeArg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>who call rebootPromptAndWipeUserData?</p><p>framework&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;RescueParty.java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">executeRescueLevelInternal</span><span class="params">(Context context, <span class="type">int</span> level)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">switch</span> (level) &#123;</span><br><span class="line">        <span class="keyword">case</span> LEVEL_RESET_SETTINGS_UNTRUSTED_DEFAULTS:</span><br><span class="line">            resetAllSettings(context, Settings.RESET_MODE_UNTRUSTED_DEFAULTS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LEVEL_RESET_SETTINGS_UNTRUSTED_CHANGES:</span><br><span class="line">            resetAllSettings(context, Settings.RESET_MODE_UNTRUSTED_CHANGES);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LEVEL_RESET_SETTINGS_TRUSTED_DEFAULTS:</span><br><span class="line">            resetAllSettings(context, Settings.RESET_MODE_TRUSTED_DEFAULTS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LEVEL_FACTORY_RESET:</span><br><span class="line">            RecoverySystem.rebootPromptAndWipeUserData(context, TAG); <span class="comment">//tj: here</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">executeRescueLevel</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> SystemProperties.getInt(PROP_RESCUE_LEVEL, LEVEL_NONE);</span><br><span class="line">    <span class="keyword">if</span> (level == LEVEL_NONE) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    Slog.w(TAG, <span class="string">&quot;Attempting rescue level &quot;</span> + levelToString(level));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executeRescueLevelInternal(context, level);</span><br><span class="line">        EventLogTags.writeRescueSuccess(level);</span><br><span class="line">        logCriticalInfo(Log.DEBUG,</span><br><span class="line">                <span class="string">&quot;Finished rescue level &quot;</span> + levelToString(level));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> ExceptionUtils.getCompleteMessage(t);</span><br><span class="line">        EventLogTags.writeRescueFailure(level, msg);</span><br><span class="line">        logCriticalInfo(Log.ERROR,</span><br><span class="line">                <span class="string">&quot;Failed rescue level &quot;</span> + levelToString(level) + <span class="string">&quot;: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lets check log:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4353 10-02 15:52:52.477  2468  3711 W RescueParty: Noticed 5 events for UID 1001 in last 4 sec</span><br><span class="line">4354 10-02 15:52:52.480  2468  3711 W PackageManager: Incremented rescue level to FACTORY_RESET triggered by UID 1001</span><br><span class="line">4355 10-02 15:52:52.481  2468  3711 W RescueParty: Attempting rescue level FACTORY_RESET</span><br></pre></td></tr></table></figure><p>ok, 到这里应该知道了是UID 1001触发的。UID 1001定义:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AID_RADIO 1001           <span class="comment">/* telephony subsystem, RIL */</span></span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/ <span class="comment"># ps -A | grep ril</span></span><br><span class="line">radio         2313     1  124168  22896 binder_thread_read  0 S qcrild</span><br><span class="line">radio         3534  2012 3699156  79284 SyS_epoll_wait      0 S com.qualcomm.qcr</span><br><span class="line">ilmsgtunnel</span><br><span class="line">xxx:/ <span class="comment"># id radio</span></span><br><span class="line">uid=1001(radio) gid=1001(radio) <span class="built_in">groups</span>=1001(radio), context=u:r:su:s0</span><br><span class="line">xxx:/ <span class="comment"># </span></span><br></pre></td></tr></table></figure><p>那UID 1001为什么要触发了？继续根据log看。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">incrementRescueLevel</span><span class="params">(<span class="type">int</span> triggerUid)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> MathUtils.constrain(</span><br><span class="line">            SystemProperties.getInt(PROP_RESCUE_LEVEL, LEVEL_NONE) + <span class="number">1</span>,</span><br><span class="line">            LEVEL_NONE, LEVEL_FACTORY_RESET);</span><br><span class="line">    SystemProperties.set(PROP_RESCUE_LEVEL, Integer.toString(level));</span><br><span class="line"></span><br><span class="line">    EventLogTags.writeRescueLevel(level, triggerUid);</span><br><span class="line">    logCriticalInfo(Log.WARN, <span class="string">&quot;Incremented rescue level to &quot;</span></span><br><span class="line">            + levelToString(level) + <span class="string">&quot; triggered by UID &quot;</span> + triggerUid);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Take note of a boot event. If we notice too many of these events</span></span><br><span class="line"><span class="comment"> * happening in rapid succession, we&#x27;ll send out a rescue party.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">noteBoot</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDisabled()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sBoot.incrementAndTest()) &#123;</span><br><span class="line">        sBoot.reset();</span><br><span class="line">        incrementRescueLevel(sBoot.uid);</span><br><span class="line">        executeRescueLevel(context);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Take note of a persistent app crash. If we notice too many of these</span></span><br><span class="line"><span class="comment"> * events happening in rapid succession, we&#x27;ll send out a rescue party.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">notePersistentAppCrash</span><span class="params">(Context context, <span class="type">int</span> uid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDisabled()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">Threshold</span> <span class="variable">t</span> <span class="operator">=</span> sApps.get(uid);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">        t = <span class="keyword">new</span> <span class="title class_">AppThreshold</span>(uid);</span><br><span class="line">        sApps.put(uid, t); </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (t.incrementAndTest()) &#123;</span><br><span class="line">        t.reset();</span><br><span class="line">        incrementRescueLevel(t.uid);</span><br><span class="line">        executeRescueLevel(context);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>这里是noteBoot还是notePersistentAppCrash了，看log: </p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">10-02 15:52:51.653  2468  3661 W ActivityManager: Process com.gsma.rcs has crashed too many times: killing!</span><br><span class="line">10-02 15:52:51.776  2468  2478 I ActivityManager: Process com.gsma.rcs (pid 8381) has died: pers PER</span><br><span class="line">4340 10-02 15:52:51.777  2468  2478 W ActivityManager: Scheduling restart of crashed service com.gsma.rcs/.service.RcsCoreService in 0ms</span><br><span class="line">10-02 15:52:51.777  2468  2478 W ActivityManager: Scheduling restart of crashed service com.gsma.rcs/.service.StartService in 0ms</span><br><span class="line">10-02 15:52:51.777  2468  2478 W ActivityManager: Re-adding persistent process ProcessRecord&#123;dd29265 8381:com.gsma.rcs/1001&#125;</span><br><span class="line">10-02 15:52:51.823  2468  2484 I ActivityManager: Start proc 8432:com.gsma.rcs/1001 for restart com.gsma.rcs</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/ <span class="comment"># ps -A | grep rcs</span></span><br><span class="line">system        2009     1   18592   5680 binder_thread_read  0 S imsrcsd</span><br><span class="line">radio         3743  2012 4363308  66952 SyS_epoll_wait      0 S com.gsma.rcs</span><br><span class="line">xxx:/ <span class="comment">#</span></span><br><span class="line">xxx:/ <span class="comment"># id radio</span></span><br><span class="line">uid=1001(radio) gid=1001(radio) <span class="built_in">groups</span>=1001(radio), context=u:r:su:s0</span><br><span class="line">xxx:/ <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>so, it’s com.gsma.rcs triggered, need check gsma.rcs crash stack, forward to app check…</p><p>所以，也不一定恢复出厂就能解决这类问题。为啥不把notes写到recovery文字菜单界面？ 一看就知道原因了啊。</p><p>by the way, eng&#x2F;userdebug+usb connect不会出现这个画面。</p><pre><code class="java">    void crashApplicationInner(ProcessRecord r, ApplicationErrorReport.CrashInfo crashInfo,            int callingPid, int callingUid) &#123;        long timeMillis = System.currentTimeMillis();        String shortMsg = crashInfo.exceptionClassName;        String longMsg = crashInfo.exceptionMessage;        String stackTrace = crashInfo.stackTrace;        if (shortMsg != null &amp;&amp; longMsg != null) &#123;            longMsg = shortMsg + &quot;: &quot; + longMsg;        &#125; else if (shortMsg != null) &#123;            longMsg = shortMsg;        &#125;            // If a persistent app is stuck in a crash loop, the device isn&#39;t very        // usable, so we want to consider sending out a rescue party.        if (r != null &amp;&amp; r.persistent) &#123;            RescueParty.notePersistentAppCrash(mContext, r.uid);        &#125;     private static boolean isDisabled() &#123;        // Check if we&#39;re explicitly enabled for testing        if (SystemProperties.getBoolean(PROP_ENABLE_RESCUE, false)) &#123;            return false;        &#125;           // We&#39;re disabled on all engineering devices        if (Build.IS_ENG) &#123;            Slog.v(TAG, &quot;Disabled because of eng build&quot;);            return true;        &#125;           // We&#39;re disabled on userdebug devices connected over USB, since that&#39;s        // a decent signal that someone is actively trying to debug the device,        // or that it&#39;s in a lab environment.        if (Build.IS_USERDEBUG &amp;&amp; isUsbActive()) &#123;            Slog.v(TAG, &quot;Disabled because of active USB connection&quot;);            return true;        &#125;           // One last-ditch check        if (SystemProperties.getBoolean(PROP_DISABLE_RESCUE, false)) &#123;            Slog.v(TAG, &quot;Disabled because of manual property&quot;);            return true;        &#125;           return false;    &#125;  </code></pre><p>另外对Google A&#x2F;B分区使能的系统，cache分区是被删掉的，而recovery会把他的log存在cache分区，目前原生recovery并不支持。</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recovery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android P LMKD分析二</title>
      <link href="/analyze2-lmkd-for-android-p.html"/>
      <url>/analyze2-lmkd-for-android-p.html</url>
      
        <content type="html"><![CDATA[<p>关于mp_event_common接受的内存压力事件，是从内核而来，简单说下。</p><p>先来看下<a href="https://source.android.com/devices/tech/perf/lmkd">官方的介绍</a>:</p><blockquote><p>Historically, Android used in-kernel lowmemorykiller driver to handle memory pressure situations by killing non-essential processes. This mechanism is rigid and depends on hard-coded values. In addition, starting with kernel 4.12, the lowmemorykiller driver is excluded from the upstream kernel.</p><p>The userspace lmkd process implements the same functionality but with already existing kernel mechanisms to detect and estimate memory pressure. It uses vmpressure events generated by the kernel to get notifications about memory pressure levels. It also can use memory cgroup features to limit memory resources allocated to each process based on its importance.</p></blockquote><p>这里还说了老的内核minfree的缺点，就是太死板，我去，那7.0还用着呢, 9.0依然可以用，除非内核不支持了。</p><p>介绍也说了用已经存在的内核机制就是kernel vmpressure探测评估内存压力，然后lmkd去获取这个状态，也就是代码看到的event相关代码。</p><p>vmpressure以前也大概分析过，可以看这里：<a href="http://tjtech.me/understand-linux-vmpressure.html">vmpressure分析</a>。</p><p>vmpressure本身就定义了low, medium, critical三类内存压力状态，所以能看到在lmkd 初始化时init了这三种状态，至于怎么和kernel交互，已经偏用户态了,主要是epoll。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (use_inkernel_interface) &#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;Using in-kernel low memory killer interface&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!init_mp_common(VMPRESS_LEVEL_LOW) ||</span><br><span class="line">        !init_mp_common(VMPRESS_LEVEL_MEDIUM) ||</span><br><span class="line">        !init_mp_common(VMPRESS_LEVEL_CRITICAL)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Kernel does not support memory pressure events or in-kernel low memory killer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init_mp_common</code>里注册 by EPOLL_CTL_ADD：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">epev.events = EPOLLIN;</span><br><span class="line"><span class="comment">/* use data to store event level */</span></span><br><span class="line">vmpressure_hinfo[level_idx].data = level_idx;</span><br><span class="line">vmpressure_hinfo[level_idx].handler = mp_event_common;</span><br><span class="line">epev.data.ptr = (<span class="type">void</span> *)&amp;vmpressure_hinfo[level_idx];</span><br><span class="line">ret = epoll_ctl(epollfd, EPOLL_CTL_ADD, evfd, &amp;epev);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">&quot;epoll_ctl for level %s failed; errno=%d&quot;</span>, levelstr, errno);</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">maxevents++;</span><br><span class="line">mpevfd[level] = evfd;</span><br></pre></td></tr></table></figure><p>另外就是策略的选择，看了下骁龙625 P kernel4. 9还是用的in kernel。</p><p>至于用户态属性怎么配置，机制大概都明白了，我想还是根据遇到的问题以及性能测试为主，rt?</p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LMK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android P LMKD分析一</title>
      <link href="/analyze1-lmkd-for-android-p.html"/>
      <url>/analyze1-lmkd-for-android-p.html</url>
      
        <content type="html"><![CDATA[<p>Android P lmkd新增了许多机制和属性，包括引入原来内核的minfree算法等，看样子是越来越复杂了，下面来看看，内核版本4.9，高通平台。</p><h2 id="how-to-kill"><a href="#how-to-kill" class="headerlink" title="how to kill"></a>how to kill</h2><p>先看下应该杀掉哪个process or 哪些processes(yes, 已经支持)？</p><p>主要改动是：</p><ul><li>support kill heaviest process</li><li>support kill multiple processes</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find processes to kill to free required number of pages.</span></span><br><span class="line"><span class="comment"> * If pages_to_free is set to 0 only one process will be killed.</span></span><br><span class="line"><span class="comment"> * Returns the size of the killed processes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">find_and_kill_processes</span><span class="params">(<span class="keyword">enum</span> vmpressure_level level,</span></span><br><span class="line"><span class="params">                                   <span class="type">int</span> min_score_adj, <span class="type">int</span> pages_to_free)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> killed_size;</span><br><span class="line">    <span class="type">int</span> pages_freed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LMKD_LOG_STATS</span></span><br><span class="line">    <span class="type">bool</span> lmk_state_change_start = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = OOM_SCORE_ADJ_MAX; i &gt;= min_score_adj; i--) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">procp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            procp = kill_heaviest_task ?</span><br><span class="line">                proc_get_heaviest(i) : proc_adj_lru(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!procp)</span><br><span class="line">                <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kill_heaviest_task =</span><br><span class="line">    property_get_bool(<span class="string">&quot;ro.lmk.kill_heaviest_task&quot;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>可见还是从大adj开始，如果我们要kill heaviest task, 那就选个heaviest的杀掉吧，否则按proc_adj_lru来选择。默认heaviest task是关闭的，到底哪一种效果好？靠你了:]</p><p>heaviest是什么意思？看样子就是占用大内存的，看code:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">proc_get_heaviest</span><span class="params">(<span class="type">int</span> oomadj)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> *<span class="title">head</span> =</span> &amp;procadjslot_list[ADJTOSLOT(oomadj)];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> *<span class="title">curr</span> =</span> head-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">maxprocp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> maxsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr != head) &#123;</span><br><span class="line">        <span class="type">int</span> pid = ((<span class="keyword">struct</span> proc *)curr)-&gt;pid;</span><br><span class="line">        <span class="type">int</span> tasksize = proc_get_size(pid);</span><br><span class="line">        <span class="keyword">if</span> (tasksize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> *<span class="title">next</span> =</span> curr-&gt;next;</span><br><span class="line">            pid_remove(pid);</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (tasksize &gt; maxsize) &#123;</span><br><span class="line">                maxsize = tasksize;</span><br><span class="line">                maxprocp = (<span class="keyword">struct</span> proc *)curr;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprocp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个adj的list里选个size(rss)最大的，size从&#x2F;proc&#x2F;pid&#x2F;statm里取，也就是adj越大&amp;&amp;占用内存越大越容易被杀，和原来内核的策略一样一样的。</p><p>proc_adj_lru就是在这个adj的list里选了个tail(最不活跃？)的杀掉。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">proc_adj_lru</span><span class="params">(<span class="type">int</span> oomadj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> proc *)adjslot_tail(&amp;procadjslot_list[ADJTOSLOT(oomadj)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">            killed_size = kill_one_process(procp, min_score_adj, level);</span><br><span class="line">            <span class="keyword">if</span> (killed_size &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LMKD_LOG_STATS</span></span><br><span class="line">                <span class="keyword">if</span> (enable_stats_log &amp;&amp; !lmk_state_change_start) &#123;</span><br><span class="line">                    lmk_state_change_start = <span class="literal">true</span>;</span><br><span class="line">                    stats_write_lmk_state_changed(log_ctx, LMK_STATE_CHANGED,</span><br><span class="line">                                                  LMK_STATE_CHANGE_START);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                pages_freed += killed_size;</span><br><span class="line">                <span class="keyword">if</span> (pages_freed &gt;= pages_to_free) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LMKD_LOG_STATS</span></span><br><span class="line">                    <span class="keyword">if</span> (enable_stats_log &amp;&amp; lmk_state_change_start) &#123;</span><br><span class="line">                        stats_write_lmk_state_changed(log_ctx, LMK_STATE_CHANGED,</span><br><span class="line">                                LMK_STATE_CHANGE_STOP);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                    <span class="keyword">return</span> pages_freed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>kill_one_process杀完后会check pages_freed是不是达标到pages_to_free，如果是就ok了，否则继续。</p><p>ok, 那什么时候去杀？如何探测内存压力？ 具体就是lmkd接收到memory pressure事件后在这个event的handler (mp_event_common)里去处理。</p><h2 id="when-to-kill"><a href="#when-to-kill" class="headerlink" title="when to kill"></a>when to kill</h2><p>mp_event_common 9.0最大的变化相比8.0就是:</p><ul><li>增加minfree algorithem</li><li>区分low ram device and high performance device</li><li>高通加入adaptive逻辑(参考msm kernel adaptive lmk)，一个加强小特性</li></ul><p>一上来会根据meminfo和zoneinfo记录相关内存信息。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (meminfo_parse(&amp;mi) &lt; <span class="number">0</span> || zoneinfo_parse(&amp;zi) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">&quot;Failed to get free memory!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果开启了use_minfree_levels(默认是关闭的):</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">use_minfree_levels =</span><br><span class="line">    property_get_bool(<span class="string">&quot;ro.lmk.use_minfree_levels&quot;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (use_minfree_levels) &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    other_free = mi.field.nr_free_pages - zi.field.totalreserve_pages;</span><br><span class="line">    <span class="keyword">if</span> (mi.field.nr_file_pages &gt; (mi.field.shmem + mi.field.unevictable + mi.field.swap_cached)) &#123;</span><br><span class="line">        other_file = (mi.field.nr_file_pages - mi.field.shmem -</span><br><span class="line">                      mi.field.unevictable - mi.field.swap_cached);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        other_file = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    min_score_adj = OOM_SCORE_ADJ_MAX + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lowmem_targets_size; i++) &#123;</span><br><span class="line">        minfree = lowmem_minfree[i];</span><br><span class="line">        <span class="keyword">if</span> (other_free &lt; minfree &amp;&amp; other_file &lt; minfree) &#123;</span><br><span class="line">            min_score_adj = lowmem_adj[i];</span><br><span class="line">            <span class="comment">// Adaptive LMK</span></span><br><span class="line">            <span class="keyword">if</span> (enable_adaptive_lmk &amp;&amp; level == VMPRESS_LEVEL_CRITICAL &amp;&amp;</span><br><span class="line">                    i &gt; lowmem_targets_size<span class="number">-4</span>) &#123;</span><br><span class="line">                min_score_adj = lowmem_adj[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (min_score_adj == OOM_SCORE_ADJ_MAX + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(<span class="string">&quot;Ignore %s memory pressure event &quot;</span></span><br><span class="line">                  <span class="string">&quot;(free memory=%ldkB, cache=%ldkB, limit=%ldkB)&quot;</span>,</span><br><span class="line">                  level_name[level], other_free * page_k, other_file * page_k,</span><br><span class="line">                  (<span class="type">long</span>)lowmem_minfree[lowmem_targets_size - <span class="number">1</span>] * page_k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enhance_batch_kill) &#123;</span><br><span class="line">        <span class="comment">// Kill one process at a time.</span></span><br><span class="line">        pages_to_free = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Original minfree logic */</span></span><br><span class="line">        <span class="comment">/* Free up enough pages to push over the highest minfree level */</span></span><br><span class="line">        pages_to_free = lowmem_minfree[lowmem_targets_size - <span class="number">1</span>] -</span><br><span class="line">            ((other_free &lt; other_file) ? other_free : other_file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> do_kill;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和内核逻辑一样，查看当前剩余内存是否在minfree分段范围内，如果在那么就把这个minfree对应的adj给到min_score_adj，那要释放多少内存了？</p><p>高通默认关闭了多个任务的逻辑，只允许杀一个进程:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (enhance_batch_kill) &#123;</span><br><span class="line">     <span class="comment">// Kill one process at a time.</span></span><br><span class="line">     pages_to_free = <span class="number">0</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">/* Original minfree logic */</span></span><br><span class="line">     <span class="comment">/* Free up enough pages to push over the highest minfree level */</span></span><br><span class="line">     pages_to_free = lowmem_minfree[lowmem_targets_size - <span class="number">1</span>] -</span><br><span class="line">         ((other_free &lt; other_file) ? other_free : other_file);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果要杀多个进程，就是把那个距离minfree的差值要释放出来。</p><p>另外，高通加的这段：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adaptive LMK</span></span><br><span class="line"><span class="keyword">if</span> (enable_adaptive_lmk &amp;&amp; level == VMPRESS_LEVEL_CRITICAL &amp;&amp;</span><br><span class="line">        i &gt; lowmem_targets_size<span class="number">-4</span>) &#123;</span><br><span class="line">    min_score_adj = lowmem_adj[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是在critical内存特紧张时，可以杀更低一级的adj的task。</p><p>ok，下来看下计算swapping是否频繁：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mem_usage = get_memory_usage(&amp;mem_usage_file_data)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> do_kill;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((memsw_usage = get_memory_usage(&amp;memsw_usage_file_data)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> do_kill;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate percent for swappinness.</span></span><br><span class="line">mem_pressure = (mem_usage * <span class="number">100</span>) / memsw_usage;</span><br></pre></td></tr></table></figure><p>没内存的直接去do_kill了，swapping从memcg处获得。</p><p>下来根据swapping情况判断是否要upgrade or downgrade level，默认关闭了, go上使能。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (enable_pressure_upgrade &amp;&amp; level != VMPRESS_LEVEL_CRITICAL) &#123;</span><br><span class="line">    <span class="comment">// We are swapping too much.</span></span><br><span class="line">    <span class="keyword">if</span> (mem_pressure &lt; upgrade_pressure) &#123;</span><br><span class="line">        level = upgrade_level(level);</span><br><span class="line">        <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(<span class="string">&quot;Event upgraded to %s&quot;</span>, level_name[level]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the pressure is larger than downgrade_pressure lmk will not</span></span><br><span class="line"><span class="comment">// kill any process, since enough memory is available.</span></span><br><span class="line"><span class="keyword">if</span> (mem_pressure &gt; downgrade_pressure) &#123;</span><br><span class="line">    <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;Ignore %s memory pressure&quot;</span>, level_name[level]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (level == VMPRESS_LEVEL_CRITICAL &amp;&amp;</span><br><span class="line">           mem_pressure &gt; upgrade_pressure) &#123;</span><br><span class="line">    <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;Downgrade critical memory pressure&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Downgrade event, since enough memory available.</span></span><br><span class="line">    level = downgrade_level(level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前的文章已经分析过。</p><p>下来看do_kill:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">do_kill:</span><br><span class="line">    <span class="keyword">if</span> (low_ram_device) &#123;</span><br><span class="line">        <span class="comment">/* For Go devices kill only one task */</span></span><br><span class="line">        <span class="keyword">if</span> (find_and_kill_processes(level, level_oomadj[level], <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">                ALOGI(<span class="string">&quot;Nothing to kill&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure><p>可见，对low ram设备，直接找个杀掉完了。对high ram，如果用了minfree直接杀，没用minfree来看下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!use_minfree_levels) &#123;</span><br><span class="line">    <span class="comment">/* If pressure level is less than critical and enough free swap then ignore */</span></span><br><span class="line">    <span class="keyword">if</span> (level &lt; VMPRESS_LEVEL_CRITICAL &amp;&amp;</span><br><span class="line">        mi.field.free_swap &gt; low_pressure_mem.max_nr_free_pages) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(<span class="string">&quot;Ignoring pressure since %&quot;</span> PRId64</span><br><span class="line">                  <span class="string">&quot; swap pages are available &quot;</span>,</span><br><span class="line">                  mi.field.free_swap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Free up enough memory to downgrate the memory pressure to low level */</span></span><br><span class="line">    <span class="keyword">if</span> (mi.field.nr_free_pages &lt; low_pressure_mem.max_nr_free_pages) &#123;</span><br><span class="line">        pages_to_free = low_pressure_mem.max_nr_free_pages -</span><br><span class="line">            mi.field.nr_free_pages;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(<span class="string">&quot;Ignoring pressure since more memory is &quot;</span></span><br><span class="line">                <span class="string">&quot;available (%&quot;</span> PRId64 <span class="string">&quot;) than watermark (%&quot;</span> PRId64 <span class="string">&quot;)&quot;</span>,</span><br><span class="line">                mi.field.nr_free_pages, low_pressure_mem.max_nr_free_pages);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    min_score_adj = level_oomadj[level];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if event level is low or medium,  那么看下如果有足够的free swap，就不杀了，如果没有就要释放enough memory到low pressure memory的free水平。rt?</p><p>关于procadjslot_list的insert是在data_sock的handle里处理，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* max supported number of data connections */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_DATA_CONN 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* socket event handler data */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock_event_handler_info</span> <span class="title">ctrl_sock</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock_event_handler_info</span> <span class="title">data_sock</span>[<span class="title">MAX_DATA_CONN</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3 memory pressure levels, 1 ctrl listen socket, 2 ctrl data socket */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EPOLL_EVENTS (1 + MAX_DATA_CONN + VMPRESS_LEVEL_COUNT)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> epollfd;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> maxevents;</span><br></pre></td></tr></table></figure><p>说的就是socket event handler，这两个连接一个是原来的for ActivityManager，一个是for lmk test process, mark to check later。</p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LMK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>F2FS保留块特性分析及如何在Android上使用</title>
      <link href="/f2fs-block-reservation-analysis-and-usage-on-android.html"/>
      <url>/f2fs-block-reservation-analysis-and-usage-on-android.html</url>
      
        <content type="html"><![CDATA[<p>Android Go data分区启用了f2fs文件系统，从介绍看是为了提高life time和4K文件读写性能，这个暂不关心，三星init，看kernel提交记录后面主要是huawei也参与进来，据说是重金聘用，多少米?</p><p>前段时间项目在Go上遇到一个问题：data填满100%一直起不来(kernel: 3.18)。不过可以使用保留空间加一层保护, 重要系统进程可以使用保留区，其他不可用, rt?，ext4这个特性叫resgid，3.18 f2fs还不支持，我从kernel 4.9移下来，基于这份代码分析。</p><p>先看下保留空间相关结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="type">block_t</span> reserved_blocks;<span class="comment">/* configurable reserved blocks */</span></span><br><span class="line"><span class="type">block_t</span> current_reserved_blocks;<span class="comment">/* current reserved blocks */</span></span><br><span class="line"><span class="type">block_t</span> root_reserved_blocks;<span class="comment">/* root reserved blocks */</span></span><br><span class="line"><span class="type">kuid_t</span> s_resuid;<span class="comment">/* reserved blocks for uid */</span></span><br><span class="line"><span class="type">kgid_t</span> s_resgid;<span class="comment">/* reserved blocks for gid */</span></span><br></pre></td></tr></table></figure><p>其实<code>reserved_blocks</code>和<code>current_reserved_blocks</code>是一个reserved feature，主要目的应该是提高性能，在sysfs下可配置。而<code>root_reserved_blocks</code>和<code>resuid</code>,<code>resgid</code>才是我们现在这个需求，用man来解释：</p><p>man mount:</p><blockquote><p>resgid&#x3D;n and resuid&#x3D;n<br>The  ext2  filesystem  reserves  a  certain percentage of the available space (by default 5%, see mke2fs(8) and tune2fs(8)).  These options determine who can use the reserved blocks.<br>(Roughly: whoever has the specified uid, or belongs to the specified group.)</p></blockquote><p>man tune2fs:</p><blockquote><p>-r reserved-blocks-count<br>Set the number of reserved filesystem blocks.</p><p>-g group<br>Set the group which can use the reserved filesystem blocks.  The group parameter can be a numerical gid or a group name.  If a group name is given, it is converted to a numerical gid before it is stored in the superblock.</p></blockquote><p>ok, 关键函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> __allow_reserved_blocks(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!test_opt(sbi, RESERVE_ROOT))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (capable(CAP_SYS_RESOURCE))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (uid_eq(sbi-&gt;s_resuid, current_fsuid()))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!gid_eq(sbi-&gt;s_resgid, GLOBAL_ROOT_GID) &amp;&amp;</span><br><span class="line">in_group_p(sbi-&gt;s_resgid))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先检查mount是否有RESERVE_BOOT选项，如果没设置就不让用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_opt(sbi, option)((sbi)-&gt;mount_opt.opt |= F2FS_MOUNT_##option)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> test_opt(sbi, option)((sbi)-&gt;mount_opt.opt &amp; F2FS_MOUNT_##option)</span></span><br></pre></td></tr></table></figure><p>哪里<code>set_opt</code>了这个了, 在<code>parse_options</code>里:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> Opt_reserve_root:</span><br><span class="line"><span class="keyword">if</span> (args-&gt;from &amp;&amp; match_int(args, &amp;arg))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (test_opt(sbi, RESERVE_ROOT)) &#123;</span><br><span class="line">f2fs_msg(sb, KERN_INFO,</span><br><span class="line"><span class="string">&quot;Preserve previous reserve_root=%u&quot;</span>,</span><br><span class="line">sbi-&gt;root_reserved_blocks);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//tj: 走这里</span></span><br><span class="line">sbi-&gt;root_reserved_blocks = arg;</span><br><span class="line">set_opt(sbi, RESERVE_ROOT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mount会解析这个选项：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">f2fs_mount</span><span class="params">(<span class="keyword">struct</span> file_system_type *fs_type, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *dev_name, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mount_bdev(fs_type, flags, dev_name, data, f2fs_fill_super);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>f2fs_fill_super</code>会call <code>parse_options</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_fill_super</span><span class="params">(<span class="keyword">struct</span> super_block *sb, <span class="type">void</span> *data, <span class="type">int</span> silent)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* parse mount options */</span></span><br><span class="line">options = kstrdup((<span class="type">const</span> <span class="type">char</span> *)data, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (data &amp;&amp; !options) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> free_sb_buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = parse_options(sb, options);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> free_options;</span><br></pre></td></tr></table></figure><p>ok, 看下<code>s_resgid</code> allow:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!gid_eq(sbi-&gt;s_resgid, GLOBAL_ROOT_GID) &amp;&amp;</span><br><span class="line">in_group_p(sbi-&gt;s_resgid))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KGIDT_INIT(value) (kgid_t)&#123; value &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBAL_ROOT_GID KGIDT_INIT(0)</span></span><br></pre></td></tr></table></figure><p>resgid&#x3D;0的不让用保留了，<code>in_group_p</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check whether we&#x27;re fsgid/egid or in the supplemental group..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">in_group_p</span><span class="params">(<span class="type">kgid_t</span> grp)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span> =</span> current_cred();</span><br><span class="line">        <span class="type">int</span> retval = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!gid_eq(grp, cred-&gt;fsgid))</span><br><span class="line">                retval = groups_search(cred-&gt;group_info, grp);</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该就是这个grp有没有加到系统里，可见mount flag要加了<code>reserve_root</code>才能激活。</p><p>另外，保留块有大小限制：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">limit_reserve_root</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">block_t</span> limit = (sbi-&gt;user_block_count &lt;&lt; <span class="number">1</span>) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* limit is 0.2% */</span></span><br><span class="line"><span class="keyword">if</span> (test_opt(sbi, RESERVE_ROOT) &amp;&amp; sbi-&gt;root_reserved_blocks &gt; limit) &#123;</span><br><span class="line">sbi-&gt;root_reserved_blocks = limit;</span><br><span class="line">f2fs_msg(sbi-&gt;sb, KERN_INFO,</span><br><span class="line"><span class="string">&quot;Reduce reserved blocks for root = %u&quot;</span>,</span><br><span class="line">sbi-&gt;root_reserved_blocks);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!test_opt(sbi, RESERVE_ROOT) &amp;&amp;</span><br><span class="line">(!uid_eq(sbi-&gt;s_resuid,</span><br><span class="line">make_kuid(&amp;init_user_ns, F2FS_DEF_RESUID)) ||</span><br><span class="line">!gid_eq(sbi-&gt;s_resgid,</span><br><span class="line">make_kgid(&amp;init_user_ns, F2FS_DEF_RESGID))))</span><br><span class="line">f2fs_msg(sbi-&gt;sb, KERN_INFO,</span><br><span class="line"><span class="string">&quot;Ignore s_resuid=%u, s_resgid=%u w/o reserve_root&quot;</span>,</span><br><span class="line">from_kuid_munged(&amp;init_user_ns, sbi-&gt;s_resuid),</span><br><span class="line">from_kgid_munged(&amp;init_user_ns, sbi-&gt;s_resgid));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于id，Android里叫AID，在system&#x2F;core&#x2F;libcutils&#x2F;include&#x2F;private&#x2F;android_filesystem_config.h:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AID_RESERVED_DISK 1065   <span class="comment">/* GID that has access to reserved disk space */</span></span></span><br></pre></td></tr></table></figure><p>比如zygote能使用reserved disk，在32bits系统里在rootdir&#x2F;init.zygote32.rc加入reserved_disk,如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br></pre></td></tr></table></figure><p>可以用id命令显示uid&#x2F;gid等信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/ <span class="comment"># ps -A | grep system_server</span></span><br><span class="line">USER           PID  PPID     VSZ    RSS WCHAN            ADDR S NAME</span><br><span class="line">system        2888   286 1127972  73976 SyS_epoll_wait b008a658 S system_server</span><br><span class="line">xxx:/ <span class="comment">#</span></span><br><span class="line">xxx:/ <span class="comment"># id system</span></span><br><span class="line">uid=1000(system) gid=1000(system) <span class="built_in">groups</span>=1000(system), context=u:r:su:s0</span><br><span class="line">xxx:/ <span class="comment">#</span></span><br><span class="line">xxx:/ <span class="comment"># id reserved_disk</span></span><br><span class="line">uid=1065(reserved_disk) gid=1065(reserved_disk) <span class="built_in">groups</span>=1065(reserved_disk), cont</span><br><span class="line">ext=u:r:su:s0</span><br></pre></td></tr></table></figure><p>Done.</p>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> resgid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Go在data分区填近满后不能启动bug分析</title>
      <link href="/analyze-boot-failed-when-full-data-part-under-android-go.html"/>
      <url>/analyze-boot-failed-when-full-data-part-under-android-go.html</url>
      
        <content type="html"><![CDATA[<p>最近遇到一个问题：重启压测十来天后出现大量手机不能启动, Android Go&#x2F;MSM8909，有FWK同事发现空间满了，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/block/mmcblk0p39 5.2G  4.8G  340M  94% /data</span><br></pre></td></tr></table></figure><p>原来是我们自定义的logd一直写满了data分区，删除后立即启动正常，为什么data满了会导致起不来，看了下Z的手机，我折腾了下1h都没起来：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msm8909go:/ $ <span class="built_in">df</span> -h</span><br><span class="line">Filesystem            Size  Used Avail Use% Mounted on</span><br><span class="line">rootfs                430M  1.6M  428M   1% /</span><br><span class="line">tmpfs                 442M     0  442M   0% /mnt</span><br><span class="line">/dev/block/mmcblk0p34 5.5G  5.2G     0  100% /data      // -&gt; data分区填满</span><br><span class="line">/dev/block/mmcblk0p31 104M  1.0M  100M   2% /cache</span><br><span class="line">msm8909go:/ $ ps -A | grep system_s</span><br><span class="line">system        1709  1517 1018068  46772                     0 R system_server</span><br><span class="line">msm8909go:/ $ <span class="built_in">uptime</span></span><br><span class="line"> 13:22:16 up 1:06,  0 <span class="built_in">users</span>,  load average: 4.61, 4.63, 3.79</span><br><span class="line">msm8909go:/ $ dmesg</span><br><span class="line">dmesg: klogctl: Permission denied</span><br><span class="line">msm8909go:/ $ ps -A | grep zygote</span><br><span class="line">root          1882     1  967528  56388 poll_schedule_timeout 0 S zygote</span><br><span class="line">msm8909go:/ $</span><br><span class="line">msm8909go:/ $ ps -A | grep system_s</span><br><span class="line">system        2073  1882 1011152  38588                     0 R system_server</span><br><span class="line">msm8909go:/ $</span><br></pre></td></tr></table></figure><p>system_server一直在重启。</p><p>再来看下logcat，发现如下zygote log:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01-06 03:25:49.287  1986  1986 E patchoat: Failed to create symlink at /data/dalvik-cache/arm/system@framework@boot.oat error(28): No space left on device</span><br><span class="line">01-06 03:25:49.288  1986  1986 W patchoat: Current thread not detached in Runtime shutdown</span><br><span class="line">01-06 03:25:48.959  1898  1898 W zygote  : Pruning dalvik cache because of low-memory situation.</span><br><span class="line">01-06 03:25:48.960  1898  1898 W zygote  : Failed to create boot marker.: No such file or directory</span><br><span class="line">01-06 03:25:48.960  1898  1898 W zygote  : Low-memory situation: only 0.17 megabytes available, need at least 50. Preemptively pruning the dalvik cache.</span><br><span class="line">01-06 03:25:48.961  1898  1898 I zygote  : Pruning dalvik-cache since we are relocating an image and will need to recompile</span><br><span class="line">01-06 03:25:48.962  1898  1898 I zygote  : RelocateImage: /system/bin/patchoat --input-image-location=/system/framework/boot.art --output-image-file=/data/dalvik-cache/arm/system@framework@boot.art --instruction-set=arm --base-offset-delta=-6152192</span><br><span class="line">01-06 03:25:49.303  1898  1898 E zygote  : Could not create image space with image file &#x27;/system/framework/boot.art&#x27;. Attempting to fall back to imageless running. Error was: Cannot relocate image /system/framework/boot.art to /data/dalvik-cache/arm/system@framework@boot.art: Failed execv(/system/bin/patchoat --input-image-location=/system/framework/boot.art --output-image-file=/data/dalvik-cache/arm/system@framework@boot.art --instruction-set=arm --base-offset-delta=-6152192) because non-0 exit status</span><br><span class="line">01-06 03:25:49.303  1898  1898 E zygote  : Attempted image: /system/framework/boot.art</span><br></pre></td></tr></table></figure><p>能看出来有No space left,  Low-memory situation，这些都是ART虚拟机的东东，让我们先简单了解下ART相关概念和背景:</p><p>Google官方解释：</p><blockquote><p>Android runtime (ART) is the managed runtime used by applications and some system services on Android. ART and its predecessor Dalvik were originally created specifically for the Android project. ART as the runtime executes the Dalvik Executable format and Dex bytecode specification.</p><p>ART and Dalvik are compatible runtimes running Dex bytecode, so apps developed for Dalvik should work when running with ART. However, some techniques that work on Dalvik do not work on ART.</p><p>ART introduces ahead-of-time (AOT) compilation, which can improve app performance. ART also has tighter install-time verification than Dalvik.</p><p>At install time, ART compiles apps using the on-device dex2oat tool. This utility accepts DEX files as input and generates a compiled app executable for the target device. The utility should be able to compile all valid DEX files without difficulty. However, some post-processing tools produce invalid files that may be tolerated by Dalvik but cannot be compiled by ART.</p></blockquote><p>以前用Dalvik，现在使用ART提高性能，ART向后兼容Dalvik。ART引入了AOT编译技术，使用dex2oat这个工具把DEX文件作为输入，生成相应的可执行文件(ELF格式)。 dex就是Dalvik excutable file， odex就是optimized dex。</p><p>再看下wikipedia上对ART和Dalvik的框架对比图：</p><p><img src="http://tjtech.me/usr/uploads/2018/08/2962129657.png" alt="ART_view.png"></p><p>ok，让我们看代码, path: art&#x2F;runtime&#x2F;gc&#x2F;space&#x2F;image_space.cc:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;ImageSpace&gt; <span class="title">ImageSpace::CreateBootImage</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* image_location,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        <span class="type">const</span> InstructionSet image_isa,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        <span class="type">bool</span> secondary_image,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        std::string* error_msg)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">// Step 0.b: If we&#x27;re the zygote, check for free space, and prune the cache preemptively,</span></span><br><span class="line">  <span class="comment">//           if necessary. While the runtime may be fine (it is pretty tolerant to</span></span><br><span class="line">  <span class="comment">//           out-of-disk-space situations), other parts of the platform are not.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//           The advantage of doing this proactively is that the later steps are simplified,</span></span><br><span class="line">  <span class="comment">//           i.e., we do not need to code retries.</span></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (is_zygote &amp;&amp; dalvik_cache_exists) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!dalvik_cache.<span class="built_in">empty</span>());</span><br><span class="line">    std::string local_error_msg;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CheckSpace</span>(dalvik_cache, &amp;local_error_msg)) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; local_error_msg &lt;&lt; <span class="string">&quot; Preemptively pruning the dalvik cache.&quot;</span>;</span><br><span class="line">      <span class="built_in">PruneDalvikCache</span>(image_isa);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Re-evaluate the image.</span></span><br><span class="line">      found_image = <span class="built_in">FindImageFilenameImpl</span>(image_location,</span><br><span class="line">                                          image_isa,</span><br><span class="line">                                          &amp;has_system,</span><br><span class="line">                                          &amp;system_filename,</span><br><span class="line">                                          &amp;dalvik_cache_exists,</span><br><span class="line">                                          &amp;dalvik_cache,</span><br><span class="line">                                          &amp;is_global_cache,</span><br><span class="line">                                          &amp;has_cache,</span><br><span class="line">                                          &amp;cache_filename);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里boot image是啥意思，稍等下看。</p><p>zygote起来后会check space，如果空间过小，就调用PruneDalvikCache把dalvik cache干掉。</p><p>先看看check space:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint64_t</span> kLowSpaceValue = <span class="number">50</span> * MB;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint64_t</span> kTmpFsSentinelValue = <span class="number">384</span> * MB;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the free space of the cache partition and make a decision whether to keep the generated</span></span><br><span class="line"><span class="comment">// image. This is to try to mitigate situations where the system might run out of space later.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">CheckSpace</span><span class="params">(<span class="type">const</span> std::string&amp; cache_filename, std::string* error_msg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Using statvfs vs statvfs64 because of b/18207376, and it is enough for all practical purposes.</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">statvfs</span> buf;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> res = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">statvfs</span>(cache_filename.<span class="built_in">c_str</span>(), &amp;buf));</span><br><span class="line">  <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Could not stat. Conservatively tell the system to delete the image.</span></span><br><span class="line">    *error_msg = <span class="string">&quot;Could not stat the filesystem, assuming low-memory situation.&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> fs_overall_size = buf.f_bsize * <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(buf.f_blocks);</span><br><span class="line">  <span class="comment">// Zygote is privileged, but other things are not. Use bavail.</span></span><br><span class="line">  <span class="type">uint64_t</span> fs_free_size = buf.f_bsize * <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(buf.f_bavail);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Take the overall size as an indicator for a tmpfs, which is being used for the decryption</span></span><br><span class="line">  <span class="comment">// environment. We do not want to fail quickening the boot image there, as it is beneficial</span></span><br><span class="line">  <span class="comment">// for time-to-UI.</span></span><br><span class="line">  <span class="keyword">if</span> (fs_overall_size &gt; kTmpFsSentinelValue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fs_free_size &lt; kLowSpaceValue) &#123;</span><br><span class="line">      *error_msg = <span class="built_in">StringPrintf</span>(<span class="string">&quot;Low-memory situation: only %4.2f megabytes available, need at &quot;</span></span><br><span class="line">                                <span class="string">&quot;least %&quot;</span> PRIu64 <span class="string">&quot;.&quot;</span>,</span><br><span class="line">                                <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(fs_free_size) / MB,</span><br><span class="line">                                kLowSpaceValue / MB);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看注释：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Read the free space of the cache partition and make a decision whether to keep the generated</span></span><br><span class="line"><span class="comment">// image. This is to try to mitigate situations where the system might run out of space later.</span></span><br></pre></td></tr></table></figure><p>这里cache partition不是说的&#x2F;cache分区，而是说的dalvik cache目录，具体是data分区的&#x2F;data&#x2F;dalvik-cache目录。</p><p>剩余空间用的<code>fs_free_size</code>，ART定的最小门限是50MB(kLowSpaceValue)，应该就是data分区的&lt;50MB就认为Low-memory了。</p><p>再看了prune dalvik cache做了什么：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// We are relocating or generating the core image. We should get rid of everything. It is all</span></span><br><span class="line"><span class="comment">// out-of-date. We also don&#x27;t really care if this fails since it is just a convenience.</span></span><br><span class="line"><span class="comment">// Adapted from prune_dex_cache(const char* subdir) in frameworks/native/cmds/installd/commands.c</span></span><br><span class="line"><span class="comment">// Note this should only be used during first boot.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PruneDalvikCache</span><span class="params">(InstructionSet isa)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">CHECK_NE</span>(isa, kNone);</span><br><span class="line">  <span class="comment">// Prune the base /data/dalvik-cache.</span></span><br><span class="line">  <span class="comment">// Note: GetDalvikCache may return the empty string if the directory doesn&#x27;t</span></span><br><span class="line">  <span class="comment">// exist. It is safe to pass &quot;&quot; to DeleteDirectoryContents, so this is okay.</span></span><br><span class="line">  impl::<span class="built_in">DeleteDirectoryContents</span>(<span class="built_in">GetDalvikCache</span>(<span class="string">&quot;.&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// Prune /data/dalvik-cache/&lt;isa&gt;.</span></span><br><span class="line">  impl::<span class="built_in">DeleteDirectoryContents</span>(<span class="built_in">GetDalvikCache</span>(<span class="built_in">GetInstructionSetString</span>(isa)), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Be defensive. There should be a runtime created here, but this may be called in a test.</span></span><br><span class="line">  <span class="keyword">if</span> (Runtime::<span class="built_in">Current</span>() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">SetPrunedDalvikCache</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是&#x2F;data&#x2F;dalvik-cache&#x2F;<isa>这个目录删了，正常启动的手机看下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">8909go:/data/dalvik-cache <span class="comment"># du -h</span></span><br><span class="line">269M    ./arm</span><br><span class="line">269M    .</span><br></pre></td></tr></table></figure><p>占用了不少啊。</p><p>我们再继续看create boot image:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 1: Check if we have an existing and relocated image.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1.a: Have files in system and cache. Then they need to match.</span></span><br><span class="line"><span class="keyword">if</span> (found_image &amp;&amp; has_system &amp;&amp; has_cache) &#123;</span><br><span class="line">  std::string local_error_msg;</span><br><span class="line">  <span class="comment">// Check that the files are matching.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ChecksumsMatch</span>(system_filename.<span class="built_in">c_str</span>(), cache_filename.<span class="built_in">c_str</span>(), &amp;local_error_msg)) &#123;</span><br><span class="line">    std::unique_ptr&lt;ImageSpace&gt; relocated_space =</span><br><span class="line">        ImageSpaceLoader::<span class="built_in">Load</span>(image_location,</span><br><span class="line">                               cache_filename,</span><br><span class="line">                               is_zygote,</span><br><span class="line">                               is_global_cache,</span><br><span class="line">                               <span class="comment">/* validate_oat_file */</span> <span class="literal">false</span>,</span><br><span class="line">                               &amp;local_error_msg);</span><br><span class="line">    <span class="keyword">if</span> (relocated_space != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> relocated_space;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;    </span><br><span class="line">  error_msgs.<span class="built_in">push_back</span>(local_error_msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1.b: Only have a cache file.</span></span><br><span class="line"><span class="keyword">if</span> (found_image &amp;&amp; !has_system &amp;&amp; has_cache) &#123;</span><br><span class="line">  std::string local_error_msg;</span><br><span class="line">  std::unique_ptr&lt;ImageSpace&gt; cache_space =</span><br><span class="line">      ImageSpaceLoader::<span class="built_in">Load</span>(image_location,</span><br><span class="line">                             cache_filename,</span><br><span class="line">                             is_zygote,</span><br><span class="line">                             is_global_cache,</span><br><span class="line">                             <span class="comment">/* validate_oat_file */</span> <span class="literal">true</span>,</span><br><span class="line">                             &amp;local_error_msg);</span><br><span class="line">  <span class="keyword">if</span> (cache_space != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache_space;</span><br><span class="line">  &#125;    </span><br><span class="line">  error_msgs.<span class="built_in">push_back</span>(local_error_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有找到image在step 1 FindImageFilenameImpl里：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">FindImageFilenameImpl</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* image_location,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> InstructionSet image_isa,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">bool</span>* has_system,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  std::string* system_filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">bool</span>* dalvik_cache_exists,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  std::string* dalvik_cache,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">bool</span>* is_global_cache,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">bool</span>* has_cache,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  std::string* cache_filename)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(dalvik_cache != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  *has_system = <span class="literal">false</span>;</span><br><span class="line">  *has_cache = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// image_location = /system/framework/boot.art</span></span><br><span class="line">  <span class="comment">// system_image_location = /system/framework/&lt;image_isa&gt;/boot.art</span></span><br><span class="line">  <span class="function">std::string <span class="title">system_image_filename</span><span class="params">(GetSystemImageFilename(image_location, image_isa))</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (OS::<span class="built_in">FileExists</span>(system_image_filename.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">    *system_filename = system_image_filename;</span><br><span class="line">    *has_system = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> have_android_data = <span class="literal">false</span>;</span><br><span class="line">  *dalvik_cache_exists = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">GetDalvikCache</span>(<span class="built_in">GetInstructionSetString</span>(image_isa),</span><br><span class="line">                 <span class="literal">true</span>,</span><br><span class="line">                 dalvik_cache,</span><br><span class="line">                 &amp;have_android_data,</span><br><span class="line">                 dalvik_cache_exists,</span><br><span class="line">                 is_global_cache);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (have_android_data &amp;&amp; *dalvik_cache_exists) &#123;</span><br><span class="line">    <span class="comment">// Always set output location even if it does not exist,</span></span><br><span class="line">    <span class="comment">// so that the caller knows where to create the image.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// image_location = /system/framework/boot.art</span></span><br><span class="line">    <span class="comment">// *image_filename = /data/dalvik-cache/&lt;image_isa&gt;/boot.art</span></span><br><span class="line">    std::string error_msg;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">GetDalvikCacheFilename</span>(image_location,</span><br><span class="line">                                dalvik_cache-&gt;<span class="built_in">c_str</span>(),</span><br><span class="line">                                cache_filename,</span><br><span class="line">                                &amp;error_msg)) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; error_msg;</span><br><span class="line">      <span class="keyword">return</span> *has_system;</span><br><span class="line">    &#125;</span><br><span class="line">    *has_cache = OS::<span class="built_in">FileExists</span>(cache_filename-&gt;<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *has_system || *has_cache;</span><br></pre></td></tr></table></figure><p>ok, file in system指的是&#x2F;system&#x2F;framework&#x2F;boot.art，file in cache指的是&#x2F;data&#x2F;dalvik-cache&#x2F;<image_isa>&#x2F;boot.art。</p><p>如果都存在且匹配就返回ok了,如果没有匹配，继续step 1.b：只有cache file，load ok也返回ok了,如果只有system有，来看step 2:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 2: We have an existing image in /system.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2.a: We are not required to relocate it. Then we can use it directly.</span></span><br><span class="line"><span class="type">bool</span> relocate = Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">ShouldRelocate</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (found_image &amp;&amp; has_system &amp;&amp; !relocate) &#123;</span><br><span class="line">  std::string local_error_msg;</span><br><span class="line">  std::unique_ptr&lt;ImageSpace&gt; system_space =</span><br><span class="line">      ImageSpaceLoader::<span class="built_in">Load</span>(image_location,</span><br><span class="line">                             system_filename,</span><br><span class="line">                             is_zygote,</span><br><span class="line">                             is_global_cache,</span><br><span class="line">                             <span class="comment">/* validate_oat_file */</span> <span class="literal">false</span>,</span><br><span class="line">                             &amp;local_error_msg);</span><br><span class="line">  <span class="keyword">if</span> (system_space != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> system_space;</span><br><span class="line">  &#125;</span><br><span class="line">  error_msgs.<span class="built_in">push_back</span>(local_error_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要relocate，直接load ok就返回ok了,那如果需要呢：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 2.b: We require a relocated image. Then we must patch it. This step fails if this is a</span></span><br><span class="line"><span class="comment">//           secondary image.</span></span><br><span class="line"><span class="keyword">if</span> (found_image &amp;&amp; has_system &amp;&amp; relocate) &#123;</span><br><span class="line">  std::string local_error_msg;</span><br><span class="line">  <span class="keyword">if</span> (!Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">IsImageDex2OatEnabled</span>()) &#123;</span><br><span class="line">    local_error_msg = <span class="string">&quot;Patching disabled.&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondary_image) &#123;</span><br><span class="line">    <span class="comment">// We really want a working image. Prune and restart.</span></span><br><span class="line">    <span class="built_in">PruneDalvikCache</span>(image_isa);</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">ImageCreationAllowed</span>(is_global_cache, image_isa, &amp;local_error_msg)) &#123;</span><br><span class="line">    <span class="type">bool</span> patch_success =</span><br><span class="line">        <span class="built_in">RelocateImage</span>(image_location, cache_filename.<span class="built_in">c_str</span>(), image_isa, &amp;local_error_msg);</span><br><span class="line">    <span class="keyword">if</span> (patch_success) &#123;</span><br><span class="line">      std::unique_ptr&lt;ImageSpace&gt; patched_space =</span><br><span class="line">          ImageSpaceLoader::<span class="built_in">Load</span>(image_location,</span><br><span class="line">                                 cache_filename,</span><br><span class="line">                                 is_zygote,</span><br><span class="line">                                 is_global_cache,</span><br><span class="line">                                 <span class="comment">/* validate_oat_file */</span> <span class="literal">false</span>,</span><br><span class="line">                                 &amp;local_error_msg);</span><br><span class="line">      <span class="keyword">if</span> (patched_space != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> patched_space;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  error_msgs.<span class="built_in">push_back</span>(<span class="built_in">StringPrintf</span>(<span class="string">&quot;Cannot relocate image %s to %s: %s&quot;</span>,</span><br><span class="line">                                    image_location,</span><br><span class="line">                                    cache_filename.<span class="built_in">c_str</span>(),</span><br><span class="line">                                    local_error_msg.<span class="built_in">c_str</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看patch是否disable了，如果patch enable了，看看是不是secondary_image，如果是那么必须删掉dalvik-cache目录重启该进程, 如果是first image那么直接调用RelocateImage进行relocate。</p><p>继续看step 3:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 3: We do not have an existing image in /system, so generate an image into the dalvik</span></span><br><span class="line"><span class="comment">//         cache. This step fails if this is a secondary image.</span></span><br><span class="line"><span class="keyword">if</span> (!has_system) &#123;</span><br><span class="line">  std::string local_error_msg;</span><br><span class="line">  <span class="keyword">if</span> (!Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">IsImageDex2OatEnabled</span>()) &#123;</span><br><span class="line">    local_error_msg = <span class="string">&quot;Image compilation disabled.&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondary_image) &#123;</span><br><span class="line">    local_error_msg = <span class="string">&quot;Cannot compile a secondary image.&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">ImageCreationAllowed</span>(is_global_cache, image_isa, &amp;local_error_msg)) &#123;</span><br><span class="line">    <span class="type">bool</span> compilation_success = <span class="built_in">GenerateImage</span>(cache_filename, image_isa, &amp;local_error_msg);</span><br><span class="line">    <span class="keyword">if</span> (compilation_success) &#123;</span><br><span class="line">      std::unique_ptr&lt;ImageSpace&gt; compiled_space =</span><br><span class="line">          ImageSpaceLoader::<span class="built_in">Load</span>(image_location,</span><br><span class="line">                                 cache_filename,</span><br><span class="line">                                 is_zygote,</span><br><span class="line">                                 is_global_cache,</span><br><span class="line">                                 <span class="comment">/* validate_oat_file */</span> <span class="literal">false</span>,</span><br><span class="line">                                 &amp;local_error_msg);</span><br><span class="line">      <span class="keyword">if</span> (compiled_space != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> compiled_space;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  error_msgs.<span class="built_in">push_back</span>(<span class="built_in">StringPrintf</span>(<span class="string">&quot;Cannot compile image to %s: %s&quot;</span>,</span><br><span class="line">                                    cache_filename.<span class="built_in">c_str</span>(),</span><br><span class="line">                                    local_error_msg.<span class="built_in">c_str</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>system下没有boot image就要创建一个到&#x2F;data&#x2F;dalvik-cache下，流程同relocate，同样的secondary image会失败。</p><p>ok, create boot image走完。有没有发现secondary image的_exit的流程，会有这种可能：</p><p>如果data空间不足50MB，而且在创建boot image的index是!first image，那么会一直死循环，right?</p><p>再看下9.0 ART应该是修复了。</p><p>还有几个疑问：啥是relocate? 就是为了安全考虑，patchoat就是用来relocate的工具, 具体参考文档里详解。那boot image是什么? 看下stackflow的回答：</p><blockquote><p>Pre-ART, Android used the Zygote to fork each app process and preload and preinitialize some classes  for optimization purposes. On ART, the set of jar libraries that should be preloaded into each app process is compiled once into the so called boot image. It consists of two files, boot.oat and boot.art. Boot.oat contains the compiled code while boot.art contains a preinitialized heap etc. Both are also generated by dex2oat. This boot image is loaded into each app’s process as an optimization. </p></blockquote><p>至于什么是secondary image，暂时不明白，由gc&#x2F;heap而来，以后再看。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a href="https://developer.android.com/guide/platform/">https://developer.android.com/guide/platform/</a></p></li><li><p><a href="https://source.android.com/devices/tech/dalvik/">https://source.android.com/devices/tech/dalvik/</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Android_Runtime">https://en.wikipedia.org/wiki/Android_Runtime</a></p></li><li><p><a href="https://mssun.me/blog/android-art-runtime-1-background.html">https://mssun.me/blog/android-art-runtime-1-background.html</a></p></li><li><p><a href="https://mssun.me/blog/android-art-runtime-2-dex2oat.html">https://mssun.me/blog/android-art-runtime-2-dex2oat.html</a></p></li><li><p><a href="https://mssun.me/blog/android-art-runtime-3-compiler.html">https://mssun.me/blog/android-art-runtime-3-compiler.html</a></p></li><li><p><a href="https://mssun.me/blog/android-art-runtime-4-patchoat.html">https://mssun.me/blog/android-art-runtime-4-patchoat.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zygote </tag>
            
            <tag> ART </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fix a strange kernel crash issue on custom driver</title>
      <link href="/fix-an-stange-kernel-crash-on-cust-drv.html"/>
      <url>/fix-an-stange-kernel-crash-on-cust-drv.html</url>
      
        <content type="html"><![CDATA[<p>最近在从msm_A&#x2F;kernel3.18 port自定义mmc driver到msm_B&#x2F;kernel4.9时，出现了kernel crash，log如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[   18.739259] Unable to handle kernel paging request at virtual address ffffffc08b8c4f40</span><br><span class="line">[   18.743483] pgd = ffffffc0a6b6e000</span><br><span class="line">[   18.751370] [ffffffc08b8c4f40] *pgd=0000000000000000, *pud=0000000000000000</span><br><span class="line">...</span><br><span class="line">[   18.829858] PC is at __inval_cache_range+0x24/0x60</span><br><span class="line">[   18.835663] LR is at __swiotlb_map_sg_attrs+0x9c/0xc8</span><br><span class="line">...</span><br><span class="line">[   19.133929] [&lt;ffffff8088ea3124&gt;] __inval_cache_range+0x24/0x60</span><br><span class="line">[   19.138620] [&lt;ffffff808999b3d4&gt;] sdhci_pre_dma_transfer.isra.25+0xa4/0x104</span><br><span class="line">[   19.144523] [&lt;ffffff808999dd88&gt;] sdhci_send_command+0x8b0/0x1224</span><br><span class="line">[   19.151379] [&lt;ffffff80899a0924&gt;] sdhci_request+0x14c/0x378</span><br><span class="line">[   19.157542] [&lt;ffffff80899750d0&gt;] __mmc_start_request+0x78/0x1b4</span><br><span class="line">[   19.162836] [&lt;ffffff8089977ca4&gt;] mmc_start_request+0x15c/0x2d4</span><br><span class="line">[   19.168652] [&lt;ffffff8089978348&gt;] __mmc_start_req+0x94/0xf4</span><br><span class="line">[   19.174553] [&lt;ffffff80899794dc&gt;] mmc_wait_for_req+0x30/0x5c</span><br><span class="line">[   19.180024] [&lt;ffffff8089b56f0c&gt;] custom_transfer.constprop.7+0x1c8/0x404</span><br></pre></td></tr></table></figure><p><code>custom_transfer</code>定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">custom_transfer</span><span class="params">(<span class="type">char</span> *buf, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    sg_init_one(&amp;sg, buf, buf_size);</span><br><span class="line">    ...</span><br><span class="line">    mmc_wait_for_req()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的代码在msm_A&#x2F;kernel 3.18上是正常的，奇怪，先看下死机位置。</p><p>cache.S里会定义<code>__inval_cache_range</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> *      __inval_cache_range(start, end)</span><br><span class="line"> *      - start   - start address of region</span><br><span class="line"> *      - end     - end address of region</span><br><span class="line"> */</span><br><span class="line">ENTRY(__inval_cache_range)</span><br><span class="line">        dcache_line_size x2, x3</span><br><span class="line">        sub     x3, x2, #1</span><br><span class="line">        tst     x1, x3                          // end cache line aligned?</span><br><span class="line">        bic     x1, x1, x3</span><br><span class="line">        b.eq    1f  </span><br><span class="line">        dc      civac, x1                       // clean &amp; invalidate D / U line</span><br><span class="line">1:      tst     x0, x3                          // start cache line aligned?</span><br><span class="line">        bic     x0, x0, x3</span><br><span class="line">        b.eq    2f  </span><br><span class="line">        dc      civac, x0                       // clean &amp; invalidate D / U line</span><br><span class="line">        b       3f  </span><br><span class="line">2:      dc      ivac, x0                        // invalidate D / U line</span><br><span class="line">3:      add     x0, x0, x2</span><br><span class="line">        cmp     x0, x1</span><br><span class="line">        b.lo    2b  </span><br><span class="line">        dsb     sy  </span><br><span class="line">        ret </span><br><span class="line">ENDPIPROC(__inval_cache_range)</span><br></pre></td></tr></table></figure><p>好家伙，死在cache里。</p><p>看下临近的<code>sdhci_pre_dma_transfer</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sdhci_pre_dma_transfer</span><span class="params">(<span class="keyword">struct</span> sdhci_host *host,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">struct</span> mmc_data *data, <span class="type">int</span> cookie)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> sg_count;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*   </span></span><br><span class="line"><span class="comment">         * If the data buffers are already mapped, return the previous</span></span><br><span class="line"><span class="comment">         * dma_map_sg() result.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (data-&gt;host_cookie == COOKIE_PRE_MAPPED)</span><br><span class="line">                <span class="keyword">return</span> data-&gt;sg_count;</span><br><span class="line"></span><br><span class="line">        sg_count = dma_map_sg(mmc_dev(host-&gt;mmc), data-&gt;sg, data-&gt;sg_len,</span><br><span class="line">                                data-&gt;flags &amp; MMC_DATA_WRITE ?</span><br><span class="line">                                DMA_TO_DEVICE : DMA_FROM_DEVICE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sg_count == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">        data-&gt;sg_count = sg_count;</span><br><span class="line">        data-&gt;host_cookie = cookie;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sg_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dma_map_sg</code>会call <code>dma_map_sg_attrs</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">dma_map_sg_attrs</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> scatterlist *sg,</span></span><br><span class="line"><span class="params">                                   <span class="type">int</span> nents, <span class="keyword">enum</span> dma_data_direction dir,</span></span><br><span class="line"><span class="params">                                   <span class="type">unsigned</span> <span class="type">long</span> attrs)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dma_map_ops</span> *<span class="title">ops</span> =</span> get_dma_ops(dev);</span><br><span class="line">        <span class="type">int</span> i, ents;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> *<span class="title">s</span>;</span> </span><br><span class="line"></span><br><span class="line">        for_each_sg(sg, s, nents, i)</span><br><span class="line">                kmemcheck_mark_initialized(sg_virt(s), s-&gt;length);</span><br><span class="line">        BUG_ON(!valid_dma_direction(dir));</span><br><span class="line">        ents = ops-&gt;map_sg(dev, sg, nents, dir, attrs);</span><br><span class="line">        BUG_ON(ents &lt; <span class="number">0</span>); </span><br><span class="line">        debug_dma_map_sg(dev, sg, nents, ents, dir);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cache line, map… 怀疑buffer。</p><p>看下buffer是如何调用的:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static char cust_buf[COUNT][BUFF_SIZE];</span><br><span class="line">custm_transfer(cust_buf[block]);</span><br></pre></td></tr></table></figure><p>二维数组? 改成malloc，fk，好了，鸡冻啊。</p><p>从这个案例可以看出，禁止用全局大二维数据:] </p><p>btw: 话说这家corp code真是不咋地，要不是…，早…</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDCardFS:删除文件后空间未释放问题分析</title>
      <link href="/why-not-free-space-when-deleting-on-sdcardfs.html"/>
      <url>/why-not-free-space-when-deleting-on-sdcardfs.html</url>
      
        <content type="html"><![CDATA[<p>Android O开始默认使用了sdcardfs，弃用了好多年的fuse，原因就是sdcardfs比fuse性能更优，原生Android sdcardfs的由来：vfs &gt; wrapfs(edu) &gt; sdcardfs(Samsung) &gt; sdcardfs(Google)。</p><p>sdcardfs有个问题：cp文件到SD卡(fat格式)再删除这个文件，该文件空间未释放。</p><p>file system头一回看，从源头先简单了解下vfs的几个重要概念：</p><ul><li>inode: index node，每个object对应一个inode，当然这个object可以是directory, file等等。</li><li>dentry: diretory entry，用来管理目录层级，他含有name，inode等。</li><li>dcache: 就是dentry cache，显然是加速dentry访问。</li><li>superblock: 代表的是文件系统，比如fs type，total blks，free blocks等。</li></ul><p>ok，下来了解下wrapfs：</p><p>一般file system有两类：一个是纯内核(native)文件系统比如ext4，一个是用户态和内核态交互的，fuse就是。wrapfs是第三类，是一种null-layer stackable file system，性能接近纯内核文件系统，so这也是Android放弃fuse的原因。</p><p>边界分层如下图：</p><p><img src="http://tjtech.me/usr/uploads/2018/07/1623065436.png" alt="wrapfs-border.png"></p><p>可以看出，wrapfs即充当vfs同时也充当native fs。</p><p>ok, 看下mmc1&#x2F;SD卡(vfat)删除的流程，msm&#x2F;kernel 3.18：</p><ul><li>rm flow: only call vfat_unlink, 空间释放ok。</li><li>delete by apk: call sdcardfs_lookup then vfat_unlink, 空间释放err。</li></ul><p>再来看下mmc0&#x2F;data分区(f2fs)的删除流程：</p><ul><li>delete by apk: call sdcardfs_unlink then f2fs_unlink, 空间释ok。</li><li>rm: 和apk一样，先走sdcardfs_unlink再f2fs_unlink，空间释放ok。</li></ul><p>那就有一个疑问：同样的rm unlink系统调用，SD卡(vfat)删除时为什么不走sdcardfs_unlink？mark to check later。</p><p>rm unlink flow on data&#x2F;sdcardfs on f2fs：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 1509.351490] [&lt;c034ef3c&gt;] (f2fs_unlink) from [&lt;c023b7f4&gt;] (vfs_unlink2+0xe8/0x17c)</span><br><span class="line">[ 1509.351508] [&lt;c023b7f4&gt;] (vfs_unlink2) from [&lt;c02fd798&gt;] (sdcardfs_unlink+0xc8/0x198)</span><br><span class="line">[ 1509.351526] [&lt;c02fd798&gt;] (sdcardfs_unlink) from [&lt;c023b7f4&gt;] (vfs_unlink2+0xe8/0x17c)</span><br><span class="line">[ 1509.351544] [&lt;c023b7f4&gt;] (vfs_unlink2) from [&lt;c023ff4c&gt;] (do_unlinkat+0xd4/0x1c4)</span><br><span class="line">[ 1509.351561] [&lt;c023ff4c&gt;] (do_unlinkat) from [&lt;c0106aa0&gt;] (ret_fast_syscall+0x0/0x44)</span><br></pre></td></tr></table></figure><p>rm unlink flow on SD&#x2F;sdcardfs on vfat:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 1489.624809] [&lt;c02fa5f4&gt;] (vfat_unlink) from [&lt;c023b7f4&gt;] (vfs_unlink2+0xe8/0x17c)</span><br><span class="line">[ 1489.624829] [&lt;c023b7f4&gt;] (vfs_unlink2) from [&lt;c023ff4c&gt;] (do_unlinkat+0xd4/0x1c4)</span><br><span class="line">[ 1489.624847] [&lt;c023ff4c&gt;] (do_unlinkat) from [&lt;c0106aa0&gt;] (ret_fast_syscall+0x0/0x44)</span><br></pre></td></tr></table></figure><p>so lets check <code>do_unlinkat</code> why not to free space:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_unlinkat</span><span class="params">(<span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span> __user *pathname)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (!IS_ERR(dentry)) &#123;</span><br><span class="line">                <span class="comment">/* Why not before? Because we want correct error value */</span></span><br><span class="line">                <span class="keyword">if</span> (nd.last.name[nd.last.len])</span><br><span class="line">                        <span class="keyword">goto</span> slashes;</span><br><span class="line">                inode = dentry-&gt;d_inode;</span><br><span class="line">                <span class="keyword">if</span> (d_is_negative(dentry))</span><br><span class="line">                        <span class="keyword">goto</span> slashes;</span><br><span class="line">                ihold(inode);</span><br><span class="line">                error = security_path_unlink(&amp;nd.path, dentry);</span><br><span class="line">                <span class="keyword">if</span> (error)</span><br><span class="line">                        <span class="keyword">goto</span> exit2;</span><br><span class="line">                error = vfs_unlink2(nd.path.mnt, nd.path.dentry-&gt;d_inode, dentry, &amp;delegated_inode);</span><br><span class="line">exit2:</span><br><span class="line">                dput(dentry);</span><br><span class="line">        &#125;    </span><br><span class="line">        mutex_unlock(&amp;nd.path.dentry-&gt;d_inode-&gt;i_mutex);</span><br><span class="line">        <span class="keyword">if</span> (inode)</span><br><span class="line">                iput(inode);    <span class="comment">/* truncate the inode here */</span> <span class="comment">//tj: 这里是关键</span></span><br></pre></td></tr></table></figure><p>input:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *iput- put an inode</span></span><br><span class="line"><span class="comment"> *@inode: inode to put</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Puts an inode, dropping its usage count. If the inode use count hits</span></span><br><span class="line"><span class="comment"> *zero, the inode is then freed and may also be destroyed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Consequently, iput() can sleep.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iput</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!inode)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">BUG_ON(inode-&gt;i_state &amp; I_CLEAR);</span><br><span class="line">retry:</span><br><span class="line"><span class="keyword">if</span> (atomic_dec_and_lock(&amp;inode-&gt;i_count, &amp;inode-&gt;i_lock)) &#123;</span><br><span class="line"><span class="keyword">if</span> (inode-&gt;i_nlink &amp;&amp; (inode-&gt;i_state &amp; I_DIRTY_TIME)) &#123;</span><br><span class="line"><span class="type">atomic_inc</span>(&amp;inode-&gt;i_count);</span><br><span class="line">inode-&gt;i_state &amp;= ~I_DIRTY_TIME;</span><br><span class="line">spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">trace_writeback_lazytime_iput(inode);</span><br><span class="line">mark_inode_dirty_sync(inode);</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">iput_final(inode); <span class="comment">//tj: 最终要走这里</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iput_final:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called when we&#x27;re dropping the last reference</span></span><br><span class="line"><span class="comment"> * to an inode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Call the FS &quot;drop_inode()&quot; function, defaulting to</span></span><br><span class="line"><span class="comment"> * the legacy UNIX filesystem behaviour.  If it tells</span></span><br><span class="line"><span class="comment"> * us to evict inode, do so.  Otherwise, retain inode</span></span><br><span class="line"><span class="comment"> * in cache if fs is alive, sync and evict if fs is</span></span><br><span class="line"><span class="comment"> * shutting down.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">iput_final</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> inode-&gt;i_sb;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> *<span class="title">op</span> =</span> inode-&gt;i_sb-&gt;s_op;</span><br><span class="line"><span class="type">int</span> drop;</span><br><span class="line"></span><br><span class="line">WARN_ON(inode-&gt;i_state &amp; I_NEW);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (op-&gt;drop_inode)</span><br><span class="line">drop = op-&gt;drop_inode(inode);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">drop = generic_drop_inode(inode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!drop &amp;&amp; (sb-&gt;s_flags &amp; MS_ACTIVE)) &#123;</span><br><span class="line">inode-&gt;i_state |= I_REFERENCED;</span><br><span class="line">inode_add_lru(inode);</span><br><span class="line">spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!drop) &#123;</span><br><span class="line">inode-&gt;i_state |= I_WILL_FREE;</span><br><span class="line">spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">write_inode_now(inode, <span class="number">1</span>);</span><br><span class="line">spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">WARN_ON(inode-&gt;i_state &amp; I_NEW);</span><br><span class="line">inode-&gt;i_state &amp;= ~I_WILL_FREE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inode-&gt;i_state |= I_FREEING;</span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;inode-&gt;i_lru))</span><br><span class="line">inode_lru_list_del(inode);</span><br><span class="line">spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line"></span><br><span class="line">evict(inode); <span class="comment">// tj: 这里会释放空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>evict:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">evict</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> *<span class="title">op</span> =</span> inode-&gt;i_sb-&gt;s_op;</span><br><span class="line"></span><br><span class="line">BUG_ON(!(inode-&gt;i_state &amp; I_FREEING));</span><br><span class="line">BUG_ON(!list_empty(&amp;inode-&gt;i_lru));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;inode-&gt;i_wb_list))</span><br><span class="line">inode_wb_list_del(inode);</span><br><span class="line"></span><br><span class="line">inode_sb_list_del(inode);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wait for flusher thread to be done with the inode so that filesystem</span></span><br><span class="line"><span class="comment"> * does not start destroying it while writeback is still running. Since</span></span><br><span class="line"><span class="comment"> * the inode has I_FREEING set, flusher thread won&#x27;t start new work on</span></span><br><span class="line"><span class="comment"> * the inode.  We just have to wait for running writeback to finish.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">inode_wait_for_writeback(inode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (op-&gt;evict_inode) &#123;</span><br><span class="line">op-&gt;evict_inode(inode); <span class="comment">// tj: call fat_evict_inode </span></span><br></pre></td></tr></table></figure><p>fat_evict_inode:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fat_evict_inode</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">        truncate_inode_pages_final(&amp;inode-&gt;i_data);</span><br><span class="line">        <span class="keyword">if</span> (!inode-&gt;i_nlink) &#123;</span><br><span class="line">                inode-&gt;i_size = <span class="number">0</span>; </span><br><span class="line">                fat_truncate_blocks(inode, <span class="number">0</span>); <span class="comment">// tj: 这里释放</span></span><br><span class="line">        &#125;    </span><br><span class="line">        invalidate_inode_buffers(inode);</span><br><span class="line">        clear_inode(inode);</span><br><span class="line">        fat_cache_inval_inode(inode);</span><br><span class="line">        fat_detach(inode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fat_truncate_blocks:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fat_truncate_blocks</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">loff_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msdos_sb_info</span> *<span class="title">sbi</span> =</span> MSDOS_SB(inode-&gt;i_sb);</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> cluster_size = sbi-&gt;cluster_size;</span><br><span class="line">        <span class="type">int</span> nr_clusters;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  </span></span><br><span class="line"><span class="comment">         * This protects against truncating a file bigger than it was then</span></span><br><span class="line"><span class="comment">         * trying to write into the hole.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (MSDOS_I(inode)-&gt;mmu_private &gt; offset)</span><br><span class="line">                MSDOS_I(inode)-&gt;mmu_private = offset;</span><br><span class="line"></span><br><span class="line">        nr_clusters = (offset + (cluster_size - <span class="number">1</span>)) &gt;&gt; sbi-&gt;cluster_bits;</span><br><span class="line"></span><br><span class="line">        fat_free(inode, nr_clusters);  <span class="comment">// tj: got here...</span></span><br><span class="line">        fat_flush_inodes(inode-&gt;i_sb, inode, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>so, 删除文件的流程：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">do_unlinkat -&gt; input -&gt; input_final -&gt; evict -&gt; fat_evict_inode</span><br></pre></td></tr></table></figure><p>可以看出，evict是有条件触发的:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (atomic_dec_and_lock(&amp;inode-&gt;i_count, &amp;inode-&gt;i_lock)) &#123;</span><br></pre></td></tr></table></figure><p>ok, 就是说i_count必须是0 vfat才能truncate block, 加了调试信息果然发现input进入i_count是2，显然就没走evict。</p><p>so, what is i_count of an inode? 就是inode的使用计数，怎么理解？i_count被封在__iget里，可以看到很多接口会call __iget。还有一个计数是i_nlink, 是inode的hard link数目，只有两者都是0才释放该空间。</p><p>那sdcardfs lookup哪里使用了i_count?</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sdcardfs_lookup &gt; __sdcardfs_lookup &gt; __sdcardfs_interpose &gt; sdcardfs_iget &gt; igrab &gt; __iget &gt; atomic_inc(&amp;inode-&gt;i_count);</span><br></pre></td></tr></table></figure><p>sdcardfs lookup一直使用该inode导致在接下来的vfat unlink不能进入evict。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a href="https://www.ibm.com/developerworks/library/l-virtual-filesystem-switch/">https://www.ibm.com/developerworks/library/l-virtual-filesystem-switch/</a></p></li><li><p><a href="http://git.fsl.cs.sunysb.edu/?p=wrapfs-latest.git;a=blob;f=Documentation/filesystems/wrapfs.txt">http://git.fsl.cs.sunysb.edu/?p=wrapfs-latest.git;a=blob;f=Documentation/filesystems/wrapfs.txt</a></p></li><li><p><a href="http://www.fsl.cs.sunysb.edu/docs/linux-stacking/linux.pdf">http://www.fsl.cs.sunysb.edu/docs/linux-stacking/linux.pdf</a></p></li><li><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-usagecounter/index.html">https://www.ibm.com/developerworks/cn/linux/l-cn-usagecounter/index.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> fs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>memcg:understand memory usage</title>
      <link href="/understand-memcg-memory-usage.html"/>
      <url>/understand-memcg-memory-usage.html</url>
      
        <content type="html"><![CDATA[<p>Android Go的用户态lmk在探测内存压力时用到了memcg的如下内存使用统计：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MEMCG_MEMORY_USAGE <span class="string">&quot;/dev/memcg/memory.usage_in_bytes&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMCG_MEMORYSW_USAGE <span class="string">&quot;/dev/memcg/memory.memsw.usage_in_bytes&quot;</span></span></span><br></pre></td></tr></table></figure><p>memcg是cgroup的一个子系统，那这两个文件是如何统计内存使用的，带着这个疑问来看下, kernel 3.18, msm平台。</p><h2 id="How-to-read"><a href="#How-to-read" class="headerlink" title="How to read"></a>How to read</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cftype</span> <span class="title">mem_cgroup_files</span>[] =</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">&quot;usage_in_bytes&quot;</span>,</span><br><span class="line">.private = MEMFILE_PRIVATE(_MEM, RES_USAGE),</span><br><span class="line">.read_u64 = mem_cgroup_read_u64,</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG_SWAP</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> cftype memsw_cgroup_files[] = &#123;</span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">&quot;memsw.usage_in_bytes&quot;</span>,</span><br><span class="line">.private = MEMFILE_PRIVATE(_MEMSWAP, RES_USAGE),</span><br><span class="line">.read_u64 = mem_cgroup_read_u64,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>统一入口<code>mem_cgroup_read_u64</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> u64 <span class="title function_">mem_cgroup_read_u64</span><span class="params">(<span class="keyword">struct</span> cgroup_subsys_state *css,</span></span><br><span class="line"><span class="params">       <span class="keyword">struct</span> cftype *cft)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span> =</span> mem_cgroup_from_css(css);</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">res_type</span> <span class="title">type</span> =</span> MEMFILE_TYPE(cft-&gt;private);</span><br><span class="line"><span class="type">int</span> name = MEMFILE_ATTR(cft-&gt;private);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> _MEM:</span><br><span class="line"><span class="keyword">if</span> (name == RES_USAGE)</span><br><span class="line"><span class="keyword">return</span> mem_cgroup_usage(memcg, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">return</span> res_counter_read_u64(&amp;memcg-&gt;res, name);</span><br><span class="line"><span class="keyword">case</span> _MEMSWAP:</span><br><span class="line"><span class="keyword">if</span> (name == RES_USAGE)</span><br><span class="line"><span class="keyword">return</span> mem_cgroup_usage(memcg, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> res_counter_read_u64(&amp;memcg-&gt;memsw, name);</span><br></pre></td></tr></table></figure><p>这里<code>usage_in_bytes</code>和<code>memsw.usage_in_bytes</code>都走了<code>mem_cgroup_usage(,boot swap)</code>。 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u64 <span class="title function_">mem_cgroup_usage</span><span class="params">(<span class="keyword">struct</span> mem_cgroup *memcg, <span class="type">bool</span> swap)</span></span><br><span class="line">&#123;</span><br><span class="line">u64 val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mem_cgroup_is_root(memcg)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!swap)</span><br><span class="line"><span class="keyword">return</span> res_counter_read_u64(&amp;memcg-&gt;res, RES_USAGE);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> res_counter_read_u64(&amp;memcg-&gt;memsw, RES_USAGE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Transparent hugepages are still accounted for in MEM_CGROUP_STAT_RSS</span></span><br><span class="line"><span class="comment"> * as well as in MEM_CGROUP_STAT_RSS_HUGE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">val = mem_cgroup_recursive_stat(memcg, MEM_CGROUP_STAT_CACHE);</span><br><span class="line">val += mem_cgroup_recursive_stat(memcg, MEM_CGROUP_STAT_RSS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (swap)</span><br><span class="line">val += mem_cgroup_recursive_stat(memcg, MEM_CGROUP_STAT_SWAP);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> val &lt;&lt; PAGE_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从字面上看，如果是root memcg那就走<code>mem_cgroup_recursive_stat</code>循环统计，如果是non root memcg那就直接call <code>res_counter_read_u64</code>去读<code>res</code>。</p><p>res的内核文档设计说明：</p><blockquote><p>2.1. Design</p><p>The core of the design is a counter called the res_counter. The res_counter<br>tracks the current memory usage and limit of the group of processes associated<br>with the controller. Each cgroup has a memory controller specific data<br>structure (mem_cgroup) associated with it. </p><p>2.2. Accounting</p><pre><code>           +--------------------+           |  mem_cgroup     |              |  (res_counter)     |              +--------------------+            /            ^      \              /             |       \         +---------------+  |        +---------------+      | mm_struct     |  |....    | mm_struct     |         |               |  |        |               |         +---------------+  |        +---------------+                         |                            + --------------+                                         |         +---------------+           +------+--------+      | page          +----------&gt;  page_cgroup|      |               |           |               |         +---------------+           +---------------+        (Figure 1: Hierarchy of Accounting)</code></pre><p>Figure 1 shows the important aspects of the controller</p><ol><li>Accounting happens per cgroup</li><li>Each mm_struct knows about which cgroup it belongs to</li><li>Each page has a pointer to the page_cgroup, which in turn knows the<br>  cgroup it belongs to</li></ol></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> <span class="title">css</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * the counter to account for memory usage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">res_counter</span> <span class="title">res</span>;</span></span><br></pre></td></tr></table></figure><p>root memcg的统计用的是<code>struct mem_cgroup_stat_cpu</code>的<code>count</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup_stat_cpu</span> &#123;</span></span><br><span class="line"><span class="type">long</span> count[MEM_CGROUP_STAT_NSTATS];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> events[MEM_CGROUP_EVENTS_NSTATS];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nr_page_events;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> targets[MEM_CGROUP_NTARGETS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * percpu counter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup_stat_cpu</span> __<span class="title">percpu</span> *<span class="title">stat</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">mem_cgroup_read_stat</span><span class="params">(<span class="keyword">struct</span> mem_cgroup *memcg,</span></span><br><span class="line"><span class="params"> <span class="keyword">enum</span> mem_cgroup_stat_index idx)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">for_each_possible_cpu(cpu)</span><br><span class="line">val += per_cpu(memcg-&gt;stat-&gt;count[idx], cpu);</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>What is root memcg? 就是初始化时创建的cgroup就是root memory cgroup:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> cgroup_subsys_state * __ref</span><br><span class="line"><span class="title function_">mem_cgroup_css_alloc</span><span class="params">(<span class="keyword">struct</span> cgroup_subsys_state *parent_css)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line"><span class="type">long</span> error = -ENOMEM;</span><br><span class="line"><span class="type">int</span> node;</span><br><span class="line"></span><br><span class="line">memcg = mem_cgroup_alloc();</span><br><span class="line"><span class="keyword">if</span> (!memcg)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line"></span><br><span class="line">for_each_node(node)</span><br><span class="line"><span class="keyword">if</span> (alloc_mem_cgroup_per_zone_info(memcg, node))</span><br><span class="line"><span class="keyword">goto</span> free_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* root ? */</span></span><br><span class="line"><span class="keyword">if</span> (parent_css == <span class="literal">NULL</span>) &#123;</span><br><span class="line">root_mem_cgroup = memcg;</span><br><span class="line">res_counter_init(&amp;memcg-&gt;res, <span class="literal">NULL</span>);</span><br><span class="line">res_counter_init(&amp;memcg-&gt;memsw, <span class="literal">NULL</span>);</span><br><span class="line">res_counter_init(&amp;memcg-&gt;kmem, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cgroup_init -&gt; cgroup_init_subsys -&gt; mem_cgroup_css_alloc(NULL)</span><br></pre></td></tr></table></figure><p>init(system&#x2F;core&#x2F;init&#x2F;init.cpp)会创建non root memcg，如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set memcg property based on kernel cmdline argument</span></span><br><span class="line"> <span class="type">bool</span> memcg_enabled = android::base::<span class="built_in">GetBoolProperty</span>(<span class="string">&quot;ro.boot.memcg&quot;</span>,<span class="literal">false</span>);</span><br><span class="line"> <span class="keyword">if</span> (memcg_enabled) &#123;</span><br><span class="line">    <span class="comment">// root memory control cgroup</span></span><br><span class="line">    <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/memcg&quot;</span>, <span class="number">0700</span>);</span><br><span class="line">    <span class="built_in">chown</span>(<span class="string">&quot;/dev/memcg&quot;</span>,AID_ROOT,AID_SYSTEM);</span><br><span class="line">    <span class="built_in">mount</span>(<span class="string">&quot;none&quot;</span>, <span class="string">&quot;/dev/memcg&quot;</span>, <span class="string">&quot;cgroup&quot;</span>, <span class="number">0</span>, <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">    <span class="comment">// app mem cgroups, used by activity manager, lmkd and zygote</span></span><br><span class="line">    <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/memcg/apps/&quot;</span>,<span class="number">0755</span>);</span><br><span class="line">    <span class="built_in">chown</span>(<span class="string">&quot;/dev/memcg/apps/&quot;</span>,AID_SYSTEM,AID_SYSTEM);</span><br><span class="line">    <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/memcg/system&quot;</span>,<span class="number">0550</span>);</span><br><span class="line">    <span class="built_in">chown</span>(<span class="string">&quot;/dev/memcg/system&quot;</span>,AID_SYSTEM,AID_SYSTEM);</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>non root的memcg创建：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cgroup_mkdir -&gt; create_css -&gt; mem_cgroup_css_alloc</span><br></pre></td></tr></table></figure><p>ok, 那lmkd统计的mem usage其实就是root memcg的统计，root memcg就是把所有memcg的mem_cgroup_stat_cpu的count累加。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">mem_cgroup_recursive_stat</span><span class="params">(<span class="keyword">struct</span> mem_cgroup *memcg,</span></span><br><span class="line"><span class="params">       <span class="keyword">enum</span> mem_cgroup_stat_index idx)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">iter</span>;</span></span><br><span class="line"><span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Per-cpu values can be negative, use a signed accumulator */</span></span><br><span class="line">for_each_mem_cgroup_tree(iter, memcg)</span><br><span class="line">val += mem_cgroup_read_stat(iter, idx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (val &lt; <span class="number">0</span>) <span class="comment">/* race ? */</span></span><br><span class="line">val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>memcg使用多少内存统计的是 MEM_CGROUP_STAT_CACHE + MEM_CGROUP_STAT_RSS + MEM_CGROUP_STAT_SWAP。</p><p>看下系统cgroups的情况：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/dev/memcg/system <span class="comment"># cat /proc/cgroups</span></span><br><span class="line"><span class="comment">#subsys_name    hierarchy       num_cgroups     enabled</span></span><br><span class="line">cpu     3       1       1</span><br><span class="line">cpuacct 2       2       1</span><br><span class="line">memory  1       128     1</span><br><span class="line">freezer 0       1       1</span><br><span class="line">debug   0       1       1</span><br></pre></td></tr></table></figure><p>memory这个cgroup子系统就一个hierarchy，其id是1，这个hierarchy里包含了128个memcg。</p><p>了解下hierarchy:</p><blockquote><ol start="6"><li>Hierarchy support</li></ol><p>The memory controller supports a deep hierarchy and hierarchical accounting.<br>The hierarchy is created by creating the appropriate cgroups in the<br>cgroup filesystem. Consider for example, the following cgroup filesystem<br>hierarchy</p><pre><code>          root        /  |   \          /   |    \         a    b     c                    | \                  |  \                 d   e   </code></pre><p>In the diagram above, with hierarchical accounting enabled, all memory<br>usage of e, is accounted to its ancestors up until the root (i.e, c and root),<br>that has memory.use_hierarchy enabled. If one of the ancestors goes over its<br>limit, the reclaim algorithm reclaims from the tasks in the ancestor and the<br>children of the ancestor.</p></blockquote><h2 id="How-to-record"><a href="#How-to-record" class="headerlink" title="How to record"></a>How to record</h2><p>主要通过charge&#x2F;uncharge来记录，文档说明：</p><blockquote><ol><li><p>Charge<br>  a page&#x2F;swp_entry may be charged (usage +&#x3D; PAGE_SIZE) at</p><pre><code>mem_cgroup_try_charge()</code></pre></li><li><p>Uncharge<br>  a page&#x2F;swp_entry may be uncharged (usage -&#x3D; PAGE_SIZE) by</p><pre><code>mem_cgroup_uncharge()  Called when a page&#39;s refcount goes down to 0.mem_cgroup_uncharge_swap()  Called when swp_entry&#39;s refcnt goes down to 0. A charge against swap  disappears.</code></pre></li><li><p>charge-commit-cancel<br>Memcg pages are charged in two steps:<br>        mem_cgroup_try_charge()<br>        mem_cgroup_commit_charge() or mem_cgroup_cancel_charge()<br><br>At try_charge(), there are no flags to say “this page is charged”.<br>at this point, usage +&#x3D; PAGE_SIZE.<br><br>At commit(), the page is associated with the memcg.<br><br>At cancel(), simply usage -&#x3D; PAGE_SIZE.</p></li></ol></blockquote><p>对root memcg，<code>mem_cgroup_try_charge</code>就不统计res_counter：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">try_charge</span><span class="params">(<span class="keyword">struct</span> mem_cgroup *memcg, <span class="type">gfp_t</span> gfp_mask,</span></span><br><span class="line"><span class="params">      <span class="type">unsigned</span> <span class="type">int</span> nr_pages)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> batch = max(CHARGE_BATCH, nr_pages);</span><br><span class="line"><span class="type">int</span> nr_retries = MEM_CGROUP_RECLAIM_RETRIES;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">mem_over_limit</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">res_counter</span> *<span class="title">fail_res</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nr_reclaimed;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> size;</span><br><span class="line"><span class="type">bool</span> may_swap = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> drained = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mem_cgroup_is_root(memcg))</span><br><span class="line"><span class="keyword">goto</span> done; <span class="comment">// tj: if root memcg, not record for res_counter</span></span><br><span class="line">...</span><br><span class="line">done:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cancel charge：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cancel_charge</span><span class="params">(<span class="keyword">struct</span> mem_cgroup *memcg, <span class="type">unsigned</span> <span class="type">int</span> nr_pages)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> bytes = nr_pages * PAGE_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mem_cgroup_is_root(memcg))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">res_counter_uncharge(&amp;memcg-&gt;res, bytes);</span><br><span class="line"><span class="keyword">if</span> (do_swap_account)</span><br><span class="line">res_counter_uncharge(&amp;memcg-&gt;memsw, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>so non root memcg和root memcg是分开统计的，具体实现后面再看。</p><p>那什么时候去统计了，比如增加a page到page cache里时会try charge。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li>kernel3.18&#x2F;Documentation&#x2F;cgroups&#x2F;memory.txt</li><li>kernel3.18&#x2F;Documentation&#x2F;cgroups&#x2F;memcg_test.txt</li></ul>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> memcg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Go lowmemorykiller分析</title>
      <link href="/analyze-lmk-under-android-go.html"/>
      <url>/analyze-lmk-under-android-go.html</url>
      
        <content type="html"><![CDATA[<p>Android Go是a feature of Android O MR1(8.1)，它已经不再使用in kernel lowmemorykiller了，取而代之的是user space的基于memory pressure的killer。</p><p>这个user space的代码就是system&#x2F;core&#x2F;lmkd&#x2F;lmkd.c，它是如何detect memory pressure的了？具体是在<code>mp_event_common</code>事件处理中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MEMCG_MEMORY_USAGE <span class="string">&quot;/dev/memcg/memory.usage_in_bytes&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMCG_MEMORYSW_USAGE <span class="string">&quot;/dev/memcg/memory.memsw.usage_in_bytes&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mp_event_common</span><span class="params">(<span class="type">bool</span> is_critical)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> evcount;</span><br><span class="line">    <span class="type">int</span> index = is_critical ? CRITICAL_INDEX : MEDIUM_INDEX;</span><br><span class="line">    <span class="type">int64_t</span> mem_usage, memsw_usage;</span><br><span class="line">    <span class="type">int64_t</span> mem_pressure;</span><br><span class="line"></span><br><span class="line">    ret = read(mpevfd[index], &amp;evcount, <span class="keyword">sizeof</span>(evcount));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        ALOGE(<span class="string">&quot;Error reading memory pressure event fd; errno=%d&quot;</span>,</span><br><span class="line">              errno);</span><br><span class="line"></span><br><span class="line">    mem_usage = get_memory_usage(MEMCG_MEMORY_USAGE);</span><br><span class="line">    memsw_usage = get_memory_usage(MEMCG_MEMORYSW_USAGE);</span><br><span class="line">    <span class="keyword">if</span> (memsw_usage &lt; <span class="number">0</span> || mem_usage &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        find_and_kill_process(is_critical); <span class="comment">//没内存了杀</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate percent for swappinness.</span></span><br><span class="line">    mem_pressure = (mem_usage * <span class="number">100</span>) / memsw_usage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enable_pressure_upgrade &amp;&amp; !is_critical) &#123; </span><br><span class="line">        <span class="comment">// We are swapping too much.</span></span><br><span class="line">        <span class="keyword">if</span> (mem_pressure &lt; upgrade_pressure) &#123;</span><br><span class="line">            ALOGI(<span class="string">&quot;Event upgraded to critical.&quot;</span>);</span><br><span class="line">            is_critical = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the pressure is larger than downgrade_pressure lmk will not</span></span><br><span class="line">    <span class="comment">// kill any process, since enough memory is available.</span></span><br><span class="line">    <span class="keyword">if</span> (mem_pressure &gt; downgrade_pressure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(<span class="string">&quot;Ignore %s memory pressure&quot;</span>, is_critical ? <span class="string">&quot;critical&quot;</span> : <span class="string">&quot;medium&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_critical &amp;&amp; mem_pressure &gt; upgrade_pressure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(<span class="string">&quot;Downgrade critical memory pressure&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Downgrade event to medium, since enough memory available.</span></span><br><span class="line">        is_critical = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (find_and_kill_process(is_critical) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(<span class="string">&quot;Nothing to kill&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看memory pressure的计算，Android Go上启用了memory cgroup,具体是如下两个内核配置：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">CONFIG_MEMCG=y</span><br><span class="line">CONFIG_MEMCG_SWAP=y</span><br></pre></td></tr></table></figure><p>kernel3.18&#x2F;Documentation&#x2F;cgroups&#x2F;memory.txt:</p><blockquote><p>memory.usage_in_bytes           # show current res_counter usage for memory<br>                                (See 5.5 for details)<br>memory.memsw.usage_in_bytes     # show current res_counter usage for memory+Swap<br>                                (See 5.5 for details)</p></blockquote><p>ok, 那基本清楚了，这个<code>mem_pressure</code>就和swapping成反比了，pressure值越小才说明有压力，数值越大基本没啥压力。</p><p>压力级别分成了medium和critical，相关代码都能看出：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MEMPRESSURE_WATCH_MEDIUM_LEVEL <span class="string">&quot;medium&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMPRESSURE_WATCH_CRITICAL_LEVEL <span class="string">&quot;critical&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* memory pressure level medium event */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mpevfd[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRITICAL_INDEX 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEDIUM_INDEX 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> medium_oomadj;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> critical_oomadj;</span><br></pre></td></tr></table></figure><p>回到<code>mp_event_common</code>，继续往下看：</p><p>如果当前swapping too much并且状态不是critical，就上升压力级别到critical，具体代码就是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (enable_pressure_upgrade &amp;&amp; !is_critical) &#123; </span><br><span class="line">    <span class="comment">// We are swapping too much.</span></span><br><span class="line">    <span class="keyword">if</span> (mem_pressure &lt; upgrade_pressure) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;Event upgraded to critical.&quot;</span>);</span><br><span class="line">        is_critical = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>如果当前没压力，也就是enough memory available时，也分成两个等级，如果内存非常充足(比downgrade_pressure还要大)，啥也不用干了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If the pressure is larger than downgrade_pressure lmk will not</span></span><br><span class="line"><span class="comment">// kill any process, since enough memory is available.</span></span><br><span class="line"><span class="keyword">if</span> (mem_pressure &gt; downgrade_pressure) &#123;</span><br><span class="line">    <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;Ignore %s memory pressure&quot;</span>, is_critical ? <span class="string">&quot;critical&quot;</span> : <span class="string">&quot;medium&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个没啥压力是在(upgrade_pressure, downgrade_pressure)之间，而且是critical event，那就把event级别降下到!critical。</p><p><code>upgrade_pressure</code>, <code>downgrade_pressure</code>可配置，默认是50，60：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">upgrade_pressure = (<span class="type">int64_t</span>)property_get_int32(<span class="string">&quot;ro.lmk.upgrade_pressure&quot;</span>, <span class="number">50</span>);</span><br><span class="line">downgrade_pressure = (<span class="type">int64_t</span>)property_get_int32(<span class="string">&quot;ro.lmk.downgrade_pressure&quot;</span>, <span class="number">60</span>);</span><br></pre></td></tr></table></figure><p>在build&#x2F;make&#x2F;target&#x2F;product&#x2F;go_defaults_common.mk文件中，google override了go的属性：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sets Android Go recommended default values for propreties.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set lowram options</span></span><br><span class="line">PRODUCT_PROPERTY_OVERRIDES += \</span><br><span class="line">     ro.config.low_ram=true \</span><br><span class="line">     ro.lmk.critical_upgrade=true \</span><br><span class="line">     ro.lmk.upgrade_pressure=40</span><br></pre></td></tr></table></figure><p>没有内存了，有压力了就调用find_and_kill_process找到某个进程并杀掉。</p><p>那选择的策略是什么了？in kernel是选择占用内存最多adj最大的那个,go的选择策略是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">find_and_kill_process</span><span class="params">(<span class="type">bool</span> is_critical)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> killed_size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min_score_adj = is_critical ? critical_oomadj : medium_oomadj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = OOM_SCORE_ADJ_MAX; i &gt;= min_score_adj; i--) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">procp</span>;</span></span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">        procp = proc_adj_lru(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (procp) &#123;</span><br><span class="line">            killed_size = kill_one_process(procp, min_score_adj, is_critical);</span><br><span class="line">            <span class="keyword">if</span> (killed_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> killed_size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见是从adj最大当中选个最近未使用的，如果压力太大adj过小的也能杀，就是把杀的范围扩大了呗，这个策略感觉明显要好于in kernel的。看了下N就这样实现了啊，难道Android很早就布局了！？</p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LMK </tag>
            
            <tag> memcg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System Crash实例分析一</title>
      <link href="/system-crash-analysis-1.html"/>
      <url>/system-crash-analysis-1.html</url>
      
        <content type="html"><![CDATA[<p>死机分析以前在R平台搞过，基本就是抓到死机时的CPU register等信息，然后用objdump反汇编出来结合源码定位分析，现在到了手机平台，多了个Tracer32，高通分析死机都在用，现在死机都挂我这了，老问高通也不是个事重拾下，我觉得可以不用trace32，基本还是那老一套。</p><p>先来看死机现场:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 1256.852648] Unable to handle kernel NULL pointer dereference at virtual address 00000004 </span><br><span class="line">[ 1256.931061] pgd = e2110000 </span><br><span class="line">[ 1256.933725] [00000004] *pgd=00000000 </span><br><span class="line">[ 1256.937725] Internal error: Oops: 5 [#1] PREEMPT SMP ARM </span><br><span class="line">[ 1256.942470] Modules linked in: wlan(O) [last unloaded: wlan] </span><br><span class="line">[ 1256.948098] CPU: 1 PID: 585 Comm: qti Tainted: G W O 3.18.71-perf-g24d2c84 #1 </span><br><span class="line">[ 1256.956092] task: e41161c0 ti: e2148000 task.ti: e2148000 </span><br><span class="line">[ 1256.961479] PC is at diagchar_read+0x610/0x11fc </span><br><span class="line">[ 1256.965978] LR is at 0x0 </span><br><span class="line">[ 1256.968488] pc : [&lt;c04e0b24&gt;] lr : [&lt;00000000&gt;] psr: 60010013 </span><br><span class="line">[ 1256.968488] sp : e2149ef0 ip : 00000051 fp : b1bb5b7c </span><br><span class="line">[ 1256.979944] r10: c6651000 r9 : 00000201 r8 : c5227bc0 </span><br><span class="line">[ 1256.985152] r7 : c13dbc38 r6 : 00000014 r5 : 000186a0 r4 : b1bb5b78 </span><br><span class="line">[ 1256.991676] r3 : 00000000 r2 : 80000000 r1 : 00000000 r0 : 00000000 </span><br></pre></td></tr></table></figure><p>内核空指针，一个关键信息是pc：c04e0b24。</p><p>objdump vmlinux出来后，基本<code>-lD</code>就够用了，搜到pc:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/code/kernel/msm-3.18/drivers/char/diag/diagchar_core.c:2933</span><br><span class="line">c04e0b1c:e3510000 cmp r1, #0</span><br><span class="line">c04e0b20:05983030 ldreq  r3, [r8, #48]; 0x30</span><br><span class="line">c04e0b24:05933004 ldreq r3, [r3, #4] ===============&gt; 这里crash</span><br><span class="line">c04e0b28:0a000028 beq c04e0bd0 &lt;diagchar_read+0x6bc&gt;</span><br><span class="line">c04e0b2c:ea0001b2 b c04e11fc &lt;diagchar_read+0xce8&gt; </span><br><span class="line">/code/kernel/msm-3.18/drivers/char/diag/diagchar_core.c:2937</span><br></pre></td></tr></table></figure><p>找到源码2933行:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (driver-&gt;data_ready[index] &amp; EVENT_MASKS_TYPE) &#123;</span><br><span class="line"><span class="comment">/*Copy the type of data being passed*/</span></span><br><span class="line">data_type = driver-&gt;data_ready[index] &amp; EVENT_MASKS_TYPE;</span><br><span class="line">session_info = diag_md_session_get_peripheral(APPS_DATA);</span><br><span class="line">COPY_USER_SPACE_OR_EXIT(buf, data_type, <span class="number">4</span>);</span><br><span class="line"><span class="number">2931</span><span class="keyword">if</span> (session_info &amp;&amp; session_info-&gt;event_mask &amp;&amp;</span><br><span class="line"><span class="number">2932</span>    session_info-&gt;event_mask-&gt;ptr) &#123;</span><br><span class="line"><span class="number">2933</span>COPY_USER_SPACE_OR_EXIT(buf + <span class="keyword">sizeof</span>(<span class="type">int</span>),</span><br><span class="line">*(session_info-&gt;event_mask-&gt;ptr),</span><br><span class="line">session_info-&gt;event_mask-&gt;mask_len);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">COPY_USER_SPACE_OR_EXIT(buf + <span class="keyword">sizeof</span>(<span class="type">int</span>),</span><br><span class="line">*(event_mask.ptr),</span><br><span class="line">event_mask.mask_len);</span><br><span class="line">&#125;</span><br><span class="line">driver-&gt;data_ready[index] ^= EVENT_MASKS_TYPE;</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2933行是：<code>COPY_USER_SPACE_OR_EXIT(buf + sizeof(int),</code>，crash的地方再看下现场：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r8 : c5227bc0</span><br><span class="line">r3 : 00000000</span><br></pre></td></tr></table></figure><p>也就是说r3 &#x3D; 0是触发这个死机的因, r3和r8看着应该和2934，2935有关，那到底是不是了，先看下偏移，struct里又是宏又是嵌套结构体，用gdb帮忙：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ arm-eabi-gdb vmlinux </span><br><span class="line">GNU gdb (GDB) 7.6</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line"></span><br><span class="line">(gdb) p &amp;((struct diag_md_session_t*)0)-&gt;event_mask</span><br><span class="line">$1 = (struct diag_mask_info **) 0x30</span><br><span class="line"></span><br><span class="line">(gdb) p &amp;((struct diag_mask_info*)0)-&gt;mask_len</span><br><span class="line">$2 = (int *) 0x4 &lt;__vectors_start+4&gt;</span><br></pre></td></tr></table></figure><p>再往上看看就能得出：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">r8=session_info</span><br><span class="line">r3=r8+48=session_info-&gt;event_mask</span><br><span class="line">r3=r3+4=session_info-&gt;event_mask-&gt;mask_len</span><br></pre></td></tr></table></figure><p>r3&#x3D;0触发，也就是session_info-&gt;event_mask是0？2931已经判断过了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/code/kernel/msm-3.18/drivers/char/diag/diagchar_core.c:2931 (discriminator 1)</span><br><span class="line">c04e0a68:e3580000 cmpr8, #0 ==================&gt; r8 = sesstion_info</span><br><span class="line">/work/buildfarm/jenkins/workspace/buildfarml_rmnj_10/kernel/msm-3.18/drivers/char/diag/diagchar_core.c:2930 (discriminator 1)</span><br><span class="line">c04e0a6c:e2833004 addr3, r3, #4</span><br><span class="line">c04e0a70:e58d3024 strr3, [sp, #36]; 0x24</span><br><span class="line">/code/kernel/msm-3.18/drivers/char/diag/diagchar_core.c:2931 (discriminator 1)</span><br><span class="line">c04e0a74:0a00002d beqc04e0b30 &lt;diagchar_read+0x61c&gt;</span><br><span class="line">c04e0a78:e5982030 ldrr2, [r8, #48]; 0x30 =====&gt; r2 = sesstion_info-&gt;event_mask</span><br><span class="line">c04e0a7c:e3520000 cmpr2, #0 ==============&gt; sesstion_info-&gt;event_mask == 0?</span><br><span class="line">c04e0a80:0a00002a beqc04e0b30 &lt;diagchar_read+0x61c&gt;</span><br><span class="line">/code/kernel/msm-3.18/drivers/char/diag/diagchar_core.c:2932 (discriminator 1)</span><br><span class="line">c04e0a84:e592a000 ldrsl, [r2]</span><br><span class="line">/code/kernel/msm-3.18/drivers/char/diag/diagchar_core.c:2931 (discriminator 1)</span><br><span class="line">c04e0a88:e35a0000 cmpsl, #0</span><br><span class="line">c04e0a8c:0a000027 beqc04e0b30 &lt;diagchar_read+0x61c&gt;</span><br></pre></td></tr></table></figure><p>so, 难道是DDR出现了跳变？多半是硬件问题。</p>]]></content>
      
      
      <categories>
          
          <category> stab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SELinux:fix an issue about &amp;quot;context_to_sid returned 12&amp;quot;</title>
      <link href="/fix-an-issue-about-context_to_sid-returned-12.html"/>
      <url>/fix-an-issue-about-context_to_sid-returned-12.html</url>
      
        <content type="html"><![CDATA[<p>前方用户提了个故障说手机发热低电下重启后发现有SD掉卡提示，Android_N&#x2F;Kernel_3.18，离线日志找了半天，logcat日志里发现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">434   439 E vold    : Failed to pclose /system/bin/sgdisk --android-dump /dev/block/vold/disk:179:64 : Success</span><br><span class="line">434   439 W vold    : disk:179:64 has unknown partition table; trying entire device</span><br></pre></td></tr></table></figure><p>代码在system&#x2F;vold&#x2F;Disk.cpp：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Disk::readPartitions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Ugly last ditch effort, treat entire disk as partition</span></span><br><span class="line">    <span class="keyword">if</span> (table == Table::kUnknown || !foundParts) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; mId &lt;&lt; <span class="string">&quot; has unknown partition table; trying entire device&quot;</span>;</span><br><span class="line"></span><br><span class="line">        std::string fsType;</span><br><span class="line">        std::string unused;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ReadMetadataUntrusted</span>(mDevPath, fsType, unused, unused) == OK) &#123;</span><br><span class="line">            <span class="built_in">createPublicVolume</span>(mDevice);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(WARNING) &lt;&lt; mId &lt;&lt; <span class="string">&quot; failed to identify, giving up&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数往上再看看：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Disk::readPartitions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Parse partition table</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::string&gt; cmd;</span><br><span class="line">    cmd.<span class="built_in">push_back</span>(kSgdiskPath);</span><br><span class="line">    cmd.<span class="built_in">push_back</span>(<span class="string">&quot;--android-dump&quot;</span>);</span><br><span class="line">    cmd.<span class="built_in">push_back</span>(mDevPath);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::string&gt; output;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;ForkExe before&quot;</span>;</span><br><span class="line">    <span class="type">status_t</span> res = <span class="built_in">ForkExecvp</span>(cmd, output);</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;sgdisk failed to scan &quot;</span> &lt;&lt; mDevPath;</span><br><span class="line">        <span class="built_in">notifyEvent</span>(ResponseCode::DiskScanned);</span><br><span class="line">        mJustPartitioned = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它是用sgdisk工具来分析分区表，只不过分析失败了，内核log里mmc1啥错也没有，不过有sgdisk权限出错：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    4.064447] SELinux: inode_doinit_with_dentry:  context_to_sid(u:object_r:sgdisk_exec:s0) returned 12 for dev=dm-0 ino=666</span><br><span class="line">[    4.064656] type=1400 audit(1726218.699:6): avc: denied &#123; execute &#125; for pid=441 comm=&quot;sh&quot; name=&quot;sgdisk&quot; dev=&quot;dm-0&quot; ino=666 scontext=u:r:vold:s0 tcontext=u:object_r:unlabeled:s0 tclass=file permissive=0</span><br></pre></td></tr></table></figure><p>怎么会有sgdisk这个错，看了下正常的log里是没有的。我决定复现看看，在尝试了多次后尽然让我复现了，和低电量就没有关系，复现以后拔出SD卡再插入仍然提示SD corrupted，dmesg多出来：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[  459.510818] mmc1: new ultra high speed SDR25 SDHC card at address 0001</span><br><span class="line">[  459.514104] mmcblk1: mmc1:0001 SD16G 14.4 GiB</span><br><span class="line">[  459.518791]  mmcblk1: p1</span><br><span class="line">[  459.545324] type=1400 audit(1515436020.539:39): avc: denied &#123; execute &#125; for p</span><br><span class="line">id=4850 comm=&quot;sh&quot; name=&quot;sgdisk&quot; dev=&quot;dm-0&quot; ino=666 scontext=u:r:vold:s0 tcontext</span><br><span class="line">=u:object_r:unlabeled:s0 tclass=file permissive=0</span><br></pre></td></tr></table></figure><p>内核已经检测出来mmc1，不过sgdisk权限出错，我们再看下出错时sgdisk权限：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxx:/ # ls -Z /system/bin/sgdisk</span><br><span class="line">u:object_r:unlabeled:s0 /system/bin/sgdisk</span><br></pre></td></tr></table></figure><p>sgdisk文件权限确是在system&#x2F;sepolicy&#x2F;file_contexts定义过的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/system/bin/sgdisk      u:object_r:sgdisk_exec:s0</span><br><span class="line">/system/bin/blkid       u:object_r:blkid_exec:s0</span><br><span class="line">/system/bin/tzdatacheck u:object_r:tzdatacheck_exec:s0</span><br></pre></td></tr></table></figure><p>再看看其他的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxx:/ # ls -Z /system/bin/blkid</span><br><span class="line">u:object_r:blkid_exec:s0 /system/bin/blkid</span><br><span class="line">xxx:/ # ls -Z /system/bin/ | grep unlabel</span><br><span class="line">u:object_r:unlabeled:s0              sgdisk</span><br><span class="line">xxx:/ #</span><br></pre></td></tr></table></figure><p>点背，只有sgdisk有问题，file_contexts是被编译到file_contexts.bin里的，参考Android.mk:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">LOCAL_MODULE := file_contexts.bin</span><br><span class="line">local_fc_files := <span class="variable">$(LOCAL_PATH)</span>/file_contexts</span><br></pre></td></tr></table></figure><p>ok, sgdisk为什么没有权限明明已经定义，注意前面还有个内核态错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    4.064447] SELinux: inode_doinit_with_dentry:  context_to_sid(u:object_r:sgdisk_exec:s0) returned 12 for dev=dm-0 ino=666</span><br></pre></td></tr></table></figure><p>这是什么意思？暂且不管，我们先跟下代码在security&#x2F;selinux&#x2F;hooks.c：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1271</span> <span class="comment">/* The inode&#x27;s security attributes must be initialized before first use. */</span></span><br><span class="line"><span class="number">1272</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">inode_doinit_with_dentry</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> dentry *opt_dentry)</span></span><br><span class="line">1273 &#123;</span><br><span class="line">...   </span><br><span class="line"><span class="number">1377</span>                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">1378</span>                         rc = security_context_to_sid_default(context, rc, &amp;sid,</span><br><span class="line"><span class="number">1379</span>                                                              sbsec-&gt;def_sid,</span><br><span class="line"><span class="number">1380</span>                                                              GFP_NOFS);</span><br><span class="line"><span class="number">1381</span>                         <span class="keyword">if</span> (rc) &#123;</span><br><span class="line"><span class="number">1382</span>                                 <span class="type">char</span> *dev = inode-&gt;i_sb-&gt;s_id;</span><br><span class="line"><span class="number">1383</span>                                 <span class="type">unsigned</span> <span class="type">long</span> ino = inode-&gt;i_ino;</span><br><span class="line"><span class="number">1384</span> </span><br><span class="line"><span class="number">1385</span>                                 <span class="keyword">if</span> (rc == -EINVAL) &#123;</span><br><span class="line"><span class="number">1386</span>                                         <span class="keyword">if</span> (printk_ratelimit())</span><br><span class="line"><span class="number">1387</span>                                                 printk(KERN_NOTICE <span class="string">&quot;SELinux: inode=%lu on dev=%s was found to have an invalid &quot;</span></span><br><span class="line"><span class="number">1388</span>                                                         <span class="string">&quot;context=%s.  This indicates you may need to relabel the inode or the &quot;</span></span><br><span class="line"><span class="number">1389</span>                                                         <span class="string">&quot;filesystem in question.\n&quot;</span>, ino, dev, context);</span><br><span class="line"><span class="number">1390</span>                                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">1391</span>                                         printk(KERN_WARNING <span class="string">&quot;SELinux: %s:  context_to_sid(%s) &quot;</span></span><br><span class="line"><span class="number">1392</span>                                                <span class="string">&quot;returned %d for dev=%s ino=%ld\n&quot;</span>,</span><br><span class="line"><span class="number">1393</span>                                                __func__, context, -rc, dev, ino);</span><br><span class="line"><span class="number">1394</span>                                 &#125;</span><br><span class="line"><span class="number">1395</span>                                 kfree(context);</span><br><span class="line"><span class="number">1396</span>                                 <span class="comment">/* Leave with the unlabeled SID */</span></span><br><span class="line"><span class="number">1397</span>                                 rc = <span class="number">0</span>;</span><br><span class="line"><span class="number">1398</span>                                 <span class="keyword">break</span>;</span><br><span class="line"><span class="number">1399</span>                         &#125;</span><br><span class="line"><span class="number">1400</span>                 &#125;</span><br><span class="line"><span class="number">1401</span>                 kfree(context);</span><br><span class="line"><span class="number">1402</span>                 isec-&gt;sid = sid;</span><br><span class="line"><span class="number">1403</span>                 <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>1391行出错，continue to track:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1486</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">1487  * security_context_to_sid_default - Obtain a SID for a given security context,</span></span><br><span class="line"><span class="comment">1488  * falling back to specified default if needed.</span></span><br><span class="line"><span class="comment">1489  *</span></span><br><span class="line"><span class="comment">1490  * @scontext: security context</span></span><br><span class="line"><span class="comment">1491  * @scontext_len: length in bytes</span></span><br><span class="line"><span class="comment">1492  * @sid: security identifier, SID</span></span><br><span class="line"><span class="comment">1493  * @def_sid: default SID to assign on error</span></span><br><span class="line"><span class="comment">1494  *</span></span><br><span class="line"><span class="comment">1495  * Obtains a SID associated with the security context that</span></span><br><span class="line"><span class="comment">1496  * has the string representation specified by @scontext.</span></span><br><span class="line"><span class="comment">1497  * The default SID is passed to the MLS layer to be used to allow</span></span><br><span class="line"><span class="comment">1498  * kernel labeling of the MLS field if the MLS field is not present</span></span><br><span class="line"><span class="comment">1499  * (for upgrading to MLS without full relabel).</span></span><br><span class="line"><span class="comment">1500  * Implicitly forces adding of the context even if it cannot be mapped yet.</span></span><br><span class="line"><span class="comment">1501  * Returns -%EINVAL if the context is invalid, -%ENOMEM if insufficient</span></span><br><span class="line"><span class="comment">1502  * memory is available, or 0 on success.</span></span><br><span class="line"><span class="comment">1503  */</span></span><br><span class="line"><span class="number">1504</span> <span class="type">int</span> <span class="title function_">security_context_to_sid_default</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *scontext, u32 scontext_len,</span></span><br><span class="line"><span class="params"><span class="number">1505</span>                                     u32 *sid, u32 def_sid, <span class="type">gfp_t</span> gfp_flags)</span></span><br><span class="line">1506 &#123;</span><br><span class="line"><span class="number">1507</span>         <span class="keyword">return</span> security_context_to_sid_core(scontext, scontext_len,</span><br><span class="line"><span class="number">1508</span>                                             sid, def_sid, gfp_flags, <span class="number">1</span>);</span><br><span class="line"><span class="number">1509</span> &#125;</span><br></pre></td></tr></table></figure><p>读下注释，return就是三个：0, -EINVAL, -ENOMEM。ENOMEM刚好是12。啥，insufficient memory？ ENOMEM太多了，加了打印最后发现是在security&#x2F;selinux&#x2F;ss&#x2F;sidtab.c:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">198</span> <span class="type">int</span> <span class="title function_">sidtab_context_to_sid</span><span class="params">(<span class="keyword">struct</span> sidtab *s,</span></span><br><span class="line"><span class="params"><span class="number">199</span>                           <span class="keyword">struct</span> context *context,</span></span><br><span class="line"><span class="params"><span class="number">200</span>                           u32 *out_sid)</span></span><br><span class="line">201 &#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">206</span>         *out_sid = SECSID_NULL;</span><br><span class="line"><span class="number">207</span> </span><br><span class="line"><span class="number">208</span>         sid  = sidtab_search_cache(s, context);</span><br><span class="line"><span class="number">209</span>         <span class="keyword">if</span> (!sid)</span><br><span class="line"><span class="number">210</span>                 sid = sidtab_search_context(s, context);</span><br><span class="line"><span class="number">211</span>         <span class="keyword">if</span> (!sid) &#123;</span><br><span class="line"><span class="number">212</span>                 spin_lock_irqsave(&amp;s-&gt;lock, flags);</span><br><span class="line"><span class="number">213</span>                 <span class="comment">/* Rescan now that we hold the lock. */</span></span><br><span class="line"><span class="number">214</span>                 sid = sidtab_search_context(s, context);</span><br><span class="line"><span class="number">215</span>                 <span class="keyword">if</span> (sid)&#123;</span><br><span class="line"><span class="number">216</span>                         <span class="keyword">goto</span> unlock_out;</span><br><span class="line"><span class="number">217</span>                 &#125;</span><br><span class="line"><span class="number">218</span>                 <span class="comment">/* No SID exists for the context.  Allocate a new one. */</span></span><br><span class="line"><span class="number">219</span>                 <span class="keyword">if</span> (s-&gt;next_sid == UINT_MAX || s-&gt;shutdown) &#123;</span><br><span class="line"><span class="number">220</span>                         ret = -ENOMEM;</span><br><span class="line"><span class="number">221</span>                         printk(KERN_INFO</span><br><span class="line"><span class="number">222</span>                        <span class="string">&quot;SELinux: next_sid=%d, shutdown=%d ret=%d.\n&quot;</span>,</span><br><span class="line"><span class="number">223</span>                                s-&gt;next_sid, s-&gt;shutdown, ret);</span><br><span class="line"><span class="number">224</span>                         <span class="keyword">goto</span> unlock_out;</span><br><span class="line"><span class="number">225</span>                 &#125;</span><br><span class="line"><span class="number">226</span>                 sid = s-&gt;next_sid++;</span><br><span class="line"><span class="number">227</span>                 <span class="keyword">if</span> (context-&gt;len)</span><br><span class="line"><span class="number">228</span>                         printk(KERN_INFO</span><br><span class="line"><span class="number">229</span>                        <span class="string">&quot;SELinux:  Context %s is not valid (left unmapped).\n&quot;</span>,</span><br><span class="line"><span class="number">230</span>                                context-&gt;str);</span><br><span class="line"><span class="number">231</span>                 ret = sidtab_insert(s, sid, context);</span><br><span class="line"><span class="number">232</span>                 <span class="keyword">if</span> (ret)</span><br><span class="line"><span class="number">233</span>                         s-&gt;next_sid--;</span><br><span class="line"><span class="number">234</span> unlock_out:</span><br><span class="line"><span class="number">235</span>                 spin_unlock_irqrestore(&amp;s-&gt;lock, flags);</span><br><span class="line"><span class="number">236</span>         &#125;</span><br><span class="line"><span class="number">237</span> </span><br><span class="line"><span class="number">238</span>         <span class="keyword">if</span> (ret)&#123;</span><br><span class="line"><span class="number">239</span>                 printk(<span class="string">&quot;return ret is %d\n&quot;</span>, ret);</span><br><span class="line"><span class="number">240</span>                 <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">241</span>         &#125;</span><br><span class="line"><span class="number">242</span> </span><br><span class="line"><span class="number">243</span>         *out_sid = sid;</span><br><span class="line"><span class="number">244</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">245</span> &#125;</span><br></pre></td></tr></table></figure><p>s-&gt;shutdown &#x3D; 1，这个才是关键，这个为啥是no memory？ 查看代码发现只有sidtab_shutdown会设置为1:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">317</span> <span class="type">void</span> <span class="title function_">sidtab_shutdown</span><span class="params">(<span class="keyword">struct</span> sidtab *s)</span></span><br><span class="line">318 &#123;</span><br><span class="line"><span class="number">319</span>         <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="number">320</span> </span><br><span class="line"><span class="number">321</span>         spin_lock_irqsave(&amp;s-&gt;lock, flags);</span><br><span class="line"><span class="number">322</span>         s-&gt;shutdown = <span class="number">1</span>;</span><br><span class="line"><span class="number">323</span>         spin_unlock_irqrestore(&amp;s-&gt;lock, flags);</span><br><span class="line"><span class="number">324</span> &#125;</span><br></pre></td></tr></table></figure><p>那我们看下sidtab_shutdown call stack:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sel_write_load -&gt; security_load_policy -&gt; sidtab_shutdown</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">sel_load_ops</span> =</span> &#123;</span><br><span class="line">        .write          = sel_write_load,</span><br><span class="line">        .llseek         = generic_file_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出来sel_write_load应该是由app通过write接口触发的，具体是在external&#x2F;libselinux, call stack：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">selinux_android_load_policy -&gt; selinux_android_load_policy_helper -&gt; security_load_policy -&gt; write( &quot;%s/load&quot;</span><br></pre></td></tr></table></figure><p>在它的上面init在call:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">init main -&gt; selinux_initialize -&gt; selinux_android_load_policy(in kernel_domain)</span><br></pre></td></tr></table></figure><p>回过头来再细看下kernel的security_load_policy：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sel_write_load :</span><br><span class="line"> |-&gt; copy_from_user</span><br><span class="line"> |-&gt; security_load_policy </span><br><span class="line">            |-&gt; policydb_read -&gt; avtab_read -&gt; avtab_alloc : print &quot;SELinux: %d avtab hash slots, %d rules&quot;</span><br><span class="line">            |-&gt; sidtab_shutdown (set shutdown=1)</span><br><span class="line">            |-&gt; sidtab_set (set shudown=0)</span><br><span class="line"> |-&gt; print &quot;policy loaded&quot;</span><br></pre></td></tr></table></figure><p>也就说在vold执行sgdisk时，因为shutdown&#x3D;1导致内核selinux报错，我们再看下报错log:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    4.064447] SELinux: inode_doinit_with_dentry:  context_to_sid(u:object_r:sgdisk_exec:s0) returned 12 for dev=dm-0 ino=666</span><br></pre></td></tr></table></figure><p>这里的sgdisk的context应该已经识别到了，就是sgdisk_exec，只不过在内核处理to sid时出错了，导致最终写到内核失败。</p><p>sgdisk的权限在file_contexts.bin里，可以看下logcat:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01-07 12:08:33.715  1860  1860 I auditd  : type=1400 audit(0.0:19): avc: denied &#123; execute &#125; for comm=&quot;sh&quot; name=&quot;sgdisk&quot; dev=&quot;dm-0&quot; ino=666 scontext=u:r:vold:s0 tcontext=u:object_r:unlabeled:s0 tclass=file permissive=0</span><br><span class="line">01-07 12:08:31.346  1459  1613 I SELinux : SELinux: Loaded file_contexts contexts from /file_contexts.bin.</span><br></pre></td></tr></table></figure><p>能看到，在12:08:31.346时file_contexts.bin已经loaded了，而权限报错是在2s后发生的，所以和load file_contexts时间无关，问题就是shutdown&#x3D;1为什么会抛出来。</p><p>我在shutdown的地方加些打印，发现security_load_policy走了2遍，一是在init first stage，一个是在init second stage，first stage是load的&#x2F;sepolicy文件，second stage是load的&#x2F;sepolicy_B。</p><p>从加的打印能看出来，在load sepolicy_B流程中shutdown&#x3D;1后面会shutdown&#x3D;0,而vold刚好踩在这个中间，这也证明了为啥偶尔会出现这个问题：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    4.090567] SELinux:  Class can_socket not defined in policy.</span><br><span class="line">[    4.090574] SELinux: the above unknown classes and permissions will be denied</span><br><span class="line">[    4.090579] shutdown=1 in sidtab_shutdown</span><br><span class="line">[    4.091293] SELinux: next_sid=294, shutdown=1 ret=-12.</span><br><span class="line">[    4.091305] SELinux: inode_doinit_with_dentry:  context_to_sid(u:object_r:sgdisk_exec:s0) returned 12 for dev=dm-0 ino=666</span><br><span class="line">[    4.091391]  shutdown=0 in sidtab_set</span><br><span class="line">[    4.091491] type=1400 audit(4328788.739:6): avc: denied &#123; execute &#125; for pid=444 comm=&quot;sh&quot; name=&quot;sgdisk&quot; dev=&quot;dm-0&quot; ino=666 scontext=u:r:vold:s0 tcontext=u:object_r:unlabeled:s0 tclass=file permissive=0</span><br><span class="line">[    4.147648] type=1403 audit(4328788.789:7): policy loaded auid=4294967295 ses=4294967295</span><br></pre></td></tr></table></figure><p>sepolicy_B是我们自己添加的，原生流程只有sepolicy是在kernel domain完成。是不是有问题？带着这个问题我们重看下init main：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">selinux_initialize</span><span class="params">(<span class="type">bool</span> in_kernel_domain)</span> </span>&#123;</span><br><span class="line">    Timer t;</span><br><span class="line"></span><br><span class="line">    selinux_callback cb;</span><br><span class="line">    cb.func_log = selinux_klog_callback;</span><br><span class="line">    <span class="built_in">selinux_set_callback</span>(SELINUX_CB_LOG, cb);</span><br><span class="line">    cb.func_audit = audit_callback;</span><br><span class="line">    <span class="built_in">selinux_set_callback</span>(SELINUX_CB_AUDIT, cb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_kernel_domain) &#123;</span><br><span class="line">        <span class="built_in">ERROR</span>(<span class="string">&quot;Loading SELinux policy...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">selinux_android_load_policy</span>() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ERROR</span>(<span class="string">&quot;failed to load policy: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">security_failure</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> kernel_enforcing = (<span class="built_in">security_getenforce</span>() == <span class="number">1</span>);</span><br><span class="line">        <span class="type">bool</span> is_enforcing = <span class="built_in">selinux_is_enforcing</span>();</span><br><span class="line">        <span class="keyword">if</span> (kernel_enforcing != is_enforcing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">security_setenforce</span>(is_enforcing)) &#123;</span><br><span class="line">                <span class="built_in">ERROR</span>(<span class="string">&quot;security_setenforce(%s) failed: %s\n&quot;</span>,</span><br><span class="line">                      is_enforcing ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                <span class="built_in">security_failure</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write_file</span>(<span class="string">&quot;/sys/fs/selinux/checkreqprot&quot;</span>, <span class="string">&quot;0&quot;</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">security_failure</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NOTICE</span>(<span class="string">&quot;(Initializing SELinux %s took %.2fs.)\n&quot;</span>,</span><br><span class="line">               is_enforcing ? <span class="string">&quot;enforcing&quot;</span> : <span class="string">&quot;non-enforcing&quot;</span>, t.<span class="built_in">duration</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ERROR</span>(<span class="string">&quot;init all handles...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">selinux_init_all_handles</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">NOTICE</span>(<span class="string">&quot;init %s started!\n&quot;</span>, is_first_stage ? <span class="string">&quot;first stage&quot;</span> : <span class="string">&quot;second stage&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Set up SELinux, including loading the SELinux policy if we&#x27;re in the kernel domain.</span></span><br><span class="line">    <span class="built_in">selinux_initialize</span>(is_first_stage);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>也就是selinux的初始化分两部分，一在first stage完成sepolicy加载，二是second stage会load file_contexts.bin等，这是本来的流程。而我们在second stage又添加了一个sepolicy加载，这个会把内核的load policy在用户态再走一边，比如shutdown&#x3D;1就会干扰用户态执行权限，应该是错误的，那我去掉这个sepolicy_B，测了多遍，故障消失:]</p><p>把这个sepolicy_B放到first stage加载应该也能解决问题，没测了。</p>]]></content>
      
      
      <categories>
          
          <category> security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> file_contexts.bin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析ueventd Coldboot耗时问题</title>
      <link href="/analyze-coldboot-time-consuming-issue.html"/>
      <url>/analyze-coldboot-time-consuming-issue.html</url>
      
        <content type="html"><![CDATA[<p>安卓go平台启动时间发现如下ueventd耗时1.907s问题：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01-11 00:20:02.854     0     0 I init    : Parsing file /odm/etc/init...</span><br><span class="line">01-11 00:20:02.854     0     0 E init    : Unable to open &#x27;/odm/etc/init&#x27;: No such file or directory</span><br><span class="line">01-11 00:20:02.854     0     0 I init    : processing action (early-init) from (/init.rc:14)</span><br><span class="line">01-11 00:20:02.855     0     0 D SELinux : initialized (dev cgroup, type cgroup), uses genfs_contexts</span><br><span class="line">01-11 00:20:02.856     0     0 I init    : starting service &#x27;ueventd&#x27;...</span><br><span class="line">01-11 00:20:02.857     0     0 W cgroup  : init (1) created nested cgroup for controller &quot;memory&quot; which has incomplete hierarchy support. Nested cgroups may change behavior in the future.</span><br><span class="line">01-11 00:20:02.857     0     0 W cgroup  : &quot;memory&quot; requires setting use_hierarchy to 1 on the root</span><br><span class="line">01-11 00:20:02.857     0     0 I init    : processing action (early-init) from (/vendor/etc/init/hw/init.qcom.rc:35)</span><br><span class="line">01-11 00:20:02.858     0     0 I init    : processing action (early-init) from (/vendor/etc/init/hw/init.target.rc:32)</span><br><span class="line">01-11 00:20:02.859     0     0 I init    : processing action (wait_for_coldboot_done) from (&lt;Builtin Action&gt;:0)</span><br><span class="line">01-11 00:20:02.861     0     0 I ueventd : ueventd started!</span><br><span class="line">01-11 00:20:02.861     0     0 I ueventd : Parsing file /ueventd.rc...</span><br><span class="line">01-11 00:20:02.867     0     0 I ueventd : Parsing file /vendor/ueventd.rc...</span><br><span class="line">01-11 00:20:02.871     0     0 I ueventd : Parsing file /odm/ueventd.rc...</span><br><span class="line">01-11 00:20:02.871     0     0 E ueventd : Unable to open &#x27;/odm/ueventd.rc&#x27;: No such file or directory</span><br><span class="line">01-11 00:20:02.871     0     0 I ueventd : Parsing file /ueventd.qcom.rc...</span><br><span class="line">01-11 00:20:02.871     0     0 E ueventd : Unable to open &#x27;/ueventd.qcom.rc&#x27;: No such file or directory</span><br><span class="line">01-11 00:20:02.881     0     0 I selinux : SELinux: Loaded file_contexts</span><br><span class="line">01-11 00:20:03.137     0     0 I chatty  : uid=0(root) logd identical 4 lines</span><br><span class="line">01-11 00:20:03.168     0     0 I selinux : SELinux: Loaded file_contexts</span><br><span class="line">01-11 00:20:04.789     0     0 I ueventd : Coldboot took 1.907 seconds</span><br><span class="line">01-11 00:20:04.791     0     0 I init    : Command &#x27;wait_for_coldboot_done&#x27; action=wait_for_coldboot_done (&lt;Builtin Action&gt;:0) returned 0 took 1932ms.</span><br><span class="line">01-11 00:20:04.792     0     0 I init    : processing action (mix_hwrng_into_linux_rng) from (&lt;Builtin Action&gt;:0)</span><br></pre></td></tr></table></figure><p>对应code在system&#x2F;core&#x2F;init&#x2F;ueventd.cpp：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ColdBoot::Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    android::base::Timer cold_boot_timer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegenerateUevents</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ForkSubProcesses</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DoRestoreCon</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WaitForSubProcesses</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(<span class="built_in">open</span>(COLDBOOT_DONE, O_WRONLY | O_CREAT | O_CLOEXEC, <span class="number">0000</span>));</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Coldboot took &quot;</span> &lt;&lt; cold_boot_timer.<span class="built_in">duration</span>().<span class="built_in">count</span>() / <span class="number">1000.0f</span> &lt;&lt; <span class="string">&quot; seconds&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ueventd main中运行：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ueventd_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">     * init sets the umask to 077 for forked processes. We need to</span></span><br><span class="line"><span class="comment">     * create files with exact permissions, without modification by</span></span><br><span class="line"><span class="comment">     * the umask.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitKernelLogging</span>(argv);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;ueventd started!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    selinux_callback cb; </span><br><span class="line">    cb.func_log = selinux_klog_callback;</span><br><span class="line">    <span class="built_in">selinux_set_callback</span>(SELINUX_CB_LOG, cb);</span><br><span class="line"></span><br><span class="line">    DeviceHandler device_handler = <span class="built_in">CreateDeviceHandler</span>();</span><br><span class="line">    UeventListener uevent_listener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">access</span>(COLDBOOT_DONE, F_OK) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function">ColdBoot <span class="title">cold_boot</span><span class="params">(uevent_listener, device_handler)</span></span>;</span><br><span class="line">        cold_boot.<span class="built_in">Run</span>();</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><p>init.rc会触发ueventd启动：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">on early-init</span><br><span class="line">    ...</span><br><span class="line">    start ueventd</span><br></pre></td></tr></table></figure><p>system&#x2F;core&#x2F;init&#x2F;init.cpp会解析init.rc:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::string bootscript = <span class="built_in">GetProperty</span>(<span class="string">&quot;ro.boot.init_rc&quot;</span>, <span class="string">&quot;&quot;</span>); </span><br><span class="line">    <span class="keyword">if</span> (bootscript.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        parser.<span class="built_in">ParseConfig</span>(<span class="string">&quot;/init.rc&quot;</span>);</span><br><span class="line">        parser.<span class="built_in">set_is_system_etc_init_loaded</span>(</span><br><span class="line">                parser.<span class="built_in">ParseConfig</span>(<span class="string">&quot;/system/etc/init&quot;</span>));</span><br><span class="line">        parser.<span class="built_in">set_is_vendor_etc_init_loaded</span>(</span><br><span class="line">                parser.<span class="built_in">ParseConfig</span>(<span class="string">&quot;/vendor/etc/init&quot;</span>));</span><br><span class="line">        parser.<span class="built_in">set_is_odm_etc_init_loaded</span>(parser.<span class="built_in">ParseConfig</span>(<span class="string">&quot;/odm/etc/init&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parser.<span class="built_in">ParseConfig</span>(bootscript);</span><br><span class="line">        parser.<span class="built_in">set_is_system_etc_init_loaded</span>(<span class="literal">true</span>);</span><br><span class="line">        parser.<span class="built_in">set_is_vendor_etc_init_loaded</span>(<span class="literal">true</span>);</span><br><span class="line">        parser.<span class="built_in">set_is_odm_etc_init_loaded</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure><p>解析完后会继续触发boot actions，首先是early-init：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">am.<span class="built_in">QueueEventTrigger</span>(<span class="string">&quot;early-init&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span></span><br><span class="line">am.<span class="built_in">QueueBuiltinAction</span>(wait_for_coldboot_done_action, <span class="string">&quot;wait_for_coldboot_done&quot;</span>);</span><br><span class="line"><span class="comment">// ... so that we can start queuing up actions that require stuff from /dev.</span></span><br><span class="line">am.<span class="built_in">QueueBuiltinAction</span>(mix_hwrng_into_linux_rng_action, <span class="string">&quot;mix_hwrng_into_linux_rng&quot;</span>);</span><br><span class="line">am.<span class="built_in">QueueBuiltinAction</span>(set_mmap_rnd_bits_action, <span class="string">&quot;set_mmap_rnd_bits&quot;</span>);</span><br><span class="line">am.<span class="built_in">QueueBuiltinAction</span>(set_kptr_restrict_action, <span class="string">&quot;set_kptr_restrict&quot;</span>);</span><br><span class="line">am.<span class="built_in">QueueBuiltinAction</span>(keychord_init_action, <span class="string">&quot;keychord_init&quot;</span>);</span><br><span class="line">am.<span class="built_in">QueueBuiltinAction</span>(console_init_action, <span class="string">&quot;console_init&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger all the boot actions to get us started.</span></span><br><span class="line">am.<span class="built_in">QueueEventTrigger</span>(<span class="string">&quot;init&quot;</span>);</span><br></pre></td></tr></table></figure><p>builtin action入队看下:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ActionManager::QueueEventTrigger</span><span class="params">(<span class="type">const</span> std::string&amp; trigger)</span> </span>&#123;</span><br><span class="line">    event_queue_.<span class="built_in">emplace</span>(trigger);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Action::AddCommand</span><span class="params">(BuiltinFunction f, <span class="type">const</span> std::vector&lt;std::string&gt;&amp; args, <span class="type">int</span> line)</span> </span>&#123;</span><br><span class="line">    commands_.<span class="built_in">emplace_back</span>(f, args, line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ActionManager::QueueBuiltinAction</span><span class="params">(BuiltinFunction func, <span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> action = std::<span class="built_in">make_unique</span>&lt;Action&gt;(<span class="literal">true</span>, <span class="string">&quot;&lt;Builtin Action&gt;&quot;</span>, <span class="number">0</span>); </span><br><span class="line">    std::vector&lt;std::string&gt; name_vector&#123;name&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!action-&gt;<span class="built_in">InitSingleTrigger</span>(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    action-&gt;<span class="built_in">AddCommand</span>(func, name_vector, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">    event_queue_.<span class="built_in">emplace</span>(action.<span class="built_in">get</span>()); <span class="comment">//也queue event</span></span><br><span class="line">    actions_.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(action));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上可见，最先处理action是early-init，然后是wait_for_coldboot_done：</p><p>入队以后会执行命令了：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// By default, sleep until something happens.</span></span><br><span class="line">    <span class="type">int</span> epoll_timeout_ms = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (do_shutdown &amp;&amp; !shutting_down) &#123;</span><br><span class="line">        do_shutdown = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">HandlePowerctlMessage</span>(shutdown_command)) &#123;</span><br><span class="line">            shutting_down = <span class="literal">true</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(waiting_for_prop || sm.<span class="built_in">IsWaitingForExec</span>())) &#123;</span><br><span class="line">        am.<span class="built_in">ExecuteOneCommand</span>();</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><p>am执行命令接口，先从queue里找到最先入队action，就是early-init了：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ActionManager::ExecuteOneCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Loop through the event queue until we have an action to execute</span></span><br><span class="line">    <span class="keyword">while</span> (current_executing_actions_.<span class="built_in">empty</span>() &amp;&amp; !event_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; action : actions_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">visit</span>([&amp;action](<span class="type">const</span> <span class="keyword">auto</span>&amp; event) &#123; <span class="keyword">return</span> action-&gt;<span class="built_in">CheckEvent</span>(event); &#125;,</span><br><span class="line">                           event_queue_.<span class="built_in">front</span>())) &#123;</span><br><span class="line">                current_executing_actions_.<span class="built_in">emplace</span>(action.<span class="built_in">get</span>());</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">        event_queue_.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_executing_actions_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> action = current_executing_actions_.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_command_ == <span class="number">0</span>) &#123;</span><br><span class="line">        std::string trigger_name = action-&gt;<span class="built_in">BuildTriggersString</span>();</span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;processing action (&quot;</span> &lt;&lt; trigger_name &lt;&lt; <span class="string">&quot;) from (&quot;</span> &lt;&lt; action-&gt;<span class="built_in">filename</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; action-&gt;<span class="built_in">line</span>() &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    action-&gt;<span class="built_in">ExecuteOneCommand</span>(current_command_);</span><br></pre></td></tr></table></figure><p>action的执行命令，超过50ms才会报个log，从log看显然early-init没有，是wait_for_coldboot_done超时了：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Action::ExecuteCommand</span><span class="params">(<span class="type">const</span> Command&amp; command)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    android::base::Timer t;</span><br><span class="line">    <span class="type">int</span> result = command.<span class="built_in">InvokeFunc</span>(); <span class="comment">//这里</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> duration = t.<span class="built_in">duration</span>();</span><br><span class="line">    <span class="comment">// Any action longer than 50ms will be warned to user as slow operation</span></span><br><span class="line">    <span class="keyword">if</span> (duration &gt; <span class="number">50</span>ms || android::base::<span class="built_in">GetMinimumLogSeverity</span>() &lt;= android::base::DEBUG) &#123;</span><br><span class="line">        std::string trigger_name = <span class="built_in">BuildTriggersString</span>();</span><br><span class="line">        std::string cmd_str = command.<span class="built_in">BuildCommandString</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Command &#x27;&quot;</span> &lt;&lt; cmd_str &lt;&lt; <span class="string">&quot;&#x27; action=&quot;</span> &lt;&lt; trigger_name &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; filename_</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; command.<span class="built_in">line</span>() &lt;&lt; <span class="string">&quot;) returned &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot; took &quot;</span></span><br><span class="line">                  &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Command::InvokeFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; expanded_args;</span><br><span class="line">    expanded_args.<span class="built_in">resize</span>(args_.<span class="built_in">size</span>());</span><br><span class="line">    expanded_args[<span class="number">0</span>] = args_[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; args_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">expand_props</span>(args_[i], &amp;expanded_args[i])) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(ERROR) &lt;&lt; args_[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;: cannot expand &#x27;&quot;</span> &lt;&lt; args_[i] &lt;&lt; <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func_</span>(expanded_args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的func_就先是do_start了，这个command就是一开始解析init.rc时add command了:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Action::AddCommand</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; args, <span class="type">int</span> line, std::string* err)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!function_map_) &#123;</span><br><span class="line">        *err = <span class="string">&quot;no function map available&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> function = function_map_-&gt;<span class="built_in">FindFunction</span>(args, err); <span class="comment">//从function map找到start命令对应的func:do_start</span></span><br><span class="line">    <span class="keyword">if</span> (!function) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AddCommand</span>(function, args, line);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ActionParser::ParseLineSection</span><span class="params">(std::vector&lt;std::string&gt;&amp;&amp; args, <span class="type">int</span> line, std::string* err)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> action_ ? action_-&gt;<span class="built_in">AddCommand</span>(std::<span class="built_in">move</span>(args), line, err) : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>function map里start命令对应的接口是do_start:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> BuiltinFunctionMap::Map&amp; <span class="title">BuiltinFunctionMap::map</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> std::<span class="type">size_t</span> kMax = std::numeric_limits&lt;std::<span class="type">size_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="comment">// clang-format off</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> Map builtin_functions = &#123;</span><br><span class="line">...</span><br><span class="line">        &#123;<span class="string">&quot;start&quot;</span>,                   &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_start&#125;&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>do_start:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">do_start</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Service* svc = ServiceManager::<span class="built_in">GetInstance</span>().<span class="built_in">FindServiceByName</span>(args[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!svc) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;do_start: Service &quot;</span> &lt;&lt; args[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; not found&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> (!svc-&gt;<span class="built_in">Start</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务启动入口：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Service::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Starting a service removes it from the disabled or reset state and</span></span><br><span class="line">    <span class="comment">// immediately takes it out of the restarting state if it was in there.</span></span><br><span class="line">    flags_ &amp;= (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Running processes require no additional work --- if they&#x27;re in the</span></span><br><span class="line">    <span class="comment">// process of exiting, we&#x27;ve ensured that they will immediately restart</span></span><br><span class="line">    <span class="comment">// on exit, unless they are ONESHOT.</span></span><br><span class="line">    <span class="keyword">if</span> (flags_ &amp; SVC_RUNNING) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;starting service &#x27;&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;&#x27;...&quot;</span>;</span><br></pre></td></tr></table></figure><p>这个service就是ueventd了，入口是ueventd_main:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ueventd_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">     * init sets the umask to 077 for forked processes. We need to</span></span><br><span class="line"><span class="comment">     * create files with exact permissions, without modification by</span></span><br><span class="line"><span class="comment">     * the umask.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitKernelLogging</span>(argv);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;ueventd started!&quot;</span>;</span><br></pre></td></tr></table></figure><p>ok，接下来就会从queue里取出coldboot_done_action:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">wait_for_coldboot_done_action</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Timer t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Waiting for &quot;</span> COLDBOOT_DONE <span class="string">&quot;...&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Historically we had a 1s timeout here because we weren&#x27;t otherwise</span></span><br><span class="line">    <span class="comment">// tracking boot time, and many OEMs made their sepolicy regular</span></span><br><span class="line">    <span class="comment">// expressions too expensive (http://b/19899875).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we&#x27;re tracking boot time, just log the time taken to a system</span></span><br><span class="line">    <span class="comment">// property. We still panic if it takes more than a minute though,</span></span><br><span class="line">    <span class="comment">// because any build that slow isn&#x27;t likely to boot at all, and we&#x27;d</span></span><br><span class="line">    <span class="comment">// rather any test lab devices fail back to the bootloader.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">wait_for_file</span>(COLDBOOT_DONE, <span class="number">60</span>s) &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Timed out waiting for &quot;</span> COLDBOOT_DONE;</span><br><span class="line">        <span class="built_in">panic</span>();</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">property_set</span>(<span class="string">&quot;ro.boottime.init.cold_boot_wait&quot;</span>, std::<span class="built_in">to_string</span>(t.<span class="built_in">duration</span>().<span class="built_in">count</span>()));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他会等待COLDBOOT_DONE文件生成，看log就是下面这个文件了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    2.180281] init: Waiting for /dev/.coldboot_done...</span><br></pre></td></tr></table></figure><p>也就是等待ueventd ColdBoot跑完：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ColdBoot::Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Coldboot took &quot;</span> &lt;&lt; cold_boot_timer.<span class="built_in">duration</span>().<span class="built_in">count</span>() / <span class="number">1000.0f</span> &lt;&lt; <span class="string">&quot; seconds&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后发现竟然是<code>DoRestoreCon()</code>耗时，看来是我们自家的sepolicy file_context太多了? </p><p>ps: 编译boot.img烧录验证。</p>]]></content>
      
      
      <categories>
          
          <category> perf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ueventd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git:如何修复gerrit merge conflict状态</title>
      <link href="/how-to-fix-merge-conflict-on-gerrit.html"/>
      <url>/how-to-fix-merge-conflict-on-gerrit.html</url>
      
        <content type="html"><![CDATA[<p>A本地修改了某个文件File，B本地也修改了这个文件File，他们都先后git push到了gerrit上，这个时候reviewer无论先进谁的提交，gerrit上另一笔提交的状态都会显示merge conflict，那如何更新这一笔change，而不是Abandon然后再提一个change呢，假设A的提交了先进了，要修改B的change。</p><ol><li>先同步服务器代码</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote update</span><br></pre></td></tr></table></figure><ol start="2"><li>rebase</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase remote_branch</span><br></pre></td></tr></table></figure><p>会出现如下提示：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: your_patch</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M your_modified_file</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging your_modified_file</span><br><span class="line">CONFLICT (content): Merge conflict in your_modified_file</span><br><span class="line">Recorded preimage for &#x27;your_modified_file&#x27;</span><br><span class="line">Failed to merge in the changes.</span><br><span class="line">Patch failed at 0001 your_patch</span><br><span class="line">The copy of the patch that failed is found in:</span><br><span class="line">   /your_prj_path/.git/rebase-apply/patch</span><br><span class="line"></span><br><span class="line">When you have resolved this problem, run &quot;git rebase --continue&quot;.</span><br><span class="line">If you prefer to skip this patch, run &quot;git rebase --skip&quot; instead.</span><br><span class="line">To check out the original branch and stop rebasing, run &quot;git rebase --abort&quot;.</span><br></pre></td></tr></table></figure><p>这个时候git log就能看到A的提交。</p><p>git status能看到此时正在rebasing,要你修复冲突后再运行continue rebase:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">rebase in progress; onto 5ac5126</span><br><span class="line">You are currently rebasing.</span><br><span class="line">  (fix conflicts and then run &quot;git rebase --continue&quot;)</span><br><span class="line">  (use &quot;git rebase --skip&quot; to skip this patch)</span><br><span class="line">  (use &quot;git rebase --abort&quot; to check out the original branch)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:      your_conflict_file</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><ol start="3"><li>修改冲突文件</li></ol><p>打开冲突文件，能发现A和B的提交都在里面，手动编辑这个文件让他保持A的提交内容，然后再加上B的修改。</p><ol start="4"><li>mark resolution</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>add后会提示冲突修复了。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">rebase in progress; onto 5ac5126</span><br><span class="line">You are currently rebasing.</span><br><span class="line">  (all conflicts fixed: run &quot;git rebase --continue&quot;)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   your_file</span><br></pre></td></tr></table></figure><ol start="5"><li>继续rebase</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>成功后会提示：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Applying: your_patch</span><br><span class="line">Recorded resolution for &#x27;your_modified_file&#x27;.</span><br></pre></td></tr></table></figure><p>再git log方法B的提交在A的后面。</p><ol start="6"><li>提交</li></ol><p>push后gerrit这一笔提交status的merge conflict已经没有了，History里会显示：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Uploaded patch set 2.</span><br></pre></td></tr></table></figure><p>OK, Done.</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核msleep()耗时过多优化</title>
      <link href="/how-to-optimize-undesired-delay-by-msleep.html"/>
      <url>/how-to-optimize-undesired-delay-by-msleep.html</url>
      
        <content type="html"><![CDATA[<p>高通低端平台启动时间发现有个地方耗时达2.5s，Linux内核版本3.18，具体是msm camera driver里使用了如下code:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">128</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">   do_something();</span><br><span class="line">   msleep(delay);</span><br><span class="line">   do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加log，delay是1ms，从log看实际延时多达20ms，整个循环下来达2.5s，如何达到预期的延时呢。</p><p>来看下内核文档Documentation&#x2F;timers&#x2F;timers-howto.txt关于延时的描述:</p><blockquote><p>ATOMIC CONTEXT:<br>       You must use the *delay family of functions. These<br>       functions use the jiffie estimation of clock speed<br>       and will busy wait for enough loop cycles to achieve<br>       the desired delay:</p><pre><code>   ndelay(unsigned long nsecs)   udelay(unsigned long usecs)   mdelay(unsigned long msecs)   udelay is the generally preferred API; ndelay-level   precision may not actually exist on many non-PC devices.   mdelay is macro wrapper around udelay, to account for    possible overflow when passing large arguments to udelay.   In general, use of mdelay is discouraged and code should   be refactored to allow for the use of msleep.</code></pre></blockquote><p>原子操作内延时必须用*delay系列忙等函数，我们来看下udelay的实现include&#x2F;asm-generic&#x2F;delay.h：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> udelay(n)                                                       \</span></span><br><span class="line"><span class="meta">        (&#123;                                                              \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (__builtin_constant_p(n)) &#123;                          \</span></span><br><span class="line"><span class="meta">                        <span class="keyword">if</span> ((n) / 20000 &gt;= 1)                           \</span></span><br><span class="line"><span class="meta">                                 __bad_udelay();                        \</span></span><br><span class="line"><span class="meta">                        <span class="keyword">else</span>                                            \</span></span><br><span class="line"><span class="meta">                                __const_udelay((n) * 0x10c7ul);         \</span></span><br><span class="line"><span class="meta">                &#125; <span class="keyword">else</span> &#123;                                                \</span></span><br><span class="line"><span class="meta">                        __udelay(n);                                    \</span></span><br><span class="line"><span class="meta">                &#125;                                                       \</span></span><br><span class="line"><span class="meta">        &#125;)</span></span><br></pre></td></tr></table></figure><p><code>__bad_udelay()</code>范围出错，<code>__udelay()</code>和<code>__const_udelay()</code>都依赖于硬件架构，比如ARM在arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;delay.h:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __udelay(n)             arm_delay_ops.udelay(n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __const_udelay(n)       arm_delay_ops.const_udelay(n)</span></span><br></pre></td></tr></table></figure><p>最后会call:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __LINUX_ARM_ARCH__ == 6 || defined(CONFIG_ARM_ERRATA_754327)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_relax()                     smp_mb()</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_relax()                     barrier()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __timer_delay(<span class="type">unsigned</span> <span class="type">long</span> cycles)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">cycles_t</span> start = get_cycles();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((get_cycles() - start) &lt; cycles)</span><br><span class="line">                cpu_relax();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>barrier()</code>是啥，内核文档Documentation&#x2F;memory-barriers.txt说明：</p><blockquote><h1 id="x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-WHAT-ARE-MEMORY-BARRIERS"><a href="#x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-WHAT-ARE-MEMORY-BARRIERS" class="headerlink" title="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;WHAT ARE MEMORY BARRIERS?"></a>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>WHAT ARE MEMORY BARRIERS?</h1><p>As can be seen above, independent memory operations are effectively performed<br>in random order, but this can be a problem for CPU-CPU interaction and for I&#x2F;O.<br>What is required is some way of intervening to instruct the compiler and the<br>CPU to restrict the order.</p><p>Memory barriers are such interventions.  They impose a perceived partial<br>ordering over the memory operations on either side of the barrier.</p><p>Such enforcement is important because the CPUs and other devices in a system<br>can use a variety of tricks to improve performance, including reordering,<br>deferral and combination of memory operations; speculative loads; speculative<br>branch prediction and various types of caching.  Memory barriers are used to<br>override or suppress these tricks, allowing the code to sanely control the<br>interaction of multiple CPUs and&#x2F;or devices.</p></blockquote><p>barrier就是强制memory operations的唯一有序性，rt? 具体以后再看。</p><blockquote><p>NON-ATOMIC CONTEXT:<br>       You should use the *sleep[_range] family of functions.<br>       There are a few more options here, while any of them may<br>       work correctly, using the “right” sleep function will<br>       help the scheduler, power management, and just make your<br>       driver better :)</p><pre><code>   -- Backed by busy-wait loop:           udelay(unsigned long usecs)   -- Backed by hrtimers:           usleep_range(unsigned long min, unsigned long max)   -- Backed by jiffies / legacy_timers           msleep(unsigned long msecs)           msleep_interruptible(unsigned long msecs)   Unlike the *delay family, the underlying mechanism   driving each of these calls varies, thus there are    quirks you should be aware of. </code></pre></blockquote><p>非原子操作内使用*sleep[_range]函数，用的不好就会带来性能问题，具体是注意一些quirks，来看看是哪些：</p><blockquote><pre><code>   SLEEPING FOR &quot;A FEW&quot; USECS ( &lt; ~10us? ):           * Use udelay           - Why not usleep?                   On slower systems, (embedded, OR perhaps a speed-                   stepped PC!) the overhead of setting up the hrtimers                   for usleep *may* not be worth it. Such an evaluation                   will obviously depend on your specific situation, but                   it is something to be aware of.</code></pre></blockquote><p>&lt; ~10us的也用udelay，不用hrtimers实现的usleep担心开销太大。what is hrtimers? see Documentation&#x2F;timers&#x2F;hrtimers.txt:</p><blockquote><p>subsystem for high-resolution kernel timers</p></blockquote><p>高精定时器，肯定准哈。</p><blockquote><pre><code>   SLEEPING FOR ~USECS OR SMALL MSECS ( 10us - 20ms):           * Use usleep_range           - Why not msleep for (1ms - 20ms)?                   Explained originally here:                           http://lkml.org/lkml/2007/8/3/250                   msleep(1~20) may not do what the caller intends, and                   will often sleep longer (~20 ms actual sleep for any                   value given in the 1~20ms range). In many cases this                   is not the desired behavior.           - Why is there no &quot;usleep&quot; / What is a good range?                   Since usleep_range is built on top of hrtimers, the                   wakeup will be very precise (ish), thus a simple                   usleep function would likely introduce a large number                   of undesired interrupts.                   With the introduction of a range, the scheduler is                   free to coalesce your wakeup with any other wakeup                   that may have happened for other reasons, or at the                   worst case, fire an interrupt for your upper bound.                   The larger a range you supply, the greater a chance                   that you will not trigger an interrupt; this should                   be balanced with what is an acceptable upper bound on                   delay / performance for your specific code path. Exact                   tolerances here are very situation specific, thus it                   is left to the caller to determine a reasonable range.</code></pre></blockquote><p>对10us - 20ms的使用usleep_range，那我们这里是delay 1ms，不应该使用msleep，原因上面说的很清楚了就是会sleep longer，应该用usleep_range，为啥要加range？没有range会带来很多中断？具体range和你的caller有关。</p><blockquote><pre><code>   SLEEPING FOR LARGER MSECS ( 10ms+ )           * Use msleep or possibly msleep_interruptible           - What&#39;s the difference?                   msleep sets the current task to TASK_UNINTERRUPTIBLE                   whereas msleep_interruptible sets the current task to                   TASK_INTERRUPTIBLE before scheduling the sleep. In                   short, the difference is whether the sleep can be ended                   early by a signal. In general, just use msleep unless                   you know you have a need for the interruptible variant</code></pre></blockquote><p>对应延时10ms+的使用msleep or msleep_interruptible。</p><p>那这里的range写多少了，我想这个问题内核drv肯定也有人遇到过，果然这个<a href="https://lkml.org/lkml/2016/11/29/54">patch</a>就是优化这类耗时：</p><figure class="highlight patch"><table><tr><td class="code"><pre><span class="line">DateTue, 29 Nov 2016 07:51:55 +0100</span><br><span class="line">FromVojtech Pavlik &lt;&gt;</span><br><span class="line">SubjectRe: [PATCH] Input: joystick: gf2k - change msleep to usleep_range for small msecs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    share 0</span><br><span class="line">    share 0</span><br><span class="line"></span><br><span class="line">On Tue, Nov 29, 2016 at 01:11:49AM +0530, Aniroop Mathur wrote:</span><br><span class="line"></span><br><span class="line">&gt; msleep(1~20) may not do what the caller intends, and will often sleep longer.</span><br><span class="line">&gt; (~20 ms actual sleep for any value given in the 1~20ms range)</span><br><span class="line">&gt; This is not the desired behaviour for many cases like device resume time,</span><br><span class="line">&gt; device suspend time, device enable time, connection time, probe time,</span><br><span class="line">&gt; loops, retry logic, etc</span><br><span class="line">&gt; msleep is built on jiffies / legacy timers which are not precise whereas</span><br><span class="line">&gt; usleep_range is build on top of hrtimers so the wakeups are precise.</span><br><span class="line">&gt; Thus, change msleep to usleep_range for precise wakeups.</span><br><span class="line">&gt; </span><br><span class="line">&gt; For example:</span><br><span class="line">&gt; On a machine with tick rate / HZ as 100, msleep(4) will make the process to</span><br><span class="line">&gt; sleep for a minimum period of 10 ms whereas usleep_range(4000, 4100) will make</span><br><span class="line">&gt; sure that the process does not sleep for more than 4100 us or 4.1ms</span><br><span class="line"></span><br><span class="line">And once more, patch not needed.</span><br><span class="line"></span><br><span class="line">&gt; </span><br><span class="line">&gt; Signed-off-by: Aniroop Mathur &lt;a.mathur@samsung.com&gt;</span><br><span class="line">&gt; ---</span><br><span class="line">&gt;  drivers/input/joystick/gf2k.c | 8 ++++----</span><br><span class="line">&gt;  1 file changed, 4 insertions(+), 4 deletions(-)</span><br><span class="line">&gt; </span><br><span class="line">&gt; diff --git a/drivers/input/joystick/gf2k.c b/drivers/input/joystick/gf2k.c</span><br></pre></td></tr></table></figure><p><code>msleep(delay)</code>改成<code>usleep_range(delay*1000, delay*1000 + 100)</code>，试了下，果然精确延时，节省了2.5s：]</p>]]></content>
      
      
      <categories>
          
          <category> perf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> msleep </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核如何获取音量键按下的状态</title>
      <link href="/how-to-get-volume-key-pressed.html"/>
      <url>/how-to-get-volume-key-pressed.html</url>
      
        <content type="html"><![CDATA[<p>高通平台一般会把音量下键绑在PMIC RESIN上，这样除了长按电源键重启外，还可以按音量下键重启。</p><p>先从内核文档（Kernel3.18）了解下RESIN:</p><blockquote><p>Qualcomm QPNP power-on</p><p>The qpnp-power-on is a driver which supports the power-on(PON)<br>peripheral on Qualcomm PMICs. The supported functionality includes<br>power on&#x2F;off reason, key press&#x2F;release detection, PMIC reset configurations<br>and other PON specifc features. The PON module supports multiple physical<br>power-on (KPDPWR_N, CBLPWR) and reset (KPDPWR_N, RESIN, KPDPWR+RESIN) sources.</p></blockquote><p>dts配置：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">pm8909_pon:</span> qcom,<span class="title class_">power-on@800</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;qcom,qpnp-power-on&quot;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x800</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x8</span> <span class="number">0x0</span>&gt;</span>,</span><br><span class="line">                     <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x8</span> <span class="number">0x1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">interrupt-names</span> <span class="operator">=</span> <span class="string">&quot;kpdpwr&quot;</span>, <span class="string">&quot;resin&quot;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">qcom,pon-dbc-delay</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">15625</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">qcom,system-reset</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">qcom,clear-warm-reset</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">qcom,store-hard-reset-reason</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line">        qcom,<span class="title class_">pon_1</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">qcom,pon-type</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                <span class="attr">qcom,support-reset</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                <span class="attr">qcom,pull-up</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                qcom,s1-<span class="attr">timer</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">10256</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                qcom,s2-<span class="attr">timer</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">2000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                qcom,s2-<span class="attr">type</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                <span class="attr">linux,code</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">116</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="punctuation">&#125;;</span>  </span><br><span class="line"></span><br><span class="line">        qcom,<span class="title class_">pon_2</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">qcom,pon-type</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                <span class="attr">qcom,pull-up</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                <span class="attr">linux,code</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">114</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="punctuation">&#125;;</span>  </span><br><span class="line"><span class="punctuation">&#125;;</span>  </span><br></pre></td></tr></table></figure><p>具体node&#x2F;prop含义都在下面这个文件里：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">devicetree/bindings/platform/msm/qpnp-power-on.txt</span><br></pre></td></tr></table></figure><p>pon-type就是复位源，linux,code就是对应的按键，116是电源键，114是音量下键，具体上报是在中断里派遣：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">qpnp_pon_input_dispatch</span><span class="params">(<span class="keyword">struct</span> qpnp_pon *pon, u32 pon_type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> rc;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">qpnp_pon_config</span> *<span class="title">cfg</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        u8 pon_rt_sts = <span class="number">0</span>, pon_rt_bit = <span class="number">0</span>; </span><br><span class="line">        u32 key_status;</span><br><span class="line">        u64 elapsed_us;</span><br><span class="line">...</span><br><span class="line">        pr_debug(<span class="string">&quot;PMIC input: code=%d, sts=0x%hhx\n&quot;</span>,</span><br><span class="line">                                        cfg-&gt;key_code, pon_rt_sts);</span><br><span class="line">        key_status = pon_rt_sts &amp; pon_rt_bit;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">qpnp_kpdpwr_irq</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *_pon)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> rc;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">qpnp_pon</span> *<span class="title">pon</span> =</span> _pon;</span><br><span class="line"></span><br><span class="line">        rc = qpnp_pon_input_dispatch(pon, PON_KPDPWR);</span><br></pre></td></tr></table></figure><p>注意看文档描述，还支持bark中断，这样可以添加一些自定义的处理了。</p><p>那音量下键没有接到PMIC RESIN，而是接到了GPIO上，内核是怎么获取按键状态的呢。</p><p>看下gpio的配置:</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">gpio_keys</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;gpio-keys&quot;</span><span class="punctuation">;</span></span><br><span class="line">                <span class="attr">input-name</span> <span class="operator">=</span> <span class="string">&quot;gpio-keys&quot;</span><span class="punctuation">;</span></span><br><span class="line">                <span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;tlmm_gpio_key_active&quot;</span>,<span class="string">&quot;tlmm_gpio_key_suspend&quot;</span><span class="punctuation">;</span></span><br><span class="line">                pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;gpio_key_active</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                pinctrl<span class="number">-1</span> = <span class="params">&lt;<span class="variable">&amp;gpio_key_suspend</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line">                <span class="title class_">vol_up</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">label</span> <span class="operator">=</span> <span class="string">&quot;volume_up&quot;</span><span class="punctuation">;</span></span><br><span class="line">                        <span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;msm_gpio</span> <span class="number">90</span> <span class="number">0x1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                        <span class="attr">linux,input-type</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                        <span class="attr">linux,code</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">115</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                        <span class="attr">gpio-key,wakeup</span><span class="punctuation">;</span></span><br><span class="line">                        <span class="attr">debounce-interval</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">15</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                <span class="punctuation">&#125;;</span>  </span><br><span class="line"></span><br><span class="line">                <span class="title class_">vol_down</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">label</span> <span class="operator">=</span> <span class="string">&quot;volume_down&quot;</span><span class="punctuation">;</span></span><br><span class="line">                        <span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;msm_gpio</span> <span class="number">91</span> <span class="number">0x1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                        <span class="attr">linux,input-type</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                        <span class="attr">linux,code</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">114</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                        <span class="attr">gpio-key,wakeup</span><span class="punctuation">;</span></span><br><span class="line">                        <span class="attr">debounce-interval</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">15</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                <span class="punctuation">&#125;;</span>  </span><br></pre></td></tr></table></figure><p>驱动解析这个设备树配置的是drivers&#x2F;input&#x2F;keyboard&#x2F;gpio_keys.c，具体是在<code>gpio_keys_get_devtree_pdata</code>里：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Translate OpenFirmware node properties into platform_data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> gpio_keys_platform_data *</span><br><span class="line"><span class="title function_">gpio_keys_get_devtree_pdata</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">       for_each_child_of_node(node, pp) &#123;</span><br><span class="line">                <span class="type">int</span> gpio;</span><br><span class="line">                <span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flags</span>;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!of_find_property(pp, <span class="string">&quot;gpios&quot;</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                        pdata-&gt;nbuttons--;</span><br><span class="line">                        dev_warn(dev, <span class="string">&quot;Found button without gpios\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                gpio = of_get_gpio_flags(pp, <span class="number">0</span>, &amp;flags);</span><br><span class="line">                <span class="keyword">if</span> (gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        error = gpio;</span><br><span class="line">                        <span class="keyword">if</span> (error != -EPROBE_DEFER)</span><br><span class="line">                                dev_err(dev,</span><br><span class="line">                                        <span class="string">&quot;Failed to get gpio flags, error: %d\n&quot;</span>,</span><br><span class="line">                                        error);</span><br><span class="line">                        <span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                button = &amp;pdata-&gt;buttons[i++];</span><br><span class="line"></span><br><span class="line">                button-&gt;gpio = gpio;</span><br><span class="line">                button-&gt;active_low = flags &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (of_property_read_u32(pp, <span class="string">&quot;linux,code&quot;</span>, &amp;button-&gt;code)) &#123;</span><br><span class="line">                        dev_err(dev, <span class="string">&quot;Button without keycode: 0x%x\n&quot;</span>,</span><br><span class="line">                                button-&gt;gpio);</span><br><span class="line">                        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                button-&gt;desc = of_get_property(pp, <span class="string">&quot;label&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (of_property_read_u32(pp, <span class="string">&quot;linux,input-type&quot;</span>, &amp;button-&gt;type))</span><br><span class="line">                        button-&gt;type = EV_KEY;</span><br><span class="line"></span><br><span class="line">                button-&gt;wakeup = !!of_get_property(pp, <span class="string">&quot;gpio-key,wakeup&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (of_property_read_u32(pp, <span class="string">&quot;debounce-interval&quot;</span>,</span><br><span class="line">                                        &amp;button-&gt;debounce_interval))</span><br><span class="line">                        button-&gt;debounce_interval = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>ok. 状态上报是在：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gpio_keys_gpio_report_event</span><span class="params">(<span class="keyword">struct</span> gpio_button_data *bdata)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_keys_button</span> *<span class="title">button</span> =</span> bdata-&gt;button;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input</span> =</span> bdata-&gt;input;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> type = button-&gt;type ?: EV_KEY;</span><br><span class="line">        <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line">        state = (__gpio_get_value(button-&gt;gpio) ? <span class="number">1</span> : <span class="number">0</span>) ^ button-&gt;active_low; <span class="comment">//here</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type == EV_ABS) &#123;</span><br><span class="line">                <span class="keyword">if</span> (state)</span><br><span class="line">                        input_event(input, type, button-&gt;code, button-&gt;value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                input_event(input, type, button-&gt;code, !!state);</span><br><span class="line">        &#125;    </span><br><span class="line">        input_sync(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么时候上报的了？中断isr处理：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_keys_gpio_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">gpio_button_data</span> *<span class="title">bdata</span> =</span> dev_id;</span><br><span class="line"></span><br><span class="line">        BUG_ON(irq != bdata-&gt;irq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bdata-&gt;button-&gt;wakeup)</span><br><span class="line">                pm_stay_awake(bdata-&gt;input-&gt;dev.parent);</span><br><span class="line">        <span class="keyword">if</span> (bdata-&gt;timer_debounce)</span><br><span class="line">                mod_timer(&amp;bdata-&gt;timer,</span><br><span class="line">                        jiffies + msecs_to_jiffies(bdata-&gt;timer_debounce));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                schedule_work(&amp;bdata-&gt;work);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_keys_setup_key</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> input_dev *input,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> gpio_button_data *bdata,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="keyword">struct</span> gpio_keys_button *button)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (gpio_is_valid(button-&gt;gpio)) &#123;</span><br><span class="line">                INIT_WORK(&amp;bdata-&gt;work, gpio_keys_gpio_work_func);</span><br><span class="line">                setup_timer(&amp;bdata-&gt;timer,</span><br><span class="line">                            gpio_keys_gpio_timer, (<span class="type">unsigned</span> <span class="type">long</span>)bdata);</span><br><span class="line"></span><br><span class="line">                isr = gpio_keys_gpio_isr;</span><br><span class="line">                irqflags = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>那内核其他模块如何获取按键状态？ 我想可以参考gpio_keys_gpio_report_event把state取出应该就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> resin </tag>
            
            <tag> reset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SELinux:如何快速验证file_contexts</title>
      <link href="/how-to-quickly-verify-sepolicy-file_contexts.html"/>
      <url>/how-to-quickly-verify-sepolicy-file_contexts.html</url>
      
        <content type="html"><![CDATA[<p>system&#x2F;core&#x2F;fs_mgr里加入一个resize工具，有权限问题log如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[   19.952455] audit: type=1400 audit(83369.909:5): avc:  denied  &#123; execute_no_trans &#125; for  pid=283 comm=&quot;init&quot; path=&quot;/system/bin/resize.f2fs&quot; dev=&quot;mmcblk0p35&quot; ino=1952 scontext=u:r:init:s0 tcontext=u:object_r:system_file:s0 tclass=file permissive=1</span><br></pre></td></tr></table></figure><p>这个log就是sepolicy不允许init执行&#x2F;system&#x2F;bin&#x2F;resize.f2fs。</p><p>Android 8.0里init.te规则要求init在执行程序时需要增加新的domain。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># init should never execute a program without changing to another domain.</span><br><span class="line">neverallow init &#123; file_type fs_type &#125;:file execute_no_trans;</span><br></pre></td></tr></table></figure><p>ok，不用新建domain，参考e2fsck添加resize.f2fs到file_contexts的fsck domain里即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/system/bin/resize\.f2fs  --  u:object_r:fsck_exec:s0</span><br></pre></td></tr></table></figure><p>修改完后如何验证是个问题，编译烧录boot.img后ls -Z看了下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u:object_r:system_file:s0 /system/bin/resize.f2fs</span><br></pre></td></tr></table></figure><p>明显没有生效，难道要编译system.img么，Xeon估计至少也要1h。</p><p>先看下sepolicy下的Android.mk，里面有个生成file_contexts.bin模块的脚本:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">LOCAL_MODULE := file_contexts.bin</span><br><span class="line">LOCAL_MODULE_CLASS := ETC</span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line">LOCAL_MODULE_PATH := <span class="variable">$(TARGET_ROOT_OUT)</span></span><br></pre></td></tr></table></figure><p>进入&#x2F;system&#x2F;sepolicy，mma -j4编译后会生成在如下路径：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">obj/ETC/file_contexts.bin_intermediates/file_contexts.bin</span><br></pre></td></tr></table></figure><p>ok，下一步把当前的system.img解压出来再用新的file_contexts.bin重新生成即可。</p><p>注意要把这个工具放入system目录再生成img才会生效，官方文档有介绍：</p><blockquote><p>file_contexts - Located in the sepolicy subdirectory. This file assigns labels to files and is used by various userspace components. As you create new policies, create or update this file to assign new labels to files. In order to apply new file_contexts, you must rebuild the filesystem image or run restorecon on the file to be relabeled. On upgrades, changes to file_contexts are automatically applied to the system and userdata partitions as part of the upgrade. Changes can also be automatically applied on upgrade to other partitions by adding restorecon_recursive calls to your init.board.rc file after the partition has been mounted read-write. </p></blockquote><p>试了下adb push进用restorecon好像没有改过来，暂且略过。</p><p>btw: 其他的te文件修改编译boot.img，生成也在ETC&#x2F;下。</p>]]></content>
      
      
      <categories>
          
          <category> security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> selinux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TF卡不能检卡问题排查</title>
      <link href="/how-to-debug-tf-card-detect-issue.html"/>
      <url>/how-to-debug-tf-card-detect-issue.html</url>
      
        <content type="html"><![CDATA[<p>bring up阶段SD始终不能检卡，我觉得软件配置应该没问题，硬件是外包的，硬件答复这套设计其他厂商也在用没问题。SD一个卡槽，SIM一个卡槽，高通平台，Linux内核版本3.18。</p><p>先看下内核文档关于检卡的描述：</p><blockquote><p>Card detection:<br>If no property below is supplied, host native card detect is used.<br>Only one of the properties in this section should be supplied:</p><ul><li>broken-cd: There is no card detection available; polling must be used.</li><li>cd-gpios: Specify GPIOs for card detection, see gpio binding</li><li>non-removable: non-removable slot (like eMMC); assume always present.</li></ul></blockquote><p>再看下dts配置:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&amp;sdhc_2 &#123;</span><br><span class="line">         #address-cells = &lt;0&gt;;</span><br><span class="line">        interrupt-parent = &lt;&amp;sdhc_2&gt;;</span><br><span class="line">        interrupts = &lt;0 1 2&gt;;</span><br><span class="line">        #interrupt-cells = &lt;1&gt;;</span><br><span class="line">        interrupt-map-mask = &lt;0xffffffff&gt;;</span><br><span class="line">        interrupt-map = &lt;0 &amp;intc 0 125 0</span><br><span class="line">                        1 &amp;intc 0 221 0</span><br><span class="line">                        2 &amp;msm_gpio 38 0&gt;;</span><br><span class="line">        interrupt-names = &quot;hc_irq&quot;, &quot;pwr_irq&quot;, &quot;status_irq&quot;;</span><br><span class="line">        cd-gpios = &lt;&amp;msm_gpio 38 0x1&gt;; //0x1 - 表示插卡低有效</span><br></pre></td></tr></table></figure><p>这里用的就是gpio中断检卡方式不能工作，解析cd-gpios在<code>sdhci_msm_populate_pdata</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flags</span> =</span> OF_GPIO_ACTIVE_LOW; <span class="comment">//is 1</span></span><br><span class="line"></span><br><span class="line">...   </span><br><span class="line"></span><br><span class="line">pdata-&gt;status_gpio = of_get_named_gpio_flags(np, <span class="string">&quot;cd-gpios&quot;</span>, <span class="number">0</span>, &amp;flags);</span><br><span class="line"><span class="keyword">if</span> (gpio_is_valid(pdata-&gt;status_gpio) &amp; !(flags &amp; OF_GPIO_ACTIVE_LOW))</span><br><span class="line">        pdata-&gt;caps2 |= MMC_CAP2_CD_ACTIVE_HIGH;</span><br></pre></td></tr></table></figure><p>把cd-gpios去掉就是用host native方式插拔检测正常，这种是轮训方式，<code>sdhci_add_host</code>里有：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*   </span></span><br><span class="line"><span class="comment"> * Enable polling on when card detection is broken and no card detect</span></span><br><span class="line"><span class="comment"> * gpio is present.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((host-&gt;quirks &amp; SDHCI_QUIRK_BROKEN_CARD_DETECTION) &amp;&amp;</span><br><span class="line">    !(mmc-&gt;caps &amp; MMC_CAP_NONREMOVABLE) &amp;&amp;</span><br><span class="line">    (mmc_gpio_get_cd(host-&gt;mmc) &lt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">    !(mmc-&gt;caps2 &amp; MMC_CAP2_NONHOTPLUG))</span><br><span class="line">        mmc-&gt;caps |= MMC_CAP_NEEDS_POLL;</span><br></pre></td></tr></table></figure><p>为什么用gpio中断方式不能检测呢，来看下：</p><p>中断注册在<code>mmc_gpiod_request_cd_irq</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mmc_gpiod_request_cd_irq</span><span class="params">(<span class="keyword">struct</span> mmc_host *host)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mmc_gpio</span> *<span class="title">ctx</span> =</span> host-&gt;slot.handler_priv;</span><br><span class="line">        <span class="type">int</span> ret, irq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (host-&gt;slot.cd_irq &gt;= <span class="number">0</span> || !ctx || !ctx-&gt;cd_gpio)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        irq = gpiod_to_irq(ctx-&gt;cd_gpio);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  </span></span><br><span class="line"><span class="comment">         * Even if gpiod_to_irq() returns a valid IRQ number, the platform might</span></span><br><span class="line"><span class="comment">         * still prefer to poll, e.g., because that IRQ number is already used</span></span><br><span class="line"><span class="comment">         * by another unit and cannot be shared.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (irq &gt;= <span class="number">0</span> &amp;&amp; host-&gt;caps &amp; MMC_CAP_NEEDS_POLL)</span><br><span class="line">                irq = -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (irq &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ret = devm_request_threaded_irq(&amp;host-&gt;class_dev, irq,</span><br><span class="line">                        <span class="literal">NULL</span>, mmc_gpio_cd_irqt,</span><br><span class="line">                        IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,</span><br><span class="line">                        ctx-&gt;cd_label, host);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                        irq = ret;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        host-&gt;slot.cd_irq = irq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">                host-&gt;caps |= MMC_CAP_NEEDS_POLL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中断处理是<code>mmc_gpio_cd_irqt</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">mmc_gpio_cd_irqt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* Schedule a card detection after a debounce timeout */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mmc_host</span> *<span class="title">host</span> =</span> dev_id;</span><br><span class="line"></span><br><span class="line">        host-&gt;trigger_card_event = <span class="literal">true</span>;</span><br><span class="line">        mmc_detect_change(host, msecs_to_jiffies(<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mmc_detect_change</code>会call<code>mmc_schedule_delayed_work(&amp;host-&gt;detect, delay);</code>,也就是会走mmc_rescan，因为前面有挂<code>INIT_DELAYED_WORK(&amp;host-&gt;detect, mmc_rescan); </code>。</p><p>sdhci_request里检卡：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*   </span></span><br><span class="line"><span class="comment"> * Firstly check card presence from cd-gpio.  The return could</span></span><br><span class="line"><span class="comment"> * be one of the following possibilities:</span></span><br><span class="line"><span class="comment"> *     negative: cd-gpio is not available</span></span><br><span class="line"><span class="comment"> *     zero: cd-gpio is used, and card is removed</span></span><br><span class="line"><span class="comment"> *     one: cd-gpio is used, and card is present</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">present = mmc_gpio_get_cd(host-&gt;mmc);</span><br><span class="line"><span class="keyword">if</span> (present &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">/* If polling, assume that the card is always present. */</span></span><br><span class="line">        <span class="keyword">if</span> (host-&gt;quirks &amp; SDHCI_QUIRK_BROKEN_CARD_DETECTION)</span><br><span class="line">                present = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">                present = sdhci_readl(host, SDHCI_PRESENT_STATE) &amp;</span><br><span class="line">                                SDHCI_CARD_PRESENT;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>注释写的很清楚，先看cd-gpio情况。</p><p>把<code>mmc_gpio_get_cd</code>加入中断处理<code>mmc_gpio_cd_irqt</code>中查看发现插卡时有太多的中断打印，拔出停止。</p><p>中断频繁可以看到142一直在增：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msmxxx:/ <span class="comment"># cat /proc/interrupts  | grep msmgpio</span></span><br><span class="line">117:         11          1          1          2   msmgpio  13  msg2xxx</span><br><span class="line">125:          0          0          0          0   msmgpio  21  cs35l41</span><br><span class="line">142:      10651       1639        499          0   msmgpio  38  7864900.sdhci <span class="built_in">cd</span></span><br></pre></td></tr></table></figure><p>GPIO配置确认：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msmxxx:/ <span class="comment"># cat /sys/kernel/debug/gpio | grep 38</span></span><br><span class="line"> gpio38  : <span class="keyword">in</span>  0 2mA no pull</span><br></pre></td></tr></table></figure><p>当修改为高有效后插入中断一个，拔出中断多出几个，但是仍然不能检卡，插卡mmc_gpio_get_cd返回0，拔卡返回1。之前其他项目配置高有效时，插卡get_cd返回的都是1，拔卡返回的是0，所以应该是硬件问题，push硬件修改后果然正常了。</p><p>这类情况以前在Z就遇到过，so有时不想调dd：]</p>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核MMC传输流程Overview</title>
      <link href="/mmc-transfer-flow-overview.html"/>
      <url>/mmc-transfer-flow-overview.html</url>
      
        <content type="html"><![CDATA[<p>最近看了下mmc读写，起由是Vendor发来eMMC固件升级要求，说如果使用了CMD18 + CMD12，就要升级，因为不知道OEM使用情况，建议都升级。</p><p>我们来确认下内核的情况, 内核版本3.18，高通平台。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_READ_DAT_UNTIL_STOP  11   <span class="comment">/* adtc [31:0] dadr        R1  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_STOP_TRANSMISSION    12   <span class="comment">/* ac                      R1b */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_SEND_STATUS          13   <span class="comment">/* ac   [31:16] RCA        R1  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_BUS_TEST_R           14   <span class="comment">/* adtc                    R1  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_GO_INACTIVE_STATE    15   <span class="comment">/* ac   [31:16] RCA            */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_BUS_TEST_W           19   <span class="comment">/* adtc                    R1  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_SPI_READ_OCR         58   <span class="comment">/* spi                  spi_R3 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_SPI_CRC_ON_OFF       59   <span class="comment">/* spi  [0:0] flag      spi_R1 */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* class 2 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_SET_BLOCKLEN         16   <span class="comment">/* ac   [31:0] block len   R1  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_READ_SINGLE_BLOCK    17   <span class="comment">/* adtc [31:0] data addr   R1  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_READ_MULTIPLE_BLOCK  18   <span class="comment">/* adtc [31:0] data addr   R1  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_SEND_TUNING_BLOCK    19   <span class="comment">/* adtc                    R1  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_SEND_TUNING_BLOCK_HS200     21      <span class="comment">/* adtc R1  */</span></span></span><br></pre></td></tr></table></figure><p>CMD18就是MMC_READ_MULTIPLE_BLOCK，CMD12就是MMC_STOP_TRANSMISSION。</p><p>查下相关代码在mmc_test_prepare_mrq中使用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mmc_test_prepare_mrq</span><span class="params">(<span class="keyword">struct</span> mmc_test_card *test,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> mmc_request *mrq, <span class="keyword">struct</span> scatterlist *sg, <span class="type">unsigned</span> sg_len,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> dev_addr, <span class="type">unsigned</span> blocks, <span class="type">unsigned</span> blksz, <span class="type">int</span> write)</span></span><br><span class="line">&#123;</span><br><span class="line">BUG_ON(!mrq || !mrq-&gt;cmd || !mrq-&gt;data || !mrq-&gt;stop);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (blocks &gt; <span class="number">1</span>) &#123;</span><br><span class="line">mrq-&gt;cmd-&gt;opcode = write ?</span><br><span class="line">MMC_WRITE_MULTIPLE_BLOCK : MMC_READ_MULTIPLE_BLOCK;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mrq-&gt;cmd-&gt;opcode = write ?</span><br><span class="line">MMC_WRITE_BLOCK : MMC_READ_SINGLE_BLOCK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mrq-&gt;cmd-&gt;arg = dev_addr;</span><br><span class="line"><span class="keyword">if</span> (!mmc_card_blockaddr(test-&gt;card))</span><br><span class="line">mrq-&gt;cmd-&gt;arg &lt;&lt;= <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">mrq-&gt;cmd-&gt;flags = MMC_RSP_R1 | MMC_CMD_ADTC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (blocks == <span class="number">1</span>)</span><br><span class="line">mrq-&gt;stop = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">mrq-&gt;stop-&gt;opcode = MMC_STOP_TRANSMISSION; <span class="comment">//CMD12</span></span><br><span class="line">mrq-&gt;stop-&gt;arg = <span class="number">0</span>;</span><br><span class="line">mrq-&gt;stop-&gt;flags = MMC_RSP_R1B | MMC_CMD_AC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mrq-&gt;data-&gt;blksz = blksz;</span><br><span class="line">mrq-&gt;data-&gt;blocks = blocks;</span><br><span class="line">mrq-&gt;data-&gt;flags = write ? MMC_DATA_WRITE : MMC_DATA_READ;</span><br><span class="line">mrq-&gt;data-&gt;sg = sg;</span><br><span class="line">mrq-&gt;data-&gt;sg_len = sg_len;</span><br><span class="line"></span><br><span class="line">mmc_set_data_timeout(mrq-&gt;data, test-&gt;card);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个具体是在mmc_test里，先看看log情况。</p><p>mmc_test默认是模块CONFIG_MMC_TEST&#x3D;m，insmod有如下签名问题。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insmod: failed to load mmc_test.ko: Required key not available</span><br></pre></td></tr></table></figure><p>先略过签名改成y后，如下路径会多出mmc_test目录。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls /sys/bus/mmc/drivers</span></span><br><span class="line">mmc_test mmcblk</span><br></pre></td></tr></table></figure><p>ok,用mmc0会直接Oops，先用mmc1 (SD card)试下,操作步骤是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> mmc1:0001 &gt; /sys/bus/mmc/drivers/mmcblk/unbind</span><br><span class="line"><span class="built_in">echo</span> mmc1:0001 &gt; /sys/bus/mmc/drivers/mmc_test/bind</span><br></pre></td></tr></table></figure><p>这时候到如下路径就能看到多出test和testlist两个文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/sys/kernel/debug/mmc1/mmc1:0001 <span class="comment"># ls</span></span><br><span class="line">state status <span class="built_in">test</span> testlist</span><br></pre></td></tr></table></figure><p>其中6就是多块读测试：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 6 &gt; <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>把CONFIG_MMC_DEBUG放开，太多打印了，能看到这项测试的log</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[  137.468637] mmc1: starting CMD18 arg 00000000 flags 00000035</span><br><span class="line">[  137.468644] mmc1:     blksz 512 blocks 16 flags 00000200 tsac 100 ms nsac 0</span><br><span class="line">[  137.468650] mmc1:     CMD12 arg 00000000 flags 0000001d</span><br><span class="line">[  137.468696] sdhci [sdhci_irq()]: *** mmc1 got interrupt: 0x00000001</span><br><span class="line">[  137.469279] sdhci [sdhci_irq()]: *** mmc1 got interrupt: 0x00000002</span><br><span class="line">[  137.469309] sdhci [sdhci_irq()]: *** mmc1 got interrupt: 0x00000003</span><br><span class="line">[  137.469323] mmc1: accumulated busy time is 33456 usec</span><br><span class="line">[  137.469331] mmc1: req done (CMD18): 0: 00000900 00000000 00000000 00000000</span><br><span class="line">[  137.469336] mmc1:     8192 bytes transferred: 0</span><br><span class="line">[  137.469343] mmc1:     (CMD12): 0: 00000b00 00000000 00000000 00000000</span><br></pre></td></tr></table></figure><p>ok, 那mmc0到底用了没，放开debug，确是没有发现CMD18 + CMD12的打印，偶尔看了下LK的代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Function: mmc sdhci read</span></span><br><span class="line"><span class="comment"> * Arg     : mmc device structure, block address, number of blocks &amp; destination</span></span><br><span class="line"><span class="comment"> * Return  : 0 on Success, non zero on success</span></span><br><span class="line"><span class="comment"> * Flow    : Fill in the command structure &amp; send the command</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmc_sdhci_read</span><span class="params">(<span class="keyword">struct</span> mmc_device *dev, <span class="type">void</span> *dest,</span></span><br><span class="line"><span class="params">                                                <span class="type">uint64_t</span> blk_addr, <span class="type">uint32_t</span> num_blocks)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">uint32_t</span> mmc_ret = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mmc_command</span> <span class="title">cmd</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mmc_card</span> *<span class="title">card</span> =</span> &amp;dev-&gt;card;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">struct</span> mmc_command *)&amp;cmd, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mmc_command));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CMD17/18 Format:</span></span><br><span class="line"><span class="comment">         * [31:0] Data Address</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (num_blocks == <span class="number">1</span>)</span><br><span class="line">                cmd.cmd_index = CMD17_READ_SINGLE_BLOCK;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                cmd.cmd_index = CMD18_READ_MULTIPLE_BLOCK;</span><br><span class="line">        ...</span><br><span class="line">                <span class="comment">/* For multi block read failures send stop command */</span></span><br><span class="line">        <span class="keyword">if</span> (mmc_ret &amp;&amp; num_blocks &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> mmc_stop_command(dev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Response contains 32 bit Card status.</span></span><br><span class="line"><span class="comment">         * Parse the errors &amp; provide relevant information</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> mmc_parse_response(cmd.resp[<span class="number">0</span>]);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常的使用应该在这类读写接口里，kernel的mmc0&#x2F;mmc1读写是怎么样的，从上面的log能看出在mmc_blk_rw_rq_prep中:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mmc_blk_rw_rq_prep</span><span class="params">(<span class="keyword">struct</span> mmc_queue_req *mqrq,</span></span><br><span class="line"><span class="params">       <span class="keyword">struct</span> mmc_card *card,</span></span><br><span class="line"><span class="params">       <span class="type">int</span> disable_multi,</span></span><br><span class="line"><span class="params">       <span class="keyword">struct</span> mmc_queue *mq)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 readcmd, writecmd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_blk_request</span> *<span class="title">brq</span> =</span> &amp;mqrq-&gt;brq;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> mqrq-&gt;req;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_blk_data</span> *<span class="title">md</span> =</span> mq-&gt;data;</span><br><span class="line"><span class="type">bool</span> do_data_tag;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reliable writes are used to implement Forced Unit Access and</span></span><br><span class="line"><span class="comment"> * REQ_META accesses, and are supported only on MMCs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">XXX:</span> this really needs a good explanation of why REQ_META</span></span><br><span class="line"><span class="comment"> * is treated special.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> do_rel_wr = ((req-&gt;cmd_flags &amp; REQ_FUA) ||</span><br><span class="line">  (req-&gt;cmd_flags &amp; REQ_META)) &amp;&amp;</span><br><span class="line">(rq_data_dir(req) == WRITE) &amp;&amp;</span><br><span class="line">(md-&gt;flags &amp; MMC_BLK_REL_WR);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">brq-&gt;cmd.arg = blk_rq_pos(req);</span><br><span class="line"><span class="keyword">if</span> (!mmc_card_blockaddr(card))</span><br><span class="line">brq-&gt;cmd.arg &lt;&lt;= <span class="number">9</span>;</span><br><span class="line">brq-&gt;cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;</span><br><span class="line">brq-&gt;data.blksz = <span class="number">512</span>;</span><br><span class="line">brq-&gt;stop.opcode = MMC_STOP_TRANSMISSION; <span class="comment">//stop</span></span><br><span class="line">brq-&gt;stop.arg = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (brq-&gt;data.blocks &gt; <span class="number">1</span> || do_rel_wr) &#123;</span><br><span class="line"><span class="comment">/* SPI multiblock writes terminate using a special</span></span><br><span class="line"><span class="comment"> * token, not a STOP_TRANSMISSION request.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!mmc_host_is_spi(card-&gt;host) ||</span><br><span class="line">    rq_data_dir(req) == READ)</span><br><span class="line">brq-&gt;mrq.stop = &amp;brq-&gt;stop; <span class="comment">//stop</span></span><br><span class="line">readcmd = MMC_READ_MULTIPLE_BLOCK;</span><br><span class="line">writecmd = MMC_WRITE_MULTIPLE_BLOCK;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">brq-&gt;mrq.stop = <span class="literal">NULL</span>;</span><br><span class="line">readcmd = MMC_READ_SINGLE_BLOCK;</span><br><span class="line">writecmd = MMC_WRITE_BLOCK;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>流程调用大概看下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mmc_blk_probe</span><br><span class="line"> |</span><br><span class="line">mmc_blk_alloc/mmc_blk_alloc_part</span><br><span class="line"> |</span><br><span class="line">mmc_blk_alloc_req (md-&gt;queue.issue_fn = mmc_blk_issue_rq) </span><br><span class="line"> |</span><br><span class="line">mmc_blk_issue_rq</span><br><span class="line"> |</span><br><span class="line">mmc_blk_issue_rw_rq</span><br><span class="line"> |</span><br><span class="line">mmc_blk_rw_rq_prep</span><br></pre></td></tr></table></figure><p>请求发出主要是通过一个线程 call issue_fn。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mmc_queue_thread</span><span class="params">(<span class="type">void</span> *d)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue</span> *<span class="title">mq</span> =</span> d;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">q</span> =</span> mq-&gt;<span class="built_in">queue</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_card</span> *<span class="title">card</span> =</span> mq-&gt;card;</span><br><span class="line"></span><br><span class="line">current-&gt;flags |= PF_MEMALLOC;</span><br><span class="line"><span class="keyword">if</span> (card-&gt;host-&gt;wakeup_on_idle)</span><br><span class="line">set_wake_up_idle(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">down(&amp;mq-&gt;thread_sem);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue_req</span> *<span class="title">tmp</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cmd_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">spin_lock_irq(q-&gt;queue_lock);</span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">req = blk_fetch_request(q);</span><br><span class="line">mq-&gt;mqrq_cur-&gt;req = req;</span><br><span class="line">spin_unlock_irq(q-&gt;queue_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (req || mq-&gt;mqrq_prev-&gt;req) &#123;</span><br><span class="line">set_current_state(TASK_RUNNING);</span><br><span class="line">cmd_flags = req ? req-&gt;cmd_flags : <span class="number">0</span>;</span><br><span class="line">mq-&gt;issue_fn(mq, req); <span class="comment">// mmc_blk_issue_rq</span></span><br></pre></td></tr></table></figure><p>线程的创建是在mmc_init_queue：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mmc_init_queue - initialise a queue structure.</span></span><br><span class="line"><span class="comment"> * @mq: mmc queue</span></span><br><span class="line"><span class="comment"> * @card: mmc card to attach this queue</span></span><br><span class="line"><span class="comment"> * @lock: queue lock</span></span><br><span class="line"><span class="comment"> * @subname: partition subname</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Initialise a MMC card request queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mmc_init_queue</span><span class="params">(<span class="keyword">struct</span> mmc_queue *mq, <span class="keyword">struct</span> mmc_card *card,</span></span><br><span class="line"><span class="params">   <span class="type">spinlock_t</span> *lock, <span class="type">const</span> <span class="type">char</span> *subname, <span class="type">int</span> area_type)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_host</span> *<span class="title">host</span> =</span> card-&gt;host;</span><br><span class="line">u64 limit = BLK_BOUNCE_HIGH;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue_req</span> *<span class="title">mqrq_cur</span> =</span> &amp;mq-&gt;mqrq[<span class="number">0</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue_req</span> *<span class="title">mqrq_prev</span> =</span> &amp;mq-&gt;mqrq[<span class="number">1</span>];</span><br><span class="line">...</span><br><span class="line">success:</span><br><span class="line">sema_init(&amp;mq-&gt;thread_sem, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* hook for pm qos legacy init */</span></span><br><span class="line"><span class="keyword">if</span> (card-&gt;host-&gt;ops-&gt;init)</span><br><span class="line">card-&gt;host-&gt;ops-&gt;init(card-&gt;host);</span><br><span class="line"></span><br><span class="line">mq-&gt;thread = kthread_run(mmc_queue_thread, mq, <span class="string">&quot;mmcqd/%d%s&quot;</span>,</span><br><span class="line">host-&gt;index, subname ? subname : <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>ps看下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ps | grep mmc</span></span><br><span class="line">root      288   2     0      0     irq_thread 00000000 S irq/145-mmc0</span><br><span class="line">root      290   2     0      0     irq_thread 00000000 S irq/147-mmc1</span><br><span class="line">root      292   2     0      0     mmc_cmdq_t 00000000 D mmc-cmdqd/0</span><br><span class="line">root      293   2     0      0     mmc_queue_ 00000000 S mmcqd/0rpmb</span><br></pre></td></tr></table></figure><p>插上SD card，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root      288   2     0      0     irq_thread 00000000 S irq/145-mmc0</span><br><span class="line">root      290   2     0      0     irq_thread 00000000 S irq/147-mmc1</span><br><span class="line">root      291   2     0      0     mmc_cmdq_t 00000000 D mmc-cmdqd/0</span><br><span class="line">root      293   2     0      0     mmc_queue_ 00000000 S mmcqd/0rpmb</span><br><span class="line">root      303   2     0      0     mmc_start_ 00000000 S mmcqd/1</span><br></pre></td></tr></table></figure><p>上面创建的线程应该就是mmcqd&#x2F;0rpmb和mmcqd&#x2F;1，mmcqd&#x2F;0rpmb是mmc0的rpmb区分，mmcqd&#x2F;1才是for mmc1(SD card)。</p><p>那还有一个线程mmc-cmdqd&#x2F;0是啥，线程创建往上再细看下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mmc_init_queue</span><span class="params">(<span class="keyword">struct</span> mmc_queue *mq, <span class="keyword">struct</span> mmc_card *card,</span></span><br><span class="line"><span class="params">   <span class="type">spinlock_t</span> *lock, <span class="type">const</span> <span class="type">char</span> *subname, <span class="type">int</span> area_type)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_host</span> *<span class="title">host</span> =</span> card-&gt;host;</span><br><span class="line">u64 limit = BLK_BOUNCE_HIGH;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue_req</span> *<span class="title">mqrq_cur</span> =</span> &amp;mq-&gt;mqrq[<span class="number">0</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue_req</span> *<span class="title">mqrq_prev</span> =</span> &amp;mq-&gt;mqrq[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mmc_dev(host)-&gt;dma_mask &amp;&amp; *mmc_dev(host)-&gt;dma_mask)</span><br><span class="line">limit = (u64)dma_max_pfn(mmc_dev(host)) &lt;&lt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">mq-&gt;card = card;</span><br><span class="line"><span class="keyword">if</span> (card-&gt;ext_csd.cmdq_support &amp;&amp;</span><br><span class="line">    (area_type == MMC_BLK_DATA_AREA_MAIN)) &#123;</span><br><span class="line">mq-&gt;<span class="built_in">queue</span> = blk_init_queue(mmc_cmdq_dispatch_req, lock);</span><br><span class="line"><span class="keyword">if</span> (!mq-&gt;<span class="built_in">queue</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">mmc_cmdq_setup_queue(mq, card);</span><br><span class="line">ret = mmc_cmdq_init(mq, card);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;%s: %d: cmdq: unable to set-up\n&quot;</span>,</span><br><span class="line">       mmc_hostname(card-&gt;host), ret);</span><br><span class="line">blk_cleanup_queue(mq-&gt;<span class="built_in">queue</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sema_init(&amp;mq-&gt;thread_sem, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* hook for pm qos cmdq init */</span></span><br><span class="line"><span class="keyword">if</span> (card-&gt;host-&gt;cmdq_ops-&gt;init)</span><br><span class="line">card-&gt;host-&gt;cmdq_ops-&gt;init(card-&gt;host);</span><br><span class="line">mq-&gt;<span class="built_in">queue</span>-&gt;queuedata = mq;</span><br><span class="line">mq-&gt;thread = kthread_run(mmc_cmdq_thread, mq,</span><br><span class="line"> <span class="string">&quot;mmc-cmdqd/%d%s&quot;</span>,</span><br><span class="line"> host-&gt;index,</span><br><span class="line"> subname ? subname : <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(mq-&gt;thread)) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;%s: %d: cmdq: failed to start mmc-cmdqd thread\n&quot;</span>,</span><br><span class="line">mmc_hostname(card-&gt;host), ret);</span><br><span class="line">ret = PTR_ERR(mq-&gt;thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret; <span class="comment">//已经返回了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mq-&gt;<span class="built_in">queue</span> = blk_init_queue(mmc_request_fn, lock);</span><br><span class="line"><span class="keyword">if</span> (!mq-&gt;<span class="built_in">queue</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br></pre></td></tr></table></figure><p>如果<code>card-&gt;ext_csd.cmdq_support</code>为真，也就是说支持cmdq，如果创建mmc-cmdqd&#x2F;0成功就返回了,ok, cmdq是啥。</p><p>看到ext_csd，很显然应该是个硬件特性，再看下开机mmc0&#x2F;mmc1相关log:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[    8.332885] mmc0: SDHCI controller on 7824900.sdhci [7824900.sdhci] using 32-bit ADMA <span class="keyword">in</span> CMDQ mode</span><br><span class="line">...</span><br><span class="line">[    8.504130] mmc1: SDHCI controller on 7864900.sdhci [7864900.sdhci] using 32-bit ADMA <span class="keyword">in</span> legacy mode</span><br></pre></td></tr></table></figure><p>看到这里似乎知道了，mmc0用的是CMDQ方式工作，而mmc1仍然使用的是过去的旧方式。</p><p>我们再对比看下CMDQ的线程mmc_cmdq_thread，它对应请求是mmc_blk_cmdq_issue_rq&#x2F;mmc_blk_cmdq_rw_prep，所有相关的cmdq的接口都在cmdq_hci.c里。</p><p>来看下git log:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 72dfcb7c9f6134282b8077beea420d5f0d736cc9</span><br><span class="line">Author: Venkat Gopalakrishnan &lt;venkatg@codeaurora.org&gt;</span><br><span class="line">Date:   Fri May 29 17:25:46 2015 -0700</span><br><span class="line"></span><br><span class="line">    mmc: cmdq: support for command queue enabled host</span><br><span class="line">    </span><br><span class="line">    This patch adds CMDQ support for command-queue compatible</span><br><span class="line">    hosts.</span><br><span class="line">    </span><br><span class="line">    Command queue is added in eMMC-5.1 specification. This</span><br><span class="line">    enables the controller to process upto 32 requests at</span><br><span class="line">    a time.</span><br><span class="line">    </span><br><span class="line">    Change-Id: I0486495ef57c64bf8427e917daeb184c69b8dc73</span><br><span class="line">    Signed-off-by: Asutosh Das &lt;asutoshd@codeaurora.org&gt;</span><br><span class="line">    Signed-off-by: Sujit Reddy Thumma &lt;sthumma@codeaurora.org&gt;</span><br><span class="line">    Signed-off-by: Konstantin Dorfman &lt;kdorfman@codeaurora.org&gt;</span><br><span class="line">    Signed-off-by: Venkat Gopalakrishnan &lt;venkatg@codeaurora.org&gt;</span><br><span class="line"></span><br><span class="line"> drivers/mmc/host/Kconfig    |  13 ++++</span><br><span class="line"> drivers/mmc/host/Makefile   |   1 +</span><br><span class="line"> drivers/mmc/host/cmdq_hci.c | 656 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> drivers/mmc/host/cmdq_hci.h | 211 ++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> include/linux/mmc/host.h    |  12 ++++</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="code"><pre><span class="line">commit df118e6a7fd85f1f649e2b35aed1d2b18cc29b94</span><br><span class="line">Author: Asutosh Das &lt;asutoshd@codeaurora.org&gt;</span><br><span class="line">Date:   Fri Oct 17 16:36:47 2014 +0530</span><br><span class="line"></span><br><span class="line">    mmc: sdhci: add command queue support to sdhci</span><br><span class="line">    </span><br><span class="line">    Adds command-queue support to SDHCi compliant drivers.</span><br><span class="line">    </span><br><span class="line">    Change-Id: I1efee7f1c86e102364083e9158e4d45c887dd06e</span><br><span class="line">    Signed-off-by: Asutosh Das &lt;asutoshd@codeaurora.org&gt;</span><br><span class="line">    Signed-off-by: Konstantin Dorfman &lt;kdorfman@codeaurora.org&gt;</span><br><span class="line">    Signed-off-by: Venkat Gopalakrishnan &lt;venkatg@codeaurora.org&gt;</span><br><span class="line"></span><br><span class="line"> drivers/mmc/host/sdhci.c  | 142 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++---</span><br><span class="line"> drivers/mmc/host/sdhci.h  |   3 +++</span><br><span class="line"> include/linux/mmc/sdhci.h |   2 ++</span><br><span class="line"> 3 files changed, 144 insertions(+), 3 deletions(-)</span><br><span class="line"></span><br><span class="line">@@ -293,6 +293,8 @@ struct sdhci_host &#123;</span><br><span class="line"> </span><br><span class="line">        u32 auto_cmd_err_sts;</span><br><span class="line">        struct ratelimit_state dbg_dump_rs;</span><br><span class="line">+ struct cmdq_host *cq_host;</span><br><span class="line">+</span><br><span class="line">        unsigned long private[0] ____cacheline_aligned;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> static irqreturn_t sdhci_irq(int irq, void *dev_id)</span><br><span class="line"> &#123;</span><br><span class="line">        irqreturn_t result = IRQ_NONE;</span><br><span class="line">@@ -2948,6 +2963,15 @@ static irqreturn_t sdhci_irq(int irq, void *dev_id)</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        do &#123;</span><br><span class="line">+         if (host-&gt;mmc-&gt;card &amp;&amp; mmc_card_cmdq(host-&gt;mmc-&gt;card) &amp;&amp;</span><br><span class="line">+             !mmc_host_halt(host-&gt;mmc)) &#123;</span><br><span class="line">+                 pr_debug(&quot;*** %s: cmdq intr: 0x%08x\n&quot;,</span><br><span class="line">+                                 mmc_hostname(host-&gt;mmc),</span><br><span class="line">+                                 intmask);</span><br><span class="line">+                 result = sdhci_cmdq_irq(host-&gt;mmc, intmask);</span><br><span class="line">+                 goto out;</span><br><span class="line">+         &#125;</span><br><span class="line">+</span><br><span class="line">                if (intmask &amp; SDHCI_INT_AUTO_CMD_ERR)</span><br><span class="line">                        host-&gt;auto_cmd_err_sts = sdhci_readw(host,</span><br><span class="line">                                        SDHCI_AUTO_CMD_ERR);</span><br><span class="line"></span><br><span class="line">@@ -3918,12 +4042,24 @@ int sdhci_add_host(struct sdhci_host *host)</span><br><span class="line">                sdhci_writel(host, host-&gt;ier, SDHCI_SIGNAL_ENABLE);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">-   pr_info(&quot;%s: SDHCI controller on %s [%s] using %s\n&quot;,</span><br><span class="line">+ if (mmc-&gt;caps2 &amp;  MMC_CAP2_CMD_QUEUE) &#123;</span><br><span class="line">+         bool dma64 = (host-&gt;flags &amp; SDHCI_USE_ADMA_64BIT) ?</span><br><span class="line">+                 true : false;</span><br><span class="line">+         ret = sdhci_cmdq_init(host, mmc, dma64);</span><br><span class="line">+         if (ret)</span><br><span class="line">+                 pr_err(&quot;%s: CMDQ init: failed (%d)\n&quot;,</span><br><span class="line">+                        mmc_hostname(host-&gt;mmc), ret);</span><br><span class="line">+         else</span><br><span class="line">+                 host-&gt;cq_host-&gt;ops = &amp;sdhci_cmdq_ops;</span><br><span class="line">+ &#125;</span><br><span class="line">+ pr_info(&quot;%s: SDHCI controller on %s [%s] using %s in %s mode\n&quot;,</span><br><span class="line">                mmc_hostname(mmc), host-&gt;hw_name, dev_name(mmc_dev(mmc)),</span><br><span class="line">                (host-&gt;flags &amp; SDHCI_USE_ADMA) ?</span><br><span class="line">                ((host-&gt;flags &amp; SDHCI_USE_ADMA_64BIT) ?</span><br><span class="line">                &quot;64-bit ADMA&quot; : &quot;32-bit ADMA&quot;) :</span><br><span class="line">-           ((host-&gt;flags &amp; SDHCI_USE_SDMA) ? &quot;DMA&quot; : &quot;PIO&quot;));</span><br><span class="line">+         ((host-&gt;flags &amp; SDHCI_USE_SDMA) ? &quot;DMA&quot; : &quot;PIO&quot;),</span><br><span class="line">+         ((mmc-&gt;caps2 &amp;  MMC_CAP2_CMD_QUEUE) &amp;&amp; !ret) ?</span><br><span class="line">+         &quot;CMDQ&quot; : &quot;legacy&quot;);</span><br></pre></td></tr></table></figure><p>那基本上就是这样了，还有一个地方：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sdhci_finish_data</span><span class="params">(<span class="keyword">struct</span> sdhci_host *host)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Need to send CMD12 if -</span></span><br><span class="line"><span class="comment"> * a) open-ended multiblock transfer (no CMD23)</span></span><br><span class="line"><span class="comment"> * b) error in multiblock transfer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (data-&gt;stop &amp;&amp;</span><br><span class="line">    (data-&gt;error ||</span><br><span class="line">     !host-&gt;mrq-&gt;sbc)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The controller needs a reset of internal state machines</span></span><br><span class="line"><span class="comment"> * upon error conditions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (data-&gt;error) &#123;</span><br><span class="line">sdhci_do_reset(host, SDHCI_RESET_CMD);</span><br><span class="line">sdhci_do_reset(host, SDHCI_RESET_DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sdhci_send_command(host, data-&gt;stop);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br></pre></td></tr></table></figure><p>so it should not be for CQ xfer. </p><p>btw: 高通总是不正面答复我，给个差评:]</p>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mmc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于高通平台串口调试行为的一点说明</title>
      <link href="/msm-serial-console.html"/>
      <url>/msm-serial-console.html</url>
      
        <content type="html"><![CDATA[<p>最近遇到一个问题，项目初期阶段,刚开机串口输入输出都正常，高通平台Android O kernel 3.18跑起来大概30-40s串口没有打印输出了，只有输入, eng&#x2F;userdebug&#x2F;user都一样。</p><p>先看kernel log:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    4.891514] msm_hsl_console_setup: console setup on port #0</span><br><span class="line">[    4.896076] console [ttyHSL0] enabled</span><br><span class="line">[    4.903353] bootconsole [uart0] disabled</span><br><span class="line">[    4.912299] msm_serial_hsl_init: driver initialized</span><br></pre></td></tr></table></figure><p>看下代码kernel&#x2F;printk&#x2F;printk.c:register_console</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*   </span></span><br><span class="line"><span class="comment">   * By unregistering the bootconsoles after we enable the real console</span></span><br><span class="line"><span class="comment">   * we get the &quot;console xxx enabled&quot; message on all the consoles -</span></span><br><span class="line"><span class="comment">   * boot consoles, real consoles, etc - this is to ensure that end</span></span><br><span class="line"><span class="comment">   * users know there might be something in the kernel&#x27;s log buffer that</span></span><br><span class="line"><span class="comment">   * went to the bootconsole (that they do not see on the real console)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  pr_info(<span class="string">&quot;%sconsole [%s%d] enabled\n&quot;</span>,</span><br><span class="line">          (newcon-&gt;flags &amp; CON_BOOT) ? <span class="string">&quot;boot&quot;</span> : <span class="string">&quot;&quot;</span> , </span><br><span class="line">          newcon-&gt;name, newcon-&gt;index);</span><br></pre></td></tr></table></figure><p>ttyHSL0才是real console，bootconsole disable和这个问题没关系。</p><p>怀疑被重定向， 杀log相关进程不好使，改脚本去掉log进程服务，删log apk，因bringup阶段版本问题较多，稍耗时。</p><p>init.rc会起个console进程:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">on property:ro.debuggable=1</span><br><span class="line">    <span class="comment"># Give writes to anyone for the trace folder on debug builds.</span></span><br><span class="line">    <span class="comment"># The folder is used to store method traces.</span></span><br><span class="line">    <span class="built_in">chmod</span> 0773 /data/misc/trace</span><br><span class="line">    start console</span><br></pre></td></tr></table></figure><p>cmd窗口下ps能看到</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">shell     <span class="number">6825</span>  <span class="number">1</span>     <span class="number">8060</span>   <span class="number">1692</span>  n_tty_read <span class="number">7</span>f98bac438 S /system/bin/sh</span><br></pre></td></tr></table></figure><p>试了下stop console串口就不能输入了，再start console，可以输入但问题还在，dmesg看了下，有个错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[   17.338918] init: setpgid failed for console: Operation not permitted</span><br></pre></td></tr></table></figure><p>权限问题？ BoardConfig.mk的cmdline加入selinux&#x3D;permissive，问题还在，看了下是Android O新加的,具体在system&#x2F;core&#x2F;init&#x2F;service.cpp：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Service::SetProcessAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Keep capabilites on uid change.</span></span><br><span class="line">    <span class="keyword">if</span> (capabilities_.<span class="built_in">any</span>() &amp;&amp; uid_) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">prctl</span>(PR_SET_SECUREBITS, SECBIT_KEEP_CAPS | SECBIT_KEEP_CAPS_LOCKED) != <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="built_in">PLOG</span>(FATAL) &lt;&lt; <span class="string">&quot;prtcl(PR_SET_KEEPCAPS) failed for &quot;</span> &lt;&lt; name_;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> work out why this fails for `console` then upgrade to FATAL.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setpgid</span>(<span class="number">0</span>, <span class="built_in">getpid</span>()) == <span class="number">-1</span>) <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;setpgid failed for &quot;</span> &lt;&lt; name_;</span><br></pre></td></tr></table></figure><p>浏览kernel&#x2F;logcat，忽然想到kernel log level， 和Android N对比，确实有差异。</p><p>最后到device一看， 居然是msm 默认行为:]</p>]]></content>
      
      
      <categories>
          
          <category> msm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> console </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ion简要介绍</title>
      <link href="/introduction-to-ion.html"/>
      <url>/introduction-to-ion.html</url>
      
        <content type="html"><![CDATA[<p>Ion是google为了解决不同Android设备的内存碎片问题，在Android4.0中提出的下一代更通用的内存管理器，支持各种不同的内存分配，这些内存种类包括有：carveout, 物理连续的，虚拟连续的，iommu，secure memory，ion也可以在不同进程，user和kernel间共享buffer。</p><p>Ion把不同的内存空间用heap来分割管理，一般在dts中配置,对应的struct是<code>ion_heap</code>。要使用ion就需要创建client，用户态进程通过&#x2F;dev&#x2F;ion创建一个唯一的client，对应的struct是<code>ion_client</code>，只对kernel开放，用户态需用fd和handle来处理。这里的handle是ioctl返回的，是a buffer的抽象，用<code>ion_handle</code>来表示,真实的实体是<code>ion_buffer</code>。</p><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><h3 id="heap-type"><a href="#heap-type" class="headerlink" title="heap type"></a>heap type</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum ion_heap_types - list of all possible types of heaps</span></span><br><span class="line"><span class="comment"> * @ION_HEAP_TYPE_SYSTEM: memory allocated via vmalloc</span></span><br><span class="line"><span class="comment"> * @ION_HEAP_TYPE_SYSTEM_CONTIG: memory allocated via kmalloc</span></span><br><span class="line"><span class="comment"> * @ION_HEAP_TYPE_CARVEOUT: memory allocated from a prereserved</span></span><br><span class="line"><span class="comment"> * carveout heap, allocations are physically</span></span><br><span class="line"><span class="comment"> * contiguous</span></span><br><span class="line"><span class="comment"> * @ION_HEAP_TYPE_DMA: memory allocated via DMA API</span></span><br><span class="line"><span class="comment"> * @ION_NUM_HEAPS: helper for iterating over heaps, a bit mask</span></span><br><span class="line"><span class="comment"> * is used to identify the heaps, so only 32</span></span><br><span class="line"><span class="comment"> * total heap types are supported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ion_heap_type</span> &#123;</span></span><br><span class="line">ION_HEAP_TYPE_SYSTEM,</span><br><span class="line">ION_HEAP_TYPE_SYSTEM_CONTIG,</span><br><span class="line">ION_HEAP_TYPE_CARVEOUT,</span><br><span class="line">ION_HEAP_TYPE_CHUNK,</span><br><span class="line">ION_HEAP_TYPE_DMA,</span><br><span class="line">ION_HEAP_TYPE_CUSTOM, <span class="comment">/* must be last so device specific heaps always</span></span><br><span class="line"><span class="comment"> are at the end of this enum */</span></span><br><span class="line">ION_NUM_HEAPS = <span class="number">16</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>ION_HEAP_TYPE_SYSTEM就是虚拟连续物理不连续的内存空间，come from vmalloc。</li><li>ION_HEAP_TYPE_SYSTEM_CONTIG就是物理连续内存空间，come from kmalloc。</li><li>ION_HEAP_TYPE_CARVEOUT就是预先分配好的物理上连续内存。</li></ul><p>ps: 代码环境是kernel3.18，msm平台。</p><p>不同的heap区间需要不同的操作内存方法，比如allocate, free, map等，对应的struct是<code>ion_heap_ops</code>。</p><p>大概看下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ion_heap_ops - ops to operate on a given heap</span></span><br><span class="line"><span class="comment"> * @allocate:allocate memory</span></span><br><span class="line"><span class="comment"> * @free:free memory. Will be called with</span></span><br><span class="line"><span class="comment"> *ION_PRIV_FLAG_SHRINKER_FREE set in buffer flags when</span></span><br><span class="line"><span class="comment"> *called from a shrinker. In that case, the pages being</span></span><br><span class="line"><span class="comment"> *free&#x27;d must be truly free&#x27;d back to the system, not put</span></span><br><span class="line"><span class="comment"> *in a page pool or otherwise cached.</span></span><br><span class="line"><span class="comment"> * @physget physical address of a buffer (only define on</span></span><br><span class="line"><span class="comment"> *physically contiguous heaps)</span></span><br><span class="line"><span class="comment"> * @map_dmamap the memory for dma to a scatterlist</span></span><br><span class="line"><span class="comment"> * @unmap_dmaunmap the memory for dma</span></span><br><span class="line"><span class="comment"> * @map_kernelmap memory to the kernel</span></span><br><span class="line"><span class="comment"> * @unmap_kernelunmap memory to the kernel</span></span><br><span class="line"><span class="comment"> * @map_usermap memory to userspace</span></span><br><span class="line"><span class="comment"> * @unmap_userunmap memory to userspace</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * allocate, phys, and map_user return 0 on success, -errno on error.</span></span><br><span class="line"><span class="comment"> * map_dma and map_kernel return pointer on success, ERR_PTR on</span></span><br><span class="line"><span class="comment"> * error. @free will be called with ION_PRIV_FLAG_SHRINKER_FREE set in</span></span><br><span class="line"><span class="comment"> * the buffer&#x27;s private_flags when called from a shrinker. In that</span></span><br><span class="line"><span class="comment"> * case, the pages being free&#x27;d must be truly free&#x27;d back to the</span></span><br><span class="line"><span class="comment"> * system, not put in a page pool or otherwise cached.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_ops</span> &#123;</span></span><br><span class="line"><span class="type">int</span> (*allocate)(<span class="keyword">struct</span> ion_heap *heap,</span><br><span class="line"><span class="keyword">struct</span> ion_buffer *buffer, <span class="type">unsigned</span> <span class="type">long</span> len,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> align, <span class="type">unsigned</span> <span class="type">long</span> flags);</span><br><span class="line"><span class="type">void</span> (*<span class="built_in">free</span>)(<span class="keyword">struct</span> ion_buffer *buffer);</span><br><span class="line"><span class="type">int</span> (*phys)(<span class="keyword">struct</span> ion_heap *heap, <span class="keyword">struct</span> ion_buffer *buffer,</span><br><span class="line">    <span class="type">ion_phys_addr_t</span> *addr, <span class="type">size_t</span> *len);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> * (*<span class="title">map_dma</span>)(<span class="keyword">struct</span> <span class="title">ion_heap</span> *<span class="title">heap</span>,</span></span><br><span class="line"><span class="class">     <span class="keyword">struct</span> <span class="title">ion_buffer</span> *<span class="title">buffer</span>);</span></span><br><span class="line"><span class="type">void</span> (*unmap_dma)(<span class="keyword">struct</span> ion_heap *heap, <span class="keyword">struct</span> ion_buffer *buffer);</span><br><span class="line"><span class="type">void</span> * (*map_kernel)(<span class="keyword">struct</span> ion_heap *heap, <span class="keyword">struct</span> ion_buffer *buffer);</span><br><span class="line"><span class="type">void</span> (*unmap_kernel)(<span class="keyword">struct</span> ion_heap *heap, <span class="keyword">struct</span> ion_buffer *buffer);</span><br><span class="line"><span class="type">int</span> (*map_user)(<span class="keyword">struct</span> ion_heap *mapper, <span class="keyword">struct</span> ion_buffer *buffer,</span><br><span class="line"><span class="keyword">struct</span> vm_area_struct *vma);</span><br><span class="line"><span class="type">int</span> (*shrink)(<span class="keyword">struct</span> ion_heap *heap, <span class="type">gfp_t</span> gfp_mask, <span class="type">int</span> nr_to_scan);</span><br><span class="line"><span class="type">void</span> (*unmap_user) (<span class="keyword">struct</span> ion_heap *mapper, <span class="keyword">struct</span> ion_buffer *buffer);</span><br><span class="line"><span class="type">int</span> (*print_debug)(<span class="keyword">struct</span> ion_heap *heap, <span class="keyword">struct</span> seq_file *s,</span><br><span class="line">   <span class="type">const</span> <span class="keyword">struct</span> list_head *mem_map);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>system heap在创建时是system_heap_ops:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_ops</span> <span class="title">system_heap_ops</span> =</span> &#123;</span><br><span class="line">.allocate = ion_system_heap_allocate,</span><br><span class="line">.<span class="built_in">free</span> = ion_system_heap_free,</span><br><span class="line">.map_dma = ion_system_heap_map_dma,</span><br><span class="line">.unmap_dma = ion_system_heap_unmap_dma,</span><br><span class="line">.map_kernel = ion_heap_map_kernel,</span><br><span class="line">.unmap_kernel = ion_heap_unmap_kernel,</span><br><span class="line">.map_user = ion_heap_map_user,</span><br><span class="line">.shrink = ion_system_heap_shrink,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ion_heap *<span class="title function_">ion_system_heap_create</span><span class="params">(<span class="keyword">struct</span> ion_platform_heap *unused)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_system_heap</span> *<span class="title">heap</span>;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> pools_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ion_page_pool *) * num_orders;</span><br><span class="line"></span><br><span class="line">heap = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ion_system_heap), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!heap)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">heap-&gt;heap.ops = &amp;system_heap_ops;</span><br><span class="line">heap-&gt;heap.type = ION_HEAP_TYPE_SYSTEM;</span><br><span class="line">heap-&gt;heap.flags = ION_HEAP_FLAG_DEFER_FREE;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>system contig heap创建时是kmalloc_ops:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_ops</span> <span class="title">kmalloc_ops</span> =</span> &#123;</span><br><span class="line">.allocate = ion_system_contig_heap_allocate,</span><br><span class="line">.<span class="built_in">free</span> = ion_system_contig_heap_free,</span><br><span class="line">.phys = ion_system_contig_heap_phys,</span><br><span class="line">.map_dma = ion_system_contig_heap_map_dma,</span><br><span class="line">.unmap_dma = ion_system_contig_heap_unmap_dma,</span><br><span class="line">.map_kernel = ion_heap_map_kernel,</span><br><span class="line">.unmap_kernel = ion_heap_unmap_kernel,</span><br><span class="line">.map_user = ion_heap_map_user,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ion_heap *<span class="title function_">ion_system_contig_heap_create</span><span class="params">(<span class="keyword">struct</span> ion_platform_heap *unused)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> *<span class="title">heap</span>;</span></span><br><span class="line"></span><br><span class="line">heap = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ion_heap), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!heap)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">heap-&gt;ops = &amp;kmalloc_ops;</span><br><span class="line">heap-&gt;type = ION_HEAP_TYPE_SYSTEM_CONTIG;</span><br><span class="line"><span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建流程是从probe开始：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">msm_ion_probe -&gt; msm_ion_heap_create -&gt; ion_system_heap_create (if ION_HEAP_TYPE_SYSTEM)</span><br></pre></td></tr></table></figure><h3 id="heap-ID"><a href="#heap-ID" class="headerlink" title="heap ID"></a>heap ID</h3><p>对于heap的描述，除了heap type，msm还定义了heap id，如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_desc</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ion_heap_type</span> <span class="title">type</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> permission_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那是怎么用的了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_desc</span> <span class="title">ion_heap_meta</span>[] =</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">.id= ION_SYSTEM_HEAP_ID,</span><br><span class="line">.name= ION_SYSTEM_HEAP_NAME,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.id= ION_SYSTEM_CONTIG_HEAP_ID,</span><br><span class="line">.name= ION_KMALLOC_HEAP_NAME,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.id= ION_SECURE_HEAP_ID,</span><br><span class="line">.name= ION_SECURE_HEAP_NAME,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.id= ION_CP_MM_HEAP_ID,</span><br><span class="line">.name= ION_MM_HEAP_NAME,</span><br><span class="line">.permission_type = IPT_TYPE_MM_CARVEOUT,</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * These are the only ids that should be used for Ion heap ids.</span></span><br><span class="line"><span class="comment"> * The ids listed are the order in which allocation will be attempted</span></span><br><span class="line"><span class="comment"> * if specified. Don&#x27;t swap the order of heap ids unless you know what</span></span><br><span class="line"><span class="comment"> * you are doing!</span></span><br><span class="line"><span class="comment"> * Id&#x27;s are spaced by purpose to allow new Id&#x27;s to be inserted in-between (for</span></span><br><span class="line"><span class="comment"> * possible fallbacks)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> ion_heap_ids &#123;</span><br><span class="line">INVALID_HEAP_ID = <span class="number">-1</span>,</span><br><span class="line">ION_CP_MM_HEAP_ID = <span class="number">8</span>,</span><br><span class="line">ION_SECURE_HEAP_ID = <span class="number">9</span>,</span><br><span class="line">ION_SECURE_DISPLAY_HEAP_ID = <span class="number">10</span>,</span><br><span class="line">ION_CP_MFC_HEAP_ID = <span class="number">12</span>,</span><br><span class="line">ION_CP_WB_HEAP_ID = <span class="number">16</span>, <span class="comment">/* 8660 only */</span></span><br><span class="line">ION_CAMERA_HEAP_ID = <span class="number">20</span>, <span class="comment">/* 8660 only */</span></span><br><span class="line">ION_SYSTEM_CONTIG_HEAP_ID = <span class="number">21</span>,</span><br><span class="line">ION_ADSP_HEAP_ID = <span class="number">22</span>,</span><br><span class="line">ION_PIL1_HEAP_ID = <span class="number">23</span>, <span class="comment">/* Currently used for other PIL images */</span></span><br><span class="line">ION_SF_HEAP_ID = <span class="number">24</span>,</span><br><span class="line">ION_SYSTEM_HEAP_ID = <span class="number">25</span>,</span><br><span class="line">ION_PIL2_HEAP_ID = <span class="number">26</span>, <span class="comment">/* Currently used for modem firmware images */</span></span><br><span class="line">ION_QSECOM_HEAP_ID = <span class="number">27</span>,</span><br><span class="line">ION_AUDIO_HEAP_ID = <span class="number">28</span>,</span><br><span class="line"></span><br><span class="line">ION_MM_FIRMWARE_HEAP_ID = <span class="number">29</span>,</span><br><span class="line"></span><br><span class="line">ION_HEAP_ID_RESERVED = <span class="number">31</span> <span class="comment">/** Bit reserved for ION_FLAG_SECURE flag */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>显然和dts有关。 </p><h3 id="ion-heap-configuration-in-dts"><a href="#ion-heap-configuration-in-dts" class="headerlink" title="ion heap configuration in dts"></a>ion heap configuration in dts</h3><p>看下某个平台的msmxxxx-ion.dtsi定义</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&amp;soc &#123;</span><br><span class="line">        qcom,ion &#123;</span><br><span class="line">                compatible = &quot;qcom,msm-ion&quot;;</span><br><span class="line">                #address-cells = &lt;1&gt;;</span><br><span class="line">                #size-cells = &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">                qcom,ion-heap@25 &#123;</span><br><span class="line">                        reg = &lt;25&gt;;</span><br><span class="line">                        qcom,ion-heap-type = &quot;SYSTEM&quot;;</span><br><span class="line">                &#125;;  </span><br><span class="line"></span><br><span class="line">                qcom,ion-heap@8 &#123; /* CP_MM HEAP */</span><br><span class="line">                        reg = &lt;8&gt;;</span><br><span class="line">                        memory-region = &lt;&amp;secure_mem&gt;;</span><br><span class="line">                        qcom,ion-heap-type = &quot;SECURE_DMA&quot;;</span><br><span class="line">                &#125;;  </span><br><span class="line"></span><br><span class="line">                qcom,ion-heap@27 &#123; /* QSEECOM HEAP */</span><br><span class="line">                        reg = &lt;27&gt;;</span><br><span class="line">                        memory-region = &lt;&amp;qseecom_mem&gt;;</span><br><span class="line">                        qcom,ion-heap-type = &quot;DMA&quot;;</span><br><span class="line">                &#125;;  </span><br><span class="line">        &#125;;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reg就是ion heap ID了, msm_ion_probe时会解析这个配置，根据这个配置创建不同的heap。</p><h2 id="clients"><a href="#clients" class="headerlink" title="clients"></a>clients</h2><p>对kernel，ion_client_create创建client后就可以用ion_alloc从heap中分配内存，用ion_handle对应分配的memory。分配好以后，client就拥有了ion handle，client要访问ion_hanlde关联的ion_buffer，就必须要有kernel virtual address，ion_map_kernel可以完成。ion_phys返回ion_buffer的物理地址，前提当然这块空间要是物理连续，比如ion_system_contig_heap_phys。</p><p>对user app，是通过open &#x2F;dev&#x2F;ion来创建的，对应的文件操作是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ion_fops</span> =</span> &#123;</span><br><span class="line">.owner          = THIS_MODULE,</span><br><span class="line">.open           = ion_open,</span><br><span class="line">.release        = ion_release,</span><br><span class="line">.unlocked_ioctl = ion_ioctl,</span><br><span class="line">.compat_ioctl   = compat_ion_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ion_open里会调用kernel的ion_client_create，和kernel本地创建client一个样。</p><p>alloc&#x2F;free&#x2F;map等操作都在ioctl中实现，分配cmd就是ION_IOC_ALLOC了,直接看代码很清楚，ION_IOC_IMPORT是结合ION_IOC_SHARE用来共享buffer在user app间。</p><p>看下heap的mapping。</p><h2 id="ion-heap-map"><a href="#ion-heap-map" class="headerlink" title="ion heap map"></a>ion heap map</h2><p>ion heap可以被map到user space供app读写, 用的cmd是ION_IOC_MAP，然后用mmap就可以了。</p><p>对map into kernel，使用ion_map_kernel，不同heap不同map方法，比如对于system&#x2F;contig heap就是ion_heap_map_kernel。</p><p>调试接口fs在&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;ion里，就是clients heaps两个目录(kernel3.18)。</p><p>完。</p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何把文件上传到ESP8266文件系统spiffs上</title>
      <link href="/how-to-upload-files-to-esp8266-spiffs.html"/>
      <url>/how-to-upload-files-to-esp8266-spiffs.html</url>
      
        <content type="html"><![CDATA[<p>spiffs是一种文件系统，是为spi flash设备设计的，所以叫spi flash file system,当然了这种spi flash都是搭在ram很小的嵌入式平台，esp8266已经支持spiffs。</p><p>有时候需要把配置文件，图片等上传到文件系统上，来看下怎么操作。</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li><p>下载工具包: <a href="https://github.com/esp8266/arduino-esp8266fs-plugin/releases/latest">https://github.com/esp8266/arduino-esp8266fs-plugin/releases/latest</a></p></li><li><p>放到项目(sketch) tools下，就是library同级的目录，没有tools就新建一个。</p></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tigerfly@tj_e40_win8 MINGW64 /d/Work/arduino</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">libraries/  tools/</span><br><span class="line"></span><br><span class="line">tigerfly@tj_e40_win8 MINGW64 /d/Work/arduino</span><br><span class="line">$ <span class="built_in">cd</span> tools/</span><br><span class="line"></span><br><span class="line">tigerfly@tj_e40_win8 MINGW64 /d/Work/arduino/tools</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ESP8266FS/</span><br><span class="line"></span><br><span class="line">tigerfly@tj_e40_win8 MINGW64 /d/Work/arduino/tools</span><br></pre></td></tr></table></figure><ol start="3"><li>重新打开ardunio, Tools下多了一个菜单”ESP8266 Sketch Data Upload”</li></ol><p>ps: 我的环境是nodemcu 1.0, ardunio ide版本是1.8.2</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li>在你的项目里新建一个data目录,把你的东东都放进去。</li><li>然后点击Tools &gt; ESP8266 Sketch Data Upload, 就能看到如下提示：</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[SPIFFS] data   : D:\Work\arduino\libraries\<span class="built_in">test</span>\data</span><br><span class="line">[SPIFFS] size   : 3052</span><br><span class="line">[SPIFFS] page   : 256</span><br><span class="line">[SPIFFS] block  : 8192</span><br><span class="line">...</span><br><span class="line">............                                                    [ 100% ]</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/esp8266/arduino-esp8266fs-plugin">https://github.com/esp8266/arduino-esp8266fs-plugin</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spiffs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Arduino IDE中添加ESP8266支持</title>
      <link href="/how-to-add-esp8266-to-arduino-ide.html"/>
      <url>/how-to-add-esp8266-to-arduino-ide.html</url>
      
        <content type="html"><![CDATA[<p>nodemcu模块竟然不到20块，比arduino nano还便宜，而且还多了wifi功能，没理由不用啊。这货也能用ardunio IDE开发环境，esp8266对arduino IDE版本有要求，最好装高版本，我用的是1.8.2, 另外用IDE下菜单Tools &gt; Board Manager来安装装不了估计是被墙了，用git版本，来看下具体添加方法。</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li>用的win8, 先确保安装过git和python2.7 for windows，记得添加python环境变量。</li><li>打开git bash窗口，进入arduino安装目录hardware下，such as:</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tigerfly@tj_e40_win8 MINGW64 /c/Program Files (x86)/Arduino/hardware</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/c/Program Files (x86)/Arduino/hardware</span><br></pre></td></tr></table></figure><ol start="3"><li>下载git版本</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> esp8266com</span><br><span class="line"><span class="built_in">cd</span> esp8266com</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/esp8266/Arduino.git esp8266</span><br></pre></td></tr></table></figure><ol start="4"><li>下载必要的工具</li></ol><p>  win+r键运行cmd进入上一步下载的esp8266&#x2F;tools目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> esp8266/tools</span><br><span class="line">python get.py</span><br></pre></td></tr></table></figure><p>  下载成功会有提示，这个下载第一次出错，再次运行ok。</p><ol start="5"><li>重启arduino</li></ol><p>  重启后Tools &gt; board里最下面就能看到了，nodemcu烧录上传一般都是1.0了。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/esp8266/Arduino">https://github.com/esp8266/Arduino</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> esp8266 </tag>
            
            <tag> nodemcu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决kmalloc分配失败的问题</title>
      <link href="/fix-an-issue-about-kmalloc-failed.html"/>
      <url>/fix-an-issue-about-kmalloc-failed.html</url>
      
        <content type="html"><![CDATA[<p>最近遇到一个kmalloc内存分配失败的问题，是刚刷完手机第一次开机很大概率出现，重启后就好了，Android7.0&#x2F;ARM64&#x2F;kernel3.18。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01-09 04:55:23.878     0     0 W Thread-2: page allocation failure: order:4, mode:0xc0d0</span><br></pre></td></tr></table></figure><p>order-4是16个page了。</p><p>call stack</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01-12 08:34:21.699     0     0 I       : [&lt;ffffffc00008a2cc&gt;] show_stack+0x20/0x28</span><br><span class="line">01-12 08:34:21.699     0     0 I       : [&lt;ffffffc001150420&gt;] dump_stack+0x80/0xa4</span><br><span class="line">01-12 08:34:21.699     0     0 I       : [&lt;ffffffc000182f98&gt;] warn_alloc_failed+0x138/0x168</span><br><span class="line">01-12 08:34:21.699     0     0 I       : [&lt;ffffffc0001868fc&gt;] __alloc_pages_nodemask+0x72c/0x994</span><br><span class="line">01-12 08:34:21.699     0     0 I       : [&lt;ffffffc000186cc4&gt;] alloc_kmem_pages+0x34/0x40</span><br><span class="line">01-12 08:34:21.699     0     0 I       : [&lt;ffffffc0001a10c4&gt;] kmalloc_order+0x40/0xb8</span><br><span class="line">01-12 08:34:21.699     0     0 I       : [&lt;ffffffc0001a1178&gt;] kmalloc_order_trace+0x3c/0x108</span><br></pre></td></tr></table></figure><p>warn_alloc_failed走的slowpath，看来fast path是失败了，水位应该比较低。</p><p>看下kmalloc:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">kmalloc_large</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> order = get_order(size);</span><br><span class="line">        <span class="keyword">return</span> kmalloc_order_trace(size, flags, order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *__kmalloc(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line"><span class="type">void</span> *ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE))</span><br><span class="line"><span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"></span><br><span class="line">s = kmalloc_slab(size, flags);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line">                        <span class="keyword">return</span> kmalloc_large(size, flags); <span class="comment">//got it</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; GFP_DMA)) &#123;</span><br><span class="line">                        <span class="type">int</span> index = kmalloc_index(size);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!index)</span><br><span class="line">                                <span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> kmem_cache_alloc_trace(kmalloc_caches[index],</span><br><span class="line">                                        flags, size);</span><br><span class="line">                &#125;   </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下KMALLOC_MAX_CACHE_SIZE,现在手机内核配置基本都是slub。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Maximum size for which we actually use a slab cache */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MAX_CACHE_SIZE  (1UL &lt;&lt; KMALLOC_SHIFT_HIGH)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SLUB directly allocates requests fitting in to an order-1 page</span></span><br><span class="line"><span class="comment"> * (PAGE_SIZE*2).  Larger requests are passed to the page allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_HIGH      (PAGE_SHIFT + 1)</span></span><br></pre></td></tr></table></figure><p>slub认为2个page以上就算大block走page alloctor.</p><p>arm64:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* PAGE_SHIFT determines the page size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM64_64K_PAGES</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT              16</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT              12</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE               (_AC(1,UL) &lt;&lt; PAGE_SHIFT)</span></span><br></pre></td></tr></table></figure><p>arm64&#x2F;4k, so PAGE_SHIFT is 12</p><p>这里分配大小是order-4，看下get_order：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get_order - Determine the allocation order of a memory size</span></span><br><span class="line"><span class="comment"> * @size: The size for which to get the order</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Determine the allocation order of a particular sized block of memory.  This</span></span><br><span class="line"><span class="comment"> * is on a logarithmic scale, where:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      0 -&gt; 2^0 * PAGE_SIZE and below</span></span><br><span class="line"><span class="comment"> *      1 -&gt; 2^1 * PAGE_SIZE to 2^0 * PAGE_SIZE + 1</span></span><br><span class="line"><span class="comment"> *      2 -&gt; 2^2 * PAGE_SIZE to 2^1 * PAGE_SIZE + 1</span></span><br><span class="line"><span class="comment"> *      3 -&gt; 2^3 * PAGE_SIZE to 2^2 * PAGE_SIZE + 1</span></span><br><span class="line"><span class="comment"> *      4 -&gt; 2^4 * PAGE_SIZE to 2^3 * PAGE_SIZE + 1</span></span><br><span class="line"><span class="comment"> *      ...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The order returned is used to find the smallest allocation granule required</span></span><br><span class="line"><span class="comment"> * to hold an object of the specified size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The result is undefined if the size is 0.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function may be used to initialise variables with compile time</span></span><br><span class="line"><span class="comment"> * evaluations of constants.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_order(n)                                            \</span></span><br><span class="line"><span class="meta">(                                                               \</span></span><br><span class="line"><span class="meta">        __builtin_constant_p(n) ? (                             \</span></span><br><span class="line"><span class="meta">                ((n) == 0UL) ? BITS_PER_LONG - PAGE_SHIFT :     \</span></span><br><span class="line"><span class="meta">                (((n) &lt; (1UL &lt;&lt; PAGE_SHIFT)) ? 0 :              \</span></span><br><span class="line"><span class="meta">                 ilog2((n) - 1) - PAGE_SHIFT + 1)               \</span></span><br><span class="line"><span class="meta">        ) :                                                     \</span></span><br><span class="line"><span class="meta">        __get_order(n)                                          \</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* __ASSEMBLY__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Runtime evaluation of get_order()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> __attribute_const__</span><br><span class="line"><span class="type">int</span> __get_order(<span class="type">unsigned</span> <span class="type">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> order;</span><br><span class="line"></span><br><span class="line">        size--;</span><br><span class="line">        size &gt;&gt;= PAGE_SHIFT;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BITS_PER_LONG == 32</span></span><br><span class="line">        order = fls(size);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        order = fls64(size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS_PER_LONG 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS_PER_LONG 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_64BIT */</span></span></span><br></pre></td></tr></table></figure><p>基本就是按照注释来的。</p><p>在slowpath最后有should_alloc_retry, 看下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PAGE_ALLOC_COSTLY_ORDER is the order at which allocations are deemed</span></span><br><span class="line"><span class="comment"> * costly to service.  That is between allocation orders which should</span></span><br><span class="line"><span class="comment"> * coalesce naturally under reasonable reclaim pressure and those which</span></span><br><span class="line"><span class="comment"> * will not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_ALLOC_COSTLY_ORDER 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">should_alloc_retry</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> did_some_progress,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> pages_reclaimed)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Do not loop if specifically requested */</span></span><br><span class="line"><span class="keyword">if</span> (gfp_mask &amp; __GFP_NORETRY)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Always retry if specifically requested */</span></span><br><span class="line"><span class="keyword">if</span> (gfp_mask &amp; __GFP_NOFAIL)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Suspend converts GFP_KERNEL to __GFP_WAIT which can prevent reclaim</span></span><br><span class="line"><span class="comment"> * making forward progress without invoking OOM. Suspend also disables</span></span><br><span class="line"><span class="comment"> * storage devices so kswapd will not help. Bail if we are suspending.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!did_some_progress &amp;&amp; pm_suspended_storage())</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In this implementation, order &lt;= PAGE_ALLOC_COSTLY_ORDER</span></span><br><span class="line"><span class="comment"> * means __GFP_NOFAIL, but that may not be true in other</span></span><br><span class="line"><span class="comment"> * implementations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (order &lt;= PAGE_ALLOC_COSTLY_ORDER)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For order &gt; PAGE_ALLOC_COSTLY_ORDER, if __GFP_REPEAT is</span></span><br><span class="line"><span class="comment"> * specified, then we retry until we no longer reclaim any pages</span></span><br><span class="line"><span class="comment"> * (above), or we&#x27;ve reclaimed an order of pages at least as</span></span><br><span class="line"><span class="comment"> * large as the allocation&#x27;s order. In both cases, if the</span></span><br><span class="line"><span class="comment"> * allocation still fails, we stop retrying.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (gfp_mask &amp; __GFP_REPEAT &amp;&amp; pages_reclaimed &lt; (<span class="number">1</span> &lt;&lt; order))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出如果是order-3以内，一定会retry到有位置。</p><p>我们这里是order-4，已经算high order了，为了解决分配不到的问题，试了下__GFP_REPEAT还是不行，看来碎片严重啊，只能一直回收尝试，那就是__GFP_NOFAIL了，试了多次没啥阻塞，功能正常，虽然不推荐用。</p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kmalloc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内存回收Overview</title>
      <link href="/memory-reclaim-overview.html"/>
      <url>/memory-reclaim-overview.html</url>
      
        <content type="html"><![CDATA[<p>内核版本3.18, 内存回收和内存分配连在一起的, 了解下:</p><p>what is order in mm:</p><p>mel gorman’s book:</p><blockquote><p>the allocator maintains blocks of free pages where each block is a power of two number of pages. The exponent for the power of two-sized block is referred to as the order.</p></blockquote><p>block由2的n次方个page组成，这个n就是order了。</p><p>内存分配可以分成快速fast path(get_page_from_freelist)和慢速slow path(__alloc_pages_slowpath), fast path失败会走slow path。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the &#x27;heart&#x27; of the zoned buddy allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zonelist</span>, <span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* First allocation attempt */</span></span><br><span class="line">page = get_page_from_freelist(gfp_mask|__GFP_HARDWALL, nodemask, order,</span><br><span class="line">zonelist, high_zoneidx, alloc_flags,</span><br><span class="line">preferred_zone, classzone_idx, migratetype);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!page)) &#123; <span class="comment">//分配不到</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Runtime PM, block IO and its error handling path</span></span><br><span class="line"><span class="comment"> * can deadlock because I/O on the device might not</span></span><br><span class="line"><span class="comment"> * complete.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">gfp_mask = memalloc_noio_flags(gfp_mask);</span><br><span class="line">page = __alloc_pages_slowpath(gfp_mask, order,</span><br><span class="line">zonelist, high_zoneidx, nodemask,</span><br><span class="line">preferred_zone, classzone_idx, migratetype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fast path里如果watermark not ok就会回收内存zone_reclaim再试一次, slow path分配里存在直接内存回收direct reclaim，slow path里也会唤醒kswapd background reclaim.</p><p>来看下slow path, 基本大逻辑从代码看:</p><ol><li>wake up kswapd if alloc_flag with it</li><li>get_page_from_freelist with checking watermark</li><li>if nopage, check if do it again without checking watermark</li><li>if still nopage, try direct compaction(__alloc_pages_direct_compact).</li><li>if still nopage, try direct reclaim then allocating.</li><li>if still nopage, oom(__alloc_pages_may_oom)</li></ol><p>compaction是分配huge pages用的，长期使用易碎片，huge pages的分配需求很难成功，看下配置描述</p><blockquote><p>config COMPACTION<br>       bool “Allow for memory compaction”<br>       def_bool y<br>       select MIGRATION<br>       depends on MMU<br>       help<br>         Allows the compaction of memory for the allocation of huge pages.</p></blockquote><p>有一份compaction 说明：from <a href="https://lwn.net/Articles/368869/">https://lwn.net/Articles/368869/</a></p><p>几个memory reclaim sum:</p><ul><li>reclaim in fast path allocation</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">get_page_from_freelist -&gt; zone_reclaim (if watermark is not ok) -&gt; shrink_zone</span><br></pre></td></tr></table></figure><ul><li>direct reclaim</li></ul><p>直接回收内存是在slowpath分配里的，来看下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The really slow allocator path where we enter direct reclaim */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_direct_reclaim</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zonelist</span>, <span class="title">enum</span> <span class="title">zone_type</span> <span class="title">high_zoneidx</span>,</span></span><br><span class="line"><span class="class"><span class="title">nodemask_t</span> *<span class="title">nodemask</span>, <span class="title">int</span> <span class="title">alloc_flags</span>, <span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">preferred_zone</span>,</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">classzone_idx</span>, <span class="title">int</span> <span class="title">migratetype</span>, <span class="title">unsigned</span> <span class="title">long</span> *<span class="title">did_some_progress</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">bool</span> drained = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">*did_some_progress = __perform_reclaim(gfp_mask, order, zonelist,</span><br><span class="line">       nodemask);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!(*did_some_progress)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* After successful reclaim, reconsider all zones for allocation */</span></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_NUMA))</span><br><span class="line">zlc_clear_zones_full(zonelist);</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">page = get_page_from_freelist(gfp_mask, nodemask, order,</span><br><span class="line">zonelist, high_zoneidx,</span><br><span class="line">alloc_flags &amp; ~ALLOC_NO_WATERMARKS,</span><br><span class="line">preferred_zone, classzone_idx,</span><br><span class="line">migratetype);</span><br></pre></td></tr></table></figure><p>先直接回收__perform_reclaim然后get_page_from_freelist.</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">__perform_reclaim -&gt; try_to_free_pages -&gt; do_try_to_free_pages -&gt; shrink_zones</span><br></pre></td></tr></table></figure><ul><li>kswapd reclaim</li></ul><p>call graph:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">kswapd -&gt; balance_pgdat -&gt; kswapd_shrink_zone -&gt; shrink_zone</span><br></pre></td></tr></table></figure><p>如果分配时all zones的free page在low wartermak以下时gfp_mask没有带上__GFP_NO_KSWAPD，也就是可以从kswapd回收，那就唤醒kswapd回收.</p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reclaim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何给内核提交补丁</title>
      <link href="/how-to-submit-patch-to-kernel.html"/>
      <url>/how-to-submit-patch-to-kernel.html</url>
      
        <content type="html"><![CDATA[<h2 id="提交过程"><a href="#提交过程" class="headerlink" title="提交过程"></a>提交过程</h2><p>step1: get the right branch</p><p>可以参考 MAINTAINERS文件,可能不对，直接看git.kernel.org, 注意git pull到最新</p><p>step2: generate one patch</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git format-patch -1 commit_id</span><br></pre></td></tr></table></figure><p>cover-letter给一次提交多个用</p><p>step3: check patch</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./scripts/checkpatch.pl *.patch</span></span><br></pre></td></tr></table></figure><p>没有错误会提示total: 0 errors, 0 warnings</p><p>step4: get maintainers</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./scripts/get_maintainer.pl *.patch </span><br></pre></td></tr></table></figure><p>比如下面：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Andrew Morton &lt;akpm@linux-foundation.org&gt; (commit_signer:111/121=92%)</span><br><span class="line">Vlastimil Babka &lt;vbabka@suse.cz&gt; (commit_signer:61/121=50%,authored:21/121=17%,added_lines:302/1333=23%,removed_lines:256/1268=20%)</span><br><span class="line">Mel Gorman &lt;mgorman@techsingularity.net&gt; (commit_signer:57/121=47%,authored:29/121=24%,added_lines:433/1333=32%,removed_lines:407/1268=32%)</span><br><span class="line">Michal Hocko &lt;mhocko@suse.com&gt; (commit_signer:44/121=36%,authored:16/121=13%,added_lines:229/1333=17%,removed_lines:201/1268=16%)</span><br><span class="line">Johannes Weiner &lt;hannes@cmpxchg.org&gt; (commit_signer:21/121=17%)</span><br><span class="line">Joonsoo Kim &lt;iamjoonsoo.kim@lge.com&gt; (authored:9/121=7%,added_lines:78/1333=6%,removed_lines:78/1268=6%)</span><br><span class="line">Minchan Kim &lt;minchan@kernel.org&gt; (authored:7/121=6%)</span><br><span class="line">linux-mm@kvack.org (open list:MEMORY MANAGEMENT)</span><br><span class="line">linux-kernel@vger.kernel.org (open list)</span><br></pre></td></tr></table></figure><p>两个open list, <a href="mailto:&#x6c;&#105;&#110;&#117;&#120;&#45;&#109;&#x6d;&#x40;&#x6b;&#x76;&#x61;&#x63;&#107;&#x2e;&#111;&#114;&#x67;">&#x6c;&#105;&#110;&#117;&#120;&#45;&#109;&#x6d;&#x40;&#x6b;&#x76;&#x61;&#x63;&#107;&#x2e;&#111;&#114;&#x67;</a>就是内核内存的邮件列表(在<a href="http://www.spinics.net/lists/mm-commits/)%EF%BC%8Clinux-kernel@vger.kernel.org%E5%B0%B1%E6%98%AFLKML.org%E5%86%85%E6%A0%B8%E9%82%AE%E4%BB%B6%E5%88%97%E8%A1%A8%E4%BA%86%E3%80%82">http://www.spinics.net/lists/mm-commits/)，linux-kernel@vger.kernel.org就是LKML.org内核邮件列表了。</a></p><p>step5: send email<br>to 维护人，cc open list就可以了，可以先send to自己测试下, mail list可以订阅了解下动态。</p><p>a. using git send-email xx.patch –to<br>b. using standard email client, windows可以用Claws Mail，适合win上办公linux无上网权限的。</p><p>step6: discussion<br>do not top post,最好要部分引用回复，客户端用推荐的见email-clients.txt。</p><p>step7: update your patch<br>如果维护人让你修改，那在修改完成后要给patch加个版本，比如第二版用如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git format-patch --subject-prefix=&quot;PATCH v2&quot; -1 commit_id</span><br></pre></td></tr></table></figure><p>生成patch后用在”—“下添加change log，比如：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Signed-off-by: Bo Shen &lt;voice.shen@atmel.com&gt;</span><br><span class="line">---</span><br><span class="line">v2: xxx</span><br></pre></td></tr></table></figure><p>ok，完成后git send-email这个patch。</p><p>notes about tags:</p><p>一般maintainer会有resend this patch的要求，比如忘记Cc了，resend时记得要加Reviewed-by等tag，如果resend多次记得加版本号…</p><p>step8: 发送补丁集</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git format-patch -o out/ --cover-letter -n --thread=shallow commit_id_start^..commit_id_end</span><br></pre></td></tr></table></figure><p>编辑cover-letter patch, then send out目录即可。</p><h2 id="refer-doc"><a href="#refer-doc" class="headerlink" title="refer doc"></a>refer doc</h2><ul><li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-send-email.html">https://www.kernel.org/pub/software/scm/git/docs/git-send-email.html</a></li><li><a href="https://kernelnewbies.org/FirstKernelPatch">https://kernelnewbies.org/FirstKernelPatch</a></li><li><a href="https://kernelnewbies.org/PatchTipsAndTricks">https://kernelnewbies.org/PatchTipsAndTricks</a></li><li>Documentation&#x2F;SubmitChecklist</li><li>Documentation&#x2F;SubmittingPatches</li><li>Documentation&#x2F;SubmittingDrivers</li><li>Documentation&#x2F;CodingStyle</li><li>Documentation&#x2F;email-clients.txt</li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux patch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下git send-email的使用</title>
      <link href="/how-to-use-git-send-email-under-ubuntu.html"/>
      <url>/how-to-use-git-send-email-under-ubuntu.html</url>
      
        <content type="html"><![CDATA[<p>家里的nas&#x2F;linaro上装个发内核补丁环境， rpi远程。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Can&#x27;t locate Net/SMTP/SSL.pm in @INC</span><br></pre></td></tr></table></figure><p>要安装下面这个包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libnet-smtp-ssl-perl</span><br></pre></td></tr></table></figure><p>安装完后有下面这个错误</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Send this email? ([y]es|[n]o|[q]uit|[a]ll): a</span><br><span class="line">Password: </span><br><span class="line">Need MIME::Base64 and Authen::SASL todo auth at /usr/lib/git-core/git-send-email line 1140, &lt;STDIN&gt; line 1.</span><br></pre></td></tr></table></figure><p>再安装:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libauthen-sasl-perl</span><br></pre></td></tr></table></figure><p>还有错误：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Send this email? ([y]es|[n]o|[q]uit|[a]ll): a</span><br><span class="line">Password: </span><br><span class="line">mail from account doesn&#x27;t conform with authentication </span><br></pre></td></tr></table></figure><p>就是说你的mail send from要和.gitconfig里的一样。</p><p>看下一个aliyun的配置:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[sendemail]</span><br><span class="line">        smtpserver = smtp.aliyun.com</span><br><span class="line">        smtpserverport = 465</span><br><span class="line">        smtpencryption = ssl</span><br><span class="line">        smtpuser = youraccount@aliyun.com</span><br></pre></td></tr></table></figure><p>发送正常会提示ok的。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git send-email </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kswapd唤醒分析</title>
      <link href="/how-to-wakeup-kswapd.html"/>
      <url>/how-to-wakeup-kswapd.html</url>
      
        <content type="html"><![CDATA[<p>kswapd is a background pageout daemon，回收内存。</p><p>唤醒的接口是 wake_all_kswapd&#x2F;wakeup_kswapd，lets check.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the &#x27;heart&#x27; of the zoned buddy allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zonelist</span>, <span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* First allocation attempt */</span></span><br><span class="line">page = get_page_from_freelist(gfp_mask|__GFP_HARDWALL, nodemask, order,</span><br><span class="line">zonelist, high_zoneidx, alloc_flags,</span><br><span class="line">preferred_zone, classzone_idx, migratetype);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Runtime PM, block IO and its error handling path</span></span><br><span class="line"><span class="comment"> * can deadlock because I/O on the device might not</span></span><br><span class="line"><span class="comment"> * complete.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">gfp_mask = memalloc_noio_flags(gfp_mask);</span><br><span class="line">page = __alloc_pages_slowpath(gfp_mask, order,</span><br><span class="line">zonelist, high_zoneidx, nodemask,</span><br><span class="line">preferred_zone, classzone_idx, migratetype);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_slowpath</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zonelist</span>, <span class="title">enum</span> <span class="title">zone_type</span> <span class="title">high_zoneidx</span>,</span></span><br><span class="line"><span class="class"><span class="title">nodemask_t</span> *<span class="title">nodemask</span>, <span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">preferred_zone</span>,</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">classzone_idx</span>, <span class="title">int</span> <span class="title">migratetype</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line">restart:</span><br><span class="line"><span class="keyword">if</span> (!(gfp_mask &amp; __GFP_NO_KSWAPD))</span><br><span class="line">wake_all_kswapds(order, zonelist, high_zoneidx,</span><br><span class="line">preferred_zone, nodemask);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>ok, 内存分配时如果调用get_page_from_freelist分配失败而且可以从kswap获取，那就唤醒它。</p><p>get_page_from_freelist有很多地方调到，比如__alloc_pages_may_oom， __alloc_pages_direct_compact， __alloc_pages_direct_reclaim， __alloc_pages_high_priority。</p><p>get_page_from_freelist的逻辑是：</p><p>先scan zonelist，根据waterwark找到一个有足够多free page的zone,遍历完没有找到就try once more for remote node.</p><p>先看remote node:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The first pass makes sure allocations are spread fairly within the</span></span><br><span class="line"><span class="comment"> * local node.  However, the local node might have free pages left</span></span><br><span class="line"><span class="comment"> * after the fairness batches are exhausted, and remote zones haven&#x27;t</span></span><br><span class="line"><span class="comment"> * even been considered yet.  Try once more without fairness, and</span></span><br><span class="line"><span class="comment"> * include remote zones now, before entering the slowpath and waking</span></span><br><span class="line"><span class="comment"> * kswapd: prefer spilling to a remote zone over swapping locally.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_FAIR) &#123;</span><br><span class="line">alloc_flags &amp;= ~ALLOC_FAIR;</span><br><span class="line"><span class="keyword">if</span> (nr_fair_skipped) &#123;    <span class="comment">// me: local node with ZONE_FAIR_DEPLETED </span></span><br><span class="line">zonelist_rescan = <span class="literal">true</span>;</span><br><span class="line">reset_alloc_batches(preferred_zone);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nr_online_nodes &gt; <span class="number">1</span>)  <span class="comment">// me: consider remote node</span></span><br><span class="line">zonelist_rescan = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(IS_ENABLED(CONFIG_NUMA) &amp;&amp; zlc_active)) &#123;</span><br><span class="line"><span class="comment">/* Disable zlc cache for second zonelist scan */</span></span><br><span class="line">zlc_active = <span class="number">0</span>;</span><br><span class="line">zonelist_rescan = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (zonelist_rescan)</span><br><span class="line"><span class="keyword">goto</span> zonelist_scan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释提到了try once more的原因：</p><ol><li>the local node会有free pages left after the fairness batches are exhausted (什么鬼？)</li><li>consider remote node in NUMA system</li></ol><p>主要来看下怎么找到zone with enough free的: 先用zone_watermark_ok看下free page是不是在watermark之上，if it’s ok 那就走try_this_zone后的流程,if it’s not ok，那就走zone_reclaim回收后再用zone_watermark_ok检查下,same as before.</p><p>传入的watermark在：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the &#x27;heart&#x27; of the zoned buddy allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zonelist</span>, <span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">high_zoneidx</span> =</span> gfp_zone(gfp_mask);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">preferred_zone</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">preferred_zoneref</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> migratetype = gfpflags_to_migratetype(gfp_mask);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cpuset_mems_cookie;</span><br><span class="line"><span class="type">int</span> alloc_flags = ALLOC_WMARK_LOW|ALLOC_CPUSET|ALLOC_FAIR; <span class="comment">//这里</span></span><br><span class="line"><span class="type">int</span> classzone_idx;</span><br></pre></td></tr></table></figure><p>ok, it’s the ALLOC_WMARK_LOW, 所以也就是在free page在low下就会走slow_path唤醒kswapd了。 </p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kswapd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Linux VM pressure</title>
      <link href="/understand-linux-vmpressure.html"/>
      <url>/understand-linux-vmpressure.html</url>
      
        <content type="html"><![CDATA[<p>原生Linux内核是把vmpressure和CONFIG_MEMCG绑定的，是给用户态用的。</p><p>makefile里写的很清楚：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-<span class="variable">$(CONFIG_MEMCG)</span> += memcontrol.o page_cgroup.o vmpressure.o</span><br></pre></td></tr></table></figure><p>内核文档也放到了cgroup下memory.txt:</p><blockquote><ol start="11"><li>Memory Pressure</li></ol><p>The pressure level notifications can be used to monitor the memory<br>allocation cost; based on the pressure, applications can implement<br>different strategies of managing their memory resources. The pressure<br>levels are defined as following:</p><p>The “low” level means that the system is reclaiming memory for new<br>allocations. Monitoring this reclaiming activity might be useful for<br>maintaining cache level. Upon notification, the program (typically<br>“Activity Manager”) might analyze vmstat and act in advance (i.e.<br>prematurely shutdown unimportant services).</p><p>The “medium” level means that the system is experiencing medium memory<br>pressure, the system might be making swap, paging out active file caches,<br>etc. Upon this event applications may decide to further analyze<br>vmstat&#x2F;zoneinfo&#x2F;memcg or internal memory usage statistics and free any<br>resources that can be easily reconstructed or re-read from a disk.</p><p>The “critical” level means that the system is actively thrashing, it is<br>about to out of memory (OOM) or even the in-kernel OOM killer is on its<br>way to trigger. Applications should do whatever they can to help the<br>system. It might be too late to consult with vmstat or any other<br>statistics, so it’s advisable to take an immediate action.</p></blockquote><p>上面这段描述就是说内核提供vmpressure监测事件给用户态，应用根据level级别实现不同管理内存策略。</p><p>low level正常回收，medium level就是开始swaping了，critical就是快没内存了。</p><p>一般Android平台memcg没打开(至少7.0及以下)，原因以后在看，先看vmpressure, 高通平台Android会把vmpressure放给in-kernel client，比如qualcomm lowmemorykiller.c:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">lowmem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">register_shrinker(&amp;lowmem_shrinker);</span><br><span class="line">vmpressure_notifier_register(&amp;lmk_vmpr_nb); <span class="comment">//在原生kernel里是没有的</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要看下Android平台。</p><p>有几种计算vmpressure的方法：</p><ul><li>vmpressure_prio(): 通过reclaimer priority level来计算, it’s called from reclaim path</li><li>vmpressure(): 通过scanned&#x2F;reclaim ratio来计算，主要是vmpressure_calc_pressure</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">vmpressure_calc_pressure</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> scanned,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> reclaimed)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> scale = scanned + reclaimed;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pressure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We calculate the ratio (in percents) of how many pages were</span></span><br><span class="line"><span class="comment"> * scanned vs. reclaimed in a given time frame (window). Note that</span></span><br><span class="line"><span class="comment"> * time is in VM reclaimer&#x27;s &quot;ticks&quot;, i.e. number of pages</span></span><br><span class="line"><span class="comment"> * scanned. This makes it possible to set desired reaction time</span></span><br><span class="line"><span class="comment"> * and serves as a ratelimit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pressure = scale - (reclaimed * scale / scanned);</span><br><span class="line">pressure = pressure * <span class="number">100</span> / scale;</span><br></pre></td></tr></table></figure><p>pressue就是(1 - reclaimed&#x2F;scanned) * 100了，这里scale估计也就是取整数rounding了， 也就是(scanned - reclaimed)&#x2F;scanned就是说在扫描中未回收的比例就是vmpressure了。</p><p>so 在定义level时里也注释了vmpressue越大就表示有越多的未成功回收。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These thresholds are used when we account memory pressure through</span></span><br><span class="line"><span class="comment"> * scanned/reclaimed ratio. The current values were chosen empirically. In</span></span><br><span class="line"><span class="comment"> * essence, they are percents: the higher the value, the more number</span></span><br><span class="line"><span class="comment"> * unsuccessful reclaims there were.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> vmpressure_level_med = <span class="number">60</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> vmpressure_level_critical = <span class="number">95</span>;</span><br></pre></td></tr></table></figure><p>vmpressure_win就是scanned pages的下限，比vmpressure_win还小就忽略这次了。</p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmpressure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zone水位阈值代码分析</title>
      <link href="/analyze-zone-watermark.html"/>
      <url>/analyze-zone-watermark.html</url>
      
        <content type="html"><![CDATA[<p>内核zone里有个水位的概念，根据这个水位判断内存压力，从而进行内存回收,版本3.18。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line"><span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> watermark[NR_WMARK];</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_watermarks</span> &#123;</span></span><br><span class="line">WMARK_MIN,</span><br><span class="line">WMARK_LOW,</span><br><span class="line">WMARK_HIGH,</span><br><span class="line">NR_WMARK</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min_wmark_pages(z) (z-&gt;watermark[WMARK_MIN])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> low_wmark_pages(z) (z-&gt;watermark[WMARK_LOW])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> high_wmark_pages(z) (z-&gt;watermark[WMARK_HIGH])</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line"><span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> watermark[NR_WMARK];</span><br></pre></td></tr></table></figure><p>watermark计算会用到managed_pages:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment"> * holes, which is calculated as:</span></span><br><span class="line"><span class="comment"> * spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment"> * is calculated as:</span></span><br><span class="line"><span class="comment"> *present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment"> * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment"> * bootmem allocator):</span></span><br><span class="line"><span class="comment"> *managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment"> * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment"> * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment"> * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment"> * and thresholds.</span></span><br><span class="line"><span class="comment"> ...</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>安装代码在__setup_per_zone_wmarks:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __setup_per_zone_wmarks(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pages_min = min_free_kbytes &gt;&gt; (PAGE_SHIFT - <span class="number">10</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pages_low = extra_free_kbytes &gt;&gt; (PAGE_SHIFT - <span class="number">10</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> lowmem_pages = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">for_each_zone(zone) &#123;</span><br><span class="line">...</span><br><span class="line">zone-&gt;watermark[WMARK_LOW]  = min_wmark_pages(zone) +</span><br><span class="line">low + (min &gt;&gt; <span class="number">2</span>);</span><br><span class="line">zone-&gt;watermark[WMARK_HIGH] = min_wmark_pages(zone) +</span><br><span class="line">low + (min &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>so, wmark min &lt; low &lt; high</p><p>那到底背后的判断zone水位压力逻辑是什么，先看下内核文档了解下：</p><p>水位的计算有两个变量：</p><blockquote><p>min_free_kbytes:</p><p>This is used to force the Linux VM to keep a minimum number<br>of kilobytes free.  The VM uses this number to compute a<br>watermark[WMARK_MIN] value for each lowmem zone in the system.<br>Each lowmem zone gets a number of reserved free pages based<br>proportionally on its size.</p><p>Some minimal amount of memory is needed to satisfy PF_MEMALLOC<br>allocations; if you set this to lower than 1024KB, your system will<br>become subtly broken, and prone to deadlock under high loads.</p><p>Setting this too high will OOM your machine instantly.</p><p>extra_free_kbytes</p><p>This parameter tells the VM to keep extra free memory between the threshold<br>where background reclaim (kswapd) kicks in, and the threshold where direct<br>reclaim (by allocating processes) kicks in.</p><p>This is useful for workloads that require low latency memory allocations<br>and have a bounded burstiness in memory allocations, for example a<br>realtime application that receives and transmits network traffic<br>(causing in-kernel memory allocations) with a maximum total message burst<br>size of 200MB may need 200MB of extra free memory to avoid direct reclaim<br>related latencies.</p></blockquote><p>再看一段描述</p><blockquote><p>watemark[WMARK_MIN&#x2F;WMARK_LOW&#x2F;WMARK_HIGH]&#x2F;low_on_memory&#x2F;zone_wake_kswapd: These<br>are per-zone fields, used to determine when a zone needs to be balanced. When<br>the number of pages falls below watermark[WMARK_MIN], the hysteric field<br>low_on_memory gets set. This stays set till the number of free pages becomes<br>watermark[WMARK_HIGH]. When low_on_memory is set, page allocation requests will<br>try to free some pages in the zone (providing GFP_WAIT is set in the request).<br>Orthogonal to this, is the decision to poke kswapd to free some zone pages.<br>That decision is not hysteresis based, and is done when the number of free<br>pages is below watermark[WMARK_LOW]; in which case zone_wake_kswapd is also set.</p></blockquote><p>so, 当free page小于wmark low时, kswapd开始活动，必须要先到wmark min以下才会触发kswapd? need to check out kswapd code.</p><p>当水位在min以下后直到high才停止kswapd，否则分配也会尝试释放内存。可以通过proc下的zoneinfo查。</p><p>这里的描述是2.x，3.18内核在用zone_balanced判断是否平衡，大概看下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">zone_watermark_ok_safe</span><span class="params">(<span class="keyword">struct</span> zone *z, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> mark, <span class="type">int</span> classzone_idx, <span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> free_pages = zone_page_state(z, NR_FREE_PAGES);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (z-&gt;percpu_drift_mark &amp;&amp; free_pages &lt; z-&gt;percpu_drift_mark)</span><br><span class="line">free_pages = zone_page_state_snapshot(z, NR_FREE_PAGES);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,</span><br><span class="line">free_pages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断标准就是free page，传入mark是high_wmark_pages。</p><p>所以说提高水位min_free_kbytes or extra_free_kbytes，回收内存提早了，因为free page更容易低于该wmark。</p><p>我们从官方Android 4.4 low memory优化说明也能看出：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;!-- Device configuration setting the /proc/sys/vm/extra_free_kbytes tunable in the kernel (if it exists). A high value will increase the amount of memory that the kernel tries to keep free, reducing allocation time and causing the lowmemorykiller to kill earlier. A low value allows more memory to be used by processes but may cause more allocations to block waiting on disk I/O or lowmemorykiller. Overrides the default value chosen by ActivityManager based on screen size. 0 prevents keeping any extra memory over what the kernel keeps by default. -1 keeps the default. --&gt;</span><br><span class="line">&lt;integer name=&quot;config_extraFreeKbytesAbsolute&quot;&gt;-1&lt;/integer&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zone </tag>
            
            <tag> Watermark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内存模型分析</title>
      <link href="/analyze-memory-module.html"/>
      <url>/analyze-memory-module.html</url>
      
        <content type="html"><![CDATA[<p>kernel版本是3.18，先看下内存描述几个概念。</p><h2 id="zone-概念"><a href="#zone-概念" class="headerlink" title="zone 概念"></a>zone 概念</h2><p>NUMA全称Non-Uniform Memory Access,主要说的是cpu访问memory bank依赖他们之间的距离成本问题。</p><p>memory被划分成bank，每一个bank叫做node，每一个node被分成很多块叫zones, node用pglist_data表示, zone里包含pages</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The pg_data_t structure is used in machines with CONFIG_DISCONTIGMEM</span></span><br><span class="line"><span class="comment"> * (mostly NUMA machines?) to denote a higher-level memory zone than the</span></span><br><span class="line"><span class="comment"> * zone denotes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On NUMA machines, each NUMA node would have a pg_data_t to describe</span></span><br><span class="line"><span class="comment"> * it&#x27;s memory layout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Memory statistics and page replacement data structures are maintained on a</span></span><br><span class="line"><span class="comment"> * per-zone basis.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line"><span class="type">int</span> nr_zones;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP<span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_cgroup</span> *<span class="title">node_page_cgroup</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">&#125;<span class="type">pg_data_t</span>;</span><br></pre></td></tr></table></figure><p>可以看到成员node_zones，就是node里有多少zones了。</p><p>注释提到这个结构是给CONFIG_DISCONTIGMEM用的，说的是内存模型，就是node如何管理pages的。</p><p>zone的数据结构是struct zone, zone种类主要有ZONE_DMA，ZONE_NORMAL，ZONE_HIGHMEM。</p><p>ZONE_HIGHMEM给32bits系统用，ZONE_DMA是架构相关特殊设备需要，ZONE_NORMAL定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Normal addressable memory is in ZONE_NORMAL. DMA operations can be</span></span><br><span class="line"><span class="comment"> * performed on pages in ZONE_NORMAL if the DMA devices support</span></span><br><span class="line"><span class="comment"> * transfers to all addressable memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ZONE_NORMAL,</span><br></pre></td></tr></table></figure><p>64bit手机系统里一般都是一个ZONE_NORMAL。</p><h2 id="memory-module"><a href="#memory-module" class="headerlink" title="memory module"></a>memory module</h2><p>linux内存模型按有3种，按演变先后顺序是：flat memory, discontiguous memory, sparse memory.</p><p>看下内核的配置说明</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config DISCONTIGMEM_MANUAL</span><br><span class="line">        bool &quot;Discontiguous Memory&quot;</span><br><span class="line">        depends on ARCH_DISCONTIGMEM_ENABLE</span><br><span class="line">        help</span><br><span class="line">          This option provides enhanced support for discontiguous</span><br><span class="line">          memory systems, over FLATMEM.  These systems have holes</span><br><span class="line">          in their physical address spaces, and this option provides</span><br><span class="line">          more efficient handling of these holes.  However, the vast</span><br><span class="line">          majority of hardware has quite flat address spaces, and</span><br><span class="line">          can have degraded performance from the extra overhead that</span><br><span class="line">          this option imposes.</span><br><span class="line"></span><br><span class="line">          Many NUMA configurations will have this as the only option.</span><br><span class="line"></span><br><span class="line">          If unsure, choose &quot;Flat Memory&quot; over this option.</span><br><span class="line"></span><br><span class="line">config SPARSEMEM_MANUAL</span><br><span class="line">        bool &quot;Sparse Memory&quot;</span><br><span class="line">        depends on ARCH_SPARSEMEM_ENABLE</span><br><span class="line">        help</span><br><span class="line">          This will be the only option for some systems, including</span><br><span class="line">          memory hotplug systems.  This is normal.</span><br><span class="line"></span><br><span class="line">          For many other systems, this will be an alternative to</span><br><span class="line">          &quot;Discontiguous Memory&quot;.  This option provides some potential</span><br><span class="line">          performance benefits, along with decreased code complexity,</span><br><span class="line">          but it is newer, and more experimental.</span><br><span class="line"></span><br><span class="line">          If unsure, choose &quot;Discontiguous Memory&quot; or &quot;Flat Memory&quot;</span><br><span class="line">          over this option.</span><br></pre></td></tr></table></figure><p>flat就是物理地址空间连续，discontigous就是不连续了，物理地址空间有holes，NUMA系统用，sparse针对是热插拔,从字面看应该是更分散，结合热插拔可以想到是更多分散的内存区域随时可以热插拔。</p><p>看下page相关成员：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line"><span class="type">int</span> nr_zones;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP<span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_cgroup</span> *<span class="title">node_page_cgroup</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config FLAT_NODE_MEM_MAP</span><br><span class="line">        def_bool y</span><br><span class="line">        depends on !SPARSEMEM</span><br></pre></td></tr></table></figure><p>这里的node_mem_map就是for discontigous, 从定义来看flat也应该适用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_NEED_MULTIPLE_NODES</span></span><br><span class="line"><span class="comment">/* use the per-pgdat data instead for discontigmem - mbligh */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> max_mapnr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">mem_map</span>;</span></span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(max_mapnr);</span><br><span class="line">EXPORT_SYMBOL(mem_map);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_DISCONTIGMEM</span></span><br><span class="line"><span class="comment">/* The array of struct pages - for discontigmem use pgdat-&gt;lmem_map */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_NEED_MULTIPLE_NODES</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> <span class="title">contig_page_data</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NODE_DATA(nid)(&amp;contig_page_data)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NODE_MEM_MAP(nid)mem_map</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* CONFIG_NEED_MULTIPLE_NODES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mmzone.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !CONFIG_NEED_MULTIPLE_NODES */</span></span></span><br></pre></td></tr></table></figure><p>上面几段代码用到了两个宏:CONFIG_NEED_MULTIPLE_NODES, CONFIG_DISCONTIGMEM:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># Both the NUMA code and DISCONTIGMEM use arrays of pg_data_t&#x27;s</span><br><span class="line"># to represent different areas of memory.  This variable allows</span><br><span class="line"># those dependencies to exist individually.</span><br><span class="line">#</span><br><span class="line">config NEED_MULTIPLE_NODES</span><br><span class="line">        def_bool y</span><br><span class="line">        depends on DISCONTIGMEM || NUMA</span><br></pre></td></tr></table></figure><p>不连续，地址空间被分成多个node，这个node就是之前的bank了。</p><p>so, mem_map应该给flat用，从代码看sparse也能用？应该不是。mem_map就是node 0的node_mem_map.</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init_refok <span class="title function_">alloc_node_mem_map</span><span class="params">(<span class="keyword">struct</span> pglist_data *pgdat)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_NEED_MULTIPLE_NODES</span></span><br><span class="line">        <span class="comment">/*   </span></span><br><span class="line"><span class="comment">         * With no DISCONTIG, the global mem_map is just set as node 0&#x27;s</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (pgdat == NODE_DATA(<span class="number">0</span>)) &#123;</span><br><span class="line">                mem_map = NODE_DATA(<span class="number">0</span>)-&gt;node_mem_map;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从代码实现能看出flat模型就是single node，disconti模型就是multiple node。flat是disconti的特性情况，也就是node 0。</p><p>看下sparse是怎么管理的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is, logically, a pointer to an array of struct</span></span><br><span class="line"><span class="comment"> * pages.  However, it is stored with some other magic.</span></span><br><span class="line"><span class="comment"> * (see sparse.c::sparse_init_one_section())</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Additionally during early boot we encode node id of</span></span><br><span class="line"><span class="comment"> * the location of the section here to guide allocation.</span></span><br><span class="line"><span class="comment"> * (see sparse.c::memory_present())</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Making it a UL at least makes someone do a cast</span></span><br><span class="line"><span class="comment"> * before using it wrong.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> section_mem_map;</span><br></pre></td></tr></table></figure><p>用section_mem_map来表示page数组, 现在的手机一般都是sparse模型了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> page_to_pfn __page_to_pfn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pfn_to_page __pfn_to_page</span></span><br></pre></td></tr></table></figure><p>这两个宏的实现按模型区分开, pfn is page frame number, 就是给page标号数组index。</p><p>对于flatmem，要找到某个page就是mem_map + n, n是该page的pfn.</p><p>对discontigmem,要找到node，然后根据node_mem_map + n</p><p>sparsemem要先找到section,然后再section_mem_map + n</p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zone </tag>
            
            <tag> Memory Module </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Settings.apk显示剩余内存代码分析</title>
      <link href="/analyze-free-memory-of-setting.html"/>
      <url>/analyze-free-memory-of-setting.html</url>
      
        <content type="html"><![CDATA[<p>一般Linux内核统计剩余内存都是meminfo的MemFree+Cached, maybe + Buffers, 如下:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxxx:/ <span class="comment"># cat /proc/meminfo</span></span><br><span class="line">MemTotal:        1883144 kB</span><br><span class="line">MemFree:           66536 kB</span><br><span class="line">MemAvailable:     724464 kB</span><br><span class="line">Buffers:           30180 kB</span><br><span class="line">Cached:           678484 kB</span><br></pre></td></tr></table></figure><p>不过Android原生系统里setting.apk界面剩余内存显示和内核有较大出入，来查下，代码是Android 7.0。</p><p>setting.apk里ProcessStatsSummary.java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refreshUi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> getContext();</span><br><span class="line"></span><br><span class="line">    <span class="type">MemInfo</span> <span class="variable">memInfo</span> <span class="operator">=</span> mStatsManager.getMemInfo();</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="variable">usedRam</span> <span class="operator">=</span> memInfo.realUsedRam;</span><br><span class="line">    <span class="type">double</span> <span class="variable">totalRam</span> <span class="operator">=</span> memInfo.realTotalRam;</span><br><span class="line">    <span class="type">double</span> <span class="variable">freeRam</span> <span class="operator">=</span> memInfo.realFreeRam;</span><br><span class="line">    <span class="type">BytesResult</span> <span class="variable">usedResult</span> <span class="operator">=</span> Formatter.formatBytes(context.getResources(), (<span class="type">long</span>) usedRam,Formatter.FLAG_SHORTER);</span><br><span class="line">    <span class="type">String</span> <span class="variable">totalString</span> <span class="operator">=</span> Formatter.formatShortFileSize(context, (<span class="type">long</span>) totalRam);</span><br><span class="line">    <span class="keyword">if</span>(context.getResources().getBoolean(R.bool.config_support_show_system_volume)&amp;&amp;totalString.contains(<span class="string">&quot;.0&quot;</span>)) &#123;</span><br><span class="line">        totalString = totalString.replace(<span class="string">&quot;.0&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="type">String</span> <span class="variable">freeString</span> <span class="operator">=</span> Formatter.formatShortFileSize(context, (<span class="type">long</span>) freeRam);</span><br><span class="line">    CharSequence memString;</span><br><span class="line">    CharSequence[] memStatesStr = getResources().getTextArray(R.array.ram_states);</span><br><span class="line">    <span class="type">int</span> <span class="variable">memState</span> <span class="operator">=</span> mStatsManager.getMemState();</span><br><span class="line">    <span class="keyword">if</span> (memState &gt;= <span class="number">0</span> &amp;&amp; memState &lt; memStatesStr.length - <span class="number">1</span>) &#123;</span><br><span class="line">        memString = memStatesStr[memState];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memString = memStatesStr[memStatesStr.length - <span class="number">1</span>]; </span><br><span class="line">    &#125;   </span><br><span class="line">    mSummaryPref.setAmount(usedResult.value);</span><br><span class="line">    mSummaryPref.setUnits(usedResult.units);</span><br><span class="line">    <span class="type">float</span> <span class="variable">usedRatio</span> <span class="operator">=</span> (<span class="type">float</span>)(usedRam / (freeRam + usedRam));</span><br><span class="line">    mSummaryPref.setRatios(usedRatio, <span class="number">0</span>, <span class="number">1</span> - usedRatio);</span><br><span class="line"></span><br><span class="line">    mPerformance.setSummary(memString);</span><br><span class="line">    mTotalMemory.setSummary(totalString);</span><br><span class="line">    mAverageUsed.setSummary(Utils.formatPercentage((<span class="type">long</span>) usedRam, (<span class="type">long</span>) totalRam));</span><br><span class="line">    mFree.setSummary(freeString);</span><br><span class="line">    <span class="type">String</span> <span class="variable">durationString</span> <span class="operator">=</span> getString(sDurationLabels[mDurationIndex]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numApps</span> <span class="operator">=</span> mStatsManager.getEntries().size();</span><br><span class="line">    mAppListPreference.setSummary(getResources().getQuantityString(</span><br><span class="line">            R.plurals.memory_usage_apps_summary, numApps, numApps, durationString));</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ProcStatsData mStatsManager;</span><br></pre></td></tr></table></figure><p>ProcStatsData.java在packages&#x2F;apps&#x2F;Settings&#x2F;src&#x2F;com&#x2F;android&#x2F;settings&#x2F;applications&#x2F;ProcStatsData.java.</p><p>memInfo.realFreeRam是我们关心的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">MemInfo</span><span class="params">(Context context, ProcessStats.TotalMemoryUseCollection totalMem,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> memTotalTime)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.memTotalTime = memTotalTime;</span><br><span class="line">    calculateWeightInfo(context, totalMem, memTotalTime);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="variable">usedRam</span> <span class="operator">=</span> (usedWeight * <span class="number">1024</span>) / memTotalTime;</span><br><span class="line">    <span class="type">double</span> <span class="variable">freeRam</span> <span class="operator">=</span> (freeWeight * <span class="number">1024</span>) / memTotalTime;</span><br><span class="line">    totalRam = usedRam + freeRam;</span><br><span class="line">    totalScale = realTotalRam / totalRam;</span><br><span class="line">    weightToRam = totalScale / memTotalTime * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    realUsedRam = usedRam * totalScale;</span><br><span class="line">    realFreeRam = freeRam * totalScale;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;Scaled Used RAM: &quot;</span> + Formatter.formatShortFileSize(context,</span><br><span class="line">                (<span class="type">long</span>) realUsedRam));</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;Scaled Free RAM: &quot;</span> + Formatter.formatShortFileSize(context,</span><br><span class="line">                (<span class="type">long</span>) realFreeRam));</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;Adj Scaled Used RAM: &quot;</span> + Formatter.formatShortFileSize(context,</span><br><span class="line">                (<span class="type">long</span>) realUsedRam));</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;Adj Scaled Free RAM: &quot;</span> + Formatter.formatShortFileSize(context,</span><br><span class="line">                (<span class="type">long</span>) realFreeRam));</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    ActivityManager.<span class="type">MemoryInfo</span> <span class="variable">memInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityManager</span>.MemoryInfo();</span><br><span class="line">    ((ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE)).getMemoryInfo(</span><br><span class="line">            memInfo);</span><br><span class="line">    <span class="keyword">if</span> (memInfo.hiddenAppThreshold &gt;= realFreeRam) &#123;</span><br><span class="line">        realUsedRam = freeRam;</span><br><span class="line">        realFreeRam = <span class="number">0</span>;</span><br><span class="line">        baseCacheRam = (<span class="type">long</span>) realFreeRam;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        realUsedRam += memInfo.hiddenAppThreshold;</span><br><span class="line">        realFreeRam -= memInfo.hiddenAppThreshold; <span class="comment">//去掉了cachedAppMem</span></span><br><span class="line">        baseCacheRam = memInfo.hiddenAppThreshold;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>hiddenAppThreshold的赋值在frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;am&#x2F;ActivityManagerService.java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMemoryInfo</span><span class="params">(ActivityManager.MemoryInfo outInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">homeAppMem</span> <span class="operator">=</span> mProcessList.getMemLevel(ProcessList.HOME_APP_ADJ);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">cachedAppMem</span> <span class="operator">=</span> mProcessList.getMemLevel(ProcessList.CACHED_APP_MIN_ADJ);</span><br><span class="line">    outInfo.availMem = Process.getFreeMemory();</span><br><span class="line">    outInfo.totalMem = Process.getTotalMemory();</span><br><span class="line">    outInfo.threshold = homeAppMem;</span><br><span class="line">    outInfo.lowMemory = outInfo.availMem &lt; (homeAppMem + ((cachedAppMem-homeAppMem)/<span class="number">2</span>));</span><br><span class="line">    outInfo.hiddenAppThreshold = cachedAppMem;  <span class="comment">//在这里定义</span></span><br><span class="line">    outInfo.secondaryServerThreshold = mProcessList.getMemLevel(</span><br><span class="line">            ProcessList.SERVICE_ADJ);</span><br><span class="line">    outInfo.visibleAppThreshold = mProcessList.getMemLevel(</span><br><span class="line">            ProcessList.VISIBLE_APP_ADJ);</span><br><span class="line">    outInfo.foregroundAppThreshold = mProcessList.getMemLevel(</span><br><span class="line">            ProcessList.FOREGROUND_APP_ADJ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is a process only hosting activities that are not visible,</span></span><br><span class="line"><span class="comment">// so it can be killed without any disruption.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CACHED_APP_MAX_ADJ</span> <span class="operator">=</span> <span class="number">906</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CACHED_APP_MIN_ADJ</span> <span class="operator">=</span> <span class="number">900</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">getMemLevel</span><span class="params">(<span class="type">int</span> adjustment)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;mOomAdj.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (adjustment &lt;= mOomAdj[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mOomMinFree[i] * <span class="number">1024</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mOomMinFree[mOomAdj.length-<span class="number">1</span>] * <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is a process currently hosting a backup operation.  Killing it</span></span><br><span class="line"><span class="comment">// is not entirely fatal but is generally a bad idea.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BACKUP_APP_ADJ</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a process only hosting components that are perceptible to the</span></span><br><span class="line"><span class="comment">// user, and we really want to avoid killing them, but they are not</span></span><br><span class="line"><span class="comment">// immediately visible. An example is background music playback.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PERCEPTIBLE_APP_ADJ</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a process only hosting activities that are visible to the</span></span><br><span class="line"><span class="comment">// user, so we&#x27;d prefer they don&#x27;t disappear.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VISIBLE_APP_ADJ</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VISIBLE_APP_LAYER_MAX</span> <span class="operator">=</span> PERCEPTIBLE_APP_ADJ - VISIBLE_APP_ADJ - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is the process running the current foreground app.  We&#x27;d really</span></span><br><span class="line"><span class="comment">// rather not kill it!</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FOREGROUND_APP_ADJ</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// These are the various interesting memory levels that we will give to</span></span><br><span class="line"><span class="comment">// the OOM killer.  Note that the OOM killer only supports 6 slots, so we</span></span><br><span class="line"><span class="comment">// can&#x27;t give it a different value for every possible kind of process.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] mOomAdj = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;</span><br><span class="line">        FOREGROUND_APP_ADJ, VISIBLE_APP_ADJ, PERCEPTIBLE_APP_ADJ,</span><br><span class="line">        BACKUP_APP_ADJ, CACHED_APP_MIN_ADJ, CACHED_APP_MAX_ADJ</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>mOomMinFree会根据mOomMinFreeLow和mOomMinFreeHigh通过一定计算方法得出,也就是lmk minfree参数倒数第二个了, cached min,注意单位是页.</p><p>来看看usedRam和freeRam是怎么来的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">MemInfo</span><span class="params">(Context context, ProcessStats.TotalMemoryUseCollection totalMem,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> memTotalTime)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.memTotalTime = memTotalTime;</span><br><span class="line">    calculateWeightInfo(context, totalMem, memTotalTime);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="variable">usedRam</span> <span class="operator">=</span> (usedWeight * <span class="number">1024</span>) / memTotalTime;</span><br><span class="line">    <span class="type">double</span> <span class="variable">freeRam</span> <span class="operator">=</span> (freeWeight * <span class="number">1024</span>) / memTotalTime;</span><br></pre></td></tr></table></figure><p>check totalMem</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refreshStats</span><span class="params">(<span class="type">boolean</span> forceLoad)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mStats == <span class="literal">null</span> || forceLoad) &#123;</span><br><span class="line">        load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pkgEntries = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    memTotalTime = DumpUtils.dumpSingleTime(<span class="literal">null</span>, <span class="literal">null</span>, mStats.mMemFactorDurations,</span><br><span class="line">            mStats.mMemFactor, mStats.mStartTime, now);</span><br><span class="line"></span><br><span class="line">    ProcessStats.<span class="type">TotalMemoryUseCollection</span> <span class="variable">totalMem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessStats</span>.TotalMemoryUseCollection(</span><br><span class="line">            ProcessStats.ALL_SCREEN_ADJ, mMemStates);</span><br><span class="line">    mStats.computeTotalMemoryUse(totalMem, now);</span><br></pre></td></tr></table></figure><p>ok, lets check <code>computeTotalMemoryUse</code></p><p>在frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;app&#x2F;procstats&#x2F;ProcessStats.java:</p><p>看下dumpTotalsLocked能看出来是根据pss计算得来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dumpTotalsLocked</span><span class="params">(PrintWriter pw, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    pw.println(<span class="string">&quot;Run time Stats:&quot;</span>);</span><br><span class="line">    DumpUtils.dumpSingleTime(pw, <span class="string">&quot;  &quot;</span>, mMemFactorDurations, mMemFactor, mStartTime, now);</span><br><span class="line">    pw.println();</span><br><span class="line">    pw.println(<span class="string">&quot;Memory usage:&quot;</span>);</span><br><span class="line">    <span class="type">TotalMemoryUseCollection</span> <span class="variable">totalMem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TotalMemoryUseCollection</span>(ALL_SCREEN_ADJ,</span><br><span class="line">            ALL_MEM_ADJ);</span><br><span class="line">    computeTotalMemoryUse(totalMem, now);</span><br><span class="line">    <span class="type">long</span> <span class="variable">totalPss</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    totalPss = printMemoryCategory(pw, <span class="string">&quot;  &quot;</span>, <span class="string">&quot;Kernel &quot;</span>, totalMem.sysMemKernelWeight,</span><br><span class="line">            totalMem.totalTime, totalPss, totalMem.sysMemSamples);</span><br><span class="line">    totalPss = printMemoryCategory(pw, <span class="string">&quot;  &quot;</span>, <span class="string">&quot;Native &quot;</span>, totalMem.sysMemNativeWeight,</span><br><span class="line">            totalMem.totalTime, totalPss, totalMem.sysMemSamples);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;STATE_COUNT; i++) &#123;</span><br><span class="line">        <span class="comment">// Skip restarting service state -- that is not actually a running process.</span></span><br><span class="line">        <span class="keyword">if</span> (i != STATE_SERVICE_RESTARTING) &#123;</span><br><span class="line">            totalPss = printMemoryCategory(pw, <span class="string">&quot;  &quot;</span>, DumpUtils.STATE_NAMES[i],</span><br><span class="line">                    totalMem.processStateWeight[i], totalMem.totalTime, totalPss,</span><br><span class="line">                    totalMem.processStateSamples[i]);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><p>ok, 然后再考虑某个时间段的使用确定内存使用统计。</p><p>对PSS的内核proc.txt有说明：</p><blockquote><p>The “proportional set size” (PSS) of a process is the count of pages it has<br>in memory, where each page is divided by the number of processes sharing it.<br>So if a process has 1000 pages all to itself, and 1000 shared with one other<br>process, its PSS will be 1500.</p></blockquote><p>&#x2F;proc&#x2F;PID&#x2F;smaps里有Pss的统计, 统计代码可以看fs&#x2F;proc&#x2F;task_mmu.c</p><p>对于RSS, resident in RAM, lwn.net的历史说明就是应用没有共享页统计,所以要引入PSS。</p><blockquote><p>The resident set size (RSS) number is a little better, but there is no information on sharing of pages there. </p></blockquote><p>refer: <a href="https://lwn.net/Articles/230975/">https://lwn.net/Articles/230975/</a></p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Free Memory </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析__pa和__va代码定义</title>
      <link href="/analyze-pa-and-va-def.html"/>
      <url>/analyze-pa-and-va-def.html</url>
      
        <content type="html"><![CDATA[<p>arm64&#x2F;kernel3.18的定义在arch&#x2F;arm64&#x2F;include&#x2F;asm&#x2F;memory.h里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLY__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pa(x)                 __virt_to_phys((unsigned long)(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __va(x)                 ((void *)__phys_to_virt((phys_addr_t)(x)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里用了宏<code>__ASSEMBLY__</code>, 也就是说上面的定义用于非汇编代码里。查了下arm64&#x2F;.S没有<code>__pa</code>的定义和使用，这里的宏是不是多余的。</p><p>继续grep。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Physical vs virtual RAM address space conversion.  These are</span></span><br><span class="line"><span class="comment"> * private definitions which should NOT be used outside memory.h</span></span><br><span class="line"><span class="comment"> * files.  Use virt_to_phys/phys_to_virt/__pa/__va instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __virt_to_phys(x)       (((phys_addr_t)(x) - PAGE_OFFSET + PHYS_OFFSET))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __phys_to_virt(x)       ((unsigned long)((x) - PHYS_OFFSET + PAGE_OFFSET))</span></span><br></pre></td></tr></table></figure><p>这里就没有用<code>__ASSEMBLY__</code>。</p><p>看下内核文档的说明, 在Documentation&#x2F;arm&#x2F;Porting里：</p><blockquote><p>PHYS_OFFSET<br>       Physical start address of the first bank of RAM.</p><p>PAGE_OFFSET<br>       Virtual start address of the first bank of RAM.  During the kernel<br>       boot phase, virtual address PAGE_OFFSET will be mapped to physical<br>       address PHYS_OFFSET, along with any other mappings you supply.<br>       This should be the same value as TASK_SIZE.</p></blockquote><p>PAGE_OFFSET代码定义:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PAGE_OFFSET - the virtual address of the start of the kernel image (top</span></span><br><span class="line"><span class="comment"> *               (VA_BITS - 1))</span></span><br><span class="line"><span class="comment"> * VA_BITS - the maximum number of bits for virtual addresses.</span></span><br><span class="line"><span class="comment"> * VA_START - the first kernel virtual address.</span></span><br><span class="line"><span class="comment"> * TASK_SIZE - the maximum size of a user space task.</span></span><br><span class="line"><span class="comment"> * TASK_UNMAPPED_BASE - the lower boundary of the mmap VM area.</span></span><br><span class="line"><span class="comment"> * The module space lives between the addresses given by TASK_SIZE</span></span><br><span class="line"><span class="comment"> * and PAGE_OFFSET - it must be within 128MB of the kernel text.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VA_BITS                 (CONFIG_ARM64_VA_BITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VA_START                (UL(0xffffffffffffffff) &lt;&lt; VA_BITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_OFFSET             (UL(0xffffffffffffffff) &lt;&lt; (VA_BITS - 1))</span></span><br></pre></td></tr></table></figure><p>CONFIG_ARM64_VA_BITS定义在arch&#x2F;arm64&#x2F;Kconfig里, 我这里高通39bits。</p><p>PHYS_OFFSET的定义稍微复杂, 先来看:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLY__</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="type">phys_addr_t</span>              memstart_addr;</span><br><span class="line"><span class="comment">/* PHYS_OFFSET - the physical address of the start of memory. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYS_OFFSET             (&#123; memstart_addr; &#125;)</span></span><br></pre></td></tr></table></figure><p>arm64&#x2F;*.S没有用到PHYS_OFFSET，应该没必要用<code>__ASSEMBLY__</code>。</p><p>memstart_addr在arch&#x2F;arm64&#x2F;kernel&#x2F;head.S:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__switch_data:</span><br><span class="line">        .quad   __mmap_switched</span><br><span class="line">        .quad   __bss_start                     // x6</span><br><span class="line">        .quad   __bss_stop                      // x7</span><br><span class="line">        .quad   processor_id                    // x4</span><br><span class="line">        .quad   __fdt_pointer                   // x5</span><br><span class="line">        .quad   memstart_addr                   // x6</span><br><span class="line">        .quad   init_thread_union + THREAD_START_SP // sp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The following fragment of code is executed with the MMU on in MMU mode, and</span><br><span class="line"> * uses absolute addresses; this is not position independent.</span><br><span class="line"> */</span><br><span class="line">__mmap_switched:</span><br><span class="line">        adr     x3, __switch_data + 8 </span><br><span class="line"></span><br><span class="line">        ldp     x6, x7, [x3], #16 </span><br><span class="line">1:      cmp     x6, x7</span><br><span class="line">        b.hs    2f  </span><br><span class="line">        str     xzr, [x6], #8                   // Clear BSS</span><br><span class="line">        b       1b  </span><br><span class="line">2:</span><br><span class="line">        ldp     x4, x5, [x3], #16               // me: x4=processor_id x5=__fdt_pointer</span><br><span class="line">        ldr     x6, [x3], #8                    // me: x6=memstart_addr</span><br><span class="line">        ldr     x16, [x3]</span><br><span class="line">        mov     sp, x16 </span><br><span class="line">        str     x22, [x4]                       // Save processor ID</span><br><span class="line">        str     x21, [x5]                       // Save FDT pointer</span><br><span class="line">        str     x24, [x6]                       // Save PHYS_OFFSET</span><br><span class="line">        mov     x29, #0</span><br><span class="line">#ifdef CONFIG_KASAN</span><br><span class="line">        bl      kasan_early_init</span><br><span class="line">#endif</span><br><span class="line">        b       start_kernel</span><br><span class="line">ENDPROC(__mmap_switched)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        ldr     x27, __switch_data              // address to jump to after</span><br><span class="line">                                                // MMU has been enabled</span><br><span class="line">        adrp    lr, __enable_mmu                // return (PIC) address</span><br><span class="line">        add     lr, lr, #:lo12:__enable_mmu</span><br><span class="line">        ldr     x12, [x23, #CPU_INFO_SETUP]</span><br><span class="line">        add     x12, x12, x28                   // __virt_to_phys</span><br><span class="line">        br      x12                             // initialise processor</span><br><span class="line">ENDPROC(stext)</span><br></pre></td></tr></table></figure><p>由上可以看出：__enable_mmu -&gt; __mmap_switched -&gt; start_kernel，在__mmap_switched里保存了memstart_addr</p><p>ok, 所以还是要搞清楚x24的来源。</p><p>看下entry, arch&#x2F;arm64&#x2F;kernel&#x2F;head.S:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(stext)</span><br><span class="line">        mov     x21, x0                         // x21=FDT</span><br><span class="line">        bl      el2_setup                       // Drop to EL1, w20=cpu_boot_mode</span><br><span class="line">        bl      __calc_phys_offset              // x24=PHYS_OFFSET, x28=PHYS_OFFSET-PAGE_OFFSET</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Calculate the start of physical memory.</span><br><span class="line"> */</span><br><span class="line">__calc_phys_offset:</span><br><span class="line">        adr     x0, 1f                          </span><br><span class="line">        ldp     x1, x2, [x0]                    </span><br><span class="line">        sub     x28, x0, x1                     // x28 = PHYS_OFFSET - PAGE_OFFSET</span><br><span class="line">        add     x24, x2, x28                    // x24 = PHYS_OFFSET</span><br><span class="line">        ret </span><br><span class="line">ENDPROC(__calc_phys_offset)</span><br><span class="line"></span><br><span class="line">        .align 3</span><br><span class="line">1:      .quad   .   </span><br><span class="line">        .quad   PAGE_OFFSET</span><br></pre></td></tr></table></figure><p>没有看明白上面计算方法主要是因为<code>.quad .</code></p><p>先看下out下System.map， 能看出这里都是虚拟地址了。</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"> <span class="number">6</span> ffffffc000080000 T _text</span><br><span class="line"> <span class="number">7</span> ffffffc000080000 t efi_head</span><br><span class="line"> <span class="number">8</span> ffffffc000080040 t pe_header</span><br><span class="line"> <span class="number">9</span> ffffffc000080044 t coff_header</span><br><span class="line"><span class="number">10</span> ffffffc000080058 t optional_header</span><br><span class="line"><span class="number">11</span> ffffffc000080070 t extra_header_fields</span><br><span class="line"><span class="number">12</span> ffffffc0000800f8 t section_table</span><br><span class="line"><span class="number">13</span> ffffffc000081000 T stext</span><br></pre></td></tr></table></figure><p>看下BL&#x2F;LK的跳转地址log:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[2180] booting linux @ 0x80080000, ramdisk @ 0x83600000 (2209319), tags/device tree @ 0x83400000</span><br></pre></td></tr></table></figure><p>这里jump addr就是0x80080000, ddr base is 0x80000000, 偏移是0x80000从kernel&#x2F;arch&#x2F;arm64也能看出来：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The byte offset of the kernel image in RAM from the start of RAM.</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CONFIG_ARM64_RANDOMIZE_TEXT_OFFSET)</span>, y)</span><br><span class="line">TEXT_OFFSET := <span class="variable">$(<span class="built_in">shell</span> awk &#x27;BEGIN &#123;srand()</span>; printf <span class="string">&quot;0x%03x000\n&quot;</span>, int(512 * rand())&#125;&#x27;)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">TEXT_OFFSET := 0x00080000</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>加了个打印看到memstart_addr是0x80000000。</p><p>arm64 code is based on arm32, 查下git log:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 72a20e22f49e2dad3180c23980a9df1c63faab0a</span><br><span class="line">Author: Russell King &lt;rmk+kernel@arm.linux.org.uk&gt;</span><br><span class="line">Date:   Tue Jan 4 19:04:00 2011 +0000</span><br><span class="line"></span><br><span class="line">    ARM: P2V: eliminate head.S use of PHYS_OFFSET for !XIP_KERNEL</span><br><span class="line">    </span><br><span class="line">    head.S makes use of PHYS_OFFSET.  When it becomes a variable, the</span><br><span class="line">    assembler won&#x27;t understand this.  Compute PHYS_OFFSET by the following</span><br><span class="line">    method.  This code is linked at its virtual address, but run at before</span><br><span class="line">    the MMU is enabled, so at his physical address.</span><br><span class="line"></span><br><span class="line">    1:  .long   .</span><br><span class="line">        .long   PAGE_OFFSET</span><br><span class="line">    </span><br><span class="line">        adr     r0, 1b          @ r0 = physical &#x27;,&#x27;</span><br><span class="line">        ldmia   r0, &#123;r1, r2&#125;    @ r1 = virtual &#x27;.&#x27;, r2 = PAGE_OFFSET</span><br><span class="line">        sub     r1, r0, r1      @ r1 = physical-virtual</span><br><span class="line">        add     r2, r2, r1      @ r2 = PAGE_OFFSET + physical-virtual</span><br><span class="line">                                @    := PHYS_OFFSET.</span><br><span class="line">    </span><br><span class="line">    Switch XIP users of PHYS_OFFSET to use PLAT_PHYS_OFFSET - we can&#x27;t</span><br><span class="line">    use this method for XIP kernels as the code doesn&#x27;t execute in RAM.</span><br><span class="line"></span><br><span class="line">    Tested-by: Tony Lindgren &lt;tony@atomide.com&gt;</span><br><span class="line">    Reviewed-by: Nicolas Pitre &lt;nicolas.pitre@linaro.org&gt;</span><br><span class="line">    Signed-off-by: Russell King &lt;rmk+kernel@arm.linux.org.uk&gt;</span><br></pre></td></tr></table></figure><p>这个修改就是把head.S里对PHYS_OFFSET的使用改成动态计算。</p><p>看注释r0 &#x3D; physical ‘.’, r1 &#x3D; virtual ‘.’, 也就是r0是1b(backward)的物理地址，r1是1b的虚拟地址</p><p>GUN as man对<code>.long .</code>的说明：</p><blockquote><p>5.4 The Special Dot Symbol</p><p>The special symbol <code>.</code> refers to the current address that as is assembling into. Thus, the expression <code>melvin: .long .</code> defines melvin to contain its own address. Assigning a value to . is treated the same as a .org directive. Thus, the expression <code>.=.+4</code> is the same as saying <code>.space 4</code>. </p></blockquote><p>这里提到就是链接地址也就是虚拟地址，而<code>adr x0, 1b</code>, 此时的环境没有打开mmu所以此时是物理地址。回过头就能理解git的注释 - <em>This code is linked at its virtual address, but run at before the MMU is enabled, so at his physical address</em></p><p>refer:</p><p><a href="https://www.sourceware.org/binutils/docs-2.12/as.info/">https://www.sourceware.org/binutils/docs-2.12/as.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHYS_OFFSET </tag>
            
            <tag> __pa </tag>
            
            <tag> __va </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lowmemorykiller misc notes</title>
      <link href="/lowmemorykiller-misc-notes.html"/>
      <url>/lowmemorykiller-misc-notes.html</url>
      
        <content type="html"><![CDATA[<p>I’m reading code about in kernel lowmemorykiller, lets know about some concepts related.  </p><ul><li>vmpressure: monitor Linux virtual memory management pressure</li><li>kernel page reclaim: background reclaim&#x2F;indrect reclaim&#x2F;kswapd and direct reclaim</li><li>kswapd: when free pages low at water page_low, it’s wakeup</li><li>direct relaim: when alloc memory and no free memory, the thread will reclaim direcly, need avoid because of delay</li><li>page thrashing: from net:too many page fault is called thrashing. CPU spend most of the time in page fault related activity than the useful work, it will degrade the system performance…, page fault need swaping in&#x2F;out, too many swaping in&#x2F;out is called page thrashing, u can vmstat 1 and look at swap device usage… The result is an unresponsive system and a very busy hard disk.when lmk is not killing, still has page thrashing, page thrashing will casue system performance degrade, so killing is better choice than thrashing.</li><li>swappiness: ctl the kernel aggressiveness in swapping-out pages, 0-100, 100 means swap out pages as many pages as possible</li><li>page fault: A major page fault is one that can only be satisfied by accessing the disk. A minor page fault can be satisfied by sharing pages that are already in memory.</li></ul><p>About lmk, i think the confused parameter is minfree, how to set it? we know AMS will calculate the value by resolution and so on, but as i know qcom does not use it, it use his own tuned.</p><p>AMS code path:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">framework/base/services/core/java/com/android/server/am/ProcessList.java:updateOomLevels</span><br></pre></td></tr></table></figure><p>Lets see the history adjusted by google&#x2F;qcom:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Author: Dianne Hackborn &lt;hackbod@google.com&gt;</span><br><span class="line">Date:   Thu Oct 2 17:21:27 2014 -0700</span><br><span class="line"></span><br><span class="line">    Maybe fix issue #17449495: Nakasi is pretty laggy/slow to do anything</span><br><span class="line">    </span><br><span class="line">    Tweak the oom tuning to raise everything by 50%.  This is the same</span><br><span class="line">    increase we did for Volantis; I am thinking that most of the issue</span><br><span class="line">    there was not it being 64 bit, but it being tighter on RAM.  From</span><br><span class="line">    my testing, it looks like in user switching there was some paging</span><br><span class="line">    going on with Nakasi, and with this change things seem to be better.</span><br><span class="line">    </span><br><span class="line">    We should probably revisit this for future work on RAM.  It seems</span><br><span class="line">    likely that a 64 bit device will need more RAM, so probably the value</span><br><span class="line">    I am picking here is larger than we actually need for other devices.</span><br><span class="line">    I think this is the safest change at this point though -- it leaves</span><br><span class="line">    Volantis the same, where we already had tweaked it to address paging</span><br><span class="line">    issues, raises it on Nakasi (to the same value as Volantis) where we</span><br><span class="line">    seem to have paging issues, and on our other devices also raises it</span><br><span class="line">    but those are generally not under memory pressure so this shouldn&#x27;t</span><br><span class="line">    really make a difference.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// mOomMinFreeLow</span><br><span class="line">- 8M, 12M, 16M, 24M,  28M, 32M </span><br><span class="line">+ 12M, 18M, 24M, 36M, 42M, 48M</span><br><span class="line"></span><br><span class="line">// mOomMinFreeHigh</span><br><span class="line">- 48M, 60M, 72M, 84M, 96M, 120M</span><br><span class="line">+ 72M, 90M, 108M, 126M, 144M, 180M</span><br><span class="line"></span><br><span class="line">    using existing for 32bit</span><br><span class="line"></span><br><span class="line">Author: Uday Kiran jandhyala &lt;ukiran@codeaurora.org&gt;</span><br><span class="line">Date:   Fri Nov 21 16:07:26 2014 +0530</span><br><span class="line"></span><br><span class="line">    ProcessList: Adjusting OOM Min Free values for L</span><br><span class="line">    </span><br><span class="line">    Existing boundary (both low and high) values for</span><br><span class="line">    OOM min free, are fine tuned to suit lowmemorykiller</span><br><span class="line">    behavior on L builds</span><br><span class="line"></span><br><span class="line">+ MinFreeLow32Bit</span><br><span class="line">+ 8M, 12M, 16M, 24M, 28M, 32M</span><br><span class="line"></span><br><span class="line">+ MinFreeHigh32Bit</span><br><span class="line">+ 48M, 60M, 72M, 84M, 96M 120M</span><br><span class="line"></span><br><span class="line">    more aggressive for 32bit</span><br><span class="line"></span><br><span class="line">Author: Trishool Narayanasetty &lt;tnarayan@codeaurora.org&gt;</span><br><span class="line">Date:   Thu Mar 19 20:56:10 2015 +0530</span><br><span class="line"></span><br><span class="line">    frameworks/base: Make minfree values aggressive for 32bit devices</span><br><span class="line">    </span><br><span class="line">    This change makes lowmemorykiller minfree values aggresive for 32bit</span><br><span class="line">    devices. So that processes get killed earlier and system can reclaim</span><br><span class="line">    memory earlier without hitting direct reclaim/background reclaim path</span><br><span class="line">    frequently.</span><br><span class="line"></span><br><span class="line">+ MinFreeLow32Bit</span><br><span class="line">+ 12M, 18M, 24M, 36M, 42M, 48M</span><br><span class="line"></span><br><span class="line">+ MinFreeHigh32Bit</span><br><span class="line">+ 72M, 90M, 108, 126, 172.x 221.x  </span><br><span class="line"></span><br><span class="line">    tune optimal 32bit</span><br><span class="line"></span><br><span class="line">Author: Trishool Narayanasetty &lt;tnarayan@codeaurora.org&gt;</span><br><span class="line">Date:   Mon Apr 13 15:58:13 2015 +0530</span><br><span class="line"></span><br><span class="line">    frameworks/base: Make minfree values optimal for 32bit devices</span><br><span class="line">    </span><br><span class="line">    This change makes lowmemorykiller minfree values optimal for 32bit</span><br><span class="line">    devices. Arrived at these values after evaluating UX and launch</span><br><span class="line">    latencies.</span><br><span class="line"></span><br><span class="line"> MinFreeHigh32Bit</span><br><span class="line">- 72M, 90M, 108, 126, 172.x 221.x  </span><br><span class="line">+ 60M, 75M, 90M, 105M, 134.x 170.x</span><br><span class="line"></span><br><span class="line">for 7.0 google no 32bits</span><br><span class="line"></span><br><span class="line">Tweak the tuning of low RAM devices to consider 480x800 as</span><br><span class="line">the base line resolution.  That is our target these days.</span><br><span class="line"></span><br><span class="line">-        int minSize = 320*480;  //  153600</span><br><span class="line">+        int minSize = 480*800;  //  38400</span><br></pre></td></tr></table></figure><p>ok, i think you got the rabbit.</p><p>And lets see below description about minfree:</p><blockquote><p>Now, these minfree values are not typical on most devices these days as manufacturers love to tweak these to their liking depending on how they feel it best suits their device.<br>But what you should take away from this brief explanation is that the more free memory you have, the less likely you’ll see critical processes being killed off.<br>The main difference between a device with 2GB of RAM versus a device with 3GB of RAM is that the device with 3GB of RAM should be able to cache more processes in the background without triggering the LMK driver to kill it off.</p></blockquote><p>at last lets see some call stack about lmk on QCOM_N:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[  373.858334] CPU: 2 PID: 5687 Comm: CAM_startstats Tainted: G        W      3.18.31-perf-g5e6acc4-00672-g606f204-dirty #31</span><br><span class="line">[  373.858363] [&lt;c010cd84&gt;] (unwind_backtrace) from [&lt;c01099f4&gt;] (show_stack+0x10/0x14)</span><br><span class="line">[  373.858376] [&lt;c01099f4&gt;] (show_stack) from [&lt;c0baf53c&gt;] (dump_stack+0x78/0x98)</span><br><span class="line">[  373.858389] [&lt;c0baf53c&gt;] (dump_stack) from [&lt;c082a824&gt;] (lowmem_scan+0x408/0x7e0)</span><br><span class="line">[  373.858401] [&lt;c082a824&gt;] (lowmem_scan) from [&lt;c01e0ba4&gt;] (shrink_slab_node+0x204/0x3d0)</span><br><span class="line">[  373.858410] [&lt;c01e0ba4&gt;] (shrink_slab_node) from [&lt;c01e12b8&gt;] (shrink_slab+0x70/0xe4)</span><br><span class="line">[  373.858418] [&lt;c01e12b8&gt;] (shrink_slab) from [&lt;c01e3ba8&gt;] (try_to_free_pages+0x3c0/0x74c)</span><br><span class="line">[  373.858428] [&lt;c01e3ba8&gt;] (try_to_free_pages) from [&lt;c01d9188&gt;] (__alloc_pages_nodemask+0x578/0x92c)</span><br><span class="line">[  373.858440] [&lt;c01d9188&gt;] (__alloc_pages_nodemask) from [&lt;c01f8f78&gt;] (handle_mm_fault+0x29c/0x904)</span><br><span class="line">[  373.858451] [&lt;c01f8f78&gt;] (handle_mm_fault) from [&lt;c0114590&gt;] (do_page_fault+0x118/0x378)</span><br><span class="line">[  373.858460] [&lt;c0114590&gt;] (do_page_fault) from [&lt;c010030c&gt;] (do_DataAbort+0x34/0x164)</span><br><span class="line">[  373.858468] [&lt;c010030c&gt;] (do_DataAbort) from [&lt;c010a6fc&gt;] (__dabt_usr+0x3c/0x40)</span><br><span class="line">[  373.858474] Exception stack(0xec275fb0 to 0xec275ff8)</span><br><span class="line">[  373.858481] 5fa0:                                     48227212 9eb00e00 a5d2287d 48227212</span><br><span class="line">[  373.858489] 5fc0: 9eadc370 9e27f000 a2afce40 00000000 a5d79864 9eb00e00 a2afa780 a2ad8d80</span><br><span class="line">[  373.858497] 5fe0: a5d79b74 9eadc328 a5d5ed77 a5d2289e a0010030 ffffffff</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  374.035992] CPU: 2 PID: 120 Comm: kswapd0 Tainted: G        W      3.18.31-perf-g5e6acc4-00672-g606f204-dirty #31</span><br><span class="line">[  374.036018] [&lt;c010cd84&gt;] (unwind_backtrace) from [&lt;c01099f4&gt;] (show_stack+0x10/0x14)</span><br><span class="line">[  374.036031] [&lt;c01099f4&gt;] (show_stack) from [&lt;c0baf53c&gt;] (dump_stack+0x78/0x98)</span><br><span class="line">[  374.036044] [&lt;c0baf53c&gt;] (dump_stack) from [&lt;c082a824&gt;] (lowmem_scan+0x408/0x7e0)</span><br><span class="line">[  374.036056] [&lt;c082a824&gt;] (lowmem_scan) from [&lt;c01e0ba4&gt;] (shrink_slab_node+0x204/0x3d0)</span><br><span class="line">[  374.036066] [&lt;c01e0ba4&gt;] (shrink_slab_node) from [&lt;c01e12b8&gt;] (shrink_slab+0x70/0xe4)</span><br><span class="line">[  374.036074] [&lt;c01e12b8&gt;] (shrink_slab) from [&lt;c01e46f4&gt;] (kswapd+0x7c0/0x9f8)</span><br><span class="line">[  374.036083] [&lt;c01e46f4&gt;] (kswapd) from [&lt;c013b9b4&gt;] (kthread+0xdc/0xf0)</span><br><span class="line">[  374.036094] [&lt;c013b9b4&gt;] (kthread) from [&lt;c0105f80&gt;] (ret_from_fork+0x14/0x34)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[53815.902603] CPU: 0 PID: 7242 Comm: CAM_defrdWrk Tainted: G        W      3.18.31-perf-g5e6acc4-00672-g606f204-dirty #31</span><br><span class="line">[53815.902631] [&lt;c010cd84&gt;] (unwind_backtrace) from [&lt;c01099f4&gt;] (show_stack+0x10/0x14)</span><br><span class="line">[53815.902644] [&lt;c01099f4&gt;] (show_stack) from [&lt;c0baf53c&gt;] (dump_stack+0x78/0x98)</span><br><span class="line">[53815.902658] [&lt;c0baf53c&gt;] (dump_stack) from [&lt;c082a824&gt;] (lowmem_scan+0x408/0x7e0)</span><br><span class="line">[53815.902669] [&lt;c082a824&gt;] (lowmem_scan) from [&lt;c01e0ba4&gt;] (shrink_slab_node+0x204/0x3d0)</span><br><span class="line">[53815.902678] [&lt;c01e0ba4&gt;] (shrink_slab_node) from [&lt;c01e12b8&gt;] (shrink_slab+0x70/0xe4)</span><br><span class="line">[53815.902686] [&lt;c01e12b8&gt;] (shrink_slab) from [&lt;c01e3ba8&gt;] (try_to_free_pages+0x3c0/0x74c)</span><br><span class="line">[53815.902696] [&lt;c01e3ba8&gt;] (try_to_free_pages) from [&lt;c01d9188&gt;] (__alloc_pages_nodemask+0x578/0x92c)</span><br><span class="line">[53815.902707] [&lt;c01d9188&gt;] (__alloc_pages_nodemask) from [&lt;c0819648&gt;] (ion_page_pool_alloc_pages+0x20/0x68)</span><br><span class="line">[53815.902718] [&lt;c0819648&gt;] (ion_page_pool_alloc_pages) from [&lt;c08196c8&gt;] (ion_page_pool_alloc+0x38/0x94)</span><br><span class="line">[53815.902728] [&lt;c08196c8&gt;] (ion_page_pool_alloc) from [&lt;c081a4e4&gt;] (ion_system_heap_allocate+0x158/0x564)</span><br><span class="line">[53815.902739] [&lt;c081a4e4&gt;] (ion_system_heap_allocate) from [&lt;c081750c&gt;] (__ion_alloc+0x170/0x8dc)</span><br><span class="line">[53815.902749] [&lt;c081750c&gt;] (__ion_alloc) from [&lt;c0817f40&gt;] (ion_ioctl+0x168/0x3c8)</span><br><span class="line">[53815.902759] [&lt;c0817f40&gt;] (ion_ioctl) from [&lt;c02265b0&gt;] (do_vfs_ioctl+0x4cc/0x58c)</span><br><span class="line">[53815.902768] [&lt;c02265b0&gt;] (do_vfs_ioctl) from [&lt;c02266bc&gt;] (SyS_ioctl+0x4c/0x74)</span><br><span class="line">[53815.902778] [&lt;c02266bc&gt;] (SyS_ioctl) from [&lt;c0105ee0&gt;] (ret_fast_syscall+0x0/0x38)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[53815.860035] CPU: 0 PID: 6761 Comm: kworker/u8:4 Tainted: G        W      3.18.31-perf-g5e6acc4-00672-g606f204-dirty #31</span><br><span class="line">[53815.860053] Workqueue: events_unbound swap_fn</span><br><span class="line">[53815.860071] [&lt;c010cd84&gt;] (unwind_backtrace) from [&lt;c01099f4&gt;] (show_stack+0x10/0x14)</span><br><span class="line">[53815.860083] [&lt;c01099f4&gt;] (show_stack) from [&lt;c0baf53c&gt;] (dump_stack+0x78/0x98)</span><br><span class="line">[53815.860096] [&lt;c0baf53c&gt;] (dump_stack) from [&lt;c082a824&gt;] (lowmem_scan+0x408/0x7e0)</span><br><span class="line">[53815.860107] [&lt;c082a824&gt;] (lowmem_scan) from [&lt;c01e0ba4&gt;] (shrink_slab_node+0x204/0x3d0)</span><br><span class="line">[53815.860116] [&lt;c01e0ba4&gt;] (shrink_slab_node) from [&lt;c01e12b8&gt;] (shrink_slab+0x70/0xe4)</span><br><span class="line">[53815.860124] [&lt;c01e12b8&gt;] (shrink_slab) from [&lt;c01e3ba8&gt;] (try_to_free_pages+0x3c0/0x74c)</span><br><span class="line">[53815.860134] [&lt;c01e3ba8&gt;] (try_to_free_pages) from [&lt;c01d9188&gt;] (__alloc_pages_nodemask+0x578/0x92c)</span><br><span class="line">[53815.860144] [&lt;c01d9188&gt;] (__alloc_pages_nodemask) from [&lt;c0212a5c&gt;] (zs_malloc+0xc0/0x2e0)</span><br><span class="line">[53815.860156] [&lt;c0212a5c&gt;] (zs_malloc) from [&lt;c052b0d8&gt;] (zram_bvec_rw+0x3e4/0x7fc)</span><br><span class="line">[53815.860166] [&lt;c052b0d8&gt;] (zram_bvec_rw) from [&lt;c052b644&gt;] (zram_rw_page+0x154/0x168)</span><br><span class="line">[53815.860177] [&lt;c052b644&gt;] (zram_rw_page) from [&lt;c0244f20&gt;] (bdev_write_page+0x6c/0x98)</span><br><span class="line">[53815.860188] [&lt;c0244f20&gt;] (bdev_write_page) from [&lt;c0206c38&gt;] (__swap_writepage+0x1b4/0x27c)</span><br><span class="line">[53815.860198] [&lt;c0206c38&gt;] (__swap_writepage) from [&lt;c01e203c&gt;] (shrink_page_list+0x57c/0x9b0)</span><br><span class="line">[53815.860207] [&lt;c01e203c&gt;] (shrink_page_list) from [&lt;c01e2658&gt;] (reclaim_pages_from_list+0xa8/0x108)</span><br><span class="line">[53815.860217] [&lt;c01e2658&gt;] (reclaim_pages_from_list) from [&lt;c0263968&gt;] (reclaim_pte_range+0x11c/0x184)</span><br><span class="line">[53815.860228] [&lt;c0263968&gt;] (reclaim_pte_range) from [&lt;c0203ce8&gt;] (walk_page_range+0x1b8/0x248)</span><br><span class="line">[53815.860238] [&lt;c0203ce8&gt;] (walk_page_range) from [&lt;c026462c&gt;] (reclaim_task_anon+0xb4/0x11c)</span><br><span class="line">[53815.860248] [&lt;c026462c&gt;] (reclaim_task_anon) from [&lt;c0214524&gt;] (swap_fn+0x248/0x4ec)</span><br><span class="line">[53815.860258] [&lt;c0214524&gt;] (swap_fn) from [&lt;c0137434&gt;] (process_one_work+0x254/0x464)</span><br><span class="line">[53815.860267] [&lt;c0137434&gt;] (process_one_work) from [&lt;c013816c&gt;] (worker_thread+0x2b4/0x3f8)</span><br><span class="line">[53815.860277] [&lt;c013816c&gt;] (worker_thread) from [&lt;c013b9b4&gt;] (kthread+0xdc/0xf0)</span><br><span class="line">[53815.860287] [&lt;c013b9b4&gt;] (kthread) from [&lt;c0105f80&gt;] (ret_from_fork+0x14/0x34)</span><br></pre></td></tr></table></figure><p>Over.</p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LMK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android UX性能测试</title>
      <link href="/android-ux-perf-test.html"/>
      <url>/android-ux-perf-test.html</url>
      
        <content type="html"><![CDATA[<p>目标就是找到一种简单的量化测试方法</p><h2 id="apk启动时间测量"><a href="#apk启动时间测量" class="headerlink" title="apk启动时间测量"></a>apk启动时间测量</h2><h3 id="方法一：利用am-start"><a href="#方法一：利用am-start" class="headerlink" title="方法一：利用am start"></a>方法一：利用am start</h3><p>一般看TotalTime，多取几次算平均。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// adb shell am start -w packagename/MainActivity</span><br><span class="line">xxx:/ # am start -W com.android.settings/com.android.settings.Settings</span><br><span class="line">Starting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.android.settings/.Settings &#125;</span><br><span class="line">Status: ok</span><br><span class="line">Activity: com.android.settings/.Settings</span><br><span class="line">ThisTime: 154</span><br><span class="line">TotalTime: 154</span><br><span class="line">WaitTime: 164</span><br></pre></td></tr></table></figure><h3 id="方法二：利用自带screenrecord录屏功能"><a href="#方法二：利用自带screenrecord录屏功能" class="headerlink" title="方法二：利用自带screenrecord录屏功能"></a>方法二：利用自带screenrecord录屏功能</h3><ol><li>CMD窗口运行如下命令：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xxxx:/sdcard # screenrecord  --bugreport launch.mp4</span><br></pre></td></tr></table></figure><ol start="2"><li>点击APP启动(冷启or热启)完成后ctrl-c取消录制</li><li>导出视频到PC上，用带按帧播放功能的player播放，一般用QuickTime专业版。</li><li>QuickTime打开mp4</li><li>用键盘右键按帧找到APP icon高亮开始，如下图</li><li>同样方法接着找到整个APP UI的第一帧</li><li>计算启动耗时</li></ol><h2 id="Scroll-FPS-Measurement"><a href="#Scroll-FPS-Measurement" class="headerlink" title="Scroll FPS Measurement"></a>Scroll FPS Measurement</h2><h3 id="方法一：dumpsys-SurfaceFlinger"><a href="#方法一：dumpsys-SurfaceFlinger" class="headerlink" title="方法一：dumpsys SurfaceFlinger"></a>方法一：dumpsys SurfaceFlinger</h3><ol><li>打开要测试的APP运行下面命令查看可用window name (比如photo)</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xxx:/ # dumpsys SurfaceFlinger --list</span><br><span class="line">  com.android.systemui.ImageWallpaper</span><br><span class="line">  animation background stackId=1</span><br><span class="line">  com.google.android.apps.photos/com.google.android.apps.photos.home.HomeActivity</span><br><span class="line">  DimLayerController/Stack=0</span><br><span class="line">  StatusBar</span><br></pre></td></tr></table></figure><ol start="2"><li>清空之前的历史记录</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xxx:/ # dumpsys SurfaceFlinger ----latency-clear</span><br></pre></td></tr></table></figure><ol start="3"><li>在phono界面滑动多次后运行下面命令获取127帧数据</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xxx:/ # dumpsys SurfaceFlinger --latency        com.google.android.apps.photos/com.google.android.apps.photos.home.HomeActivity</span><br><span class="line">16666666</span><br><span class="line">0       0       0</span><br><span class="line">. ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="4"><li>计算FPS</li></ol><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">time = (最后一行，第二列) - (第一行，第二列) //unit:ns</span><br><span class="line">fps = 126000000000/time</span><br></pre></td></tr></table></figure><ol start="5"><li>清空循环多次，计算平均值。</li></ol><h3 id="方法二：dumpsys-gfxinfo"><a href="#方法二：dumpsys-gfxinfo" class="headerlink" title="方法二：dumpsys gfxinfo"></a>方法二：dumpsys gfxinfo</h3><ol><li>Setting-&gt;Developer options-&gt;Profile GPU rendering下选择dumpsys gfxinfo </li><li>回到APP界面先运行多次下面命令，确保Profile data in ms为空</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dumpsys gfxinfo com.google.android.apps.photos</span><br><span class="line"> ...</span><br><span class="line"> Profile data in ms:</span><br><span class="line">         com.google.android.apps.photos/com</span><br><span class="line">         Draw    Prepare Process Execute</span><br><span class="line"> View hierarchy:</span><br></pre></td></tr></table></figure><ol start="3"><li>在APP界面滑动多次后再次运行上面命令获取simple frame timing数据</li></ol><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Draw    Prepare Process Execute</span><br><span class="line">4.06    0.23    0.83    2.02</span><br><span class="line">1.60    0.22    0.93    1.99</span><br><span class="line">1.39    0.18    0.80    2.08</span><br><span class="line">1.41    0.19    0.84    2.06</span><br><span class="line">1.45    0.35    0.90    1.79</span><br><span class="line">1.46    0.34    0.89    1.67</span><br><span class="line">5.81    0.23    0.77    1.91</span><br><span class="line">1.25    0.18    0.95    1.46</span><br><span class="line">1.34    0.19    0.96    1.63</span><br><span class="line">1.41    0.23    0.74    1.63</span><br><span class="line">1.25    0.15    0.67    1.27</span><br><span class="line">1.21    0.15    0.67    1.28</span><br><span class="line">1.24    0.16    0.73    1.29</span><br><span class="line">1.23    0.15    0.69    1.28</span><br><span class="line">1.19    0.15    0.65    1.29</span><br><span class="line">1.02    0.16    0.72    1.31</span><br></pre></td></tr></table></figure><p>拷贝到excel表格里看效果图</p><p>最直接应该就是打到屏幕上看。 </p><p>参考文档</p><ul><li><a href="https://developer.android.com/training/testing/performance.html">https://developer.android.com/training/testing/performance.html</a></li><li><a href="https://developer.android.com/studio/profile/dev-options-rendering.html">https://developer.android.com/studio/profile/dev-options-rendering.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> perf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPS </tag>
            
            <tag> Launch Time </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Get Weather Forecasts on Raspberry Pi</title>
      <link href="/get-weather-forecasts-on-rpi.html"/>
      <url>/get-weather-forecasts-on-rpi.html</url>
      
        <content type="html"><![CDATA[<ul><li>take a picture</li></ul><p><img src="http://tjtech.me/usr/uploads/2017/05/10255474.jpg" alt="pi_weather.jpg"></p><ul><li>No module named pywapi</li></ul><p>download address: <a href="https://github.com/kapt/pywapi">https://github.com/kapt/pywapi</a></p><ul><li>No module named psutil</li></ul><p>download address: <a href="https://github.com/packages/psutil">https://github.com/packages/psutil</a></p><ul><li>No file named Python.h</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setup install has error: Python.h: No such file or directory</span><br></pre></td></tr></table></figure><p>need install python-dev</p><ul><li>no module bs4</li></ul><p>download from <a href="https://pypi.python.org/pypi/beautifulsoup4">https://pypi.python.org/pypi/beautifulsoup4</a></p><ul><li>sudo modprobe w1-gpio</li></ul><p>DS18B20 sensor</p><ul><li>lcd</li></ul><p><a href="http://www.waveshare.net/wiki/5inch-HDMI-LCD-B-IMG-REV1.1">http://www.waveshare.net/wiki/5inch-HDMI-LCD-B-IMG-REV1.1</a></p><ul><li>can not shutdown via ssh</li></ul><p>kill the app then shudown is working.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@rpi2b:~ $ cat /home/pi/Tools/kill-weather.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">pid=$(pidof python)</span><br><span class="line">sudo kill -9 $pid</span><br></pre></td></tr></table></figure><ul><li>power on&amp;off automaticly</li></ul><p>smart plug + crontab </p><ul><li>original</li></ul><p><a href="http://www.instructables.com/id/Raspberry-Pi-Internet-Weather-Station/">http://www.instructables.com/id/Raspberry-Pi-Internet-Weather-Station/</a></p>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pywapi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARMv7多核中断调试</title>
      <link href="/arm-gic-debug.html"/>
      <url>/arm-gic-debug.html</url>
      
        <content type="html"><![CDATA[<p>之前调了在Bootloader下bring up secondary cpu， arch是armv7， gic v2,记录下。</p><h2 id="Hardware-logic"><a href="#Hardware-logic" class="headerlink" title="Hardware logic"></a>Hardware logic</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+----------+       +------------+        +-------------+        +------------+       +----+</span><br><span class="line">|soc timer |--1--&gt; |soc int ctrl| --2---&gt;|arm gic dist | -|-3a-&gt;|arm gic cpu0| -4a-&gt; |cpu0|</span><br><span class="line">+----------+       +------------+        +-------------+  |     +------------+       +----+</span><br><span class="line">                                                          |</span><br><span class="line">                                                          |     +------------+       +----+</span><br><span class="line">                                                          |-3b-&gt;|arm gic cpu1| -4b-&gt; |cpu1|</span><br><span class="line">                                                                +------------+       +----+</span><br></pre></td></tr></table></figure><p>首先外设timer中断上报中断控制器，这个timer和中断控制器应该是SoC自己的东东， 各自都应该有个中断状态可以看到中断是不是已经产生了。</p><p>下来就是ARM的gic，我调的是v2， 一般都有id寄存器可以确认gic版本。gic分成gic dist和gic cpu interface，dist就是负责forwarding转发中断到cpu interface上， 如上图转发中断到gic cpu0 or gic cpu1 or both，都可以控制。</p><p>而gic cpu interface就是负责把中断上报给cpu core里，cpu core里都有各自的arch local interrupt，使能就可以看到了。</p><p>整个过程需要确认状态调试。</p><h2 id="GIC-Debug"><a href="#GIC-Debug" class="headerlink" title="GIC Debug"></a>GIC Debug</h2><p>gic这块的初始化配置主要分为dist和cpu两块。</p><p>dist是全局的，一般放到cpu0上先初始化一下就可以了， gic cpu因为是per cpu， 所以在每个cpu上都要配置一下。</p><p>gic的中断分为两块，0-31个中断是per cpu，32-max是全局中断， 一般对于SoC来说， 需要自定义也就是分配中断号，都是从32号开始，所以看kernel代码会有个base是32。</p><p>对于dist把中断转发给那个cpu interface，有个寄存器可以配， 就是每个中断你要分配给哪个或哪些cpu了，比如gicv2里max cpu是8个，那就需要用8个bit来表示8个cpu，分别是cpu0-cpu7， 要想把某个中断分给cpu0，那就是0x1， 要分给cpu1就是0x2，分给cpu0也分给cpu1，那就是0x3了。</p><p>对于gic是否有中断上来， 有个寄存器可以查看这个状态，就是中断响应寄存器(GICC_IAR，应该是这个名字)，也就是中断服务处理里获取中断号的寄存器。如果这个一直是1023，那么你就要查查状态了。手册里面有写，基本上就是有没有使能gic中断之类，即使code使能了， 也要打印出来确认！</p><p>在没有装stack和vector之前，可以先disable cpu core的local interrupt，这样你在cpu上应该能看到GICC_IAR的中断号，只有看到了，才说明gic的调试过了，否则继续debug。soc timer int状态确认， soc int contr interrupt status确认，gic dist中断使能确认，target cpu转发确认…</p><h2 id="exception-vector-table"><a href="#exception-vector-table" class="headerlink" title="exception vector table"></a>exception vector table</h2><p>上面调试过了，下面就要来调试cpu1的向量表安装了，注意这个时候mmu cache的都是禁用的。</p><p>说到向量表， 必须要提到它的位置，一般有两种，低地址和高地址之分。例如cortex a7有个重要的配置就是系统控制寄存器,它有个bit13就是来控制这个向量表在低还是在高。</p><p>我的问题是打开cpu1的local interrupt enable后就死了。这个时候的调试，mmu关闭，cache关闭，除了svc stack其他模式 stack没有安装，cpu0的处理也关闭了， 最好禁用cpu0的local资源，比如local arch irq最好了。cpu1尽量保持和cpu0的start up code一致， 其实cpu1启动时刚开始执行的就是一个svc stack安装，下来就是vector安装。</p><p>这时到底是死在哪里了，唯一怀疑就是向量表没响应导致的死机，仔细看了看arm arch手册，cortex rpm手册啊，arm develop手册，最后看到了向量表位置可以控制，就是前面提到的，赶紧打开看看，发现cpu0和cpu1的sys ctrl果然不同，一看bit13 cpu0是0，而cpu1是1， 这不就是了嘛， 改成0后刚才在中断处理加的汇编打印果然有了：] cpu1 stack和cpu0一样就可以了，</p>]]></content>
      
      
      <categories>
          
          <category> arm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM Linux高端内存分析(下)</title>
      <link href="/analyze-linux-high-memory-bh.html"/>
      <url>/analyze-linux-high-memory-bh.html</url>
      
        <content type="html"><![CDATA[<p>上半部分分析了kmap_atomic里的low memory page地址的获取，那如何获取high memory page的virtual address呢。</p><h2 id="kmap-atomic分析"><a href="#kmap-atomic分析" class="headerlink" title="kmap_atomic分析"></a>kmap_atomic分析</h2><p>入口就是<code>pagefault_disable</code>，查看定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These routines enable/disable the pagefault handler in that</span></span><br><span class="line"><span class="comment"> * it will not take any locks and go straight to the fixup table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * They have great resemblance to the preempt_disable/enable calls</span></span><br><span class="line"><span class="comment"> * and in fact they are identical; this is because currently there is</span></span><br><span class="line"><span class="comment"> * no other way to make the pagefault handlers do this. So we do</span></span><br><span class="line"><span class="comment"> * disable preemption but we don&#x27;t necessarily care about that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">pagefault_disable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        preempt_count_inc();</span><br><span class="line">        <span class="comment">/*  </span></span><br><span class="line"><span class="comment">         * make sure to have issued the store before a pagefault</span></span><br><span class="line"><span class="comment">         * can hit.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        barrier();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来也就是禁止抢占了,应该和后面用到smp_processor_id有关，是否对kmap_high_get有必要？接着看：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kmap = kmap_high_get(page);</span><br><span class="line"><span class="keyword">if</span> (kmap)</span><br><span class="line"><span class="keyword">return</span> kmap;</span><br></pre></td></tr></table></figure><p>kmap_high_get和架构特性有关：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ARCH_NEEDS_KMAP_HIGH_GET</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">kmap_high_get</span><span class="params">(<span class="keyword">struct</span> page *page)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">kmap_high_get</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>先看看支持的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmap_high_get</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vaddr, flags;</span><br><span class="line"></span><br><span class="line">lock_kmap_any(flags);</span><br><span class="line">vaddr = (<span class="type">unsigned</span> <span class="type">long</span>)page_address(page);</span><br><span class="line"><span class="keyword">if</span> (vaddr) &#123;</span><br><span class="line">BUG_ON(pkmap_count[PKMAP_NR(vaddr)] &lt; <span class="number">1</span>);</span><br><span class="line">pkmap_count[PKMAP_NR(vaddr)]++;</span><br><span class="line">&#125;</span><br><span class="line">unlock_kmap_any(flags);</span><br><span class="line"><span class="keyword">return</span> (<span class="type">void</span>*) vaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里这样注释：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The reason for kmap_high_get() is to ensure that the currently kmap&#x27;d</span></span><br><span class="line"><span class="comment"> * page usage count does not decrease to zero while we&#x27;re using its</span></span><br><span class="line"><span class="comment"> * existing virtual mapping in an atomic context. </span></span><br></pre></td></tr></table></figure><p>lock应该是保护pkmap_count，BUG_ON就是确保原子操作的count不会为0。</p><p>如何获取high memory page地址：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * page_address - get the mapped virtual address of a page</span></span><br><span class="line"><span class="comment"> * @page: &amp;struct page to get the virtual address of</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the page&#x27;s virtual address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">page_address</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="type">void</span> *ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_address_slot</span> *<span class="title">pas</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!PageHighMem(page))</span><br><span class="line"><span class="keyword">return</span> lowmem_page_address(page);</span><br><span class="line"></span><br><span class="line">pas = page_slot(page);</span><br><span class="line">ret = <span class="literal">NULL</span>;</span><br><span class="line">spin_lock_irqsave(&amp;pas-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;pas-&gt;lh)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_address_map</span> *<span class="title">pam</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each_entry(pam, &amp;pas-&gt;lh, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (pam-&gt;page == page) &#123;</span><br><span class="line">ret = pam-&gt;virtual;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">done:</span><br><span class="line">spin_unlock_irqrestore(&amp;pas-&gt;lock, flags);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码看是在遍历某个链表，涉及到两个结构体：<code>page_address_map</code>和<code>page_address_slot</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(HASHED_PAGE_VIRTUAL)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA_HASH_ORDER7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Describes one page-&gt;virtual association</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_address_map</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">void</span> *virtual;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page_address_map</span> <span class="title">page_address_maps</span>[<span class="title">LAST_PKMAP</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Hash table bucket</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page_address_slot</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lh</span>;</span><span class="comment">/* List of page_address_maps */</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;<span class="comment">/* Protect this bucket&#x27;s list */</span></span><br><span class="line">&#125; ____cacheline_aligned_in_smp page_address_htable[<span class="number">1</span>&lt;&lt;PA_HASH_ORDER];</span><br></pre></td></tr></table></figure><p>高端内存用page_address_map里的virtual保存page的虚拟地址，用page_address_slot的lh list来管理这些highmem pages。也就是先找到slot，再找到slot里的page，整个过程通过hash table完成。这点从set_page_address也能看出来：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set_page_address - set a page&#x27;s virtual address</span></span><br><span class="line"><span class="comment"> * @page: &amp;struct page to set</span></span><br><span class="line"><span class="comment"> * @virtual: virtual address to use</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_page_address</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">void</span> *virtual)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_address_slot</span> *<span class="title">pas</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_address_map</span> *<span class="title">pam</span>;</span></span><br><span class="line"></span><br><span class="line">BUG_ON(!PageHighMem(page));</span><br><span class="line"></span><br><span class="line">pas = page_slot(page); <span class="comment">//先定下slot</span></span><br><span class="line"><span class="keyword">if</span> (virtual) &#123;<span class="comment">/* Add */</span></span><br><span class="line">pam = &amp;page_address_maps[PKMAP_NR((<span class="type">unsigned</span> <span class="type">long</span>)virtual)];</span><br><span class="line">pam-&gt;page = page;</span><br><span class="line">pam-&gt;virtual = virtual;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;pas-&gt;lock, flags);</span><br><span class="line">list_add_tail(&amp;pam-&gt;<span class="built_in">list</span>, &amp;pas-&gt;lh); <span class="comment">//把该page增加到slot里</span></span><br></pre></td></tr></table></figure><p>那如果不支持ARCH_NEEDS_KMAP_HIGH_GET特性：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmap_atomic</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// 以下不支持ARCH_NEEDS_KMAP_HIGH_GET处理</span></span><br><span class="line">type = kmap_atomic_idx_push();</span><br><span class="line"></span><br><span class="line">idx = FIX_KMAP_BEGIN + type + KM_TYPE_NR * smp_processor_id();</span><br><span class="line">vaddr = __fix_to_virt(idx);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_HIGHMEM</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * With debugging enabled, kunmap_atomic forces that entry to 0.</span></span><br><span class="line"><span class="comment"> * Make sure it was indeed properly unmapped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BUG_ON(!pte_none(get_fixmap_pte(vaddr)));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When debugging is off, kunmap_atomic leaves the previous mapping</span></span><br><span class="line"><span class="comment"> * in place, so the contained TLB flush ensures the TLB is updated</span></span><br><span class="line"><span class="comment"> * with the new mapping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_fixmap_pte(idx, mk_pte(page, kmap_prot));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="type">void</span> *)vaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是SMP架构内存共享，kmap_high_get用了lock的方式防止临界访问，这里用的方法:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type = kmap_atomic_idx_push(); <span class="comment">//每映射一次，idx++</span></span><br><span class="line">idx = FIX_KMAP_BEGIN + type + KM_TYPE_NR * smp_processor_id();</span><br></pre></td></tr></table></figure><p>我理解如下图：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cpu0 ----+-----------+-------&gt; FIX_KMAP_BEGIN</span><br><span class="line">         |           |</span><br><span class="line">         | highmem0  +-------&gt; type0 ---- pageN</span><br><span class="line">         |           |           |    </span><br><span class="line">cpu1 ----+-----------+           +---&gt; KM_TYPE_NR * smp_processor_id() </span><br><span class="line">         |           |           |</span><br><span class="line">         | highmem1  +-------&gt; type1 ---- pageN</span><br><span class="line">         |           |</span><br><span class="line">         +-----------+</span><br><span class="line">           ...</span><br></pre></td></tr></table></figure><p>也就是每个cpu有自己的kmap映射空间。FIX_KMAP_BEGIN在arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;fixmap.h里：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIXADDR_START           0xffc00000UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIXADDR_END             0xfff00000UL</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">fixed_addresses</span> &#123;</span></span><br><span class="line">        FIX_EARLYCON_MEM_BASE,</span><br><span class="line">        FIX_SMP_MEM_BASE,</span><br><span class="line">        __end_of_permanent_fixed_addresses,</span><br><span class="line">        FIX_BTMAP_END = __end_of_permanent_fixed_addresses,</span><br><span class="line">        FIX_BTMAP_BEGIN = FIX_BTMAP_END + TOTAL_FIX_BTMAPS - <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">        FIX_KMAP_BEGIN = __end_of_permanent_fixed_addresses,</span><br><span class="line">        FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_TYPE_NR * NR_CPUS) - <span class="number">1</span>,</span><br><span class="line">        <span class="comment">/* Support writing RO kernel text via kprobes, jump labels, etc. */</span></span><br><span class="line">        FIX_TEXT_POKE0,</span><br><span class="line">        FIX_TEXT_POKE1,</span><br><span class="line"></span><br><span class="line">        __end_of_fixed_addresses = (FIXADDR_END - FIXADDR_START) &gt;&gt; PAGE_SHIFT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从定义来看，</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">       FIX_KMAP_BEGIN</span><br><span class="line">          |</span><br><span class="line">permanent |  KM_TYPE_NR * NR_CPUS  |</span><br><span class="line">                                   |</span><br><span class="line">                            FIX_KMAP_END</span><br></pre></td></tr></table></figure><p>用__fix_to_virt(idx)得到虚拟地址：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIXADDR_END0xfff00000UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIXADDR_TOP(FIXADDR_END - PAGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __fix_to_virt(x)        (FIXADDR_TOP - ((x) &lt;&lt; PAGE_SHIFT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __virt_to_fix(x)        ((FIXADDR_TOP - ((x)&amp;PAGE_MASK)) &gt;&gt; PAGE_SHIFT)</span></span><br></pre></td></tr></table></figure><p>最后把page和idx建立对应关系，用set_fixmap_pte实现。</p><h2 id="kunmap-atomic分析"><a href="#kunmap-atomic分析" class="headerlink" title="kunmap_atomic分析"></a>kunmap_atomic分析</h2><p>kunmap相对kmap简单许多，代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __kunmap_atomic(<span class="type">void</span> *kvaddr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (kvaddr &gt;= (<span class="type">void</span> *)FIXADDR_START) &#123;</span><br><span class="line">type = kmap_atomic_idx();</span><br><span class="line">idx = FIX_KMAP_BEGIN + type + KM_TYPE_NR * smp_processor_id();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cache_is_vivt())</span><br><span class="line">__cpuc_flush_dcache_area((<span class="type">void</span> *)vaddr, PAGE_SIZE);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_HIGHMEM</span></span><br><span class="line">BUG_ON(vaddr != __fix_to_virt(idx));</span><br><span class="line">set_fixmap_pte(idx, __pte(<span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">(<span class="type">void</span>) idx;  <span class="comment">/* to kill a warning */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">kmap_atomic_idx_pop(); <span class="comment">//idx--</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (vaddr &gt;= PKMAP_ADDR(<span class="number">0</span>) &amp;&amp; vaddr &lt; PKMAP_ADDR(LAST_PKMAP)) &#123;</span><br><span class="line"><span class="comment">/* this address was obtained through kmap_high_get() */</span></span><br><span class="line">kunmap_high(pte_page(pkmap_page_table[PKMAP_NR(vaddr)]));</span><br><span class="line">&#125;</span><br><span class="line">pagefault_enable(); <span class="comment">//放开抢占，对应kmap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是看下分支条件, 涉及到FIXADDR_START， PKMAP_ADDR(0)，PKMAP_ADDR(LAST_PKMAP)。</p><p>kmap_atomic的地址获取通过kmap_high_get or kmap_atomic_idx_push, 用kmap_atomic_idx_push时是在FIXADDR范围内。</p><p>kmap_atomic里的kmap_high_get是通过page_address_htable获取地址的，pkmap_page_table是用在kmap_high里的啊，rt?</p><p>完。 </p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux Kernel </tag>
            
            <tag> High Memory </tag>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM Linux高端内存分析(上)</title>
      <link href="/analyze-linux-high-memory-th.html"/>
      <url>/analyze-linux-high-memory-th.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>What is high memory </li><li>kmap_atomic</li><li>kunmap_atomic</li></ul><h2 id="What-is-high-memory"><a href="#What-is-high-memory" class="headerlink" title="What is high memory"></a>What is high memory</h2><p>先看下内核文档kernel3.18 vm&#x2F;highmem.txt的说明：</p><blockquote><p>High memory (highmem) is used when the size of physical memory approaches or<br>exceeds the maximum size of virtual memory.  At that point it becomes<br>impossible for the kernel to keep all of the available physical memory mapped<br>at all times.  This means the kernel needs to start using temporary mappings of<br>the pieces of physical memory that it wants to access.</p><p>The part of (physical) memory not covered by a permanent mapping is what we<br>refer to as ‘highmem’.  There are various architecture dependent constraints on<br>where exactly that border lies.</p><p>The traditional split for architectures using this approach is 3:1, 3GiB for<br>userspace and the top 1GiB for kernel space:</p><pre><code>           +--------+ 0xffffffff           | Kernel |           +--------+ 0xc0000000           |        |              | User   |              |        |           +--------+ 0x00000000</code></pre><p>This means that the kernel can at most map 1GiB of physical memory at any one<br>time, but because we need virtual address space for other things - including<br>temporary maps to access the rest of the physical memory - the actual direct<br>map will typically be less (usually around ~896MiB).</p></blockquote><p>在32bit系统里，一般内核可以访问的空间大小是1G，如果物理内存大小也是1G，不可能全部映射，因为内核空间还要访问其他比如外设register，所以没有被永久映射的那一块物理内存就叫高端内存，大小和架构有关。</p><p>如果物理内存大于1G，那最多永久映射1G，剩下的部分也就是高端内存了。permanent mapping的内存也叫low memory。通过temporary mapping(kmap_atomic for smp)访问高端内存。</p><p>64bits系统里内核空间很大，就没有high memory的概念了。</p><h2 id="kmap-atomic分析"><a href="#kmap-atomic分析" class="headerlink" title="kmap_atomic分析"></a>kmap_atomic分析</h2><p>kmap已经不推荐用了，内核主要用kmap_atomic来创建temporary mapping。文档说明：</p><blockquote><p>(*) kmap().  This permits a short duration mapping of a single page.  It needs<br>     global synchronization, but is amortized somewhat.  It is also prone to<br>     deadlocks when using in a nested fashion, and so it is not recommended for<br>     new code.</p><p>(*) kmap_atomic().  This permits a very short duration mapping of a single<br>     page.  Since the mapping is restricted to the CPU that issued it, it<br>     performs well, but the issuing task is therefore required to stay on that<br>     CPU until it has finished, lest some other task displace its mappings.</p><p>   kmap_atomic() may also be used by interrupt contexts, since it is does not<br>     sleep and the caller may not sleep until after kunmap_atomic() is called.</p><p>   It may be assumed that k[un]map_atomic() won’t fail.</p></blockquote><p>ARM high memory的代码主要分布在：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel3.18/mm/highmemory.c</span><br><span class="line">kernel3.18/include/linux/highmem.h</span><br><span class="line">kernel3.18/arch/arm/mm/highmem.c</span><br><span class="line">kernel3.18/arch/arm/include/asm/highmem.h</span><br></pre></td></tr></table></figure><p>kmap_atomic的定义在ARM里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmap_atomic</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">pagefault_disable();</span><br><span class="line"><span class="keyword">if</span> (!PageHighMem(page)) <span class="comment">//如果页面不在high memory</span></span><br><span class="line"><span class="keyword">return</span> page_address(page);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>page_address有好3处定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_HIGHMEM) &amp;&amp; !defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHED_PAGE_VIRTUAL</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">page_address</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> page-&gt;virtual;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_page_address</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">void</span> *address)</span></span><br><span class="line">&#123;</span><br><span class="line">page-&gt;virtual = address;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> page_address_init()  do &#123; &#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(HASHED_PAGE_VIRTUAL)</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">page_address</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">set_page_address</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">void</span> *virtual)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">page_address_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(HASHED_PAGE_VIRTUAL) &amp;&amp; !defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> page_address(page) lowmem_page_address(page)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_page_address(page, address)  do &#123; &#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> page_address_init()  do &#123; &#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>ARM没有定义WANT_PAGE_VIRTUAL，是给其他arch使用的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="comment">/*  </span></span><br><span class="line"><span class="comment">         * On machines where all RAM is mapped into kernel address space,</span></span><br><span class="line"><span class="comment">         * we can simply calculate the virtual address. On machines with</span></span><br><span class="line"><span class="comment">         * highmem some memory is mapped into kernel virtual memory</span></span><br><span class="line"><span class="comment">         * dynamically, so we need a place to store that address.</span></span><br><span class="line"><span class="comment">         * Note that this field could be 16 bits on x86 ... ;)</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Architectures with slow multiplication can define</span></span><br><span class="line"><span class="comment">         * WANT_PAGE_VIRTUAL in asm/page.h</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">        <span class="type">void</span> *virtual;                  <span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">                                           not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br></pre></td></tr></table></figure><p>ARM的page_address在mm下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">page_address</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="type">void</span> *ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_address_slot</span> *<span class="title">pas</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!PageHighMem(page))</span><br><span class="line"><span class="keyword">return</span> lowmem_page_address(page);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对于low memory的page直接计算：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PHYS(x)     ((phys_addr_t)(x) &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">lowmem_page_address</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __va(PFN_PHYS(page_to_pfn(page)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>page_to_pfn在memory_model.h里定义：</p><p>涉及到linux支持的三种内存模型：CONFIG_FLATMEM&#x2F;DISCONTIGMEM&#x2F;SPARSEMEM，这里就看FLAGMEM:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_FLATMEM)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pfn_to_page(pfn)(mem_map + ((pfn) - ARCH_PFN_OFFSET))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __page_to_pfn(page)((unsigned long)((page) - mem_map) + \</span></span><br><span class="line"><span class="meta"> ARCH_PFN_OFFSET)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_FLATMEM/DISCONTIGMEM/SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> page_to_pfn __page_to_pfn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pfn_to_page __pfn_to_page</span></span><br></pre></td></tr></table></figure><p>看样子像是偏移计算，来看下mem_map和ARCH_PFN_OFFSET。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_NEED_MULTIPLE_NODES</span></span><br><span class="line"><span class="comment">/* use the per-pgdat data instead for discontigmem - mbligh */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> max_mapnr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">mem_map</span>;</span></span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(max_mapnr);</span><br><span class="line">EXPORT_SYMBOL(mem_map);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init_refok <span class="title function_">alloc_node_mem_map</span><span class="params">(<span class="keyword">struct</span> pglist_data *pgdat)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* Skip empty nodes */</span></span><br><span class="line">        <span class="keyword">if</span> (!pgdat-&gt;node_spanned_pages)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP</span></span><br><span class="line">        ...</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_NEED_MULTIPLE_NODES</span></span><br><span class="line">        <span class="comment">/*   </span></span><br><span class="line"><span class="comment">         * With no DISCONTIG, the global mem_map is just set as node 0&#x27;s</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (pgdat == NODE_DATA(<span class="number">0</span>)) &#123;</span><br><span class="line">                mem_map = NODE_DATA(<span class="number">0</span>)-&gt;node_mem_map;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config NEED_MULTIPLE_NODES</span><br><span class="line">        def_bool y</span><br><span class="line">        depends on DISCONTIGMEM || NUMA</span><br></pre></td></tr></table></figure><p>对于手机配置目前一般不是NUMA，也就是1个node。看下node_mem_map：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> nr_zones;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP<span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_cgroup</span> *<span class="title">node_page_cgroup</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>分配处理</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> node_spanned_pages; <span class="comment">/* total size of physical page</span></span><br><span class="line"><span class="comment">     range, including holes */</span></span><br><span class="line">...</span><br><span class="line">&#125;<span class="type">pg_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">pgdat_end_pfn</span><span class="params">(<span class="type">pg_data_t</span> *pgdat)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> pgdat-&gt;node_start_pfn + pgdat-&gt;node_spanned_pages;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init_refok <span class="title function_">alloc_node_mem_map</span><span class="params">(<span class="keyword">struct</span> pglist_data *pgdat)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Skip empty nodes */</span></span><br><span class="line"><span class="keyword">if</span> (!pgdat-&gt;node_spanned_pages)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP</span></span><br><span class="line"><span class="comment">/* ia64 gets its own node_mem_map, before this, without bootmem */</span></span><br><span class="line"><span class="keyword">if</span> (!pgdat-&gt;node_mem_map) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> size, start, end;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">map</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The zone&#x27;s endpoints aren&#x27;t required to be MAX_ORDER</span></span><br><span class="line"><span class="comment"> * aligned but the node_mem_map endpoints must be in order</span></span><br><span class="line"><span class="comment"> * for the buddy allocator to function correctly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">start = pgdat-&gt;node_start_pfn &amp; ~(MAX_ORDER_NR_PAGES - <span class="number">1</span>);</span><br><span class="line">end = pgdat_end_pfn(pgdat);</span><br><span class="line">end = ALIGN(end, MAX_ORDER_NR_PAGES);</span><br><span class="line">size =  (end - start) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> page);</span><br><span class="line"><span class="built_in">map</span> = alloc_remap(pgdat-&gt;node_id, size);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">map</span>)</span><br><span class="line"><span class="built_in">map</span> = memblock_virt_alloc_node_nopanic(size,</span><br><span class="line">       pgdat-&gt;node_id);</span><br><span class="line">pgdat-&gt;node_mem_map = <span class="built_in">map</span> + (pgdat-&gt;node_start_pfn - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>start, end, size都有了，具体分配调用了alloc_remap：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAVE_ARCH_ALLOC_REMAP</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">alloc_remap</span><span class="params">(<span class="type">int</span> nid, <span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">alloc_remap</span><span class="params">(<span class="type">int</span> nid, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_HAVE_ARCH_ALLOC_REMAP */</span></span></span><br></pre></td></tr></table></figure><p>ARM没有定义CONFIG_HAVE_ARCH_ALLOC_REMAP，走memblock_virt_alloc_node_nopanic，分配涉及到bootmem，暂略过。</p><p>可以看出，这个pgdat-&gt;node_mem_map&#x2F;map空间存放着所有的物理page，mem_map指向开头。也就是如下图：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mem_map</span><br><span class="line">  |</span><br><span class="line">  +-------+-------+-----+-------+</span><br><span class="line">  | page1 | page2 | ... | pageN |</span><br><span class="line">  +-------+-------+-----+-------+</span><br></pre></td></tr></table></figure><p>ok，再回头看page_to_pfn就是要找到index，直接page - mem_map就可以了,加上pfn偏移ARCH_PFN_OFFSET</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KERNEL_RAM_BASE_ADDRESS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_OFFSET             (CONFIG_KERNEL_RAM_BASE_ADDRESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_OFFSET             (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ARCH_PFN_OFFSET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARCH_PFN_OFFSET         (PAGE_OFFSET &gt;&gt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>再通过PFN_PHYS转换为地址,这里的地址就是物理地址，为啥，因为lowmemory是一一对应的。ok，用__va转化为虚拟地址。</p><p>PAGE_SHIFT用来决定page size:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT      12</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE       (1 &lt;&lt; PAGE_SHIFT)  <span class="comment">//4KB</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE       (1UL &lt;&lt; PAGE_SHIFT)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux Kernel </tag>
            
            <tag> High Memory </tag>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Windows VirtualBox虚拟的Ubuntu中使用adb</title>
      <link href="/using-adb-in-ubuntu-via-virtualbox-under-win7.html"/>
      <url>/using-adb-in-ubuntu-via-virtualbox-under-win7.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Android手机有些脚本需要在Linux环境中用，有些场景下还是需要在Windows中用VirtualBox虚拟一个Linux&#x2F;Ubuntu来使用。</p><h2 id="主机虚拟机互访"><a href="#主机虚拟机互访" class="headerlink" title="主机虚拟机互访"></a>主机虚拟机互访</h2><p>在VirutalBox安装好Ubuntu后，adb命令包是没有的，虚拟机也是不能上网的，不可能用apt-get了，一个简单的方法就是先在主机上下好deb包，把deb包传输到Ubuntu下用dpkg命令安装。</p><p>主机虚拟机文件互访可以通过设置VB的共享文件夹，不过需要安装增强功能，安装过程好像需要依赖包，不可行，只能先把主机虚拟机ping通了，通过Ubuntu的网上邻居就可以访问。</p><p>ok，下来需要做的事情：</p><ul><li>在全局设定&#x2F;网络路径下，Host-only中添加一个网络，ip&#x2F;netmask配下，一般用192.168.1.111&#x2F;255.255.255.0，不启用DHCP服务器。</li><li>网络界面默认是Nat方式，连接方式改成Host-only，界面名称就是刚才添加的网卡了。</li><li>网络界面有个选项是插入网络，必须要勾选表示启用网络。</li><li>在虚拟ubuntu下配置静态ip，重启，互ping应该都通了。</li></ul><p>Ubuntu eth0 ip:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.1.122</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.1.1</span><br></pre></td></tr></table></figure><p>Windows下网卡信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">以太网适配器 VirtualBox Host-Only Network:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : ...</span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : 192.168.1.111</span><br><span class="line">   子网掩码  . . . . . . . . . . . . : 255.255.255.0</span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br></pre></td></tr></table></figure><p>ping通后，可以在Windows上共享某个文件夹(not everyone)，然后到Ubuntu下用网上邻居登录Windows就可以看到啦 or 直接在Files浏览里点击connect a server输入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">smb://192.168.1.122</span><br></pre></td></tr></table></figure><h2 id="adb包离线安装"><a href="#adb包离线安装" class="headerlink" title="adb包离线安装"></a>adb包离线安装</h2><p>offline install is always what we want. <a href="http://packages.ubuntu.com/">http://packages.ubuntu.com</a>中找到对应adb deb文件，dpkg安装不需要依赖，ubuntu是desktop。</p><h2 id="lsusb找不到设备"><a href="#lsusb找不到设备" class="headerlink" title="lsusb找不到设备"></a>lsusb找不到设备</h2><p>为了在vb中使用usb，需要安装扩展包Oracle_VM_VirtualBox_Extension_Pack…到VB网站下载到本地后在全局设定&#x2F;扩展中安装。</p><p>安装完成后启用USB2.0，lsusb依然找不到设备，Win7&#x2F;cmd下adb使用正常。</p><p>偶然发现最下面状态栏的USB设备状态没有活动设备，右击可以看到设备，不过就是选不中，多选几次会出现弹出如下错误：</p><blockquote><p>不能分配 USB设备</p></blockquote><p>查了下网上有解决方法要改下Windows7的注册表，先备份：</p><blockquote><p>打开注册表工具regedit，依次进入HKEY_LOCAL_MACHINE\SYSTEM\Curr-entControlSet\Control，会看到下面有Class{36-FC9E60-C465-11CF-8056-44455354-0000}，点击它，在右侧出现窗口会看到有个UpperFilter，选中它，鼠标右键-删除，重启电脑。</p></blockquote><p>删掉后连接手机会发现Windows在找驱动：VirtualBox USB驱动，安装完成后，lsusb就可以看到了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Bus 001 Deivce 002: ID 1eee:3333</span><br></pre></td></tr></table></figure><h2 id="adb-devices-no-permissions"><a href="#adb-devices-no-permissions" class="headerlink" title="adb devices no permissions"></a>adb devices no permissions</h2><p>adb devices运行后仍然找不到设备，会有如下提示，这个已经和VirtualBox么关系了，linux问题。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">???????????   no permissions</span><br></pre></td></tr></table></figure><ol><li>进入&#x2F;etc&#x2F;udev&#x2F; 创建70-Android.rules文件，加入如下内容：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SUBSYSTEM==&quot;usb&quot;, ATTRS&#123;idVendor&#125;==&quot;1eee&quot;, ATTRS&#123;idProduct&#125;==&quot;3333&quot;, MODE=&quot;0666&quot;</span><br></pre></td></tr></table></figure></li><li>进入~&#x2F;.android&#x2F;目录，创建adb_usb.ini文件，把lsusb的idVendor填入，注意0x。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x1eee</span><br></pre></td></tr></table></figure></li><li>vb下直接重启ubuntu，adb devices就可以找到设备了。</li></ol><p>btw: VB下USB设备在活动时Win7下的adb devices已经失效，虚拟机退出后恢复。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VirtualBox </tag>
            
            <tag> Linux adb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析ZRAM数据流操作</title>
      <link href="/analyze-zram-stream-operation.html"/>
      <url>/analyze-zram-stream-operation.html</url>
      
        <content type="html"><![CDATA[<h2 id="ZRAM基本"><a href="#ZRAM基本" class="headerlink" title="ZRAM基本"></a>ZRAM基本</h2><ul><li>kernel3.18下代码路径在driver&#x2F;block&#x2F;zram下，主要是三部分：zram块设备驱动zram_drv.c，zram数据流操作zcomp.c以及压缩后台lzo&#x2F;lz4接口</li><li>zram sysfs node path: &#x2F;sys&#x2F;block&#x2F;zram0&#x2F;</li><li>zram kernel doc: Documentation&#x2F;blockdev&#x2F;zram.txt</li></ul><h2 id="数据流创建"><a href="#数据流创建" class="headerlink" title="数据流创建"></a>数据流创建</h2><p>在zram驱动中设置sysfs disksize时,会根据sysfs max_comp_streams的配置数创建一个或多个数据流，代码看下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> zcomp *<span class="title function_">zcomp_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *compress, <span class="type">int</span> max_strm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp</span> *<span class="title">comp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_backend</span> *<span class="title">backend</span>;</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">backend = find_backend(compress);</span><br><span class="line"><span class="keyword">if</span> (!backend)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">comp = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> zcomp), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!comp)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">comp-&gt;backend = backend;</span><br><span class="line"><span class="keyword">if</span> (max_strm &gt; <span class="number">1</span>)</span><br><span class="line">error = zcomp_strm_multi_create(comp, max_strm);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">error = zcomp_strm_single_create(comp);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br></pre></td></tr></table></figure><p>找到backend(lzo&#x2F;lz4)后用zcomp_strm_multi_create创建多个 or 用zcomp_strm_single_create创建单个压缩流。</p><p>先来看简单的单压缩流数据。</p><h2 id="单数据流操作"><a href="#单数据流操作" class="headerlink" title="单数据流操作"></a>单数据流操作</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm</span> &#123;</span></span><br><span class="line"><span class="comment">/* compression/decompression buffer */</span></span><br><span class="line"><span class="type">void</span> *buffer;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The private data of the compression stream, only compression</span></span><br><span class="line"><span class="comment"> * stream backend can touch this (e.g. compression algorithm</span></span><br><span class="line"><span class="comment"> * working memory)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *private;</span><br><span class="line"><span class="comment">/* used in multi stream backend, protected by backend strm_lock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * single zcomp_strm backend</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_single</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">strm_lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm</span> *<span class="title">zstrm</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用一个互斥锁strm_lock保护这一个数据流访问的串行化，buffer用于存放压缩后的数据，private是压缩backend用到的，压缩backend就是lzo&#x2F;lz4了，看下压缩backend结构定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* static compression backend */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_backend</span> &#123;</span></span><br><span class="line"><span class="type">int</span> (*compress)(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *src, <span class="type">unsigned</span> <span class="type">char</span> *dst,</span><br><span class="line"><span class="type">size_t</span> *dst_len, <span class="type">void</span> *private);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*decompress)(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *src, <span class="type">size_t</span> src_len,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *dst);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*create)(<span class="type">void</span>);</span><br><span class="line"><span class="type">void</span> (*destroy)(<span class="type">void</span> *private);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的create就是给private用的了，也就是申请backend所需要的working memory。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">lzo_create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">ret = kzalloc(LZO1X_MEM_COMPRESS, GFP_NOIO | __GFP_NORETRY |</span><br><span class="line">__GFP_NOWARN);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = __vmalloc(LZO1X_MEM_COMPRESS,</span><br><span class="line">GFP_NOIO | __GFP_NORETRY | __GFP_NOWARN |</span><br><span class="line">__GFP_ZERO | __GFP_HIGHMEM,</span><br><span class="line">PAGE_KERNEL);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单压缩流创建时会先分配好这个zstrm并初始化互斥锁strm_lock，当zram block drv在rw时先通过zcomp_strm_single_find拿到zstrm（如果有其他进程占着就等着释放），用完后再用zcomp_strm_single_release解锁这个strm_lock。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">zcomp_strm_single_create</span><span class="params">(<span class="keyword">struct</span> zcomp *comp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_single</span> *<span class="title">zs</span>;</span></span><br><span class="line"></span><br><span class="line">comp-&gt;destroy = zcomp_strm_single_destroy;</span><br><span class="line">comp-&gt;strm_find = zcomp_strm_single_find;</span><br><span class="line">comp-&gt;strm_release = zcomp_strm_single_release;</span><br><span class="line">comp-&gt;set_max_streams = zcomp_strm_single_set_max_streams;</span><br><span class="line">zs = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> zcomp_strm_single), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!zs)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">comp-&gt;stream = zs;</span><br><span class="line">mutex_init(&amp;zs-&gt;strm_lock);         <span class="comment">//互斥锁初始化</span></span><br><span class="line">zs-&gt;zstrm = zcomp_strm_alloc(comp); <span class="comment">//先分配好这个压缩流</span></span><br><span class="line"><span class="keyword">if</span> (!zs-&gt;zstrm) &#123;</span><br><span class="line">kfree(zs);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> zcomp_strm *<span class="title function_">zcomp_strm_single_find</span><span class="params">(<span class="keyword">struct</span> zcomp *comp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_single</span> *<span class="title">zs</span> =</span> comp-&gt;stream;</span><br><span class="line">mutex_lock(&amp;zs-&gt;strm_lock);</span><br><span class="line"><span class="keyword">return</span> zs-&gt;zstrm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">zcomp_strm_single_release</span><span class="params">(<span class="keyword">struct</span> zcomp *comp,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> zcomp_strm *zstrm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_single</span> *<span class="title">zs</span> =</span> comp-&gt;stream;</span><br><span class="line">mutex_unlock(&amp;zs-&gt;strm_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多数据流操作"><a href="#多数据流操作" class="headerlink" title="多数据流操作"></a>多数据流操作</h2><p>引入多压缩流的目的, 内核文档有说明：</p><blockquote><p>Compression backend may use up to max_comp_streams compression<br>streams, thus allowing up to max_comp_streams concurrent compression<br>operations. By default, compression backend uses single compression<br>stream.</p><p>Note:<br>In order to enable compression backend’s multi stream support max_comp_streams<br>must be initially set to desired concurrency level before ZRAM device<br>initialisation. Once the device initialised as a single stream compression<br>backend (max_comp_streams equals to 1), you will see error if you try to change<br>the value of max_comp_streams because single stream compression backend<br>implemented as a special case by lock overhead issue and does not support<br>dynamic max_comp_streams. Only multi stream backend supports dynamic<br>max_comp_streams adjustment.</p></blockquote><p>这里提到两个点：</p><ol><li>max_comp_streams是用来增强zram的并发性concurrent，而不是并行性parallel，某国内手机厂家内核说明在此问题上提到了并行，我想是他们理解有错。</li><li>当zram使用单压缩流后不能动态修改为多压缩流，只有多压缩流支持运行时修改。</li></ol><p>来看下上面的第2个问题：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">zcomp_strm_single_set_max_streams</span><span class="params">(<span class="keyword">struct</span> zcomp *comp, <span class="type">int</span> num_strm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* zcomp_strm_single support only max_comp_streams == 1 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">max_comp_streams_store</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> device_attribute *attr, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">        ...</span><br><span class="line">down_write(&amp;zram-&gt;init_lock);</span><br><span class="line"><span class="keyword">if</span> (init_done(zram)) &#123;         <span class="comment">// disksize已配置过</span></span><br><span class="line"><span class="keyword">if</span> (!zcomp_set_max_streams(zram-&gt;comp, num)) &#123; <span class="comment">// 如果当前是单压缩流模式，不能修改</span></span><br><span class="line">pr_info(<span class="string">&quot;Cannot change max compression streams\n&quot;</span>);</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">zram-&gt;max_comp_streams = num;</span><br><span class="line">ret = len;</span><br><span class="line">out:</span><br><span class="line">up_write(&amp;zram-&gt;init_lock);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* change max_strm limit */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">zcomp_strm_multi_set_max_streams</span><span class="params">(<span class="keyword">struct</span> zcomp *comp, <span class="type">int</span> num_strm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_multi</span> *<span class="title">zs</span> =</span> comp-&gt;stream;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm</span> *<span class="title">zstrm</span>;</span></span><br><span class="line"></span><br><span class="line">spin_lock(&amp;zs-&gt;strm_lock);</span><br><span class="line">zs-&gt;max_strm = num_strm;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * if user has lowered the limit and there are idle streams,</span></span><br><span class="line"><span class="comment"> * immediately free as much streams (and memory) as we can.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">while</span> (zs-&gt;avail_strm &gt; num_strm &amp;&amp; !list_empty(&amp;zs-&gt;idle_strm)) &#123;</span><br><span class="line">zstrm = list_entry(zs-&gt;idle_strm.next,</span><br><span class="line"><span class="keyword">struct</span> zcomp_strm, <span class="built_in">list</span>);</span><br><span class="line">list_del(&amp;zstrm-&gt;<span class="built_in">list</span>);</span><br><span class="line">zcomp_strm_free(comp, zstrm);</span><br><span class="line">zs-&gt;avail_strm--;</span><br><span class="line">&#125;</span><br><span class="line">spin_unlock(&amp;zs-&gt;strm_lock);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多压缩流在运行中修改时，如果当前可用的avail_strm大于这个新配置，那就把多出来的idle_strm释放掉。</p><p>下面看下多压缩流的创建，查找申请，释放。</p><h3 id="多压缩流创建"><a href="#多压缩流创建" class="headerlink" title="多压缩流创建"></a>多压缩流创建</h3><p>多压缩流的逻辑就是创建一个list，在使用时从中选择一个idle strm, 如果list为空那就是都被人占着了，要等待释放。 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * multi zcomp_strm backend</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_multi</span> &#123;</span></span><br><span class="line"><span class="comment">/* protect strm list */</span></span><br><span class="line"><span class="type">spinlock_t</span> strm_lock;</span><br><span class="line"><span class="comment">/* max possible number of zstrm streams */</span></span><br><span class="line"><span class="type">int</span> max_strm;</span><br><span class="line"><span class="comment">/* number of available zstrm streams */</span></span><br><span class="line"><span class="type">int</span> avail_strm;</span><br><span class="line"><span class="comment">/* list of available strms */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">idle_strm</span>;</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> strm_wait;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">zcomp_strm_multi_create</span><span class="params">(<span class="keyword">struct</span> zcomp *comp, <span class="type">int</span> max_strm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm</span> *<span class="title">zstrm</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_multi</span> *<span class="title">zs</span>;</span></span><br><span class="line"></span><br><span class="line">comp-&gt;destroy = zcomp_strm_multi_destroy;</span><br><span class="line">comp-&gt;strm_find = zcomp_strm_multi_find;</span><br><span class="line">comp-&gt;strm_release = zcomp_strm_multi_release;</span><br><span class="line">comp-&gt;set_max_streams = zcomp_strm_multi_set_max_streams;</span><br><span class="line">zs = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> zcomp_strm_multi), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!zs)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">comp-&gt;stream = zs;</span><br><span class="line">spin_lock_init(&amp;zs-&gt;strm_lock);</span><br><span class="line">INIT_LIST_HEAD(&amp;zs-&gt;idle_strm);</span><br><span class="line">init_waitqueue_head(&amp;zs-&gt;strm_wait);</span><br><span class="line">zs-&gt;max_strm = max_strm;</span><br><span class="line">zs-&gt;avail_strm = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">zstrm = zcomp_strm_alloc(comp);</span><br><span class="line"><span class="keyword">if</span> (!zstrm) &#123;</span><br><span class="line">kfree(zs);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line">list_add(&amp;zstrm-&gt;<span class="built_in">list</span>, &amp;zs-&gt;idle_strm);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上，多压缩流结构中定义一个list idle_strm，使用单压缩流结构的backend data链入这个list来管理，具体就是zcomp_strm_alloc申请到了一个zstrm后把它list_add idle_strm这个list中。</p><p>avail_strm用来计数可用的idle stream。</p><p>strm_wait用来处理等待的情况。</p><h3 id="多压缩流中查找可用压缩流"><a href="#多压缩流中查找可用压缩流" class="headerlink" title="多压缩流中查找可用压缩流"></a>多压缩流中查找可用压缩流</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> zcomp_strm *<span class="title function_">zcomp_strm_multi_find</span><span class="params">(<span class="keyword">struct</span> zcomp *comp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_multi</span> *<span class="title">zs</span> =</span> comp-&gt;stream;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm</span> *<span class="title">zstrm</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">spin_lock(&amp;zs-&gt;strm_lock);</span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;zs-&gt;idle_strm)) &#123;</span><br><span class="line">zstrm = list_entry(zs-&gt;idle_strm.next,</span><br><span class="line"><span class="keyword">struct</span> zcomp_strm, <span class="built_in">list</span>);</span><br><span class="line">list_del(&amp;zstrm-&gt;<span class="built_in">list</span>);</span><br><span class="line">spin_unlock(&amp;zs-&gt;strm_lock);</span><br><span class="line"><span class="keyword">return</span> zstrm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* zstrm streams limit reached, wait for idle stream */</span></span><br><span class="line"><span class="keyword">if</span> (zs-&gt;avail_strm &gt;= zs-&gt;max_strm) &#123;</span><br><span class="line">spin_unlock(&amp;zs-&gt;strm_lock);</span><br><span class="line">wait_event(zs-&gt;strm_wait, !list_empty(&amp;zs-&gt;idle_strm));</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* allocate new zstrm stream */</span></span><br><span class="line">zs-&gt;avail_strm++;</span><br><span class="line">spin_unlock(&amp;zs-&gt;strm_lock);</span><br><span class="line"></span><br><span class="line">zstrm = zcomp_strm_alloc(comp);</span><br><span class="line"><span class="keyword">if</span> (!zstrm) &#123;</span><br><span class="line">spin_lock(&amp;zs-&gt;strm_lock);</span><br><span class="line">zs-&gt;avail_strm--;</span><br><span class="line">spin_unlock(&amp;zs-&gt;strm_lock);</span><br><span class="line">wait_event(zs-&gt;strm_wait, !list_empty(&amp;zs-&gt;idle_strm));</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> zstrm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看可用列表中有没有可用的，如果有就找到了。如果可用列表空了，那就再分配资源，当然前提是资源数不能超过最大压缩数max_strm，如果超过了就等待其他进程释放资源。</p><p>ps: 这里可以看到在zcomp_strm_alloc后并没有直接list_add加入可用列表，而是在释放时加入，应该是和上限逻辑有关。</p><h3 id="多压缩流释放"><a href="#多压缩流释放" class="headerlink" title="多压缩流释放"></a>多压缩流释放</h3><p>zram block driver在find中找到某个压缩流，使用完后会释放这块资源。具体是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* add stream back to idle list and wake up waiter or free the stream */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">zcomp_strm_multi_release</span><span class="params">(<span class="keyword">struct</span> zcomp *comp, <span class="keyword">struct</span> zcomp_strm *zstrm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_multi</span> *<span class="title">zs</span> =</span> comp-&gt;stream;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;zs-&gt;strm_lock);</span><br><span class="line"><span class="keyword">if</span> (zs-&gt;avail_strm &lt;= zs-&gt;max_strm) &#123;</span><br><span class="line">list_add(&amp;zstrm-&gt;<span class="built_in">list</span>, &amp;zs-&gt;idle_strm);</span><br><span class="line">spin_unlock(&amp;zs-&gt;strm_lock);</span><br><span class="line">wake_up(&amp;zs-&gt;strm_wait);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">zs-&gt;avail_strm--;</span><br><span class="line">spin_unlock(&amp;zs-&gt;strm_lock);</span><br><span class="line">zcomp_strm_free(comp, zstrm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放时max_strm范围内list_add加入可用列表并唤醒等待该压缩流的进程 or 范围外就释放资源。</p><h2 id="ZRAM-callstack"><a href="#ZRAM-callstack" class="headerlink" title="ZRAM callstack"></a>ZRAM callstack</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> [&lt;c010cd84&gt;] (unwind_backtrace) from [&lt;c01099f4&gt;] (show_stack+0x10/0x14)</span><br><span class="line">[   65.015711] [&lt;c01099f4&gt;] (show_stack) from [&lt;c0baeaa4&gt;] (dump_stack+0x78/0x98)</span><br><span class="line">[   65.015721] [&lt;c0baeaa4&gt;] (dump_stack) from [&lt;c052acac&gt;] (zram_make_request+0x12c/0x474)</span><br><span class="line">[   65.015731] [&lt;c052acac&gt;] (zram_make_request) from [&lt;c035278c&gt;] (generic_make_request+0x90/0xc8)</span><br><span class="line">[   65.015741] [&lt;c035278c&gt;] (generic_make_request) from [&lt;c03528d8&gt;] (submit_bio+0x114/0x15c)</span><br><span class="line">[   65.015752] [&lt;c03528d8&gt;] (submit_bio) from [&lt;c0206ce4&gt;] (__swap_writepage+0x260/0x27c)</span><br><span class="line">[   65.015762] [&lt;c0206ce4&gt;] (__swap_writepage) from [&lt;c01e203c&gt;] (shrink_page_list+0x57c/0x9b0)</span><br><span class="line">[   65.015771] [&lt;c01e203c&gt;] (shrink_page_list) from [&lt;c01e2658&gt;] (reclaim_pages_from_list+0xa8/0x108)</span><br><span class="line">[   65.015781] [&lt;c01e2658&gt;] (reclaim_pages_from_list) from [&lt;c0263968&gt;] (reclaim_pte_range+0x11c/0x184)</span><br><span class="line">[   65.015791] [&lt;c0263968&gt;] (reclaim_pte_range) from [&lt;c0203ce8&gt;] (walk_page_range+0x1b8/0x248)</span><br><span class="line">[   65.015801] [&lt;c0203ce8&gt;] (walk_page_range) from [&lt;c026462c&gt;] (reclaim_task_anon+0xb4/0x11c)</span><br><span class="line">[   65.015810] [&lt;c026462c&gt;] (reclaim_task_anon) from [&lt;c0214524&gt;] (swap_fn+0x248/0x4ec)</span><br><span class="line">[   65.015821] [&lt;c0214524&gt;] (swap_fn) from [&lt;c0137434&gt;] (process_one_work+0x254/0x464)</span><br><span class="line">[   65.015830] [&lt;c0137434&gt;] (process_one_work) from [&lt;c013816c&gt;] (worker_thread+0x2b4/0x3f8)</span><br><span class="line">[   65.015839] [&lt;c013816c&gt;] (worker_thread) from [&lt;c013b9b4&gt;] (kthread+0xdc/0xf0)</span><br><span class="line">[   65.015849] [&lt;c013b9b4&gt;] (kthread) from [&lt;c0105f80&gt;] (ret_from_fork+0x14/0x34)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">] CPU: 1 PID: 2737 Comm: ngs.android.pop Tainted: G        W      3.18.31-perf-g5e6acc4-00677-gb0cabe3-dirty #9</span><br><span class="line">[   65.014502] [&lt;c010cd84&gt;] (unwind_backtrace) from [&lt;c01099f4&gt;] (show_stack+0x10/0x14)</span><br><span class="line">[   65.014514] [&lt;c01099f4&gt;] (show_stack) from [&lt;c0baeaa4&gt;] (dump_stack+0x78/0x98)</span><br><span class="line">[   65.014527] [&lt;c0baeaa4&gt;] (dump_stack) from [&lt;c052acac&gt;] (zram_make_request+0x12c/0x474)</span><br><span class="line">[   65.014540] [&lt;c052acac&gt;] (zram_make_request) from [&lt;c035278c&gt;] (generic_make_request+0x90/0xc8)</span><br><span class="line">[   65.014550] [&lt;c035278c&gt;] (generic_make_request) from [&lt;c03528d8&gt;] (submit_bio+0x114/0x15c)</span><br><span class="line">[   65.014561] [&lt;c03528d8&gt;] (submit_bio) from [&lt;c0206e18&gt;] (swap_readpage+0xdc/0xf0)</span><br><span class="line">[   65.014571] [&lt;c0206e18&gt;] (swap_readpage) from [&lt;c0207430&gt;] (read_swap_cache_async+0x154/0x1cc)</span><br><span class="line">[   65.014582] [&lt;c0207430&gt;] (read_swap_cache_async) from [&lt;c0207618&gt;] (swapin_readahead+0x170/0x184)</span><br><span class="line">[   65.014592] [&lt;c0207618&gt;] (swapin_readahead) from [&lt;c01f916c&gt;] (handle_mm_fault+0x490/0x904)</span><br><span class="line">[   65.014603] [&lt;c01f916c&gt;] (handle_mm_fault) from [&lt;c0114590&gt;] (do_page_fault+0x118/0x378)</span><br><span class="line">[   65.014612] [&lt;c0114590&gt;] (do_page_fault) from [&lt;c010030c&gt;] (do_DataAbort+0x34/0x164)</span><br><span class="line">[   65.014620] [&lt;c010030c&gt;] (do_DataAbort) from [&lt;c010a6fc&gt;] (__dabt_usr+0x3c/0x40)</span><br><span class="line">[   65.014625] Exception stack(0xe4895fb0 to 0xe4895ff8)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux Kernel </tag>
            
            <tag> zRAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析adaptive lmk特性</title>
      <link href="/analyze-adaptive-lmk.html"/>
      <url>/analyze-adaptive-lmk.html</url>
      
        <content type="html"><![CDATA[<h2 id="特性来源"><a href="#特性来源" class="headerlink" title="特性来源"></a>特性来源</h2><p>ALMK: adaptive lowmemorykiller，是Qualcomm针对安卓LMK的优化，当系统lmk还没有杀进程时，如果发现有过高的vmpressure，就有可能会造成卡顿，此时杀掉某个进程是个比较好的选择。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>msm kernel3.18 lowmemorykiller.c 主体函数如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">lowmem_scan</span><span class="params">(<span class="keyword">struct</span> shrinker *s, <span class="keyword">struct</span> shrink_control *sc)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; array_size; i++) &#123;</span><br><span class="line">        minfree = lowmem_minfree[i];</span><br><span class="line">        <span class="keyword">if</span> (other_free &lt; minfree &amp;&amp; other_file &lt; minfree) &#123;</span><br><span class="line">            min_score_adj = lowmem_adj[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = adjust_minadj(&amp;min_score_adj);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在minfree的范围判断后加入了min_score_adj的调整，代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">adjust_minadj</span><span class="params">(<span class="type">short</span> *min_score_adj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = VMPRESSURE_NO_ADJUST;</span><br><span class="line">    <span class="keyword">if</span> (!enable_adaptive_lmk)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">atomic_read</span>(&amp;shift_adj) &amp;&amp;</span><br><span class="line">        (*min_score_adj &gt; adj_max_shift)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*min_score_adj == OOM_SCORE_ADJ_MAX + <span class="number">1</span>)</span><br><span class="line">            ret = VMPRESSURE_ADJUST_ENCROACH;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = VMPRESSURE_ADJUST_NORMAL;</span><br><span class="line">        *min_score_adj = adj_max_shift;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">atomic_set</span>(&amp;shift_adj, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enable_adaptive_lmk是特性开关。</p><p>shift_adj用作入口首要条件，&gt;0才能进入，这个会在vm pressure中set，等下来看。</p><p>同时，lmk所选择的min_score_adj要&gt;adj_max_shift才能working，比如如果系统内存在minfree之上时，此时的adjust_minadj就是VMPRESSURE_ADJUST_ENCROACH.</p><p>下面的代码就是如何用vmpressure探测系统thrashing：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">lmk_vmpressure_notifier</span><span class="params">(<span class="keyword">struct</span> notifier_block *nb,</span></span><br><span class="line"><span class="params">            <span class="type">unsigned</span> <span class="type">long</span> action, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> other_free, other_file;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pressure = action;</span><br><span class="line">    <span class="type">int</span> array_size = ARRAY_SIZE(lowmem_adj);</span><br><span class="line">    <span class="keyword">if</span> (!enable_adaptive_lmk)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pressure &gt;= <span class="number">95</span>) &#123;</span><br><span class="line">        other_file = global_page_state(NR_FILE_PAGES) + zcache_pages() -</span><br><span class="line">            global_page_state(NR_SHMEM) -</span><br><span class="line">            total_swapcache_pages();</span><br><span class="line">        other_free = global_page_state(NR_FREE_PAGES);</span><br><span class="line">        <span class="type">atomic_set</span>(&amp;shift_adj, <span class="number">1</span>);</span><br><span class="line">        trace_almk_vmpressure(pressure, other_free, other_file);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pressure &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lowmem_adj_size &lt; array_size)</span><br><span class="line">            array_size = lowmem_adj_size;</span><br><span class="line">        <span class="keyword">if</span> (lowmem_minfree_size &lt; array_size)</span><br><span class="line">            array_size = lowmem_minfree_size;</span><br><span class="line">        other_file = global_page_state(NR_FILE_PAGES) + zcache_pages() -</span><br><span class="line">            global_page_state(NR_SHMEM) -</span><br><span class="line">            total_swapcache_pages();</span><br><span class="line">        other_free = global_page_state(NR_FREE_PAGES);</span><br><span class="line">        <span class="keyword">if</span> ((other_free &lt; lowmem_minfree[array_size - <span class="number">1</span>]) &amp;&amp;</span><br><span class="line">            (other_file &lt; vmpressure_file_min)) &#123;</span><br><span class="line">                <span class="type">atomic_set</span>(&amp;shift_adj, <span class="number">1</span>);</span><br><span class="line">                trace_almk_vmpressure(pressure, other_free,</span><br><span class="line">                    other_file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码里的90，95有code style问题，在vmpressure.c有如下级别定义：</p><pre><code>static const unsigned int vmpressure_level_med = 60;static const unsigned int vmpressure_level_critical = 95;</code></pre><p>这里的95就表明系统基本上page thrashing了，要释放内存。至于90可以理解为incoming状态，提前发现问题，也符合lmk思想。</p><p>对于95以上的，shift_adj直接置1了。</p><p>对于90-94之间的，要满足一定条件才能触发，很明显，相比lowmem_scan，这里就把空进程的minfree换成了vmpressure_file_min。</p><p>为了保证在空进程时系统thrashing也能杀进程，一般vmpressure_file_min要高于minfree max。</p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux Kernel </tag>
            
            <tag> LMK </tag>
            
            <tag> ALMK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析lowmemorykiller内核处理</title>
      <link href="/analyze-lmk-kernel.html"/>
      <url>/analyze-lmk-kernel.html</url>
      
        <content type="html"><![CDATA[<h2 id="lowmemorykiller"><a href="#lowmemorykiller" class="headerlink" title="lowmemorykiller"></a>lowmemorykiller</h2><p>简称lmk，是安卓平台特有的特性，代码路径在drivers&#x2F;staging&#x2F;android&#x2F;lowmemorykiller.c (kernel 3.18)，sysfs node在&#x2F;sys&#x2F;module&#x2F;lowmemorykiller&#x2F;下，它的前身是linux OOM，主要两个参数是minfree和adj，minfree的设置主要根据framework层代码算出，但也有厂商会自己修改，要做充分的UX测试后给出。</p><h2 id="主体扫描"><a href="#主体扫描" class="headerlink" title="主体扫描"></a>主体扫描</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">lowmem_scan</span><span class="params">(<span class="keyword">struct</span> shrinker *s, <span class="keyword">struct</span> shrink_control *sc)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">selected</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rem = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tasksize;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">short</span> min_score_adj = OOM_SCORE_ADJ_MAX + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> selected_tasksize = <span class="number">0</span>;</span><br><span class="line"><span class="type">short</span> selected_oom_score_adj;</span><br><span class="line"><span class="type">int</span> array_size = ARRAY_SIZE(lowmem_adj);</span><br><span class="line"><span class="type">int</span> other_free = global_page_state(NR_FREE_PAGES) - totalreserve_pages;</span><br><span class="line"><span class="type">int</span> other_file = global_page_state(NR_FILE_PAGES) -</span><br><span class="line">global_page_state(NR_SHMEM) -</span><br><span class="line">total_swapcache_pages();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lowmem_adj_size &lt; array_size)</span><br><span class="line">array_size = lowmem_adj_size;</span><br><span class="line"><span class="keyword">if</span> (lowmem_minfree_size &lt; array_size)</span><br><span class="line">array_size = lowmem_minfree_size;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; array_size; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (other_free &lt; lowmem_minfree[i] &amp;&amp;</span><br><span class="line">    other_file &lt; lowmem_minfree[i]) &#123;</span><br><span class="line">min_score_adj = lowmem_adj[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lowmem_print(<span class="number">3</span>, <span class="string">&quot;lowmem_scan %lu, %x, ofree %d %d, ma %hd\n&quot;</span>,</span><br><span class="line">sc-&gt;nr_to_scan, sc-&gt;gfp_mask, other_free,</span><br><span class="line">other_file, min_score_adj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (min_score_adj == OOM_SCORE_ADJ_MAX + <span class="number">1</span>) &#123;</span><br><span class="line">lowmem_print(<span class="number">5</span>, <span class="string">&quot;lowmem_scan %lu, %x, return 0\n&quot;</span>,</span><br><span class="line">     sc-&gt;nr_to_scan, sc-&gt;gfp_mask);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">selected_oom_score_adj = min_score_adj;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看看能不能找到oom_score_adj，如果找不到就认为内存充足不杀进程，如果找到就按一定的策略选出某个进程杀掉。</p><p>判断内存是否充足的条件就是other_free和other_file两个都必须同时小于lowmem_minfree中的用户设定值,other_free基本上是free pages，other_file基本上是file pages，两者可以分别看成proc&#x2F;meminfo的MemFree和Cached大小，一般来说Cached远大于MemFree。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">lowmem_scan</span><span class="params">(<span class="keyword">struct</span> shrinker *s, <span class="keyword">struct</span> shrink_control *sc)</span></span><br><span class="line">&#123;</span><br><span class="line">        ...</span><br><span class="line">rcu_read_lock();</span><br><span class="line">for_each_process(tsk) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="type">short</span> oom_score_adj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tsk-&gt;flags &amp; PF_KTHREAD)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">p = find_lock_task_mm(tsk);</span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (test_tsk_thread_flag(p, TIF_MEMDIE) &amp;&amp;</span><br><span class="line">    time_before_eq(jiffies, lowmem_deathpending_timeout)) &#123;</span><br><span class="line">task_unlock(p);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">oom_score_adj = p-&gt;signal-&gt;oom_score_adj;</span><br><span class="line"><span class="keyword">if</span> (oom_score_adj &lt; min_score_adj) &#123;</span><br><span class="line">task_unlock(p);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">tasksize = get_mm_rss(p-&gt;mm);</span><br><span class="line">task_unlock(p);</span><br><span class="line"><span class="keyword">if</span> (tasksize &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (selected) &#123;</span><br><span class="line"><span class="keyword">if</span> (oom_score_adj &lt; selected_oom_score_adj)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (oom_score_adj == selected_oom_score_adj &amp;&amp;</span><br><span class="line">    tasksize &lt;= selected_tasksize)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">selected = p;</span><br><span class="line">selected_tasksize = tasksize;</span><br><span class="line">selected_oom_score_adj = oom_score_adj;</span><br><span class="line">lowmem_print(<span class="number">2</span>, <span class="string">&quot;select %d (%s), adj %hd, size %d, to kill\n&quot;</span>,</span><br><span class="line">     p-&gt;pid, p-&gt;comm, oom_score_adj, tasksize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (selected) &#123;</span><br><span class="line">lowmem_print(<span class="number">1</span>, <span class="string">&quot;send sigkill to %d (%s), adj %hd, size %d\n&quot;</span>,</span><br><span class="line">     selected-&gt;pid, selected-&gt;comm,</span><br><span class="line">     selected_oom_score_adj, selected_tasksize);</span><br><span class="line">lowmem_deathpending_timeout = jiffies + HZ;</span><br><span class="line">set_tsk_thread_flag(selected, TIF_MEMDIE);</span><br><span class="line">send_sig(SIGKILL, selected, <span class="number">0</span>);</span><br><span class="line">rem += selected_tasksize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lowmem_print(<span class="number">4</span>, <span class="string">&quot;lowmem_scan %lu, %x, return %lu\n&quot;</span>,</span><br><span class="line">     sc-&gt;nr_to_scan, sc-&gt;gfp_mask, rem);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历所有的进程for_each_process，当前任务如果是PF_KTHREAD就不能杀，如果不是用find_lock_task_mm遍历当前进程子线程，找到持有<code>-&gt;mm</code>的子线程。</p><p>如果该线程有TIF_MEMDIE标记就不杀了，如果没有看下该线程的oom_score_adj要比min_score_adj小就直接continue到下一个进程如果比较大而且rss有值(&gt;0)就作为备选后再查看下一个进程。</p><p>下一个进程必须比上一次选中的得分要大 or 得分相同但是rss比上一次的占用多的就被认为是更搓的task，要杀。</p><h2 id="lmk是如何被调用的"><a href="#lmk是如何被调用的" class="headerlink" title="lmk是如何被调用的"></a>lmk是如何被调用的</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[&lt;c082a824&gt;] (lowmem_scan) from [&lt;c01e0ba4&gt;] (shrink_slab_node+0x204/0x3d0)</span><br><span class="line">[&lt;c01e0ba4&gt;] (shrink_slab_node) from [&lt;c01e12b8&gt;] (shrink_slab+0x70/0xe4)</span><br><span class="line">[&lt;c01e12b8&gt;] (shrink_slab) from [&lt;c01e3ba8&gt;] (try_to_free_pages+0x3c0/0x74c)</span><br><span class="line">[&lt;c01e3ba8&gt;] (try_to_free_pages) from [&lt;c01d9188&gt;] (__alloc_pages_nodemask+0x578/0x92c)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">shrinker</span> <span class="title">lowmem_shrinker</span> =</span> &#123;</span><br><span class="line">.scan_objects = lowmem_scan,</span><br><span class="line">.count_objects = lowmem_count,</span><br><span class="line">.seeks = DEFAULT_SEEKS * <span class="number">16</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要是回收内存流程时会调用，lowmem_scan挂到了register_shrinker里, shrink_slab_node里会scan_objects。</p>]]></content>
      
      
      <categories>
          
          <category> mm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux Kernel </tag>
            
            <tag> LMK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Ubuntu下开发调试stm32</title>
      <link href="/debug-enviroment-for-stm32-under-ubuntu.html"/>
      <url>/debug-enviroment-for-stm32-under-ubuntu.html</url>
      
        <content type="html"><![CDATA[<p>12.04 32bits上，secureCRT有linux版本也要crack, mdk474可以用wine，mdk cpu利用率高可以用cpulimit.</p><ul><li>crack secureCRT4linux</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://download.boll.me/securecrt_linux_crack.pl</span><br><span class="line">sudo perl securecrt_linux_crack.pl /usr/bin/SecureCRT</span><br></pre></td></tr></table></figure><p>run: sudo secureCRT, my version is scrt-7.1.0-244.ubuntu12.i386.deb</p><ul><li>how to reduce wineserver cpu usage or any application</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cpulimit -P /usr/bin/wineserver -l 20</span><br></pre></td></tr></table></figure><p>ps: or 10, pls test it</p><ul><li>wine</li></ul><p>wine mdk4.74.exe + wine KEIL4.0_Lic.exe, 操作和win下一样一样地。</p><ul><li>wine menu恢复</li></ul><p>右击edit menu, 不小心delete wine菜单了，图形没发恢复，看下cmd。</p><p>下面这个路径能打开就能看到,把Deleted的行删掉就可以了哇。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/.config/menus/applications.menu </span><br></pre></td></tr></table></figure><ul><li>从panel上运行SecureCRT</li></ul><p>就是快捷图标，因为有sudo，不想用sudo不输入密码方式，弹出窗口输入比较好。Applications-System Tools - Admin下有app就需要弹出密码窗口，看来可行。</p><p>看了下gparted-pkexec需要，file看下是个脚本，打开看下原来用的是pkexec &#x2F;usr&#x2F;sbin&#x2F;gparted</p><p>好，找样搞了个SecureCRT-pkexec，改下pkexec &#x2F;usr&#x2F;bin&#x2F;SecureCRT， 点击图标没反应，到命令行下有提示错误</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cannot connect to x server</span><br></pre></td></tr></table></figure><p>google</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// from freedesktop.org</span><br><span class="line">As a result, pkexec will not by default allow you to run X11 applications as another user since the $DISPLAY and </span><br><span class="line">$XAUTHORITY environment variables are not set. These two variables will be retained </span><br><span class="line">if the org.freedesktop.policykit.exec.allow_gui annotation on an action is set to a nonempty value; </span><br><span class="line">this is discouraged, though, and should only be used for legacy programs. </span><br></pre></td></tr></table></figure><p>nd,man pkexec看下，里面也有一样的说明，里面还有个例子，说要放个文件到below dir下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/share/polkit-1/actions</span><br></pre></td></tr></table></figure><p>好了，看下gparted，果然有</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hy@hy-desktop:/usr/share/polkit-1/actions$ ls -l com.ubuntu.pkexec.*</span><br><span class="line">-rw-r--r-- 1 root root 763  3月  9  2012 com.ubuntu.pkexec.gparted.policy</span><br><span class="line">-rw-r--r-- 1 root root 740  4月 17  2012 com.ubuntu.pkexec.synaptic.policy</span><br></pre></td></tr></table></figure><p>照着cp一个然后把里面的gparted字样改掉，我去，icon的属性里command就填 SecureCRT-pkexec， 点击有了啊。。。</p><p>我试了下mdk编译无问题，securecrt ymodem烧录么问题。。。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交换芯片开发小结</title>
      <link href="/switch-develop-summary.html"/>
      <url>/switch-develop-summary.html</url>
      
        <content type="html"><![CDATA[<p>2012年做过L1&#x2F;L2的相关开发维护， 芯片厂家是BCM.</p><p>说L1，主要是硬件信号，软件参与很少，除非上电默认配置不能工作，软件才配置，比如说PHY工作模式是sgmii还是serdes等。</p><p>而L2的核心就是forwarding，具体就是报文进来后，硬件logic完成报文转发的功能，进出报文内容不变，涉及到的feature有:</p><ul><li>address管理: mac学习，老化，静态mac</li><li>vlan: port vlan, ingress&#x2F;egress vlan tag的处理等</li><li>trunk: 增加带宽，链路备份，由lacp软件来维护</li><li>rate ctrl: 端口限速</li><li>CoS: 报文优先级管理</li><li>mirror: 报文copy,调试用</li><li>stack: 2个芯片当1个使用,端口更多</li><li>pkt counter: 调试用，按字节统计，uni-, mutil-, broad-cast等,有个SNMP标准</li></ul><p>全部看芯片手册就可以了, L3主要涉及业务较多，涉猎较少，关注ip头, route等。</p>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Switch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决因connection reset by peer错误导致的ping不通问题</title>
      <link href="/fix-ping-issue-about-connect-rst-by-peer.html"/>
      <url>/fix-ping-issue-about-connect-rst-by-peer.html</url>
      
        <content type="html"><![CDATA[<p>2010年做网卡开发遇到的问题, 现在就放到这里了。</p><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>两个节点ping不同，上层显示socket失去连接，建立连接，再失去连接…socket是个54错误, 错误宏是ECONNRESET&#x3D;connection reset by peer.</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>ping直接走的是网卡驱动层， kernel是VxWorks，一般不会出问题, 用ifShow查看没有发现error。ping包是icmp协议， 添加抓包代码， 发现是节点B收不到ping包。</p><p>先查下节点B是不是有接收错误. 在rx中， 添加错误打印(用logMsg, printf太多会打死)， 查看发现bug出来时是大量的netGetCluster错误。再查下driver, 发现有dump error函数， 用这个函数查到bug时有 rx overrun error, 手册解释就是内部的FIFO溢出。再看下数据流向，先到网卡FIFO, 然后再送到system(host) memory。手册提到了82557 mem有3部分：CBL + RFA就驻留在system memory + CSR(on chip).</p><p>这个system mem就是VxWorks 82557 END memory pool, 它的初始化是 fei82557InitMem, 它的memsize的计算方法：rfd num(nRFDs) * rfd size + rfd loan * rfd size + cfd size(nCFDs) * cfd num(代码里有, rfd和cfd size都是1536byte)。FIFO溢出，很有可能就是system mem较小(这只是推断，手册应该提到FIFO的包是如何上送到system, 估计是rx控制单元先查看system pool是否有空间，有就上送，没就不上送，这样一来，就可能是memory pool size小了:)，使得FIFO的包没有及时上送到system mem导致。</p><p>手册也提到了rfd过小可以捕获到:</p><blockquote><p>Software can determine the current RU status by reading the SCB status word in the CSR (bits 5:2).<br>No Resources Due to No More RFDs (0010).</p></blockquote><p>添加测试代码果然有， 也验证了之前的猜测。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>后面改大RFD, CFD的number，就是initString中，一般在sysFei82557 or configNet.h中。改大后正常。</p><p>公开手册是8255X_OpenSDM.pdf。</p>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VxWorks </tag>
            
            <tag> Fei82557 </tag>
            
            <tag> END </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移植spansion boot flash LLD</title>
      <link href="/port-spansion-flash-drv.html"/>
      <url>/port-spansion-flash-drv.html</url>
      
        <content type="html"><![CDATA[<p>2010年VxWorks下做过的boot flash driver，记录下。</p><h2 id="BSP配置"><a href="#BSP配置" class="headerlink" title="BSP配置"></a>BSP配置</h2><p>首先要确保配置正确。</p><ul><li>mmu cache not： vxworks中sysPhysMem的vm state必须是VM_CACHE_NOT,否则访问不到。linux中是ioremap。</li><li>address map: vx中要添加flash map space,否则d时不能访问；另,bsp mmu的配置要和cpu bus controller配置一致，否则d 访问时显示不全。例如，ppc的Local Bus的BR0,OR0用于boot访问，BR0和OR0的address mask配置要和mmu的map address一致。</li></ul><h2 id="Flash操作"><a href="#Flash操作" class="headerlink" title="Flash操作"></a>Flash操作</h2><ul><li>how cpu access flash, define the cpu_read&#x2F;write interface of your target</li></ul><p>cpu和flash之间有没有其他的dev(如pld),如果有就要知道这个dev是如何从cpu address译码成flash address的。根据这个我们定义cpu上rd&#x2F;wr flash的接口：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLASHDATA BYTE <span class="comment">/* or WORD or DWORD */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_OFFSET(b,o)   (*(( (volatile FLASHDATA*)(b) ) + (o)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_WR(b,o,d)     FLASH_OFFSET((b),(o)) = (d)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_RD(b,o)       FLASH_OFFSET((b),(o))</span></span><br></pre></td></tr></table></figure><ul><li>where to operation</li></ul><p>小容量的flash(1M)基本是全片操作，而在大容量的flash里，如s29gl128n是16M,会对flash划分空间，只有某个空间是可以操作的。就要注意flash空间的address map了。</p><ul><li>first find device id then erase&#x2F;write</li></ul><p>先找device id 因为这个操作最简单，确保能找到flash的前几个bus cycle,后面擦写数据也用到这几个bus cycle。如果成功找到chip id,flash的大片地方全有规律显示出id值。注意有的片子可能支持x8,x16两种模式，这个 FLASHDATA 用来标识。在找chip id时，FLASHDATA按x8和x16应该都能找到，然后根据datasheet确定是x8还是x16的id，确定x8 or x16后再擦写。</p><h2 id="LLD接口"><a href="#LLD接口" class="headerlink" title="LLD接口"></a>LLD接口</h2><p>这里主要说下spansion LLD在移植中的问题。</p><ul><li>lld_GetDeviceId: 在lld_AutoselectEntryCmd后需延迟下读id,防止你的cpu过快;</li><li>lld_Poll: 在erase 大片时verify时需要loop delay,如erase sector, 而在verify program时只需要简单的loop就可以，否则program速度就太慢拉。</li><li>lld_StatusGet: erase和program都没有必要去check DQ2,因为手册提到DQ2是在erase supend&#x2F;program supend模式，而我就没用。不去掉这个lld_Poll中会有问题。</li><li>lld_memcpy: 其实这个接口没必要用，自己写个loop, call write buffer or write byte都可以。</li></ul>]]></content>
      
      
      <categories>
          
          <category> dd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spansion </tag>
            
            <tag> Boot Flash </tag>
            
            <tag> VxWorks </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>高通平台AB系统刷机说明 | TJ的技术博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">高通平台AB系统刷机说明</h1><a id="logo" href="/.">TJ的技术博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 首页</i></a><a href="/archives/"><i class="fa undefined"> 归档</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">高通平台AB系统刷机说明</h1><div class="post-meta">2018-11-06</div><div class="post-content"><p>A&#x2F;B系统是Google推的一种OTA升级方法，就是为了方便，简单说就是多了个备份区，升级时写备份区然后尝试从备份区启动，如果启动ok，就把备份区作为主区，遥想当年ROS平台bootloader就有这么个东东。</p>
<p>这里不关心OTA流程，我们关心的是A&#x2F;B系统分区选择相关，A&#x2F;B下刷机要不要带_a, _b。</p>
<p>ok，先让我们看下官方对分区选择说明：</p>
<blockquote>
<p>A&#x2F;B system updates use two sets of partitions referred to as <em>slots</em> (normally slot A and slot B). The system runs from the <em>current</em> slot while the partitions in the <em>unused</em> slot are not accessed by the running system during normal operation.</p>
<p>Each slot has a <em>bootable</em> attribute that states whether the slot contains a correct system from which the device can boot. </p>
<p>Each slot also has a <em>successful</em> attribute set by the user space, which is relevant only if the slot is also bootable. A successful slot should be able to boot, run, and update itself. A bootable slot that was not marked as successful (after several attempts were made to boot from it) should be marked as unbootable by the bootloader, including changing the active slot to another bootable slot (normally to the slot running immediately before the attempt to boot into the new, active one). </p>
</blockquote>
<p>高通在LK下对A&#x2F;B支持的文件是: ab_partition_parser.c，来看下当fastboot刷机时LK是如何解析的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find index of parition in array of partition entries</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition_get_index</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> input_string_length = <span class="built_in">strlen</span>(name);</span><br><span class="line">	<span class="type">unsigned</span> n;</span><br><span class="line">	<span class="type">int</span> curr_slot = INVALID;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *suffix_curr_actv_slot = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">char</span> *curr_suffix = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( partition_count &gt;= NUM_PARTITIONS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> INVALID_PTN;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*	We iterate through the parition entries list,</span></span><br><span class="line"><span class="comment">		to find the partition with active slot suffix.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; partition_count; n++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strncmp</span>((<span class="type">const</span> <span class="type">char</span>*)name, (<span class="type">const</span> <span class="type">char</span> *)partition_entries[n].name,</span><br><span class="line">					input_string_length))</span><br><span class="line">		&#123;</span><br><span class="line">			curr_suffix = (<span class="type">char</span> *)(partition_entries[n].name+input_string_length);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* if partition_entries.name is NULL terminated return the index */</span></span><br><span class="line">			<span class="keyword">if</span> (*curr_suffix == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">				<span class="keyword">return</span> n; <span class="comment">// tj: 完全一致名称</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (partition_multislot_is_supported())</span><br><span class="line">			&#123;</span><br><span class="line">				curr_slot = partition_find_active_slot();</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* If suffix string matches with current active slot suffix return index */</span></span><br><span class="line">				<span class="keyword">if</span> (curr_slot != INVALID)</span><br><span class="line">				&#123;</span><br><span class="line">					suffix_curr_actv_slot = SUFFIX_SLOT(curr_slot);</span><br><span class="line">					<span class="keyword">if</span> (!<span class="built_in">strncmp</span>((<span class="type">const</span> <span class="type">char</span> *)curr_suffix, suffix_curr_actv_slot,</span><br><span class="line">							<span class="built_in">strlen</span>(suffix_curr_actv_slot)))</span><br><span class="line">						<span class="keyword">return</span> n;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">/* No valid active slot */</span></span><br><span class="line">					<span class="keyword">return</span> INVALID_PTN;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> INVALID_PTN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先要在分区表里找到这个name，如果完全一致那就是这个分区，对有ab分区的，找到active slot:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	This function returns the most priority and active slot,</span></span><br><span class="line"><span class="comment">	also you need to update the global state seperately.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition_find_active_slot</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">for</span> (boot_priority = MAX_PRIORITY;</span><br><span class="line">			boot_priority &gt; <span class="number">0</span>; boot_priority--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Search valid boot slot with highest priority */</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; AB_SUPPORTED_SLOTS; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			current_priority = slot_priority(partition_entries, boot_slot_index[i]);</span><br><span class="line">			current_active_bit = slot_is_active(partition_entries, boot_slot_index[i]);</span><br><span class="line">			current_bootable_bit = slot_is_bootable(partition_entries, boot_slot_index[i]);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Count number of slots with all attributes as zero */</span></span><br><span class="line">			<span class="keyword">if</span> ( !current_priority &amp;&amp;</span><br><span class="line">				!current_active_bit &amp;&amp;</span><br><span class="line">				current_bootable_bit)</span><br><span class="line">			&#123;</span><br><span class="line">				count ++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>如上，忽略non active, non bootable, non priority的slot，对首次烧录都是non的给个default: <code>SLOT_A</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* All slots are zeroed, this is first bootup */</span></span><br><span class="line"><span class="comment">/* Marking and trying SLOT 0 as default */</span></span><br><span class="line"><span class="keyword">if</span> (count == AB_SUPPORTED_SLOTS)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Update the priority of the boot slot */</span></span><br><span class="line">	partition_activate_slot(SLOT_A);</span><br><span class="line"></span><br><span class="line">	active_slot = SLOT_A;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This is required to mark all bits as active,</span></span><br><span class="line"><span class="comment">	for fresh boot post fresh flash */</span></span><br><span class="line">	mark_all_partitions_active(active_slot);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到<code>partition_get_index</code>，它会返回这个active slot的partition index。</p>
<p>也就是说，如果我们敲入了flash system，其实烧录的就是system active slot。唯一例外就是boot分区:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmd_flash_mmc_img</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">void</span> *data, <span class="type">unsigned</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">			index = partition_get_index(pname);</span><br><span class="line">			ptn = partition_get_offset(index);</span><br><span class="line">			<span class="keyword">if</span>(ptn == <span class="number">0</span>) &#123;</span><br><span class="line">				fastboot_fail(<span class="string">&quot;partition table doesn&#x27;t exist&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">strncmp</span>(pname, <span class="string">&quot;boot&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;boot&quot;</span>))</span><br><span class="line">					|| !<span class="built_in">strcmp</span>(pname, <span class="string">&quot;recovery&quot;</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">memcmp</span>((<span class="type">void</span> *)data, BOOT_MAGIC, BOOT_MAGIC_SIZE)) &#123;</span><br><span class="line">					fastboot_fail(<span class="string">&quot;image is not a boot image&quot;</span>);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* Reset multislot_partition attributes in case of flashing boot */</span></span><br><span class="line">				<span class="keyword">if</span> (partition_multislot_is_supported())</span><br><span class="line">				&#123;</span><br><span class="line">					partition_reset_attributes(index);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>注释写的很清楚，如果要烧boot，就要复位这个active slot分区的属性:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Function: To reset partition attributes</span></span><br><span class="line"><span class="comment">	This function reset partition_priority, retry_count</span></span><br><span class="line"><span class="comment">	and clear successful and bootable bits.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">partition_reset_attributes</span><span class="params">(<span class="type">unsigned</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">partition_entry</span> *<span class="title">partition_entries</span> =</span></span><br><span class="line">					partition_get_partition_entries();</span><br><span class="line"></span><br><span class="line">	partition_entries[index].attribute_flag |= (PART_ATT_PRIORITY_VAL |</span><br><span class="line">				PART_ATT_MAX_RETRY_COUNT_VAL);</span><br><span class="line"></span><br><span class="line">	partition_entries[index].attribute_flag &amp;= ((~PART_ATT_SUCCESSFUL_VAL) &amp;</span><br><span class="line">						(~PART_ATT_UNBOOTABLE_VAL));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!attributes_updated)</span><br><span class="line">		attributes_updated = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make attributes persistant */</span></span><br><span class="line">	partition_mark_active_slot(active_slot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见把分区表里这个index的分区属性全部clear了，比如变成了non bootable，non successful，这样在前面的<code>partition_find_active_slot</code>就找不到这个active slot， 比如当前active slot是slot a, 敲入flash boot后，boot_a内容更新了但是不再是active了。此时fastboot reboot到底走不走boot_a要看boot_b是不是active，所以保险起见，还是boot_a[b]都烧入，rt?</p>
<p>有人会问如何判断系统用了A&#x2F;B，我想有一种方法就是在fastboot看下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\&gt;fastboot getvar all</span><br><span class="line">...</span><br><span class="line">(bootloader) slot-count:2</span><br><span class="line">(bootloader) current-slot:a</span><br><span class="line">(bootloader) slot-retry-count:b:0</span><br><span class="line">(bootloader) slot-success:b:No</span><br><span class="line">(bootloader) slot-active:b:No</span><br><span class="line">(bootloader) slot-unbootable:b:No</span><br><span class="line">(bootloader) slot-retry-count:a:6</span><br><span class="line">(bootloader) slot-success:a:Yes</span><br><span class="line">(bootloader) slot-active:a:Yes</span><br><span class="line">(bootloader) slot-unbootable:a:No</span><br><span class="line">(bootloader) has-slot:userdata: No</span><br><span class="line">(bootloader) has-slot:vendor: Yes</span><br><span class="line">(bootloader) has-slot:system: Yes</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Google对刷机时间的说明：</p>
<blockquote>
<p>Does flashing two system partitions increase factory flashing time?<br>No. Pixel didn’t increase in system image size (it merely divided the space across two partitions).</p>
</blockquote>
<p>so，出厂刷机没必要_a&#x2F;_b都刷，rt?</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>版权声明：</span>本站所有文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明原文链接！</p></div><br><div class="tags"><a href="/tags/A/B"><i class="fa fa-tag">A/B</i></a></div><div class="post-nav"><a class="pre" href="/analyze-oem-unlocking-under-android.html">Android平台OEM解锁分析</a><a class="next" href="/fix-an-issue-about-always-stuck-on-encrypting.html">分析解决安卓启动一直卡在加密界面的问题</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/how-to-use-adeb-to-install-bcc-into-android.html">转: 使用 adeb 在 Android 上编译安装 bcc</a></li><li class="post-list-item"><a class="post-list-link" href="/kworker-sched-la-stat.html">kworker 调度延迟性能测试和统计</a></li><li class="post-list-item"><a class="post-list-link" href="/implement-erofs-fragment-dedupe.html">转：EROFS 碎片去重实践</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-enable-kasan-in-ubuntu-18-04-for-x86_64.html">How to enable KASAN in Ubuntu 18.04 for X86_64</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-analyze-segmentation-fault-for-non-install-package-in-ubuntu.html">如何分析 Linux user space's segmentation fault</a></li><li class="post-list-item"><a class="post-list-link" href="/prepare-fragment-dedupe-in-erofs.html">EROFS 碎片去重准备</a></li><li class="post-list-item"><a class="post-list-link" href="/good-naming-in-programming.html">优秀代码命名法</a></li><li class="post-list-item"><a class="post-list-link" href="/erofs-compressed-data-deduplication.html">EROFS 压缩去重分析</a></li><li class="post-list-item"><a class="post-list-link" href="/analyze-fscache-cookie-code.html">转：浅析 Linux FS-Cache</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-let-bluetooth-work-under-armbian-kodi-for-rockpi4b-within-metal-case.html">Rockpi4b Armbian Kodi 终于能使用蓝牙了</a></li></ul></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arm/">ARM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dd/">Device Driver</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fs/">File System</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iot/">IoT</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/msm/">MSM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mm/">Memory Management</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/perf/">Performance</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">Security</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/stab/">Stability</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">Tools</a><span class="category-list-count">18</span></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">TJ的技术博客.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
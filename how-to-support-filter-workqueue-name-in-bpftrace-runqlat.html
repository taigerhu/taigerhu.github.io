<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>如何使 bpftrace:runqlat.bt 按 workqueue name 统计延迟 | TJ的技术博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">如何使 bpftrace:runqlat.bt 按 workqueue name 统计延迟</h1><a id="logo" href="/.">TJ的技术博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 首页</i></a><a href="/archives/"><i class="fa undefined"> 归档</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">如何使 bpftrace:runqlat.bt 按 workqueue name 统计延迟</h1><div class="post-meta">2023-03-14</div><div class="post-content"><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当我们想利用 ebpf 统计 task&#x2F;kworker 的调度延迟，通常有两个前端选择，一是 bcc，另一个是 bpftrace。而如果要自定义，通常选择先上手 bpftrace，因为简单。</p>
<p>bpftrace&#x2F;tools 下的工具 runqlat.bt 就可以统计调度延迟，只不过输出是直方图，我们希望能够像 <code>perf sched</code> 那样输出 task&#x2F;kworker 的调度延迟时间。</p>
<h2 id="浏览-runqlat-bt"><a href="#浏览-runqlat-bt" class="headerlink" title="浏览 runqlat.bt"></a>浏览 runqlat.bt</h2><p>先浏览下代码，参考 v0.11.4:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1 #!/usr/bin/env bpftrace</span><br><span class="line"> 2 /*</span><br><span class="line"> 3  * runqlat.bt   CPU scheduler run queue latency as a histogram.</span><br><span class="line"> 4  *              For Linux, uses bpftrace, eBPF.</span><br><span class="line"> 5  *</span><br><span class="line"> 6  * This is a bpftrace version of the bcc tool of the same name.</span><br><span class="line"> 7  *</span><br><span class="line"> 8  * Copyright 2018 Netflix, Inc.</span><br><span class="line"> 9  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;)</span><br><span class="line">10  *</span><br><span class="line">11  * 17-Sep-2018  Brendan Gregg   Created this.</span><br><span class="line">12  */</span><br><span class="line">13</span><br><span class="line">14 #include &lt;linux/sched.h&gt;</span><br><span class="line">15</span><br><span class="line">16 BEGIN</span><br><span class="line">17 &#123;</span><br><span class="line">18         printf(&quot;Tracing CPU scheduler... Hit Ctrl-C to end.\n&quot;);</span><br><span class="line">19 &#125;</span><br><span class="line">20</span><br><span class="line">21 tracepoint:sched:sched_wakeup,</span><br><span class="line">22 tracepoint:sched:sched_wakeup_new</span><br><span class="line">23 &#123;</span><br><span class="line">24         @qtime[args-&gt;pid] = nsecs;</span><br><span class="line">25 &#125;</span><br><span class="line">26</span><br><span class="line">27 tracepoint:sched:sched_switch</span><br><span class="line">28 &#123;</span><br><span class="line">29         if (args-&gt;prev_state == TASK_RUNNING) &#123;</span><br><span class="line">30                 @qtime[args-&gt;prev_pid] = nsecs;</span><br><span class="line">31         &#125;</span><br><span class="line">32</span><br><span class="line">33         $ns = @qtime[args-&gt;next_pid];</span><br><span class="line">34         if ($ns) &#123;</span><br><span class="line">35                 @usecs = hist((nsecs - $ns) / 1000);</span><br><span class="line">36         &#125;</span><br><span class="line">37         delete(@qtime[args-&gt;next_pid]);</span><br><span class="line">38 &#125;</span><br><span class="line">39</span><br><span class="line">40 END</span><br><span class="line">41 &#123;</span><br><span class="line">42         clear(@qtime);</span><br><span class="line">43 &#125;</span><br></pre></td></tr></table></figure>

<p>行数不多，看上去也很简单，对于首次接触 bpftrace 的这段代码主要盲点: <code>args/@/$/nsecs/hist/delete/clear/BEGIN/END</code>。</p>
<p>先运行下看看：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@localhost:/bpftrace# bpftrace tools/runqlat.bt</span><br><span class="line">Attaching 5 probes...</span><br><span class="line">Tracing CPU scheduler... Hit Ctrl-C to end.</span><br><span class="line">^C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@usecs:</span><br><span class="line">[2, 4)               236 |@@@@@@@@@                                           |</span><br><span class="line">[4, 8)              1109 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      |</span><br><span class="line">[8, 16)             1246 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|</span><br><span class="line">[16, 32)             772 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    |</span><br><span class="line">[32, 64)             233 |@@@@@@@@@                                           |</span><br><span class="line">[64, 128)            318 |@@@@@@@@@@@@@                                       |</span><br><span class="line">[128, 256)           147 |@@@@@@                                              |</span><br><span class="line">[256, 512)            42 |@                                                   |</span><br><span class="line">[512, 1K)             52 |@@                                                  |</span><br><span class="line">[1K, 2K)              22 |                                                    |</span><br><span class="line">[2K, 4K)               7 |                                                    |</span><br></pre></td></tr></table></figure>

<p>这些输出是怎么产生的？带着这些疑问来认识 bpftrace。</p>
<h2 id="了解-bpftrace-语言"><a href="#了解-bpftrace-语言" class="headerlink" title="了解 bpftrace 语言"></a>了解 bpftrace 语言</h2><p>基本语法就是：<code>probe[,probe,...] /filter/ &#123; action &#125;</code></p>
<p>probe 可以有多种，比如这里的 traceponit，action 可以有多个，filter 是过滤条件，可写可不写，看情况。</p>
<ul>
<li>@, $</li>
</ul>
<p>代表变量类型，<code>@</code> 表示全局 (map variables)，而 <code>$</code> 表示 scratch variables(栈变量？)</p>
<p><code>@[]</code> 表示关联数组，它是 map variable 的变体，格式 <code>@array_name[key_name, key_name2, ...] = value</code>, 类似 hash or Python Dict：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Dict = &#123;1: <span class="string">&#x27;Geeks&#x27;</span>, 2: <span class="string">&#x27;For&#x27;</span>, 3: <span class="string">&#x27;Geeks&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt; Dict</span><br><span class="line">&#123;1: <span class="string">&#x27;Geeks&#x27;</span>, 2: <span class="string">&#x27;For&#x27;</span>, 3: <span class="string">&#x27;Geeks&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt; Dict[1]</span><br><span class="line"><span class="string">&#x27;Geeks&#x27;</span></span><br><span class="line">&gt;&gt;&gt; Dict[2]</span><br><span class="line"><span class="string">&#x27;For&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>args</li>
</ul>
<p>docs&#x2F;tutorial_one_liners.md:</p>
<blockquote>
<p><code>args</code> is a pointer to a struct containing all the tracepoint arguments. This<br>struct is automatically generated by bpftrace based tracepoint information.</p>
</blockquote>
<p><code>args</code> 是一个指针，指向该 tracepoint 的所有参数。这个结构是由 bpftrace 根据 tracepoint 信息自动生成。</p>
<p>可以用如下命令找出这个结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:/<span class="comment"># bpftrace -vl &#x27;tracepoint:sched:sched_wakeup&#x27;</span></span><br><span class="line">tracepoint:<span class="built_in">sched</span>:sched_wakeup</span><br><span class="line">    char <span class="built_in">comm</span>[16];</span><br><span class="line">    pid_t pid;</span><br><span class="line">    int prio;</span><br><span class="line">    int success;</span><br><span class="line">    int target_cpu;</span><br><span class="line">    long state;</span><br></pre></td></tr></table></figure>

<p>再看下 wakeup tracepoint code:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ttwu_do_wakeup</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> wake_flags,</span></span><br><span class="line"><span class="params">                           <span class="keyword">struct</span> rq_flags *rf)</span></span><br><span class="line">&#123;</span><br><span class="line">        check_preempt_curr(rq, p, wake_flags);</span><br><span class="line">        p-&gt;state = TASK_RUNNING;</span><br><span class="line">        trace_sched_wakeup(p);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_EVENT(sched_wakeup_template, sched_wakeup,</span><br><span class="line">             TP_PROTO(<span class="keyword">struct</span> task_struct *p),</span><br><span class="line">             TP_ARGS(p));</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_EVENT_CLASS(sched_wakeup_template,</span><br><span class="line"></span><br><span class="line">        TP_PROTO(<span class="keyword">struct</span> task_struct *p),</span><br><span class="line"></span><br><span class="line">        TP_ARGS(__perf_task(p)),</span><br><span class="line"></span><br><span class="line">        TP_STRUCT__entry(</span><br><span class="line">                __array(        <span class="type">char</span>,   comm,   TASK_COMM_LEN   )</span><br><span class="line">                __field(        <span class="type">pid_t</span>,  pid                     )</span><br><span class="line">                __field(        <span class="type">int</span>,    prio                    )</span><br><span class="line">                __field(        <span class="type">int</span>,    success                 )</span><br><span class="line">                __field(        <span class="type">int</span>,    target_cpu              )</span><br><span class="line">        ),</span><br></pre></td></tr></table></figure>

<p>到这里就清晰了，这个 <code>args</code> 就指向 <code>TP_STRUCT__entry</code>。</p>
<ul>
<li>nsecs</li>
</ul>
<p>内置变量，里面用的是 <code>&#123;bpf_&#125;ktime_get_ns()</code>。</p>
<ul>
<li>BEGIN, END</li>
</ul>
<blockquote>
<p>These are special built-in events provided by the bpftrace runtime. BEGIN is triggered before all other probes are attached. END is triggered after all other probes are detached.</p>
</blockquote>
<p>内置probe，管开头和结束。</p>
<ul>
<li>delete&#x2F;clear&#x2F;hist</li>
</ul>
<p>都是内置 map functions，map 是一种特殊的 data type，除了用作 variable 外，还可以用来存储直方图（调用hist） 等。</p>
<p><code>delete</code> 是从 map 里删除一个 key，所以要指定 key，比如上面的 <code>delete(@qtime[args-&gt;next_pid])</code>，</p>
<p>而 <code>clear</code> 是清除 map 里所有 keys&#x2F;values, 所以语法是 <code>clear(map m)</code>, 比如上面的 <code>clear(@qtime)</code>。</p>
<p>bpftrace 退出时所有的 maps 都会打印出来, 不想打就在 END block 里加上 <code>clear</code>。</p>
<p>ok, 在了解下这些基本语言规则后，我们来修改这个 bt 文件。</p>
<h2 id="修改-runqlat-bt"><a href="#修改-runqlat-bt" class="headerlink" title="修改 runqlat.bt"></a>修改 runqlat.bt</h2><p>调度延迟的时间就是从 wakeup 开始一直到 start running 这个时间点。</p>
<p>wakeup 时记录 wakeup time 到 <code>@qtimes[task_id]</code> 里，而在 switch 时，用 <code>nsecs</code> 减去这个 wakeup 的时间(前提要存在)就是这个 task 的调度延迟。</p>
<p>来看下 kernel <code>trace_sched_switch()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TRACE_EVENT(sched_switch,</span><br><span class="line"></span><br><span class="line">        TP_PROTO(<span class="type">bool</span> preempt,</span><br><span class="line">                 <span class="keyword">struct</span> task_struct *prev,</span><br><span class="line">                 <span class="keyword">struct</span> task_struct *next),</span><br><span class="line"></span><br><span class="line">        TP_ARGS(preempt, prev, next),</span><br><span class="line"></span><br><span class="line">        TP_STRUCT__entry(</span><br><span class="line">                __array(        <span class="type">char</span>,   prev_comm,      TASK_COMM_LEN   )</span><br><span class="line">                __field(        <span class="type">pid_t</span>,  prev_pid                        )</span><br><span class="line">                __field(        <span class="type">int</span>,    prev_prio                       )</span><br><span class="line">                __field(        <span class="type">long</span>,   prev_state                      )</span><br><span class="line">                __array(        <span class="type">char</span>,   next_comm,      TASK_COMM_LEN   )</span><br><span class="line">                __field(        <span class="type">pid_t</span>,  next_pid                        )</span><br><span class="line">                __field(        <span class="type">int</span>,    next_prio                       )</span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">        TP_fast_assign(</span><br><span class="line">                <span class="built_in">memcpy</span>(__entry-&gt;next_comm, next-&gt;comm, TASK_COMM_LEN);</span><br><span class="line">                __entry-&gt;prev_pid       = prev-&gt;pid;</span><br><span class="line">                __entry-&gt;prev_prio      = prev-&gt;prio;</span><br><span class="line">                __entry-&gt;prev_state     = __trace_sched_switch_state(preempt, prev);</span><br><span class="line">                <span class="built_in">memcpy</span>(__entry-&gt;prev_comm, prev-&gt;comm, TASK_COMM_LEN);</span><br><span class="line">                __entry-&gt;next_pid       = next-&gt;pid;</span><br><span class="line">                __entry-&gt;next_prio      = next-&gt;prio;</span><br></pre></td></tr></table></figure>

<p>我们关心的是 <code>prev_comm</code> 和 <code>next_comm</code>，<code>next</code> 是即将 running 的 task，所以 switch block 可以改成：</p>
<figure class="highlight patch"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        $ns = @qtime[args-&gt;next_pid];</span><br><span class="line">        if ($ns) &#123;</span><br><span class="line"><span class="deletion">-               @usecs = hist((nsecs - $ns) / 1000);</span></span><br><span class="line"><span class="addition">+               @uesc[args-&gt;next_comm] = ((nsecs - $ns) / 1000);</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这样就输出所有 tasks 的调度延迟了，效果如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Attaching 5 probes...</span><br><span class="line">Tracing CPU scheduler... Hit Ctrl-C to end.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@usecs[ksoftirqd/6]: 14</span><br><span class="line">@usecs[swapper/2]: 14</span><br><span class="line">@usecs[swapper/1]: 17</span><br><span class="line">@usecs[swapper/0]: 17</span><br><span class="line">@usecs[kworker/7:1]: 32</span><br><span class="line">@usecs[swapper/6]: 42</span><br><span class="line">@usecs[kworker/6:1]: 50</span><br><span class="line">@usecs[kworker/3:2]: 57</span><br></pre></td></tr></table></figure>

<p>因为要 Ctrl-c 才终止，把 <code>bpftrace tools/runqlat.bt</code> 输出重定向到文本，<code>grep kworker</code> 搜索这个文本即可完成 kworker 统计。</p>
<p>那代码要支持过滤 kworker 怎么写了？高版本有字符串包含，这个版本只有 <code>strncmp</code>，修改如下:</p>
<figure class="highlight patch"><table><tr><td class="code"><pre><span class="line"> tracepoint:sched:sched_wakeup_new</span><br><span class="line"> &#123;</span><br><span class="line"><span class="deletion">-       @qtime[args-&gt;pid] = nsecs;</span></span><br><span class="line"><span class="addition">+       if (!strncmp(args-&gt;comm, &quot;kworker&quot;, 7)) &#123;</span></span><br><span class="line"><span class="addition">+               @qtime[args-&gt;pid] = nsecs;</span></span><br><span class="line"><span class="addition">+       &#125;</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> tracepoint:sched:sched_switch</span><br><span class="line"> &#123;</span><br><span class="line">        if (args-&gt;prev_state == TASK_RUNNING) &#123;</span><br><span class="line"><span class="deletion">-               @qtime[args-&gt;prev_pid] = nsecs;</span></span><br><span class="line"><span class="addition">+               if (!strncmp(args-&gt;prev_comm, &quot;kworker&quot;, 7)) &#123;</span></span><br><span class="line"><span class="addition">+                       @qtime[args-&gt;prev_pid] = nsecs;</span></span><br><span class="line"><span class="addition">+               &#125;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这样一次性统计所有 kworker 的调度延迟，我们跑下看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Attaching 5 probes...</span><br><span class="line">Tracing CPU scheduler... Hit Ctrl-C to end.</span><br><span class="line">^C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@usecs[kworker/3:2]: 40</span><br><span class="line">@usecs[kworker/u17:2]: 44</span><br><span class="line">@usecs[kworker/7:1]: 64</span><br><span class="line">@usecs[kworker/u16:14]: 81</span><br><span class="line">@usecs[kworker/6:1]: 92</span><br><span class="line">@usecs[kworker/u16:5]: 120</span><br><span class="line">@usecs[kworker/u16:7]: 121</span><br><span class="line">@usecs[kworker/u16:1]: 124</span><br></pre></td></tr></table></figure>

<p>怎么没有 workqueue name? 方括号里的显示来自 <code>args-&gt;next_comm</code>，也就是入参 <code>next</code> 的 <code>comm</code>，来看 kernel 部分(大概还有一半-)。</p>
<p>btw: 看了下最新的 Linux 6.3rc 也不支持。</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>版权声明：</span>本站所有文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明原文链接！</p></div><br><div class="tags"><a href="/tags/bpftrace"><i class="fa fa-tag">bpftrace</i></a><a href="/tags/runqlat"><i class="fa fa-tag">runqlat</i></a></div><div class="post-nav"><a class="pre" href="/why-cpu-intensive-work-is-meaningless-for-unbound-wq.html">为什么 WQ_CPU_INTENSIVE 对 unbound 工作队列没有意义</a><a class="next" href="/how-to-support-workqueue-name-for-perf-sched.html">如何使 perf sched 支持 workqueue name</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/how-to-xmit-evt-response-to-bt-vendor-lib-in-oh.html">How to transmit evt response to BT vendor lib in OH</a></li><li class="post-list-item"><a class="post-list-link" href="/kernel-cfi-failure-analysis.html">Kernel CFI failure实例分析</a></li><li class="post-list-item"><a class="post-list-link" href="/linux-kernel-drm-overview.html">Linux kernel DRM overview</a></li><li class="post-list-item"><a class="post-list-link" href="/upgrade-my-custom-build-server-amd-based.html">我的PC组装升级记</a></li><li class="post-list-item"><a class="post-list-link" href="/convert-typecho-to-hexo.html">I am back!</a></li><li class="post-list-item"><a class="post-list-link" href="/review-freezing-issue-when-drag-icon-after-ohos-adaption.html">OpenHarmony适配后图标拖拽卡屏问题回顾</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-fix-parse-too-complex-in-source-insight.html">Source Insight 自定义解析</a></li><li class="post-list-item"><a class="post-list-link" href="/adapt-ohos-for-mali-g57-on-sprd-t606.html">转：拥抱鸿蒙 - 在展讯T606平台上的探索与实践</a></li><li class="post-list-item"><a class="post-list-link" href="/essential-inventory-of-adaption-for-unisoc-platform-androidt-based.html">展讯平台 OpenHarmony 3.2.2 适配基础盘点</a></li><li class="post-list-item"><a class="post-list-link" href="/porting-openharmony-linux-kernel-to-3rd-party-chip.html">快速移植 OpenHarmony Linux 内核到三方 ARM64 平台</a></li></ul></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arm/">arm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dd/">dd</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ebpf/">ebpf</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fs/">fs</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iot/">iot</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mm/">mm</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/msm/">msm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ohos/">ohos</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/perf/">perf</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">security</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/stab/">stab</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">tools</a><span class="category-list-count">20</span></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">TJ的技术博客.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
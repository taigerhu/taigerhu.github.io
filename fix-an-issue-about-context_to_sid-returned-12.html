<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>SELinux: fix an issue about context_to_sid returned 12 | TJ的技术博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">SELinux: fix an issue about context_to_sid returned 12</h1><a id="logo" href="/.">TJ的技术博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 首页</i></a><a href="/archives/"><i class="fa undefined"> 归档</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">SELinux: fix an issue about context_to_sid returned 12</h1><div class="post-meta">2018-04-26</div><div class="post-content"><p>前方用户提了个故障说手机发热低电下重启后发现有SD掉卡提示，Android_N&#x2F;Kernel_3.18，离线日志找了半天，logcat日志里发现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">434   439 E vold    : Failed to pclose /system/bin/sgdisk --android-dump /dev/block/vold/disk:179:64 : Success</span><br><span class="line">434   439 W vold    : disk:179:64 has unknown partition table; trying entire device</span><br></pre></td></tr></table></figure>

<p>代码在system&#x2F;vold&#x2F;Disk.cpp：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Disk::readPartitions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Ugly last ditch effort, treat entire disk as partition</span></span><br><span class="line">    <span class="keyword">if</span> (table == Table::kUnknown || !foundParts) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; mId &lt;&lt; <span class="string">&quot; has unknown partition table; trying entire device&quot;</span>;</span><br><span class="line"></span><br><span class="line">        std::string fsType;</span><br><span class="line">        std::string unused;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ReadMetadataUntrusted</span>(mDevPath, fsType, unused, unused) == OK) &#123;</span><br><span class="line">            <span class="built_in">createPublicVolume</span>(mDevice);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(WARNING) &lt;&lt; mId &lt;&lt; <span class="string">&quot; failed to identify, giving up&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数往上再看看：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Disk::readPartitions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Parse partition table</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::string&gt; cmd;</span><br><span class="line">    cmd.<span class="built_in">push_back</span>(kSgdiskPath);</span><br><span class="line">    cmd.<span class="built_in">push_back</span>(<span class="string">&quot;--android-dump&quot;</span>);</span><br><span class="line">    cmd.<span class="built_in">push_back</span>(mDevPath);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::string&gt; output;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;ForkExe before&quot;</span>;</span><br><span class="line">    <span class="type">status_t</span> res = <span class="built_in">ForkExecvp</span>(cmd, output);</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;sgdisk failed to scan &quot;</span> &lt;&lt; mDevPath;</span><br><span class="line">        <span class="built_in">notifyEvent</span>(ResponseCode::DiskScanned);</span><br><span class="line">        mJustPartitioned = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>它是用sgdisk工具来分析分区表，只不过分析失败了，内核log里mmc1啥错也没有，不过有sgdisk权限出错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    4.064447] SELinux: inode_doinit_with_dentry:  context_to_sid(u:object_r:sgdisk_exec:s0) returned 12 for dev=dm-0 ino=666</span><br><span class="line">[    4.064656] type=1400 audit(1726218.699:6): avc: denied &#123; execute &#125; for pid=441 comm=&quot;sh&quot; name=&quot;sgdisk&quot; dev=&quot;dm-0&quot; ino=666 scontext=u:r:vold:s0 tcontext=u:object_r:unlabeled:s0 tclass=file permissive=0</span><br></pre></td></tr></table></figure>

<p>怎么会有sgdisk这个错，看了下正常的log里是没有的。我决定复现看看，在尝试了多次后尽然让我复现了，和低电量就没有关系，复现以后拔出SD卡再插入仍然提示SD corrupted，dmesg多出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[  459.510818] mmc1: new ultra high speed SDR25 SDHC card at address 0001</span><br><span class="line">[  459.514104] mmcblk1: mmc1:0001 SD16G 14.4 GiB</span><br><span class="line">[  459.518791]  mmcblk1: p1</span><br><span class="line">[  459.545324] type=1400 audit(1515436020.539:39): avc: denied &#123; execute &#125; for p</span><br><span class="line">id=4850 comm=&quot;sh&quot; name=&quot;sgdisk&quot; dev=&quot;dm-0&quot; ino=666 scontext=u:r:vold:s0 tcontext</span><br><span class="line">=u:object_r:unlabeled:s0 tclass=file permissive=0</span><br></pre></td></tr></table></figure>

<p>内核已经检测出来mmc1，不过sgdisk权限出错，我们再看下出错时sgdisk权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxx:/ # ls -Z /system/bin/sgdisk</span><br><span class="line">u:object_r:unlabeled:s0 /system/bin/sgdisk</span><br></pre></td></tr></table></figure>

<p>sgdisk文件权限确是在system&#x2F;sepolicy&#x2F;file_contexts定义过的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/system/bin/sgdisk      u:object_r:sgdisk_exec:s0</span><br><span class="line">/system/bin/blkid       u:object_r:blkid_exec:s0</span><br><span class="line">/system/bin/tzdatacheck u:object_r:tzdatacheck_exec:s0</span><br></pre></td></tr></table></figure>

<p>再看看其他的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxx:/ # ls -Z /system/bin/blkid</span><br><span class="line">u:object_r:blkid_exec:s0 /system/bin/blkid</span><br><span class="line">xxx:/ # ls -Z /system/bin/ | grep unlabel</span><br><span class="line">u:object_r:unlabeled:s0              sgdisk</span><br><span class="line">xxx:/ #</span><br></pre></td></tr></table></figure>

<p>点背，只有sgdisk有问题，file_contexts是被编译到file_contexts.bin里的，参考Android.mk:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">LOCAL_MODULE := file_contexts.bin</span><br><span class="line">local_fc_files := <span class="variable">$(LOCAL_PATH)</span>/file_contexts</span><br></pre></td></tr></table></figure>

<p>ok, sgdisk为什么没有权限明明已经定义，注意前面还有个内核态错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    4.064447] SELinux: inode_doinit_with_dentry:  context_to_sid(u:object_r:sgdisk_exec:s0) returned 12 for dev=dm-0 ino=666</span><br></pre></td></tr></table></figure>

<p>这是什么意思？暂且不管，我们先跟下代码在security&#x2F;selinux&#x2F;hooks.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1271</span> <span class="comment">/* The inode&#x27;s security attributes must be initialized before first use. */</span></span><br><span class="line"><span class="number">1272</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">inode_doinit_with_dentry</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> dentry *opt_dentry)</span></span><br><span class="line">1273 &#123;</span><br><span class="line">...   </span><br><span class="line"><span class="number">1377</span>                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">1378</span>                         rc = security_context_to_sid_default(context, rc, &amp;sid,</span><br><span class="line"><span class="number">1379</span>                                                              sbsec-&gt;def_sid,</span><br><span class="line"><span class="number">1380</span>                                                              GFP_NOFS);</span><br><span class="line"><span class="number">1381</span>                         <span class="keyword">if</span> (rc) &#123;</span><br><span class="line"><span class="number">1382</span>                                 <span class="type">char</span> *dev = inode-&gt;i_sb-&gt;s_id;</span><br><span class="line"><span class="number">1383</span>                                 <span class="type">unsigned</span> <span class="type">long</span> ino = inode-&gt;i_ino;</span><br><span class="line"><span class="number">1384</span> </span><br><span class="line"><span class="number">1385</span>                                 <span class="keyword">if</span> (rc == -EINVAL) &#123;</span><br><span class="line"><span class="number">1386</span>                                         <span class="keyword">if</span> (printk_ratelimit())</span><br><span class="line"><span class="number">1387</span>                                                 printk(KERN_NOTICE <span class="string">&quot;SELinux: inode=%lu on dev=%s was found to have an invalid &quot;</span></span><br><span class="line"><span class="number">1388</span>                                                         <span class="string">&quot;context=%s.  This indicates you may need to relabel the inode or the &quot;</span></span><br><span class="line"><span class="number">1389</span>                                                         <span class="string">&quot;filesystem in question.\n&quot;</span>, ino, dev, context);</span><br><span class="line"><span class="number">1390</span>                                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">1391</span>                                         printk(KERN_WARNING <span class="string">&quot;SELinux: %s:  context_to_sid(%s) &quot;</span></span><br><span class="line"><span class="number">1392</span>                                                <span class="string">&quot;returned %d for dev=%s ino=%ld\n&quot;</span>,</span><br><span class="line"><span class="number">1393</span>                                                __func__, context, -rc, dev, ino);</span><br><span class="line"><span class="number">1394</span>                                 &#125;</span><br><span class="line"><span class="number">1395</span>                                 kfree(context);</span><br><span class="line"><span class="number">1396</span>                                 <span class="comment">/* Leave with the unlabeled SID */</span></span><br><span class="line"><span class="number">1397</span>                                 rc = <span class="number">0</span>;</span><br><span class="line"><span class="number">1398</span>                                 <span class="keyword">break</span>;</span><br><span class="line"><span class="number">1399</span>                         &#125;</span><br><span class="line"><span class="number">1400</span>                 &#125;</span><br><span class="line"><span class="number">1401</span>                 kfree(context);</span><br><span class="line"><span class="number">1402</span>                 isec-&gt;sid = sid;</span><br><span class="line"><span class="number">1403</span>                 <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>1391行出错，continue to track:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1486</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">1487  * security_context_to_sid_default - Obtain a SID for a given security context,</span></span><br><span class="line"><span class="comment">1488  * falling back to specified default if needed.</span></span><br><span class="line"><span class="comment">1489  *</span></span><br><span class="line"><span class="comment">1490  * @scontext: security context</span></span><br><span class="line"><span class="comment">1491  * @scontext_len: length in bytes</span></span><br><span class="line"><span class="comment">1492  * @sid: security identifier, SID</span></span><br><span class="line"><span class="comment">1493  * @def_sid: default SID to assign on error</span></span><br><span class="line"><span class="comment">1494  *</span></span><br><span class="line"><span class="comment">1495  * Obtains a SID associated with the security context that</span></span><br><span class="line"><span class="comment">1496  * has the string representation specified by @scontext.</span></span><br><span class="line"><span class="comment">1497  * The default SID is passed to the MLS layer to be used to allow</span></span><br><span class="line"><span class="comment">1498  * kernel labeling of the MLS field if the MLS field is not present</span></span><br><span class="line"><span class="comment">1499  * (for upgrading to MLS without full relabel).</span></span><br><span class="line"><span class="comment">1500  * Implicitly forces adding of the context even if it cannot be mapped yet.</span></span><br><span class="line"><span class="comment">1501  * Returns -%EINVAL if the context is invalid, -%ENOMEM if insufficient</span></span><br><span class="line"><span class="comment">1502  * memory is available, or 0 on success.</span></span><br><span class="line"><span class="comment">1503  */</span></span><br><span class="line"><span class="number">1504</span> <span class="type">int</span> <span class="title function_">security_context_to_sid_default</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *scontext, u32 scontext_len,</span></span><br><span class="line"><span class="params"><span class="number">1505</span>                                     u32 *sid, u32 def_sid, <span class="type">gfp_t</span> gfp_flags)</span></span><br><span class="line">1506 &#123;</span><br><span class="line"><span class="number">1507</span>         <span class="keyword">return</span> security_context_to_sid_core(scontext, scontext_len,</span><br><span class="line"><span class="number">1508</span>                                             sid, def_sid, gfp_flags, <span class="number">1</span>);</span><br><span class="line"><span class="number">1509</span> &#125;</span><br></pre></td></tr></table></figure>

<p>读下注释，return就是三个：0, -EINVAL, -ENOMEM。ENOMEM刚好是12。啥，insufficient memory？ ENOMEM太多了，加了打印最后发现是在security&#x2F;selinux&#x2F;ss&#x2F;sidtab.c:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">198</span> <span class="type">int</span> <span class="title function_">sidtab_context_to_sid</span><span class="params">(<span class="keyword">struct</span> sidtab *s,</span></span><br><span class="line"><span class="params"><span class="number">199</span>                           <span class="keyword">struct</span> context *context,</span></span><br><span class="line"><span class="params"><span class="number">200</span>                           u32 *out_sid)</span></span><br><span class="line">201 &#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">206</span>         *out_sid = SECSID_NULL;</span><br><span class="line"><span class="number">207</span> </span><br><span class="line"><span class="number">208</span>         sid  = sidtab_search_cache(s, context);</span><br><span class="line"><span class="number">209</span>         <span class="keyword">if</span> (!sid)</span><br><span class="line"><span class="number">210</span>                 sid = sidtab_search_context(s, context);</span><br><span class="line"><span class="number">211</span>         <span class="keyword">if</span> (!sid) &#123;</span><br><span class="line"><span class="number">212</span>                 spin_lock_irqsave(&amp;s-&gt;lock, flags);</span><br><span class="line"><span class="number">213</span>                 <span class="comment">/* Rescan now that we hold the lock. */</span></span><br><span class="line"><span class="number">214</span>                 sid = sidtab_search_context(s, context);</span><br><span class="line"><span class="number">215</span>                 <span class="keyword">if</span> (sid)&#123;</span><br><span class="line"><span class="number">216</span>                         <span class="keyword">goto</span> unlock_out;</span><br><span class="line"><span class="number">217</span>                 &#125;</span><br><span class="line"><span class="number">218</span>                 <span class="comment">/* No SID exists for the context.  Allocate a new one. */</span></span><br><span class="line"><span class="number">219</span>                 <span class="keyword">if</span> (s-&gt;next_sid == UINT_MAX || s-&gt;shutdown) &#123;</span><br><span class="line"><span class="number">220</span>                         ret = -ENOMEM;</span><br><span class="line"><span class="number">221</span>                         printk(KERN_INFO</span><br><span class="line"><span class="number">222</span>                        <span class="string">&quot;SELinux: next_sid=%d, shutdown=%d ret=%d.\n&quot;</span>,</span><br><span class="line"><span class="number">223</span>                                s-&gt;next_sid, s-&gt;shutdown, ret);</span><br><span class="line"><span class="number">224</span>                         <span class="keyword">goto</span> unlock_out;</span><br><span class="line"><span class="number">225</span>                 &#125;</span><br><span class="line"><span class="number">226</span>                 sid = s-&gt;next_sid++;</span><br><span class="line"><span class="number">227</span>                 <span class="keyword">if</span> (context-&gt;len)</span><br><span class="line"><span class="number">228</span>                         printk(KERN_INFO</span><br><span class="line"><span class="number">229</span>                        <span class="string">&quot;SELinux:  Context %s is not valid (left unmapped).\n&quot;</span>,</span><br><span class="line"><span class="number">230</span>                                context-&gt;str);</span><br><span class="line"><span class="number">231</span>                 ret = sidtab_insert(s, sid, context);</span><br><span class="line"><span class="number">232</span>                 <span class="keyword">if</span> (ret)</span><br><span class="line"><span class="number">233</span>                         s-&gt;next_sid--;</span><br><span class="line"><span class="number">234</span> unlock_out:</span><br><span class="line"><span class="number">235</span>                 spin_unlock_irqrestore(&amp;s-&gt;lock, flags);</span><br><span class="line"><span class="number">236</span>         &#125;</span><br><span class="line"><span class="number">237</span> </span><br><span class="line"><span class="number">238</span>         <span class="keyword">if</span> (ret)&#123;</span><br><span class="line"><span class="number">239</span>                 printk(<span class="string">&quot;return ret is %d\n&quot;</span>, ret);</span><br><span class="line"><span class="number">240</span>                 <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">241</span>         &#125;</span><br><span class="line"><span class="number">242</span> </span><br><span class="line"><span class="number">243</span>         *out_sid = sid;</span><br><span class="line"><span class="number">244</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">245</span> &#125;</span><br></pre></td></tr></table></figure>

<p>s-&gt;shutdown &#x3D; 1，这个才是关键，这个为啥是no memory？ 查看代码发现只有sidtab_shutdown会设置为1:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">317</span> <span class="type">void</span> <span class="title function_">sidtab_shutdown</span><span class="params">(<span class="keyword">struct</span> sidtab *s)</span></span><br><span class="line">318 &#123;</span><br><span class="line"><span class="number">319</span>         <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="number">320</span> </span><br><span class="line"><span class="number">321</span>         spin_lock_irqsave(&amp;s-&gt;lock, flags);</span><br><span class="line"><span class="number">322</span>         s-&gt;shutdown = <span class="number">1</span>;</span><br><span class="line"><span class="number">323</span>         spin_unlock_irqrestore(&amp;s-&gt;lock, flags);</span><br><span class="line"><span class="number">324</span> &#125;</span><br></pre></td></tr></table></figure>

<p>那我们看下sidtab_shutdown call stack:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sel_write_load -&gt; security_load_policy -&gt; sidtab_shutdown</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">sel_load_ops</span> =</span> &#123;</span><br><span class="line">        .write          = sel_write_load,</span><br><span class="line">        .llseek         = generic_file_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出来sel_write_load应该是由app通过write接口触发的，具体是在external&#x2F;libselinux, call stack：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">selinux_android_load_policy -&gt; selinux_android_load_policy_helper -&gt; security_load_policy -&gt; write( &quot;%s/load&quot;</span><br></pre></td></tr></table></figure>

<p>在它的上面init在call:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">init main -&gt; selinux_initialize -&gt; selinux_android_load_policy(in kernel_domain)</span><br></pre></td></tr></table></figure>

<p>回过头来再细看下kernel的security_load_policy：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sel_write_load :</span><br><span class="line"> |-&gt; copy_from_user</span><br><span class="line"> |-&gt; security_load_policy </span><br><span class="line">            |-&gt; policydb_read -&gt; avtab_read -&gt; avtab_alloc : print &quot;SELinux: %d avtab hash slots, %d rules&quot;</span><br><span class="line">            |-&gt; sidtab_shutdown (set shutdown=1)</span><br><span class="line">            |-&gt; sidtab_set (set shudown=0)</span><br><span class="line"> |-&gt; print &quot;policy loaded&quot;</span><br></pre></td></tr></table></figure>

<p>也就说在vold执行sgdisk时，因为shutdown&#x3D;1导致内核selinux报错，我们再看下报错log:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    4.064447] SELinux: inode_doinit_with_dentry:  context_to_sid(u:object_r:sgdisk_exec:s0) returned 12 for dev=dm-0 ino=666</span><br></pre></td></tr></table></figure>

<p>这里的sgdisk的context应该已经识别到了，就是sgdisk_exec，只不过在内核处理to sid时出错了，导致最终写到内核失败。</p>
<p>sgdisk的权限在file_contexts.bin里，可以看下logcat:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01-07 12:08:33.715  1860  1860 I auditd  : type=1400 audit(0.0:19): avc: denied &#123; execute &#125; for comm=&quot;sh&quot; name=&quot;sgdisk&quot; dev=&quot;dm-0&quot; ino=666 scontext=u:r:vold:s0 tcontext=u:object_r:unlabeled:s0 tclass=file permissive=0</span><br><span class="line">01-07 12:08:31.346  1459  1613 I SELinux : SELinux: Loaded file_contexts contexts from /file_contexts.bin.</span><br></pre></td></tr></table></figure>

<p>能看到，在12:08:31.346时file_contexts.bin已经loaded了，而权限报错是在2s后发生的，所以和load file_contexts时间无关，问题就是shutdown&#x3D;1为什么会抛出来。</p>
<p>我在shutdown的地方加些打印，发现security_load_policy走了2遍，一是在init first stage，一个是在init second stage，first stage是load的&#x2F;sepolicy文件，second stage是load的&#x2F;sepolicy_B。</p>
<p>从加的打印能看出来，在load sepolicy_B流程中shutdown&#x3D;1后面会shutdown&#x3D;0,而vold刚好踩在这个中间，这也证明了为啥偶尔会出现这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    4.090567] SELinux:  Class can_socket not defined in policy.</span><br><span class="line">[    4.090574] SELinux: the above unknown classes and permissions will be denied</span><br><span class="line">[    4.090579] shutdown=1 in sidtab_shutdown</span><br><span class="line">[    4.091293] SELinux: next_sid=294, shutdown=1 ret=-12.</span><br><span class="line">[    4.091305] SELinux: inode_doinit_with_dentry:  context_to_sid(u:object_r:sgdisk_exec:s0) returned 12 for dev=dm-0 ino=666</span><br><span class="line">[    4.091391]  shutdown=0 in sidtab_set</span><br><span class="line">[    4.091491] type=1400 audit(4328788.739:6): avc: denied &#123; execute &#125; for pid=444 comm=&quot;sh&quot; name=&quot;sgdisk&quot; dev=&quot;dm-0&quot; ino=666 scontext=u:r:vold:s0 tcontext=u:object_r:unlabeled:s0 tclass=file permissive=0</span><br><span class="line">[    4.147648] type=1403 audit(4328788.789:7): policy loaded auid=4294967295 ses=4294967295</span><br></pre></td></tr></table></figure>

<p>sepolicy_B是我们自己添加的，原生流程只有sepolicy是在kernel domain完成。是不是有问题？带着这个问题我们重看下init main：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">selinux_initialize</span><span class="params">(<span class="type">bool</span> in_kernel_domain)</span> </span>&#123;</span><br><span class="line">    Timer t;</span><br><span class="line"></span><br><span class="line">    selinux_callback cb;</span><br><span class="line">    cb.func_log = selinux_klog_callback;</span><br><span class="line">    <span class="built_in">selinux_set_callback</span>(SELINUX_CB_LOG, cb);</span><br><span class="line">    cb.func_audit = audit_callback;</span><br><span class="line">    <span class="built_in">selinux_set_callback</span>(SELINUX_CB_AUDIT, cb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_kernel_domain) &#123;</span><br><span class="line">        <span class="built_in">ERROR</span>(<span class="string">&quot;Loading SELinux policy...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">selinux_android_load_policy</span>() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ERROR</span>(<span class="string">&quot;failed to load policy: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">security_failure</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> kernel_enforcing = (<span class="built_in">security_getenforce</span>() == <span class="number">1</span>);</span><br><span class="line">        <span class="type">bool</span> is_enforcing = <span class="built_in">selinux_is_enforcing</span>();</span><br><span class="line">        <span class="keyword">if</span> (kernel_enforcing != is_enforcing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">security_setenforce</span>(is_enforcing)) &#123;</span><br><span class="line">                <span class="built_in">ERROR</span>(<span class="string">&quot;security_setenforce(%s) failed: %s\n&quot;</span>,</span><br><span class="line">                      is_enforcing ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                <span class="built_in">security_failure</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write_file</span>(<span class="string">&quot;/sys/fs/selinux/checkreqprot&quot;</span>, <span class="string">&quot;0&quot;</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">security_failure</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NOTICE</span>(<span class="string">&quot;(Initializing SELinux %s took %.2fs.)\n&quot;</span>,</span><br><span class="line">               is_enforcing ? <span class="string">&quot;enforcing&quot;</span> : <span class="string">&quot;non-enforcing&quot;</span>, t.<span class="built_in">duration</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ERROR</span>(<span class="string">&quot;init all handles...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">selinux_init_all_handles</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">NOTICE</span>(<span class="string">&quot;init %s started!\n&quot;</span>, is_first_stage ? <span class="string">&quot;first stage&quot;</span> : <span class="string">&quot;second stage&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Set up SELinux, including loading the SELinux policy if we&#x27;re in the kernel domain.</span></span><br><span class="line">    <span class="built_in">selinux_initialize</span>(is_first_stage);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>也就是selinux的初始化分两部分，一在first stage完成sepolicy加载，二是second stage会load file_contexts.bin等，这是本来的流程。而我们在second stage又添加了一个sepolicy加载，这个会把内核的load policy在用户态再走一边，比如shutdown&#x3D;1就会干扰用户态执行权限，应该是错误的，那我去掉这个sepolicy_B，测了多遍，故障消失:]</p>
<p>把这个sepolicy_B放到first stage加载应该也能解决问题，没测了。</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>版权声明：</span>本站所有文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明原文链接！</p></div><br><div class="tags"><a href="/tags/file_contexts.bin"><i class="fa fa-tag">file_contexts.bin</i></a></div><div class="post-nav"><a class="pre" href="/system-crash-analysis-1.html">System Crash实例分析一</a><a class="next" href="/analyze-coldboot-time-consuming-issue.html">分析ueventd Coldboot耗时问题</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/kworker-sched-la-stat.html">kworker 调度延迟性能测试和统计</a></li><li class="post-list-item"><a class="post-list-link" href="/implement-erofs-fragment-dedupe.html">转：EROFS 碎片去重实践</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-enable-kasan-in-ubuntu-18-04-for-x86_64.html">How to enable KASAN in Ubuntu 18.04 for X86_64</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-analyze-segmentation-fault-for-non-install-package-in-ubuntu.html">如何分析 Linux user space's segmentation fault</a></li><li class="post-list-item"><a class="post-list-link" href="/prepare-fragment-dedupe-in-erofs.html">EROFS 碎片去重准备</a></li><li class="post-list-item"><a class="post-list-link" href="/good-naming-in-programming.html">优秀代码命名法</a></li><li class="post-list-item"><a class="post-list-link" href="/erofs-compressed-data-deduplication.html">EROFS 压缩去重分析</a></li><li class="post-list-item"><a class="post-list-link" href="/analyze-fscache-cookie-code.html">转：浅析 Linux FS-Cache</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-let-bluetooth-work-under-armbian-kodi-for-rockpi4b-within-metal-case.html">Rockpi4b Armbian Kodi 终于能使用蓝牙了</a></li><li class="post-list-item"><a class="post-list-link" href="/erofs-ztailpacking-explain.html">转：EROFS ztailpacking 特性实现详解</a></li></ul></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arm/">ARM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dd/">Device Driver</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fs/">File System</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iot/">IoT</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/msm/">MSM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mm/">Memory Management</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/perf/">Performance</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">Security</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/stab/">Stability</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">Tools</a><span class="category-list-count">17</span></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">TJ的技术博客.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
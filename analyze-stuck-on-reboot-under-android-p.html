<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Android P重启卡死问题分析 | TJ的技术博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android P重启卡死问题分析</h1><a id="logo" href="/.">TJ的技术博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 首页</i></a><a href="/archives/"><i class="fa undefined"> 归档</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android P重启卡死问题分析</h1><div class="post-meta">2019-02-27</div><div class="post-content"><p>最近遇到重启卡死的问题，有的是黑屏，有的是定屏在”正在重新启动”adb可用，高通平台。</p>
<p>抓下logcat能发现如下log：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ShutdownThread: Rebooting, reason: null</span><br></pre></td></tr></table></figure>

<p>代码在：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;power&#x2F;ShutdownThread.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (reboot) &#123;</span><br><span class="line">    Log.i(TAG, <span class="string">&quot;Rebooting, reason: &quot;</span> + reason);</span><br><span class="line">    PowerManagerService.lowLevelReboot(reason);</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;Reboot failed, will attempt shutdown instead&quot;</span>);</span><br><span class="line">    reason = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;power&#x2F;PowerManagerService.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Low-level function to reboot the device. On success, this</span></span><br><span class="line"><span class="comment"> * function doesn&#x27;t return. If more than 20 seconds passes from</span></span><br><span class="line"><span class="comment"> * the time a reboot is requested, this method returns.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reason code to pass to the kernel (e.g. &quot;recovery&quot;), or null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lowLevelReboot</span><span class="params">(String reason)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (reason == <span class="literal">null</span>) &#123;</span><br><span class="line">        reason = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the reason is &quot;quiescent&quot;, it means that the boot process should proceed</span></span><br><span class="line">    <span class="comment">// without turning on the screen/lights.</span></span><br><span class="line">    <span class="comment">// The &quot;quiescent&quot; property is sticky, meaning that any number</span></span><br><span class="line">    <span class="comment">// of subsequent reboots should honor the property until it is reset.</span></span><br><span class="line">    <span class="keyword">if</span> (reason.equals(PowerManager.REBOOT_QUIESCENT)) &#123;</span><br><span class="line">        sQuiescent = <span class="literal">true</span>;</span><br><span class="line">        reason = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reason.endsWith(<span class="string">&quot;,&quot;</span> + PowerManager.REBOOT_QUIESCENT)) &#123;</span><br><span class="line">        sQuiescent = <span class="literal">true</span>;</span><br><span class="line">        reason = reason.substring(<span class="number">0</span>,</span><br><span class="line">                reason.length() - PowerManager.REBOOT_QUIESCENT.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reason.equals(PowerManager.REBOOT_RECOVERY)</span><br><span class="line">            || reason.equals(PowerManager.REBOOT_RECOVERY_UPDATE)) &#123;</span><br><span class="line">        reason = <span class="string">&quot;recovery&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sQuiescent) &#123;</span><br><span class="line">        <span class="comment">// Pass the optional &quot;quiescent&quot; argument to the bootloader to let it know</span></span><br><span class="line">        <span class="comment">// that it should not turn the screen/lights on.</span></span><br><span class="line">        reason = reason + <span class="string">&quot;,quiescent&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    SystemProperties.set(<span class="string">&quot;sys.powerctl&quot;</span>, <span class="string">&quot;reboot,&quot;</span> + reason); <span class="comment">//tj: trigger reboot</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">20</span> * <span class="number">1000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;    </span><br><span class="line">    Slog.wtf(TAG, <span class="string">&quot;Unexpected return from lowLevelReboot!&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>通过设置属性<code>sys.powerctl</code>来重启，属性设置会走HandlePropertySet -&gt; PropertySet -&gt; property_changed(init.cpp)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">property_changed</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If the property is sys.powerctl, we bypass the event queue and immediately handle it.</span></span><br><span class="line">    <span class="comment">// This is to ensure that init will always and immediately shutdown/reboot, regardless of</span></span><br><span class="line">    <span class="comment">// if there are other pending events to process or if init is waiting on an exec service or</span></span><br><span class="line">    <span class="comment">// waiting on a property.</span></span><br><span class="line">    <span class="comment">// In non-thermal-shutdown case, &#x27;shutdown&#x27; trigger will be fired to let device specific</span></span><br><span class="line">    <span class="comment">// commands to be executed.</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;sys.powerctl&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// Despite the above comment, we can&#x27;t call HandlePowerctlMessage() in this function,</span></span><br><span class="line">        <span class="comment">// because it modifies the contents of the action queue, which can cause the action queue</span></span><br><span class="line">        <span class="comment">// to get into a bad state if this function is called from a command being executed by the</span></span><br><span class="line">        <span class="comment">// action queue.  Instead we set this flag and ensure that shutdown happens before the next</span></span><br><span class="line">        <span class="comment">// command is run in the main init loop.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> once property service is removed from init, this will never happen from a builtin,</span></span><br><span class="line">        <span class="comment">// but rather from a callback from the property service socket, in which case this hack can</span></span><br><span class="line">        <span class="comment">// go away.</span></span><br><span class="line">        shutdown_command = value;</span><br><span class="line">        do_shutdown = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>init.cpp的<code>main()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// By default, sleep until something happens.</span></span><br><span class="line">    <span class="type">int</span> epoll_timeout_ms = <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (do_shutdown &amp;&amp; !shutting_down) &#123;</span><br><span class="line">        do_shutdown = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">HandlePowerctlMessage</span>(shutdown_command)) &#123;</span><br><span class="line">            shutting_down = <span class="literal">true</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<p>HandlePowerctlMessage():</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HandlePowerctlMessage</span><span class="params">(<span class="type">const</span> std::string&amp; command)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cmd = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; cmd_params = <span class="built_in">Split</span>(command, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    std::string reboot_target = <span class="string">&quot;&quot;</span>; </span><br><span class="line">    <span class="type">bool</span> run_fsck = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> command_invalid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmd_params.<span class="built_in">size</span>() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        command_invalid = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd_params[<span class="number">0</span>] == <span class="string">&quot;shutdown&quot;</span>) &#123;</span><br><span class="line">        cmd = ANDROID_RB_POWEROFF;</span><br><span class="line">        <span class="keyword">if</span> (cmd_params.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cmd_params[<span class="number">1</span>] == <span class="string">&quot;userrequested&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// The shutdown reason is PowerManager.SHUTDOWN_USER_REQUESTED.</span></span><br><span class="line">                <span class="comment">// Run fsck once the file system is remounted in read-only mode.</span></span><br><span class="line">                run_fsck = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd_params[<span class="number">1</span>] == <span class="string">&quot;thermal&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// Turn off sources of heat immediately.</span></span><br><span class="line">                <span class="built_in">TurnOffBacklight</span>();</span><br><span class="line">                <span class="comment">// run_fsck is false to avoid delay</span></span><br><span class="line">                cmd = ANDROID_RB_THERMOFF;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd_params[<span class="number">0</span>] == <span class="string">&quot;reboot&quot;</span>) &#123;</span><br><span class="line">        cmd = ANDROID_RB_RESTART2;</span><br><span class="line">        <span class="keyword">if</span> (cmd_params.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            reboot_target = cmd_params[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// When rebooting to the bootloader notify the bootloader writing</span></span><br><span class="line">            <span class="comment">// also the BCB.</span></span><br><span class="line">            <span class="keyword">if</span> (reboot_target == <span class="string">&quot;bootloader&quot;</span>) &#123;</span><br><span class="line">                std::string err;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">write_reboot_bootloader</span>(&amp;err)) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;reboot-bootloader: Error writing &quot;</span></span><br><span class="line">                                  <span class="string">&quot;bootloader_message: &quot;</span></span><br><span class="line">                               &lt;&lt; err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If there is an additional parameter, pass it along</span></span><br><span class="line">            <span class="keyword">if</span> ((cmd_params.<span class="built_in">size</span>() == <span class="number">3</span>) &amp;&amp; cmd_params[<span class="number">2</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                reboot_target += <span class="string">&quot;,&quot;</span> + cmd_params[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        command_invalid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (command_invalid) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;powerctl: unrecognized command &#x27;&quot;</span> &lt;&lt; command &lt;&lt; <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Clear action queue and start shutdown trigger&quot;</span>;</span><br><span class="line">    ActionManager::<span class="built_in">GetInstance</span>().<span class="built_in">ClearQueue</span>();</span><br><span class="line">    <span class="comment">// Queue shutdown trigger first</span></span><br><span class="line">    ActionManager::<span class="built_in">GetInstance</span>().<span class="built_in">QueueEventTrigger</span>(<span class="string">&quot;shutdown&quot;</span>);</span><br><span class="line">    <span class="comment">// Queue built-in shutdown_done</span></span><br><span class="line">    <span class="keyword">auto</span> shutdown_handler = [cmd, command, reboot_target, run_fsck](<span class="type">const</span> BuiltinArguments&amp;) &#123;</span><br><span class="line">        <span class="built_in">DoReboot</span>(cmd, command, reboot_target, run_fsck);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Success</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    ActionManager::<span class="built_in">GetInstance</span>().<span class="built_in">QueueBuiltinAction</span>(shutdown_handler, <span class="string">&quot;shutdown_done&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip wait for prop if it is in progress</span></span><br><span class="line">    <span class="built_in">ResetWaitForProp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear EXEC flag if there is one pending</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : ServiceList::<span class="built_in">GetInstance</span>()) &#123;</span><br><span class="line">        s-&gt;<span class="built_in">UnSetExec</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LOG(INFO) &lt;&lt; &quot;Clear action queue and start shutdown trigger&quot;</code>这句log(check dmesg)有时有，有时没有？继续看<code>DoReboot</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoReboot</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">const</span> std::string&amp; reason, <span class="type">const</span> std::string&amp; rebootTarget,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">bool</span> runFsck)</span> </span>&#123;</span><br><span class="line">    Timer t;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Reboot start, reason: &quot;</span> &lt;&lt; reason &lt;&lt; <span class="string">&quot;, rebootTarget: &quot;</span> &lt;&lt; rebootTarget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure last reboot reason is reduced to canonical</span></span><br><span class="line">    <span class="comment">// alias reported in bootloader or system boot reason.</span></span><br><span class="line">    <span class="type">size_t</span> skip = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(ERR) &lt;&lt; <span class="string">&quot;[YL] Reboot start, reason: &quot;</span> &lt;&lt; reason &lt;&lt; <span class="string">&quot;, rebootTarget: &quot;</span> &lt;&lt; rebootTarget;</span><br><span class="line">    std::vector&lt;std::string&gt; reasons = <span class="built_in">Split</span>(reason, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (reasons.<span class="built_in">size</span>() &gt;= <span class="number">2</span> &amp;&amp; reasons[<span class="number">0</span>] == <span class="string">&quot;reboot&quot;</span> &amp;&amp;</span><br><span class="line">        (reasons[<span class="number">1</span>] == <span class="string">&quot;recovery&quot;</span> || reasons[<span class="number">1</span>] == <span class="string">&quot;bootloader&quot;</span> || reasons[<span class="number">1</span>] == <span class="string">&quot;cold&quot;</span> ||</span><br><span class="line">         reasons[<span class="number">1</span>] == <span class="string">&quot;hard&quot;</span> || reasons[<span class="number">1</span>] == <span class="string">&quot;warm&quot;</span>)) &#123;</span><br><span class="line">        skip = <span class="built_in">strlen</span>(<span class="string">&quot;reboot,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">property_set</span>(LAST_REBOOT_REASON_PROPERTY, reason.<span class="built_in">c_str</span>() + skip);</span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> is_thermal_shutdown = cmd == ANDROID_RB_THERMOFF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> shutdown_timeout = <span class="number">0</span>ms;</span><br><span class="line">    <span class="keyword">if</span> (!SHUTDOWN_ZERO_TIMEOUT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_thermal_shutdown) &#123;</span><br><span class="line">            <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> thermal_shutdown_timeout = <span class="number">3</span>;</span><br><span class="line">            shutdown_timeout = std::chrono::<span class="built_in">seconds</span>(thermal_shutdown_timeout);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> shutdown_timeout_default = <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">auto</span> shutdown_timeout_property = android::base::<span class="built_in">GetUintProperty</span>(</span><br><span class="line">                <span class="string">&quot;ro.build.shutdown_timeout&quot;</span>, shutdown_timeout_default);</span><br><span class="line">            shutdown_timeout = std::chrono::<span class="built_in">seconds</span>(shutdown_timeout_property);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Shutdown timeout: &quot;</span> &lt;&lt; shutdown_timeout.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ms&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>奇怪，<code>Reboot start, reason</code>和<code>Shutdown timeout</code>这两句log也不是每次都有？这里有个属性<code>LAST_REBOOT_REASON_PROPERTY</code>会记录重启原因:</p>
<figure class="highlight h"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Properties */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANDROID_RB_PROPERTY <span class="string">&quot;sys.powerctl&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Android reboot reason stored in this property */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_REBOOT_REASON_PROPERTY <span class="string">&quot;persist.sys.boot.reason&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>复现了一次抓到如下log，是通过adb reboot压测的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[   36.255358] init: Received sys.powerctl=&#x27;reboot,adb&#x27; from pid: 2491 (/system/bin/adbd)</span><br><span class="line">[   36.255533] init: Clear action queue and start shutdown trigger</span><br><span class="line">[   36.255731] init: processing action (shutdown_done) from (&lt;Builtin Action&gt;:0)</span><br><span class="line">[   36.255759] init: Reboot start, reason: reboot,adb, rebootTarget: adb</span><br><span class="line">[   36.291254] init: Shutdown timeout: 6000 ms</span><br><span class="line">[   36.291385] init: Could not start shutdown critical service &#x27;chre&#x27;: Cannot find &#x27;/vendor/bin/chre&#x27;: No such file or directory</span><br><span class="line">[   36.292815] init: starting service &#x27;blank_screen&#x27;...</span><br><span class="line">[   36.294620] init: terminating init services</span><br><span class="line">[   36.294804] init: Sending signal 15 to service &#x27;gx_fpd&#x27; (pid 3714) process group...</span><br><span class="line">[   36.295203] init: Sending signal 15 to service &#x27;trustonic-daemon&#x27; (pid 3295) process group...</span><br></pre></td></tr></table></figure>

<p>继续跟下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// keep debugging tools until non critical ones are all gone.</span></span><br><span class="line"><span class="type">const</span> std::set&lt;std::string&gt; kill_after_apps&#123;<span class="string">&quot;tombstoned&quot;</span>, <span class="string">&quot;logd&quot;</span>, <span class="string">&quot;adbd&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// watchdogd is a vendor specific component but should be alive to complete shutdown safely.</span></span><br><span class="line"><span class="type">const</span> std::set&lt;std::string&gt; to_starts&#123;<span class="string">&quot;watchdogd&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : ServiceList::<span class="built_in">GetInstance</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (kill_after_apps.<span class="built_in">count</span>(s-&gt;<span class="built_in">name</span>())) &#123;</span><br><span class="line">        s-&gt;<span class="built_in">SetShutdownCritical</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (to_starts.<span class="built_in">count</span>(s-&gt;<span class="built_in">name</span>())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> result = s-&gt;<span class="built_in">Start</span>(); !result) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Could not start shutdown &#x27;to_start&#x27; service &#x27;&quot;</span> &lt;&lt; s-&gt;<span class="built_in">name</span>()</span><br><span class="line">                       &lt;&lt; <span class="string">&quot;&#x27;: &quot;</span> &lt;&lt; result.<span class="built_in">error</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;<span class="built_in">SetShutdownCritical</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;<span class="built_in">IsShutdownCritical</span>()) &#123;</span><br><span class="line">        <span class="comment">// Start shutdown critical service if not started.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> result = s-&gt;<span class="built_in">Start</span>(); !result) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Could not start shutdown critical service &#x27;&quot;</span> &lt;&lt; s-&gt;<span class="built_in">name</span>()</span><br><span class="line">                       &lt;&lt; <span class="string">&quot;&#x27;: &quot;</span> &lt;&lt; result.<span class="built_in">error</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remaining operations (specifically fsck) may take a substantial duration</span></span><br><span class="line"><span class="keyword">if</span> (cmd == ANDROID_RB_POWEROFF || is_thermal_shutdown) &#123;</span><br><span class="line">    <span class="built_in">TurnOffBacklight</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Service* bootAnim = ServiceList::<span class="built_in">GetInstance</span>().<span class="built_in">FindService</span>(<span class="string">&quot;bootanim&quot;</span>);</span><br><span class="line">Service* surfaceFlinger = ServiceList::<span class="built_in">GetInstance</span>().<span class="built_in">FindService</span>(<span class="string">&quot;surfaceflinger&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (bootAnim != <span class="literal">nullptr</span> &amp;&amp; surfaceFlinger != <span class="literal">nullptr</span> &amp;&amp; surfaceFlinger-&gt;<span class="built_in">IsRunning</span>()) &#123;</span><br><span class="line">    <span class="comment">// will not check animation class separately</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; service : ServiceList::<span class="built_in">GetInstance</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (service-&gt;<span class="built_in">classnames</span>().<span class="built_in">count</span>(<span class="string">&quot;animation&quot;</span>)) service-&gt;<span class="built_in">SetShutdownCritical</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先保留几个critical service，比如tombstoned, logd, adbd, watchdogd。接下来会terminate所有的服务除了这几个critical:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// optional shutdown step</span></span><br><span class="line"><span class="comment">// 1. terminate all services except shutdown critical ones. wait for delay to finish</span></span><br><span class="line"><span class="keyword">if</span> (shutdown_timeout &gt; <span class="number">0</span>ms) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;terminating init services&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ask all services to terminate except shutdown critical ones.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : ServiceList::<span class="built_in">GetInstance</span>().<span class="built_in">services_in_shutdown_order</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;<span class="built_in">IsShutdownCritical</span>()) s-&gt;<span class="built_in">Terminate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> service_count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Only wait up to half of timeout here</span></span><br><span class="line">    <span class="keyword">auto</span> termination_wait_timeout = shutdown_timeout / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (t.<span class="built_in">duration</span>() &lt; termination_wait_timeout) &#123;</span><br><span class="line">        <span class="built_in">ReapAnyOutstandingChildren</span>();</span><br><span class="line"></span><br><span class="line">        service_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : ServiceList::<span class="built_in">GetInstance</span>()) &#123;</span><br><span class="line">            <span class="comment">// Count the number of services running except shutdown critical.</span></span><br><span class="line">            <span class="comment">// Exclude the console as it will ignore the SIGTERM signal</span></span><br><span class="line">            <span class="comment">// and not exit.</span></span><br><span class="line">            <span class="comment">// Note: SVC_CONSOLE actually means &quot;requires console&quot; but</span></span><br><span class="line">            <span class="comment">// it is only used by the shell.</span></span><br><span class="line">            <span class="keyword">if</span> (!s-&gt;<span class="built_in">IsShutdownCritical</span>() &amp;&amp; s-&gt;<span class="built_in">pid</span>() != <span class="number">0</span> &amp;&amp; (s-&gt;<span class="built_in">flags</span>() &amp; SVC_CONSOLE) == <span class="number">0</span>) &#123;</span><br><span class="line">                service_count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (service_count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// All terminable services terminated. We can exit early.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait a bit before recounting the number or running services.</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">50</span>ms);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Terminating running services took &quot;</span> &lt;&lt; t</span><br><span class="line">              &lt;&lt; <span class="string">&quot; with remaining services:&quot;</span> &lt;&lt; service_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会有个等待超时时间<code>termination_wait_timeout</code>，调大些？继续看:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// minimum safety steps before restarting</span></span><br><span class="line"><span class="comment">// 2. kill all services except ones that are necessary for the shutdown sequence.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : ServiceList::<span class="built_in">GetInstance</span>().<span class="built_in">services_in_shutdown_order</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s-&gt;<span class="built_in">IsShutdownCritical</span>()) s-&gt;<span class="built_in">Stop</span>(); <span class="comment">//tj: stop non critical</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ReapAnyOutstandingChildren</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. send volume shutdown to vold</span></span><br><span class="line">Service* voldService = ServiceList::<span class="built_in">GetInstance</span>().<span class="built_in">FindService</span>(<span class="string">&quot;vold&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (voldService != <span class="literal">nullptr</span> &amp;&amp; voldService-&gt;<span class="built_in">IsRunning</span>()) &#123;</span><br><span class="line">    <span class="built_in">ShutdownVold</span>();</span><br><span class="line">    voldService-&gt;<span class="built_in">Stop</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;vold not running, skipping vold shutdown&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logcat stopped here</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : ServiceList::<span class="built_in">GetInstance</span>().<span class="built_in">services_in_shutdown_order</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (kill_after_apps.<span class="built_in">count</span>(s-&gt;<span class="built_in">name</span>())) s-&gt;<span class="built_in">Stop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后才stop了logcat, adbd等服务。ok，定屏adb不能连的那肯定走到下面去了。下面就是umount:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. sync, try umount, and optionally run fsck for user shutdown</span></span><br><span class="line">&#123;</span><br><span class="line">    Timer sync_timer;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;sync() before umount...&quot;</span>;</span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;sync() before umount took&quot;</span> &lt;&lt; sync_timer;</span><br><span class="line">&#125;</span><br><span class="line">UmountStat stat = <span class="built_in">TryUmountAndFsck</span>(runFsck, shutdown_timeout - t.<span class="built_in">duration</span>());</span><br><span class="line"><span class="comment">// Follow what linux shutdown is doing: one more sync with little bit delay</span></span><br><span class="line">&#123;</span><br><span class="line">    Timer sync_timer;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;sync() after umount...&quot;</span>;</span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;sync() after umount took&quot;</span> &lt;&lt; sync_timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">KillAllProcesses</span><span class="params">()</span> </span>&#123; android::base::<span class="built_in">WriteStringToFile</span>(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;/proc/sysrq-trigger&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try umounting all emulated file systems R/W block device cfile systems.</span></span><br><span class="line"><span class="comment"> * This will just try umount and give it up if it fails.</span></span><br><span class="line"><span class="comment"> * For fs like ext4, this is ok as file system will be marked as unclean shutdown</span></span><br><span class="line"><span class="comment"> * and necessary check can be done at the next reboot.</span></span><br><span class="line"><span class="comment"> * For safer shutdown, caller needs to make sure that</span></span><br><span class="line"><span class="comment"> * all processes / emulated partition for the target fs are all cleaned-up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * return true when umount was successful. false when timed out.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> UmountStat <span class="title">TryUmountAndFsck</span><span class="params">(<span class="type">bool</span> runFsck, std::chrono::milliseconds timeout)</span> </span>&#123;</span><br><span class="line">    Timer t;</span><br><span class="line">    std::vector&lt;MountEntry&gt; block_devices;</span><br><span class="line">    std::vector&lt;MountEntry&gt; emulated_devices;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runFsck &amp;&amp; !<span class="built_in">FindPartitionsToUmount</span>(&amp;block_devices, &amp;emulated_devices, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> UMOUNT_STAT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UmountStat stat = <span class="built_in">UmountPartitions</span>(timeout - t.<span class="built_in">duration</span>());</span><br><span class="line">    <span class="keyword">if</span> (stat != UMOUNT_STAT_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;umount timeout, last resort, kill all and try&quot;</span>;</span><br><span class="line">        <span class="type">bool</span> dumpUmountDebugInfo = <span class="built_in">property_get_bool</span>(<span class="string">&quot;persist.sys.dumpUmountDebugInfo&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (dumpUmountDebugInfo) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DUMP_ON_UMOUNT_FAILURE) <span class="built_in">DumpUmountDebuggingInfo</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">KillAllProcesses</span>();</span><br><span class="line">        <span class="comment">// even if it succeeds, still it is timeout and do not run fsck with all processes killed</span></span><br><span class="line">        UmountStat st = <span class="built_in">UmountPartitions</span>(<span class="number">0</span>ms);</span><br><span class="line">        <span class="keyword">if</span> (dumpUmountDebugInfo) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((st != UMOUNT_STAT_SUCCESS) &amp;&amp; DUMP_ON_UMOUNT_FAILURE)</span><br><span class="line">                 <span class="built_in">DumpUmountDebuggingInfo</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们这里是reboot，不走fsck，<code>sync() before umount</code>这个log也是看不到的。很有可能就是卡在umount里了？</p>
<p>又复现一次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[   92.971658] scm: secure world has been busy for 1 second!</span><br><span class="line">[   94.331640] scm_call failed: func id 0x7300fa01, ret: -12, syscall returns: 0x0, 0x0, 0x0</span><br><span class="line">[   97.454185] init: Terminating running services took 6023ms with remaining services:3</span><br><span class="line">[   97.454293] init: Sending signal 9 to service &#x27;gx_fpd&#x27; (pid 4944) process group...</span><br><span class="line">[   97.680210] libprocessgroup: Failed to kill process cgroup uid 1000 pid 4944 in 225ms, 1 processes remain</span><br><span class="line">[   97.680392] init: Sending signal 9 to service &#x27;trustonic-daemon&#x27; (pid 3315) process group...</span><br><span class="line">[   97.905801] libprocessgroup: Failed to kill process cgroup uid 1000 pid 3315 in 225ms, 1 processes remain</span><br><span class="line">[   97.905980] init: Sending signal 9 to service &#x27;vendor.per_mgr&#x27; (pid 561) process group...</span><br><span class="line">[   97.914897] libprocessgroup: Successfully killed process cgroup uid 1000 pid 561 in 8ms</span><br><span class="line">[   97.915339] init: Service &#x27;vendor.per_mgr&#x27; (pid 561) received signal 9</span><br><span class="line">[   97.951903] vdc: Waited 0ms for vold</span><br><span class="line">[   97.952039] binder: 483:487 transaction failed 29189/-22, size 88-0 line 3017</span><br><span class="line">[  101.601745] Trustonic TEE: wait_mcp_notification: No answer after 10s</span><br></pre></td></tr></table></figure>

<p>这里我们加大过timeout，仍然不起作用，有个gx_fpd杀不掉？ps看下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/ <span class="comment"># ps -A | grep fpd</span></span><br><span class="line">system        4944     1   19768   6844 __qseecom_process_incomplete_cmd 0 S gx_fpd</span><br><span class="line">fpd</span><br><span class="line">xxx:/ <span class="comment"># ps -A | grep trustonic-daemon</span></span><br><span class="line">xxx:/ <span class="comment"># ps -A | grep 3315</span></span><br><span class="line">system        3315     1       0      0 0                   0 Z [mcDriverDaemon]</span><br><span class="line">xxx:/ <span class="comment"># ps -A | grep Z</span></span><br><span class="line">USER           PID  PPID     VSZ    RSS WCHAN            ADDR S NAME</span><br><span class="line"></span><br><span class="line">system        3315     1       0      0 0                   0 Z [mcDriverDaemon]</span><br><span class="line"></span><br><span class="line">root          5094     1       0      0 0                   0 Z [vdc]</span><br></pre></td></tr></table></figure>

<p>Z？ 都僵尸了？后来发现指纹没接，接上去重启压测上千次暂未复现。</p>
<p>还有复现的log，这个是用apk做的reboot，log都有限:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;14&gt;[   86.307908] init: Received sys.powerctl=&#x27;reboot,&#x27; from pid: 1368 (system_server)</span><br><span class="line">&lt;14&gt;[   86.308048] init: Clear action queue and start shutdown trigger</span><br><span class="line">&lt;14&gt;[   86.308278] init: processing action (shutdown_done) from (&lt;Builtin Action&gt;:0)</span><br><span class="line">&lt;14&gt;[   86.308300] init: Reboot start, reason: reboot,, rebootTarget:</span><br></pre></td></tr></table></figure>

<p>对于无adb定屏的问题，发现google有一笔<a target="_blank" rel="noopener" href="https://android-review.googlesource.com/c/platform/system/core/+/872492">patch</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reland &quot;init: Reboot after timeout passes during reboot&quot;</span><br><span class="line"></span><br><span class="line">We&#x27;re experiencing issues where unmount is forcing the device to be</span><br><span class="line">stuck permanently, so it&#x27;s better to have this shutdownt thread with a</span><br><span class="line">long timeout (30s) and a potential kernel panic if it fails than a</span><br><span class="line">stuck device.</span><br></pre></td></tr></table></figure>

<p>这里<code>a potential kernel panic</code>指的啥？抛了个reboot线程来执行，如果reboot线程卡住超时，init就复位了。</p>
<p>这笔改动目前状态是合入冲突，我拿过来合入，暂未复现。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Merge Conflict 872492: Reland &quot;init: Reboot after timeout passes during reboot&quot;</span><br></pre></td></tr></table></figure>

<p>Done.</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>版权声明：</span>本站所有文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明原文链接！</p></div><br><div class="tags"><a href="/tags/reboot"><i class="fa fa-tag">reboot</i></a></div><div class="post-nav"><a class="pre" href="/essential-analysis-of-linux-cma-code.html">Linux CMA代码分析</a><a class="next" href="/tips-about-submitting-linux-kernel-patch-under-windows.html">提交Linux内核补丁遇坑说明</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/how-to-use-adeb-to-install-bcc-into-android.html">转: 使用 adeb 在 Android 上编译安装 bcc</a></li><li class="post-list-item"><a class="post-list-link" href="/kworker-sched-la-stat.html">kworker 调度延迟性能测试和统计</a></li><li class="post-list-item"><a class="post-list-link" href="/implement-erofs-fragment-dedupe.html">转：EROFS 碎片去重实践</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-enable-kasan-in-ubuntu-18-04-for-x86_64.html">How to enable KASAN in Ubuntu 18.04 for X86_64</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-analyze-segmentation-fault-for-non-install-package-in-ubuntu.html">如何分析 Linux user space's segmentation fault</a></li><li class="post-list-item"><a class="post-list-link" href="/prepare-fragment-dedupe-in-erofs.html">EROFS 碎片去重准备</a></li><li class="post-list-item"><a class="post-list-link" href="/good-naming-in-programming.html">优秀代码命名法</a></li><li class="post-list-item"><a class="post-list-link" href="/erofs-compressed-data-deduplication.html">EROFS 压缩去重分析</a></li><li class="post-list-item"><a class="post-list-link" href="/analyze-fscache-cookie-code.html">转：浅析 Linux FS-Cache</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-let-bluetooth-work-under-armbian-kodi-for-rockpi4b-within-metal-case.html">Rockpi4b Armbian Kodi 终于能使用蓝牙了</a></li></ul></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arm/">ARM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dd/">Device Driver</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fs/">File System</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iot/">IoT</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/msm/">MSM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mm/">Memory Management</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/perf/">Performance</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">Security</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/stab/">Stability</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">Tools</a><span class="category-list-count">18</span></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">TJ的技术博客.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
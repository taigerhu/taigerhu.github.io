<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>ion简要介绍 | TJ的技术博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ion简要介绍</h1><a id="logo" href="/.">TJ的技术博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 首页</i></a><a href="/archives/"><i class="fa undefined"> 归档</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ion简要介绍</h1><div class="post-meta">2017-10-10</div><div class="post-content"><p>Ion是google为了解决不同Android设备的内存碎片问题，在Android4.0中提出的下一代更通用的内存管理器，支持各种不同的内存分配，这些内存种类包括有：carveout, 物理连续的，虚拟连续的，iommu，secure memory，ion也可以在不同进程，user和kernel间共享buffer。</p>
<p>Ion把不同的内存空间用heap来分割管理，一般在dts中配置,对应的struct是<code>ion_heap</code>。要使用ion就需要创建client，用户态进程通过&#x2F;dev&#x2F;ion创建一个唯一的client，对应的struct是<code>ion_client</code>，只对kernel开放，用户态需用fd和handle来处理。这里的handle是ioctl返回的，是a buffer的抽象，用<code>ion_handle</code>来表示,真实的实体是<code>ion_buffer</code>。</p>
<h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><h3 id="heap-type"><a href="#heap-type" class="headerlink" title="heap type"></a>heap type</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum ion_heap_types - list of all possible types of heaps</span></span><br><span class="line"><span class="comment"> * @ION_HEAP_TYPE_SYSTEM:	 memory allocated via vmalloc</span></span><br><span class="line"><span class="comment"> * @ION_HEAP_TYPE_SYSTEM_CONTIG: memory allocated via kmalloc</span></span><br><span class="line"><span class="comment"> * @ION_HEAP_TYPE_CARVEOUT:	 memory allocated from a prereserved</span></span><br><span class="line"><span class="comment"> *				 carveout heap, allocations are physically</span></span><br><span class="line"><span class="comment"> *				 contiguous</span></span><br><span class="line"><span class="comment"> * @ION_HEAP_TYPE_DMA:		 memory allocated via DMA API</span></span><br><span class="line"><span class="comment"> * @ION_NUM_HEAPS:		 helper for iterating over heaps, a bit mask</span></span><br><span class="line"><span class="comment"> *				 is used to identify the heaps, so only 32</span></span><br><span class="line"><span class="comment"> *				 total heap types are supported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ion_heap_type</span> &#123;</span></span><br><span class="line">	ION_HEAP_TYPE_SYSTEM,</span><br><span class="line">	ION_HEAP_TYPE_SYSTEM_CONTIG,</span><br><span class="line">	ION_HEAP_TYPE_CARVEOUT,</span><br><span class="line">	ION_HEAP_TYPE_CHUNK,</span><br><span class="line">	ION_HEAP_TYPE_DMA,</span><br><span class="line">	ION_HEAP_TYPE_CUSTOM, <span class="comment">/* must be last so device specific heaps always</span></span><br><span class="line"><span class="comment">				 are at the end of this enum */</span></span><br><span class="line">	ION_NUM_HEAPS = <span class="number">16</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>ION_HEAP_TYPE_SYSTEM就是虚拟连续物理不连续的内存空间，come from vmalloc。</li>
<li>ION_HEAP_TYPE_SYSTEM_CONTIG就是物理连续内存空间，come from kmalloc。</li>
<li>ION_HEAP_TYPE_CARVEOUT就是预先分配好的物理上连续内存。</li>
</ul>
<p>ps: 代码环境是kernel3.18，msm平台。</p>
<p>不同的heap区间需要不同的操作内存方法，比如allocate, free, map等，对应的struct是<code>ion_heap_ops</code>。</p>
<p>大概看下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ion_heap_ops - ops to operate on a given heap</span></span><br><span class="line"><span class="comment"> * @allocate:		allocate memory</span></span><br><span class="line"><span class="comment"> * @free:		free memory. Will be called with</span></span><br><span class="line"><span class="comment"> *			ION_PRIV_FLAG_SHRINKER_FREE set in buffer flags when</span></span><br><span class="line"><span class="comment"> *			called from a shrinker. In that case, the pages being</span></span><br><span class="line"><span class="comment"> *			free&#x27;d must be truly free&#x27;d back to the system, not put</span></span><br><span class="line"><span class="comment"> *			in a page pool or otherwise cached.</span></span><br><span class="line"><span class="comment"> * @phys		get physical address of a buffer (only define on</span></span><br><span class="line"><span class="comment"> *			physically contiguous heaps)</span></span><br><span class="line"><span class="comment"> * @map_dma		map the memory for dma to a scatterlist</span></span><br><span class="line"><span class="comment"> * @unmap_dma		unmap the memory for dma</span></span><br><span class="line"><span class="comment"> * @map_kernel		map memory to the kernel</span></span><br><span class="line"><span class="comment"> * @unmap_kernel	unmap memory to the kernel</span></span><br><span class="line"><span class="comment"> * @map_user		map memory to userspace</span></span><br><span class="line"><span class="comment"> * @unmap_user		unmap memory to userspace</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * allocate, phys, and map_user return 0 on success, -errno on error.</span></span><br><span class="line"><span class="comment"> * map_dma and map_kernel return pointer on success, ERR_PTR on</span></span><br><span class="line"><span class="comment"> * error. @free will be called with ION_PRIV_FLAG_SHRINKER_FREE set in</span></span><br><span class="line"><span class="comment"> * the buffer&#x27;s private_flags when called from a shrinker. In that</span></span><br><span class="line"><span class="comment"> * case, the pages being free&#x27;d must be truly free&#x27;d back to the</span></span><br><span class="line"><span class="comment"> * system, not put in a page pool or otherwise cached.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_ops</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*allocate)(<span class="keyword">struct</span> ion_heap *heap,</span><br><span class="line">			<span class="keyword">struct</span> ion_buffer *buffer, <span class="type">unsigned</span> <span class="type">long</span> len,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> align, <span class="type">unsigned</span> <span class="type">long</span> flags);</span><br><span class="line">	<span class="type">void</span> (*<span class="built_in">free</span>)(<span class="keyword">struct</span> ion_buffer *buffer);</span><br><span class="line">	<span class="type">int</span> (*phys)(<span class="keyword">struct</span> ion_heap *heap, <span class="keyword">struct</span> ion_buffer *buffer,</span><br><span class="line">		    <span class="type">ion_phys_addr_t</span> *addr, <span class="type">size_t</span> *len);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> * (*<span class="title">map_dma</span>)(<span class="keyword">struct</span> <span class="title">ion_heap</span> *<span class="title">heap</span>,</span></span><br><span class="line"><span class="class">				     <span class="keyword">struct</span> <span class="title">ion_buffer</span> *<span class="title">buffer</span>);</span></span><br><span class="line">	<span class="type">void</span> (*unmap_dma)(<span class="keyword">struct</span> ion_heap *heap, <span class="keyword">struct</span> ion_buffer *buffer);</span><br><span class="line">	<span class="type">void</span> * (*map_kernel)(<span class="keyword">struct</span> ion_heap *heap, <span class="keyword">struct</span> ion_buffer *buffer);</span><br><span class="line">	<span class="type">void</span> (*unmap_kernel)(<span class="keyword">struct</span> ion_heap *heap, <span class="keyword">struct</span> ion_buffer *buffer);</span><br><span class="line">	<span class="type">int</span> (*map_user)(<span class="keyword">struct</span> ion_heap *mapper, <span class="keyword">struct</span> ion_buffer *buffer,</span><br><span class="line">			<span class="keyword">struct</span> vm_area_struct *vma);</span><br><span class="line">	<span class="type">int</span> (*shrink)(<span class="keyword">struct</span> ion_heap *heap, <span class="type">gfp_t</span> gfp_mask, <span class="type">int</span> nr_to_scan);</span><br><span class="line">	<span class="type">void</span> (*unmap_user) (<span class="keyword">struct</span> ion_heap *mapper, <span class="keyword">struct</span> ion_buffer *buffer);</span><br><span class="line">	<span class="type">int</span> (*print_debug)(<span class="keyword">struct</span> ion_heap *heap, <span class="keyword">struct</span> seq_file *s,</span><br><span class="line">			   <span class="type">const</span> <span class="keyword">struct</span> list_head *mem_map);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>system heap在创建时是system_heap_ops:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_ops</span> <span class="title">system_heap_ops</span> =</span> &#123;</span><br><span class="line">	.allocate = ion_system_heap_allocate,</span><br><span class="line">	.<span class="built_in">free</span> = ion_system_heap_free,</span><br><span class="line">	.map_dma = ion_system_heap_map_dma,</span><br><span class="line">	.unmap_dma = ion_system_heap_unmap_dma,</span><br><span class="line">	.map_kernel = ion_heap_map_kernel,</span><br><span class="line">	.unmap_kernel = ion_heap_unmap_kernel,</span><br><span class="line">	.map_user = ion_heap_map_user,</span><br><span class="line">	.shrink = ion_system_heap_shrink,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ion_heap *<span class="title function_">ion_system_heap_create</span><span class="params">(<span class="keyword">struct</span> ion_platform_heap *unused)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ion_system_heap</span> *<span class="title">heap</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> pools_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ion_page_pool *) * num_orders;</span><br><span class="line"></span><br><span class="line">	heap = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ion_system_heap), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!heap)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	heap-&gt;heap.ops = &amp;system_heap_ops;</span><br><span class="line">	heap-&gt;heap.type = ION_HEAP_TYPE_SYSTEM;</span><br><span class="line">	heap-&gt;heap.flags = ION_HEAP_FLAG_DEFER_FREE;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>system contig heap创建时是kmalloc_ops:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_ops</span> <span class="title">kmalloc_ops</span> =</span> &#123;</span><br><span class="line">	.allocate = ion_system_contig_heap_allocate,</span><br><span class="line">	.<span class="built_in">free</span> = ion_system_contig_heap_free,</span><br><span class="line">	.phys = ion_system_contig_heap_phys,</span><br><span class="line">	.map_dma = ion_system_contig_heap_map_dma,</span><br><span class="line">	.unmap_dma = ion_system_contig_heap_unmap_dma,</span><br><span class="line">	.map_kernel = ion_heap_map_kernel,</span><br><span class="line">	.unmap_kernel = ion_heap_unmap_kernel,</span><br><span class="line">	.map_user = ion_heap_map_user,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ion_heap *<span class="title function_">ion_system_contig_heap_create</span><span class="params">(<span class="keyword">struct</span> ion_platform_heap *unused)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> *<span class="title">heap</span>;</span></span><br><span class="line"></span><br><span class="line">	heap = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ion_heap), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!heap)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	heap-&gt;ops = &amp;kmalloc_ops;</span><br><span class="line">	heap-&gt;type = ION_HEAP_TYPE_SYSTEM_CONTIG;</span><br><span class="line">	<span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建流程是从probe开始：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">msm_ion_probe -&gt; msm_ion_heap_create -&gt; ion_system_heap_create (if ION_HEAP_TYPE_SYSTEM)</span><br></pre></td></tr></table></figure>

<h3 id="heap-ID"><a href="#heap-ID" class="headerlink" title="heap ID"></a>heap ID</h3><p>对于heap的描述，除了heap type，msm还定义了heap id，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_desc</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> id;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">ion_heap_type</span> <span class="title">type</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> permission_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那是怎么用的了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_desc</span> <span class="title">ion_heap_meta</span>[] =</span> &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		.id	= ION_SYSTEM_HEAP_ID,</span><br><span class="line">		.name	= ION_SYSTEM_HEAP_NAME,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.id	= ION_SYSTEM_CONTIG_HEAP_ID,</span><br><span class="line">		.name	= ION_KMALLOC_HEAP_NAME,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.id	= ION_SECURE_HEAP_ID,</span><br><span class="line">		.name	= ION_SECURE_HEAP_NAME,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.id	= ION_CP_MM_HEAP_ID,</span><br><span class="line">		.name	= ION_MM_HEAP_NAME,</span><br><span class="line">		.permission_type = IPT_TYPE_MM_CARVEOUT,</span><br><span class="line">	&#125;,</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * These are the only ids that should be used for Ion heap ids.</span></span><br><span class="line"><span class="comment"> * The ids listed are the order in which allocation will be attempted</span></span><br><span class="line"><span class="comment"> * if specified. Don&#x27;t swap the order of heap ids unless you know what</span></span><br><span class="line"><span class="comment"> * you are doing!</span></span><br><span class="line"><span class="comment"> * Id&#x27;s are spaced by purpose to allow new Id&#x27;s to be inserted in-between (for</span></span><br><span class="line"><span class="comment"> * possible fallbacks)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> ion_heap_ids &#123;</span><br><span class="line">	INVALID_HEAP_ID = <span class="number">-1</span>,</span><br><span class="line">	ION_CP_MM_HEAP_ID = <span class="number">8</span>,</span><br><span class="line">	ION_SECURE_HEAP_ID = <span class="number">9</span>,</span><br><span class="line">	ION_SECURE_DISPLAY_HEAP_ID = <span class="number">10</span>,</span><br><span class="line">	ION_CP_MFC_HEAP_ID = <span class="number">12</span>,</span><br><span class="line">	ION_CP_WB_HEAP_ID = <span class="number">16</span>, <span class="comment">/* 8660 only */</span></span><br><span class="line">	ION_CAMERA_HEAP_ID = <span class="number">20</span>, <span class="comment">/* 8660 only */</span></span><br><span class="line">	ION_SYSTEM_CONTIG_HEAP_ID = <span class="number">21</span>,</span><br><span class="line">	ION_ADSP_HEAP_ID = <span class="number">22</span>,</span><br><span class="line">	ION_PIL1_HEAP_ID = <span class="number">23</span>, <span class="comment">/* Currently used for other PIL images */</span></span><br><span class="line">	ION_SF_HEAP_ID = <span class="number">24</span>,</span><br><span class="line">	ION_SYSTEM_HEAP_ID = <span class="number">25</span>,</span><br><span class="line">	ION_PIL2_HEAP_ID = <span class="number">26</span>, <span class="comment">/* Currently used for modem firmware images */</span></span><br><span class="line">	ION_QSECOM_HEAP_ID = <span class="number">27</span>,</span><br><span class="line">	ION_AUDIO_HEAP_ID = <span class="number">28</span>,</span><br><span class="line"></span><br><span class="line">	ION_MM_FIRMWARE_HEAP_ID = <span class="number">29</span>,</span><br><span class="line"></span><br><span class="line">	ION_HEAP_ID_RESERVED = <span class="number">31</span> <span class="comment">/** Bit reserved for ION_FLAG_SECURE flag */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然和dts有关。 </p>
<h3 id="ion-heap-configuration-in-dts"><a href="#ion-heap-configuration-in-dts" class="headerlink" title="ion heap configuration in dts"></a>ion heap configuration in dts</h3><p>看下某个平台的msmxxxx-ion.dtsi定义</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&amp;soc &#123;</span><br><span class="line">        qcom,ion &#123;</span><br><span class="line">                compatible = &quot;qcom,msm-ion&quot;;</span><br><span class="line">                #address-cells = &lt;1&gt;;</span><br><span class="line">                #size-cells = &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">                qcom,ion-heap@25 &#123;</span><br><span class="line">                        reg = &lt;25&gt;;</span><br><span class="line">                        qcom,ion-heap-type = &quot;SYSTEM&quot;;</span><br><span class="line">                &#125;;  </span><br><span class="line"></span><br><span class="line">                qcom,ion-heap@8 &#123; /* CP_MM HEAP */</span><br><span class="line">                        reg = &lt;8&gt;;</span><br><span class="line">                        memory-region = &lt;&amp;secure_mem&gt;;</span><br><span class="line">                        qcom,ion-heap-type = &quot;SECURE_DMA&quot;;</span><br><span class="line">                &#125;;  </span><br><span class="line"></span><br><span class="line">                qcom,ion-heap@27 &#123; /* QSEECOM HEAP */</span><br><span class="line">                        reg = &lt;27&gt;;</span><br><span class="line">                        memory-region = &lt;&amp;qseecom_mem&gt;;</span><br><span class="line">                        qcom,ion-heap-type = &quot;DMA&quot;;</span><br><span class="line">                &#125;;  </span><br><span class="line">        &#125;;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>reg就是ion heap ID了, msm_ion_probe时会解析这个配置，根据这个配置创建不同的heap。</p>
<h2 id="clients"><a href="#clients" class="headerlink" title="clients"></a>clients</h2><p>对kernel，ion_client_create创建client后就可以用ion_alloc从heap中分配内存，用ion_handle对应分配的memory。分配好以后，client就拥有了ion handle，client要访问ion_hanlde关联的ion_buffer，就必须要有kernel virtual address，ion_map_kernel可以完成。ion_phys返回ion_buffer的物理地址，前提当然这块空间要是物理连续，比如ion_system_contig_heap_phys。</p>
<p>对user app，是通过open &#x2F;dev&#x2F;ion来创建的，对应的文件操作是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ion_fops</span> =</span> &#123;</span><br><span class="line">	.owner          = THIS_MODULE,</span><br><span class="line">	.open           = ion_open,</span><br><span class="line">	.release        = ion_release,</span><br><span class="line">	.unlocked_ioctl = ion_ioctl,</span><br><span class="line">	.compat_ioctl   = compat_ion_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ion_open里会调用kernel的ion_client_create，和kernel本地创建client一个样。</p>
<p>alloc&#x2F;free&#x2F;map等操作都在ioctl中实现，分配cmd就是ION_IOC_ALLOC了,直接看代码很清楚，ION_IOC_IMPORT是结合ION_IOC_SHARE用来共享buffer在user app间。</p>
<p>看下heap的mapping。</p>
<h2 id="ion-heap-map"><a href="#ion-heap-map" class="headerlink" title="ion heap map"></a>ion heap map</h2><p>ion heap可以被map到user space供app读写, 用的cmd是ION_IOC_MAP，然后用mmap就可以了。</p>
<p>对map into kernel，使用ion_map_kernel，不同heap不同map方法，比如对于system&#x2F;contig heap就是ion_heap_map_kernel。</p>
<p>调试接口fs在&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;ion里，就是clients heaps两个目录(kernel3.18)。</p>
<p>完。</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>版权声明：</span>本站所有文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明原文链接！</p></div><br><div class="tags"><a href="/tags/ion"><i class="fa fa-tag">ion</i></a></div><div class="post-nav"><a class="pre" href="/msm-serial-console.html">关于高通平台串口调试行为的一点说明</a><a class="next" href="/how-to-upload-files-to-esp8266-spiffs.html">如何把文件上传到ESP8266文件系统spiffs上</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/review-freezing-issue-when-drag-icon-after-ohos-adaption.html">OpenHarmony适配后图标拖拽卡屏问题回顾</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-fix-parse-too-complex-in-source-insight.html">Source Insight 自定义解析</a></li><li class="post-list-item"><a class="post-list-link" href="/adapt-ohos-for-mali-g57-on-sprd-t606.html">转：拥抱鸿蒙 - 在展讯T606平台上的探索与实践</a></li><li class="post-list-item"><a class="post-list-link" href="/essential-inventory-of-adaption-for-unisoc-platform-androidt-based.html">展讯平台 OpenHarmony 3.2.2 适配基础盘点</a></li><li class="post-list-item"><a class="post-list-link" href="/porting-openharmony-linux-kernel-to-3rd-party-chip.html">快速移植 OpenHarmony Linux 内核到三方 ARM64 平台</a></li><li class="post-list-item"><a class="post-list-link" href="/openharmony-linux-kernel-overview.html">初识 OpenHarmony Linux Kernel</a></li><li class="post-list-item"><a class="post-list-link" href="/what-android-gki-brings-to-oems.html">What Android GKI Brings to OEMs</a></li><li class="post-list-item"><a class="post-list-link" href="/analyze-erofs-pcluster-mode.html">转：EROFS pcluster 模式分析</a></li><li class="post-list-item"><a class="post-list-link" href="/why-cpu-intensive-work-is-meaningless-for-unbound-wq.html">为什么 WQ_CPU_INTENSIVE 对 unbound 工作队列没有意义</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-support-filter-workqueue-name-in-bpftrace-runqlat.html">如何使 bpftrace:runqlat.bt 按 workqueue name 统计延迟</a></li></ul></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arm/">arm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dd/">dd</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ebpf/">ebpf</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fs/">fs</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iot/">iot</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mm/">mm</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/msm/">msm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ohos/">ohos</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/perf/">perf</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">security</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/stab/">stab</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">tools</a><span class="category-list-count">18</span></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">TJ的技术博客.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Kernel Panic实例分析二 : Null pointer | TJ的技术博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Kernel Panic实例分析二 : Null pointer</h1><a id="logo" href="/.">TJ的技术博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 首页</i></a><a href="/archives/"><i class="fa undefined"> 归档</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Kernel Panic实例分析二 : Null pointer</h1><div class="post-meta">2020-11-04</div><div class="post-content"><p>QCOM安卓armv7 smp平台, kernel 4.x。死机时dmesg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    4.790798] Unable to handle kernel NULL pointer dereference at virtual address 000001e0</span><br><span class="line">[    4.790803] pgd = edfd65c2</span><br><span class="line">[    4.790807] [000001e0] *pgd=00000000</span><br><span class="line">[    4.790813] Internal error: Oops: 5 [#1] PREEMPT SMP ARM</span><br><span class="line">[    4.790817] Modules linked in:</span><br><span class="line">[    4.790822] CPU: 2 PID: 300 Comm: kworker/2:2 Not tainted 4.x</span><br><span class="line">[    4.790838] Workqueue: events monitor_soc_work</span><br><span class="line">[    4.790841] task: 82e93681 task.stack: be01efa9</span><br><span class="line">[    4.790848] PC is at _raw_spin_lock_irqsave+0x30/0x70</span><br><span class="line">[    4.790854] LR is at preempt_count_add+0xa4/0xb8</span><br><span class="line">[    4.790859] pc : [&lt;c10638c8&gt;]    lr : [&lt;c0168194&gt;]    psr: 40000193</span><br><span class="line">[    4.790859] sp : e9707d80  ip : e9707d60  fp : e9707d94</span><br><span class="line">[    4.790861] r10: c1909248  r9 : e9707e48  r8 : 00000000</span><br><span class="line">[    4.790864] r7 : e972d9e4  r6 : 00000020  r5 : 60000113  r4 : 000001e0</span><br><span class="line">[    4.790866] r3 : c1909a68  r2 : 00000001  r1 : 00000000  r0 : 00000000</span><br><span class="line">[    4.790870] Flags: nZcv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment none</span><br><span class="line">[    4.790873] Control: 10c0383d  Table: 8000406a  DAC: 00000051</span><br></pre></td></tr></table></figure>

<p>QCOM私有的那个分析工具的Call Stacks就看不出来，Red Hat的crash的bt提示不能work：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crash.arm&gt; bt</span><br><span class="line">PID: 300    TASK: e9698e80  CPU: 2   COMMAND: <span class="string">&quot;kworker/2:2&quot;</span></span><br><span class="line">bt: WARNING: cannot determine starting stack frame <span class="keyword">for</span> task e9698e80</span><br></pre></td></tr></table></figure>

<p>Why? mark to check later.</p>
<p>用QCOM的ramparser继续check:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parsing CPU2 context start aab41000 end aab41800</span><br><span class="line">Core 2 PC: _raw_spin_lock+4c &lt;c106350c&gt;</span><br><span class="line">Core 2 LR: _raw_spin_lock+20 &lt;c10634e0&gt;</span><br><span class="line"></span><br><span class="line">[&lt;c106350c&gt;] _raw_spin_lock+0x4c</span><br><span class="line">[&lt;c105bfa0&gt;] __schedule+0xc0</span><br><span class="line">[&lt;c105cac0&gt;] schedule+0x58</span><br><span class="line">[&lt;c013794c&gt;] do_exit+0x95c</span><br><span class="line">[&lt;c010ea9c&gt;] die+0x248</span><br><span class="line">[&lt;c0121c90&gt;] __do_kernel_fault.part.0+0x74</span><br><span class="line">[&lt;c1064e6c&gt;] do_page_fault+0x44c</span><br><span class="line">[&lt;c010130c&gt;] do_DataAbort+0x58</span><br><span class="line">[&lt;c10640bc&gt;] __dabt_svc+0x5c</span><br><span class="line">[&lt;c01584dc&gt;] kthread_data+0x18</span><br><span class="line">[&lt;c0151cec&gt;] wq_worker_sleeping+0x18</span><br><span class="line">[&lt;c105c2d4&gt;] __schedule+0x3f4</span><br><span class="line">[&lt;c016fa08&gt;] do_task_dead+0xa4</span><br><span class="line">[&lt;c0137808&gt;] do_exit+0x818</span><br><span class="line">[&lt;c010ea9c&gt;] die+0x248</span><br><span class="line">[&lt;c0121c90&gt;] __do_kernel_fault.part.0+0x74</span><br><span class="line">[&lt;c1064e6c&gt;] do_page_fault+0x44c</span><br><span class="line">[&lt;c1064f88&gt;] do_translation_fault+0x110</span><br><span class="line">[&lt;c010130c&gt;] do_DataAbort+0x58</span><br><span class="line">[&lt;c10640bc&gt;] __dabt_svc+0x5c</span><br><span class="line">[&lt;c10638c8&gt;] _raw_spin_lock_irqsave+0x30</span><br><span class="line">[&lt;c0aee46c&gt;] power_supply_changed+0x3c</span><br><span class="line">[&lt;c0b66510&gt;] qpnp_batt_power_set_property+0xf0</span><br><span class="line">[&lt;c0aee330&gt;] power_supply_set_property+0x34</span><br><span class="line">[&lt;c0b55760&gt;] report_eoc+0x90</span><br><span class="line">[&lt;c0b579d4&gt;] report_vm_bms_soc+0x7c8</span><br><span class="line">[&lt;c0b5a398&gt;] monitor_soc_work+0x708</span><br><span class="line">[&lt;c014f814&gt;] process_one_work+0x184</span><br><span class="line">[&lt;c014fc20&gt;] worker_thread+0x54</span><br><span class="line">[&lt;c0157720&gt;] kthread+0x128</span><br><span class="line">[&lt;c0109774&gt;] ret_from_fork+0x14</span><br></pre></td></tr></table></figure>

<p>ok, 以上就是panic时call stack。先来看c code:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">113</span><span class="type">void</span> <span class="title function_">power_supply_changed</span><span class="params">(<span class="keyword">struct</span> power_supply *psy)</span></span><br><span class="line">114&#123;</span><br><span class="line"><span class="number">115</span>	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="number">116</span></span><br><span class="line"><span class="number">117</span>	dev_dbg(&amp;psy-&gt;dev, <span class="string">&quot;%s\n&quot;</span>, __func__);</span><br><span class="line"><span class="number">118</span></span><br><span class="line"><span class="number">119</span>	spin_lock_irqsave(&amp;psy-&gt;changed_lock, flags); <span class="comment">//tj: here</span></span><br><span class="line"><span class="number">120</span>	psy-&gt;changed = <span class="literal">true</span>;</span><br><span class="line"><span class="number">121</span>	pm_stay_awake(&amp;psy-&gt;dev);</span><br><span class="line"><span class="number">122</span>	spin_unlock_irqrestore(&amp;psy-&gt;changed_lock, flags);</span><br><span class="line"><span class="number">123</span>	schedule_work(&amp;psy-&gt;changed_work);</span><br><span class="line"><span class="number">124</span>&#125;</span><br><span class="line"><span class="number">125</span>EXPORT_SYMBOL_GPL(power_supply_changed);</span><br></pre></td></tr></table></figure>

<p>看name，好像是死在<code>spin_lock_irqsave()</code>里了。来看看是不是：</p>
<p><code>spin_lock_irqsave()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">335</span><span class="meta">#<span class="keyword">define</span> spin_lock_irqsave(lock, flags)				\</span></span><br><span class="line"><span class="meta">336do &#123;								\</span></span><br><span class="line"><span class="meta">337	raw_spin_lock_irqsave(spinlock_check(lock), flags);	\</span></span><br><span class="line"><span class="meta">338&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p><code>spinlock_check()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">289</span><span class="type">static</span> __always_inline <span class="type">raw_spinlock_t</span> *<span class="title function_">spinlock_check</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">290&#123;</span><br><span class="line"><span class="number">291</span>	<span class="keyword">return</span> &amp;lock-&gt;rlock;</span><br><span class="line"><span class="number">292</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>raw_spin_lock_irqsave()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">203</span><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)</span></span><br><span class="line"><span class="number">204</span></span><br><span class="line"><span class="number">205</span><span class="meta">#<span class="keyword">define</span> raw_spin_lock_irqsave(lock, flags)			\</span></span><br><span class="line"><span class="meta">206	do &#123;						\</span></span><br><span class="line"><span class="meta">207		typecheck(unsigned long, flags);	\</span></span><br><span class="line"><span class="meta">208		flags = _raw_spin_lock_irqsave(lock);	\</span></span><br><span class="line"><span class="meta">209	&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p><code>_raw_spin_lock_irqsave()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">156</span><span class="meta">#<span class="keyword">ifndef</span> CONFIG_INLINE_SPIN_LOCK_IRQSAVE</span></span><br><span class="line"><span class="number">157u</span>nsigned <span class="type">long</span> __lockfunc _raw_spin_lock_irqsave(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line"><span class="number">158</span>&#123;</span><br><span class="line"><span class="number">159</span>	<span class="keyword">return</span> __raw_spin_lock_irqsave(lock);</span><br><span class="line"><span class="number">160</span>&#125;</span><br><span class="line"><span class="number">161</span>EXPORT_SYMBOL(_raw_spin_lock_irqsave);</span><br><span class="line"><span class="number">162</span><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>ps: <code>CONFIG_INLINE_SPIN_LOCK_IRQSAVE</code>未配置。</p>
<p>ok，<code>_raw_spin_lock_irqsave</code>出现了，正如我们预料的。继续看：</p>
<p><code>__raw_spin_lock_irqsave()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If lockdep is enabled then we use the non-preemption spin-ops</span></span><br><span class="line"><span class="comment"> * even on CONFIG_PREEMPT, because lockdep assumes that interrupts are</span></span><br><span class="line"><span class="comment"> * not re-enabled during lock-acquire (which the preempt-spin-ops do):</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_GENERIC_LOCKBREAK) || defined(CONFIG_DEBUG_LOCK_ALLOC)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> __raw_spin_lock_irqsave(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">        local_irq_save(flags);</span><br><span class="line">        preempt_disable();</span><br><span class="line">        spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * On lockdep we dont want the hand-coded irq-enable of</span></span><br><span class="line"><span class="comment">         * do_raw_spin_lock_flags() code, because lockdep assumes</span></span><br><span class="line"><span class="comment">         * that interrupts are not re-enabled during lock-acquire:</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">        LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        do_raw_spin_lock_flags(lock, &amp;flags);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok。我们来看死机现场asm code:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    4.790848] PC is at _raw_spin_lock_irqsave+0x30/0x70</span><br><span class="line">...</span><br><span class="line">[    4.790859] pc : [&lt;c10638c8&gt;]  </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;c10638c8&gt;] _raw_spin_lock_irqsave+0x30</span><br></pre></td></tr></table></figure>

<p>不用objdump整个vmlinux，这时crash就派上用场了，直接dis就可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crash.arm&gt; dis _raw_spin_lock_irqsave</span><br><span class="line">0xc1063898 &lt;_raw_spin_lock_irqsave&gt;:    mov     r12, sp</span><br><span class="line">0xc106389c &lt;_raw_spin_lock_irqsave+4&gt;:  push    &#123;r4, r5, r11, r12, lr, pc&#125;</span><br><span class="line">0xc10638a0 &lt;_raw_spin_lock_irqsave+8&gt;:  sub     r11, r12, #4</span><br><span class="line">0xc10638a4 &lt;_raw_spin_lock_irqsave+12&gt;: push    &#123;lr&#125;            ; (str lr, [sp, #-4]!)</span><br><span class="line">0xc10638a8 &lt;_raw_spin_lock_irqsave+16&gt;: ldmfd   sp!, &#123;lr&#125;</span><br><span class="line">0xc10638ac &lt;_raw_spin_lock_irqsave+20&gt;: mov     r4, r0</span><br><span class="line">0xc10638b0 &lt;_raw_spin_lock_irqsave+24&gt;: mrs     r5, CPSR</span><br><span class="line">0xc10638b4 &lt;_raw_spin_lock_irqsave+28&gt;: cpsid   i</span><br><span class="line">0xc10638b8 &lt;_raw_spin_lock_irqsave+32&gt;: bl      0xc0239fe0 &lt;trace_hardirqs_off&gt;</span><br><span class="line">0xc10638bc &lt;_raw_spin_lock_irqsave+36&gt;: mov     r0, #1</span><br><span class="line">0xc10638c0 &lt;_raw_spin_lock_irqsave+40&gt;: bl      0xc01680f0 &lt;preempt_count_add&gt;</span><br><span class="line">0xc10638c4 &lt;_raw_spin_lock_irqsave+44&gt;: pldw    [r4]</span><br><span class="line">0xc10638c8 &lt;_raw_spin_lock_irqsave+48&gt;: ldrex   r3, [r4] //tj: pc</span><br><span class="line">0xc10638cc &lt;_raw_spin_lock_irqsave+52&gt;: add     r2, r3, #65536  ; 0x10000</span><br><span class="line">0xc10638d0 &lt;_raw_spin_lock_irqsave+56&gt;: strex   r1, r2, [r4]</span><br><span class="line">0xc10638d4 &lt;_raw_spin_lock_irqsave+60&gt;: teq     r1, #0</span><br><span class="line">0xc10638d8 &lt;_raw_spin_lock_irqsave+64&gt;: bne     0xc10638c8 &lt;_raw_spin_lock_irqsave+48&gt;</span><br><span class="line">0xc10638dc &lt;_raw_spin_lock_irqsave+68&gt;: lsr     r2, r3, #16</span><br><span class="line">0xc10638e0 &lt;_raw_spin_lock_irqsave+72&gt;: uxth    r3, r3</span><br><span class="line">0xc10638e4 &lt;_raw_spin_lock_irqsave+76&gt;: cmp     r2, r3</span><br><span class="line">0xc10638e8 &lt;_raw_spin_lock_irqsave+80&gt;: beq     0xc10638fc &lt;_raw_spin_lock_irqsave+100&gt;</span><br><span class="line">0xc10638ec &lt;_raw_spin_lock_irqsave+84&gt;: wfe</span><br><span class="line">0xc10638f0 &lt;_raw_spin_lock_irqsave+88&gt;: ldrh    r3, [r4]</span><br><span class="line">0xc10638f4 &lt;_raw_spin_lock_irqsave+92&gt;: cmp     r2, r3</span><br><span class="line">0xc10638f8 &lt;_raw_spin_lock_irqsave+96&gt;: bne     0xc10638ec &lt;_raw_spin_lock_irqsave+84&gt;</span><br><span class="line">0xc10638fc &lt;_raw_spin_lock_irqsave+100&gt;:        dmb     ish</span><br><span class="line">0xc1063900 &lt;_raw_spin_lock_irqsave+104&gt;:        mov     r0, r5</span><br><span class="line">0xc1063904 &lt;_raw_spin_lock_irqsave+108&gt;:        ldm     sp, &#123;r4, r5, r11, sp, pc&#125;</span><br><span class="line">crash.arm&gt;</span><br></pre></td></tr></table></figure>

<p>pc:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xc10638c8 &lt;_raw_spin_lock_irqsave+48&gt;: ldrex   r3, [r4] //tj: pc</span><br></pre></td></tr></table></figure>

<p>现场r4是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r4 : 000001e0</span><br></pre></td></tr></table></figure>

<p>r4就来源r0：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xc10638ac &lt;_raw_spin_lock_irqsave+20&gt;: mov     r4, r0</span><br></pre></td></tr></table></figure>

<p>r0就是<code>_raw_spin_lock_irqsave()</code>的入参喽。前面看过c code了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">157u</span>nsigned <span class="type">long</span> __lockfunc _raw_spin_lock_irqsave(<span class="type">raw_spinlock_t</span> *lock)</span><br></pre></td></tr></table></figure>

<p>这个<code>lock</code>是000001e0？ 不是<code>[    4.790798] Unable to handle kernel NULL pointer dereference at virtual address 000001e0</code>吗？哪里有0?</p>
<p>看下<code>NULL pointer</code>由来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">131</span><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="number">132</span>__do_kernel_fault(<span class="keyword">struct</span> mm_struct *mm, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">int</span> fsr,</span><br><span class="line"><span class="number">133</span>		  <span class="keyword">struct</span> pt_regs *regs)</span><br><span class="line"><span class="number">134</span>&#123;</span><br><span class="line"><span class="number">135</span>	<span class="comment">/*</span></span><br><span class="line"><span class="comment">136	 * Are we prepared to handle this kernel fault?</span></span><br><span class="line"><span class="comment">137	 */</span></span><br><span class="line"><span class="number">138</span>	<span class="keyword">if</span> (fixup_exception(regs))</span><br><span class="line"><span class="number">139</span>		<span class="keyword">return</span>;</span><br><span class="line"><span class="number">140</span></span><br><span class="line"><span class="number">141</span>	<span class="comment">/*</span></span><br><span class="line"><span class="comment">142	 * No handler, we&#x27;ll have to terminate things with extreme prejudice.</span></span><br><span class="line"><span class="comment">143	 */</span></span><br><span class="line"><span class="number">144</span>	bust_spinlocks(<span class="number">1</span>);</span><br><span class="line"><span class="number">145</span>	pr_alert(<span class="string">&quot;Unable to handle kernel %s at virtual address %08lx\n&quot;</span>,</span><br><span class="line"><span class="number">146</span>		 (addr &lt; PAGE_SIZE) ? <span class="string">&quot;NULL pointer dereference&quot;</span> :</span><br><span class="line"><span class="number">147</span>		 <span class="string">&quot;paging request&quot;</span>, addr);</span><br></pre></td></tr></table></figure>

<p>好嘛，只要<code>addr &lt; PAGE_SIZE</code>就是<code>NULL pointer</code>了。那<code>_raw_spin_lock_irqsave(raw_spinlock_t *lock)</code>入参<code>lock</code>是不是000001e0？继续分析:</p>
<p>这个<code>lock</code>来源：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">335</span><span class="meta">#<span class="keyword">define</span> spin_lock_irqsave(lock, flags)				\</span></span><br><span class="line"><span class="meta">336do &#123;								\</span></span><br><span class="line"><span class="meta">337	raw_spin_lock_irqsave(spinlock_check(lock), flags);	\</span></span><br><span class="line"><span class="meta">338&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p><code>spinlock_check</code>的反汇编check下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crash.arm&gt; dis spinlock_check</span><br><span class="line">symbol not found: spinlock_check</span><br><span class="line">possible alternatives:</span><br><span class="line">  (none found)</span><br></pre></td></tr></table></figure>

<p>应该是inline的原因：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">289</span><span class="type">static</span> __always_inline <span class="type">raw_spinlock_t</span> *<span class="title function_">spinlock_check</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">290&#123;</span><br><span class="line"><span class="number">291</span>	<span class="keyword">return</span> &amp;lock-&gt;rlock;</span><br><span class="line"><span class="number">292</span>&#125;</span><br></pre></td></tr></table></figure>

<p>spinlock_t结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br></pre></td></tr></table></figure>

<p>继续看caller：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">113</span><span class="type">void</span> <span class="title function_">power_supply_changed</span><span class="params">(<span class="keyword">struct</span> power_supply *psy)</span></span><br><span class="line">114&#123;</span><br><span class="line"><span class="number">115</span>	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="number">116</span></span><br><span class="line"><span class="number">117</span>	dev_dbg(&amp;psy-&gt;dev, <span class="string">&quot;%s\n&quot;</span>, __func__);</span><br><span class="line"><span class="number">118</span></span><br><span class="line"><span class="number">119</span>	spin_lock_irqsave(&amp;psy-&gt;changed_lock, flags); <span class="comment">//tj: here</span></span><br></pre></td></tr></table></figure>

<p>so，这里的<code>&amp;psy-&gt;changed_lock</code>是000001e0吗？ 继续反汇编分析：</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>版权声明：</span>本站所有文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明原文链接！</p></div><br><div class="tags"><a href="/tags/panic"><i class="fa fa-tag">panic</i></a></div><div class="post-nav"><a class="pre" href="/how-to-get-kaslr-offset-on-arm64.html">How to get kaslr offset on ARM64</a><a class="next" href="/how-to-build-redhat-crash-for-arm-under-x86_64-ubuntu.html">How to build Red Hat Crash for ARM under x86_64 Ubuntu</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/kworker-sched-la-stat.html">kworker 调度延迟性能测试和统计</a></li><li class="post-list-item"><a class="post-list-link" href="/implement-erofs-fragment-dedupe.html">转：EROFS 碎片去重实践</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-enable-kasan-in-ubuntu-18-04-for-x86_64.html">How to enable KASAN in Ubuntu 18.04 for X86_64</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-analyze-segmentation-fault-for-non-install-package-in-ubuntu.html">如何分析 Linux user space's segmentation fault</a></li><li class="post-list-item"><a class="post-list-link" href="/prepare-fragment-dedupe-in-erofs.html">EROFS 碎片去重准备</a></li><li class="post-list-item"><a class="post-list-link" href="/good-naming-in-programming.html">优秀代码命名法</a></li><li class="post-list-item"><a class="post-list-link" href="/erofs-compressed-data-deduplication.html">EROFS 压缩去重分析</a></li><li class="post-list-item"><a class="post-list-link" href="/analyze-fscache-cookie-code.html">转：浅析 Linux FS-Cache</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-let-bluetooth-work-under-armbian-kodi-for-rockpi4b-within-metal-case.html">Rockpi4b Armbian Kodi 终于能使用蓝牙了</a></li><li class="post-list-item"><a class="post-list-link" href="/erofs-ztailpacking-explain.html">转：EROFS ztailpacking 特性实现详解</a></li></ul></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arm/">ARM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dd/">Device Driver</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fs/">File System</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iot/">IoT</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/msm/">MSM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mm/">Memory Management</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/perf/">Performance</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">Security</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/stab/">Stability</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">Tools</a><span class="category-list-count">17</span></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">TJ的技术博客.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
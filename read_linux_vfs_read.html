<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Read vfs_read() code | TJ的技术博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Read vfs_read() code</h1><a id="logo" href="/.">TJ的技术博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 首页</i></a><a href="/archives/"><i class="fa undefined"> 归档</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Read vfs_read() code</h1><div class="post-meta">2022-01-28</div><div class="post-content"><p>主要关注page cache部分，参考Linux Kernel 4.14:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">407</span> <span class="type">ssize_t</span> __vfs_read(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count,</span><br><span class="line"><span class="number">408</span>                    <span class="type">loff_t</span> *pos)</span><br><span class="line"><span class="number">409</span> &#123;</span><br><span class="line"><span class="number">410</span>         <span class="keyword">if</span> (file-&gt;f_op-&gt;read)</span><br><span class="line"><span class="number">411</span>                 <span class="keyword">return</span> file-&gt;f_op-&gt;read(file, buf, count, pos);</span><br><span class="line"><span class="number">412</span>         <span class="keyword">else</span> <span class="keyword">if</span> (file-&gt;f_op-&gt;read_iter)</span><br><span class="line"><span class="number">413</span>                 <span class="keyword">return</span> new_sync_read(file, buf, count, pos);</span><br><span class="line"><span class="number">414</span>         <span class="keyword">else</span></span><br><span class="line"><span class="number">415</span>                 <span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="number">416</span> &#125;</span><br></pre></td></tr></table></figure>

<p><code>-&gt;read</code>和<code>-&gt;read_iter</code>的接口定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1699</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line"><span class="number">1702</span>         <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="number">1703</span>         <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="number">1704</span>         <span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="number">1705</span>         <span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br></pre></td></tr></table></figure>

<p>来看<code>new_sync_read()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">new_sync_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> len, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123; .iov_base = buf, .iov_len = len &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kiocb</span> <span class="title">kiocb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iov_iter</span> <span class="title">iter</span>;</span></span><br><span class="line">        <span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">        init_sync_kiocb(&amp;kiocb, filp);</span><br><span class="line">        kiocb.ki_pos = *ppos;</span><br><span class="line">        iov_iter_init(&amp;iter, READ, &amp;iov, <span class="number">1</span>, len);</span><br><span class="line"></span><br><span class="line">        ret = call_read_iter(filp, &amp;kiocb, &amp;iter);</span><br><span class="line">        BUG_ON(ret == -EIOCBQUEUED);</span><br><span class="line">        *ppos = kiocb.ki_pos;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1769</span> <span class="type">static</span> <span class="keyword">inline</span> <span class="type">ssize_t</span> <span class="title function_">call_read_iter</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> kiocb *kio,</span></span><br><span class="line"><span class="params"><span class="number">1770</span>                                      <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">1771 &#123;</span><br><span class="line"><span class="number">1772</span>         <span class="keyword">return</span> file-&gt;f_op-&gt;read_iter(kio, iter);</span><br><span class="line"><span class="number">1773</span> &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>vfs_open()</code>时会把inode关联到file。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">858</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"> <span class="number">863</span>         <span class="class"><span class="keyword">struct</span> <span class="title">path</span>             <span class="title">f_path</span>;</span></span><br><span class="line"> <span class="number">864</span>         <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>            *<span class="title">f_inode</span>;</span>       <span class="comment">/* cached value */</span></span><br><span class="line"> <span class="number">865</span>         <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">f_op</span>;</span></span><br><span class="line">...</span><br><span class="line"> <span class="number">894</span>         <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">f_mapping</span>;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">879</span> <span class="type">int</span> <span class="title function_">vfs_open</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *path, <span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params"><span class="number">880</span>              <span class="type">const</span> <span class="keyword">struct</span> cred *cred)</span></span><br><span class="line">881 &#123;</span><br><span class="line"><span class="number">882</span>         <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> d_real(path-&gt;dentry, <span class="literal">NULL</span>, file-&gt;f_flags, <span class="number">0</span>);</span><br><span class="line"><span class="number">883</span></span><br><span class="line"><span class="number">884</span>         <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line"><span class="number">885</span>                 <span class="keyword">return</span> PTR_ERR(dentry);</span><br><span class="line"><span class="number">886</span></span><br><span class="line"><span class="number">887</span>         file-&gt;f_path = *path;</span><br><span class="line"><span class="number">888</span>         <span class="keyword">return</span> do_dentry_open(file, d_backing_inode(dentry), <span class="literal">NULL</span>, cred);</span><br><span class="line"><span class="number">889</span> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">714</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">do_dentry_open</span><span class="params">(<span class="keyword">struct</span> file *f,</span></span><br><span class="line"><span class="params"> <span class="number">715</span>                           <span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params"> <span class="number">716</span>                           <span class="type">int</span> (*open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *),</span></span><br><span class="line"><span class="params"> <span class="number">717</span>                           <span class="type">const</span> <span class="keyword">struct</span> cred *cred)</span></span><br><span class="line"> 718 &#123;</span><br><span class="line">...</span><br><span class="line"> <span class="number">726</span>         f-&gt;f_inode = inode;</span><br><span class="line"> <span class="number">727</span>         f-&gt;f_mapping = inode-&gt;i_mapping; <span class="comment">//tj: pagecache</span></span><br><span class="line">...</span><br><span class="line"> <span class="number">760</span>         f-&gt;f_op = fops_get(inode-&gt;i_fop); <span class="comment">//tj: f_op</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2150</span> <span class="meta">#<span class="keyword">define</span> fops_get(fops) \</span></span><br><span class="line"><span class="meta">2151         (((fops) &amp;&amp; try_module_get((fops)-&gt;owner) ? (fops) : NULL))</span></span><br></pre></td></tr></table></figure>

<p>vfs有个通用的<code>generic_file_read_iter()</code>接口，比如f2fs就直接用了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2795</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">f2fs_file_operations</span> =</span> &#123;</span><br><span class="line"><span class="number">2796</span>         .llseek         = f2fs_llseek,</span><br><span class="line"><span class="number">2797</span>         .read_iter      = generic_file_read_iter,</span><br></pre></td></tr></table></figure>

<p>在mm&#x2F;filemap.c:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2214</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">2215  * generic_file_read_iter - generic filesystem read routine</span></span><br><span class="line"><span class="comment">2216  * @iocb:       kernel I/O control block</span></span><br><span class="line"><span class="comment">2217  * @iter:       destination for the data read</span></span><br><span class="line"><span class="comment">2218  *</span></span><br><span class="line"><span class="comment">2219  * This is the &quot;read_iter()&quot; routine for all filesystems</span></span><br><span class="line"><span class="comment">2220  * that can use the page cache directly.</span></span><br><span class="line"><span class="comment">2221  */</span></span><br><span class="line"><span class="number">2222</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="number">2223</span> generic_file_read_iter(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span><br><span class="line"><span class="number">2224</span> &#123;</span><br><span class="line"><span class="number">2225</span>         <span class="type">size_t</span> count = iov_iter_count(iter);</span><br><span class="line"><span class="number">2226</span>         <span class="type">ssize_t</span> retval = <span class="number">0</span>;</span><br><span class="line"><span class="number">2227</span></span><br><span class="line"><span class="number">2228</span>         <span class="keyword">if</span> (!count)</span><br><span class="line"><span class="number">2229</span>                 <span class="keyword">goto</span> out; <span class="comment">/* skip atime */</span></span><br><span class="line"><span class="number">2230</span></span><br><span class="line"><span class="number">2231</span>         <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123;</span><br></pre></td></tr></table></figure>

<p><code>IOCB_DIRECT</code>不走page cache。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2272</span></span><br><span class="line"><span class="number">2273</span>         retval = generic_file_buffered_read(iocb, iter, retval);</span><br><span class="line"><span class="number">2274</span> out:</span><br><span class="line"><span class="number">2275</span>         <span class="keyword">return</span> retval;</span><br><span class="line"><span class="number">2276</span> &#125;</span><br></pre></td></tr></table></figure>

<p>来看 <code>generic_file_buffered_read()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1949</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">1950  * generic_file_buffered_read - generic file read routine</span></span><br><span class="line"><span class="comment">1951  * @iocb:       the iocb to read</span></span><br><span class="line"><span class="comment">1952  * @iter:       data destination</span></span><br><span class="line"><span class="comment">1953  * @written:    already copied</span></span><br><span class="line"><span class="comment">1954  *</span></span><br><span class="line"><span class="comment">1955  * This is a generic file read routine, and uses the</span></span><br><span class="line"><span class="comment">1956  * mapping-&gt;a_ops-&gt;readpage() function for the actual low-level stuff.</span></span><br><span class="line"><span class="comment">1957  *</span></span><br><span class="line"><span class="comment">1958  * This is really ugly. But the goto&#x27;s actually try to clarify some</span></span><br><span class="line"><span class="comment">1959  * of the logic when it comes to error handling etc.</span></span><br><span class="line"><span class="comment">1960  */</span></span><br><span class="line"><span class="number">1961</span> <span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">generic_file_buffered_read</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb,</span></span><br><span class="line"><span class="params"><span class="number">1962</span>                 <span class="keyword">struct</span> iov_iter *iter, <span class="type">ssize_t</span> written)</span></span><br><span class="line">1963 &#123;</span><br></pre></td></tr></table></figure>

<p>函数头注释已经提到了这里会用底层的<code>mapping-&gt;a_ops-&gt;readpage()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1980</span>         index = *ppos &gt;&gt; PAGE_SHIFT;</span><br><span class="line"><span class="number">1981</span>         prev_index = ra-&gt;prev_pos &gt;&gt; PAGE_SHIFT;</span><br><span class="line"><span class="number">1982</span>         prev_offset = ra-&gt;prev_pos &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line"><span class="number">1983</span>         last_index = (*ppos + iter-&gt;count + PAGE_SIZE<span class="number">-1</span>) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"><span class="number">1984</span>         offset = *ppos &amp; ~PAGE_MASK;</span><br></pre></td></tr></table></figure>

<p>读范围：<code>index</code>和<code>last_index</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1999</span>                 page = find_get_page(mapping, index);</span><br></pre></td></tr></table></figure>

<p>先<code>find_get_page()</code>在page cache里找这个index偏移的page:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">263</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">264  * find_get_page - find and get a page reference</span></span><br><span class="line"><span class="comment">265  * @mapping: the address_space to search</span></span><br><span class="line"><span class="comment">266  * @offset: the page index</span></span><br><span class="line"><span class="comment">267  *</span></span><br><span class="line"><span class="comment">268  * Looks up the page cache slot at @mapping &amp; @offset.  If there is a</span></span><br><span class="line"><span class="comment">269  * page cache page, it is returned with an increased refcount.</span></span><br><span class="line"><span class="comment">270  *</span></span><br><span class="line"><span class="comment">271  * Otherwise, %NULL is returned.</span></span><br><span class="line"><span class="comment">272  */</span></span><br><span class="line"><span class="number">273</span> <span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page *<span class="title function_">find_get_page</span><span class="params">(<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params"><span class="number">274</span>                                         <span class="type">pgoff_t</span> offset)</span></span><br><span class="line">275 &#123;</span><br><span class="line"><span class="number">276</span>         <span class="keyword">return</span> pagecache_get_page(mapping, offset, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="number">277</span> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2000</span>                 <span class="keyword">if</span> (!page) &#123;</span><br><span class="line"><span class="number">2001</span>                         <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_NOWAIT)</span><br><span class="line"><span class="number">2002</span>                                 <span class="keyword">goto</span> would_block;</span><br><span class="line"><span class="number">2003</span>                         page_cache_sync_readahead(mapping,</span><br><span class="line"><span class="number">2004</span>                                         ra, filp,</span><br><span class="line"><span class="number">2005</span>                                         index, last_index - index);</span><br><span class="line"><span class="number">2006</span>                         page = find_get_page(mapping, index);</span><br><span class="line"><span class="number">2007</span>                         <span class="keyword">if</span> (unlikely(page == <span class="literal">NULL</span>))</span><br><span class="line"><span class="number">2008</span>                                 <span class="keyword">goto</span> no_cached_page;</span><br><span class="line"><span class="number">2009</span>                 &#125;</span><br></pre></td></tr></table></figure>

<p>如果找不到，就<code>page_cache_sync_readahead( , , , offset, req_size)</code>同步预读下，再找还找不到就走<code>no_cached_page</code>(可能性小)。来看同步读：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">489</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">490  * page_cache_sync_readahead - generic file readahead</span></span><br><span class="line"><span class="comment">491  * @mapping: address_space which holds the pagecache and I/O vectors</span></span><br><span class="line"><span class="comment">492  * @ra: file_ra_state which holds the readahead state</span></span><br><span class="line"><span class="comment">493  * @filp: passed on to -&gt;readpage() and -&gt;readpages()</span></span><br><span class="line"><span class="comment">494  * @offset: start offset into @mapping, in pagecache page-sized units</span></span><br><span class="line"><span class="comment">495  * @req_size: hint: total size of the read which the caller is performing in</span></span><br><span class="line"><span class="comment">496  *            pagecache pages</span></span><br><span class="line"><span class="comment">497  *</span></span><br><span class="line"><span class="comment">498  * page_cache_sync_readahead() should be called when a cache miss happened:</span></span><br><span class="line"><span class="comment">499  * it will submit the read.  The readahead logic may decide to piggyback more</span></span><br><span class="line"><span class="comment">500  * pages onto the read request if access patterns suggest it will improve</span></span><br><span class="line"><span class="comment">501  * performance.</span></span><br><span class="line"><span class="comment">502  */</span></span><br><span class="line"><span class="number">503</span> <span class="type">void</span> <span class="title function_">page_cache_sync_readahead</span><span class="params">(<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params"><span class="number">504</span>                                <span class="keyword">struct</span> file_ra_state *ra, <span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params"><span class="number">505</span>                                <span class="type">pgoff_t</span> offset, <span class="type">unsigned</span> <span class="type">long</span> req_size)</span></span><br><span class="line">506 &#123;</span><br><span class="line"><span class="number">507</span>         <span class="comment">/* no read-ahead */</span></span><br><span class="line"><span class="number">508</span>         <span class="keyword">if</span> (!ra-&gt;ra_pages)</span><br><span class="line"><span class="number">509</span>                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">510</span></span><br><span class="line"><span class="number">511</span>         <span class="comment">/* be dumb */</span></span><br><span class="line"><span class="number">512</span>         <span class="keyword">if</span> (filp &amp;&amp; (filp-&gt;f_mode &amp; FMODE_RANDOM)) &#123;</span><br><span class="line"><span class="number">513</span>                 force_page_cache_readahead(mapping, filp, offset, req_size);</span><br><span class="line"><span class="number">514</span>                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">515</span>         &#125;</span><br><span class="line"><span class="number">516</span></span><br><span class="line"><span class="number">517</span>         <span class="comment">/* do read-ahead */</span></span><br><span class="line"><span class="number">518</span>         ondemand_readahead(mapping, ra, filp, <span class="literal">false</span>, offset, req_size);</span><br><span class="line"><span class="number">519</span> &#125;</span><br></pre></td></tr></table></figure>

<p>cache miss时触发同步读， 如果是<code>FMODE_RANDOM</code>随机读走<code>force_page_cache_readahead()</code>，否则走<code>ondemand_readahead()</code>。</p>
<p>先看<code>force_page_cache_readahead()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">205</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">206  * Chunk the readahead into 2 megabyte units, so that we don&#x27;t pin too much</span></span><br><span class="line"><span class="comment">207  * memory at once.</span></span><br><span class="line"><span class="comment">208  */</span></span><br><span class="line"><span class="number">209</span> <span class="type">int</span> <span class="title function_">force_page_cache_readahead</span><span class="params">(<span class="keyword">struct</span> address_space *mapping, <span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params"><span class="number">210</span>                                <span class="type">pgoff_t</span> offset, <span class="type">unsigned</span> <span class="type">long</span> nr_to_read)</span></span><br><span class="line">211 &#123;</span><br><span class="line"><span class="number">212</span>         <span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">bdi</span> =</span> inode_to_bdi(mapping-&gt;host);</span><br><span class="line"><span class="number">213</span>         <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span> *<span class="title">ra</span> =</span> &amp;filp-&gt;f_ra;</span><br><span class="line"><span class="number">214</span>         <span class="type">unsigned</span> <span class="type">long</span> max_pages;</span><br><span class="line"><span class="number">215</span></span><br><span class="line"><span class="number">216</span>         <span class="keyword">if</span> (unlikely(!mapping-&gt;a_ops-&gt;readpage &amp;&amp; !mapping-&gt;a_ops-&gt;readpages))</span><br><span class="line"><span class="number">217</span>                 <span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="number">218</span></span><br><span class="line"><span class="number">219</span>         <span class="comment">/*</span></span><br><span class="line"><span class="comment">220          * If the request exceeds the readahead window, allow the read to</span></span><br><span class="line"><span class="comment">221          * be up to the optimal hardware IO size</span></span><br><span class="line"><span class="comment">222          */</span></span><br><span class="line"><span class="number">223</span>         max_pages = <span class="type">max_t</span>(<span class="type">unsigned</span> <span class="type">long</span>, bdi-&gt;io_pages, ra-&gt;ra_pages);</span><br><span class="line"><span class="number">224</span>         nr_to_read = min(nr_to_read, max_pages);</span><br><span class="line"><span class="number">225</span>         <span class="keyword">while</span> (nr_to_read) &#123;</span><br><span class="line"><span class="number">226</span>                 <span class="type">int</span> err;</span><br><span class="line"><span class="number">227</span></span><br><span class="line"><span class="number">228</span>                 <span class="type">unsigned</span> <span class="type">long</span> this_chunk = (<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>) / PAGE_SIZE;</span><br><span class="line"><span class="number">229</span></span><br><span class="line"><span class="number">230</span>                 <span class="keyword">if</span> (this_chunk &gt; nr_to_read)</span><br><span class="line"><span class="number">231</span>                         this_chunk = nr_to_read;</span><br><span class="line"><span class="number">232</span>                 err = __do_page_cache_readahead(mapping, filp,</span><br><span class="line"><span class="number">233</span>                                                 offset, this_chunk, <span class="number">0</span>);</span><br><span class="line"><span class="number">234</span>                 <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">235</span>                         <span class="keyword">return</span> err;</span><br><span class="line"><span class="number">236</span></span><br><span class="line"><span class="number">237</span>                 offset += this_chunk;</span><br><span class="line"><span class="number">238</span>                 nr_to_read -= this_chunk;</span><br><span class="line"><span class="number">239</span>         &#125;</span><br><span class="line"><span class="number">240</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">241</span> &#125;</span><br></pre></td></tr></table></figure>

<p>就是按最大2MB单元大小的chunk进行预读，逻辑很单一。下面来看<code>ondemand_readahead()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">372</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">373  * A minimal readahead algorithm for trivial sequential/random reads.</span></span><br><span class="line"><span class="comment">374  */</span></span><br><span class="line"><span class="number">375</span> <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"><span class="number">376</span> ondemand_readahead(<span class="keyword">struct</span> address_space *mapping,</span><br><span class="line"><span class="number">377</span>                    <span class="keyword">struct</span> file_ra_state *ra, <span class="keyword">struct</span> file *filp,</span><br><span class="line"><span class="number">378</span>                    <span class="type">bool</span> hit_readahead_marker, <span class="type">pgoff_t</span> offset,</span><br><span class="line"><span class="number">379</span>                    <span class="type">unsigned</span> <span class="type">long</span> req_size)</span><br><span class="line"><span class="number">380</span> &#123;</span><br></pre></td></tr></table></figure>

<p>算法逻辑就不看了，涉及到预读窗口readahead window: (<code>ra-&gt;start</code>, <code>ra-&gt;size</code>, <code>ra-&gt;async_size</code>), 最终调用<code>_do_page_cache_readahead()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">142</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">143 * __do_page_cache_readahead() actually reads a chunk of disk.  It allocates all</span></span><br><span class="line"><span class="comment">144 * the pages first, then submits them all for I/O. This avoids the very bad</span></span><br><span class="line"><span class="comment">145 * behaviour which would occur if page allocations are causing VM writeback.</span></span><br><span class="line"><span class="comment">146 * We really don&#x27;t want to intermingle reads and writes like that.</span></span><br><span class="line"><span class="comment">147 *</span></span><br><span class="line"><span class="comment">148 * Returns the number of pages requested, or the maximum amount of I/O allowed.</span></span><br><span class="line"><span class="comment">149 */</span></span><br><span class="line"><span class="number">150</span><span class="type">int</span> __do_page_cache_readahead(<span class="keyword">struct</span> address_space *mapping, <span class="keyword">struct</span> file *filp,</span><br><span class="line"><span class="number">151</span>			<span class="type">pgoff_t</span> offset, <span class="type">unsigned</span> <span class="type">long</span> nr_to_read,</span><br><span class="line"><span class="number">152</span>			<span class="type">unsigned</span> <span class="type">long</span> lookahead_size)</span><br></pre></td></tr></table></figure>

<p>先分配all pages再开始IO:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">193</span>         <span class="comment">/*</span></span><br><span class="line"><span class="comment">194          * Now start the IO.  We ignore I/O errors - if the page is not</span></span><br><span class="line"><span class="comment">195          * uptodate then the caller will launch readpage again, and</span></span><br><span class="line"><span class="comment">196          * will then handle the error.</span></span><br><span class="line"><span class="comment">197          */</span></span><br><span class="line"><span class="number">198</span>         <span class="keyword">if</span> (ret)</span><br><span class="line"><span class="number">199</span>                 read_pages(mapping, filp, &amp;page_pool, ret, gfp_mask);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">111</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">read_pages</span><span class="params">(<span class="keyword">struct</span> address_space *mapping, <span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">...</span></span><br><span class="line"><span class="params"><span class="number">120</span>         <span class="keyword">if</span> (mapping-&gt;a_ops-&gt;readpages) &#123;</span></span><br><span class="line"><span class="params"><span class="number">121</span>                 ret = mapping-&gt;a_ops-&gt;readpages(filp, mapping, pages, nr_pages);</span></span><br><span class="line"><span class="params"><span class="number">122</span>                 <span class="comment">/* Clean up the remaining pages */</span></span></span><br><span class="line"><span class="params"><span class="number">123</span>                 put_pages_list(pages);</span></span><br><span class="line"><span class="params"><span class="number">124</span>                 <span class="keyword">goto</span> out;</span></span><br><span class="line"><span class="params"><span class="number">125</span>         &#125;</span></span><br><span class="line"><span class="params"><span class="number">126</span></span></span><br><span class="line"><span class="params"><span class="number">127</span>         <span class="keyword">for</span> (page_idx = <span class="number">0</span>; page_idx &lt; nr_pages; page_idx++) &#123;</span></span><br><span class="line"><span class="params"><span class="number">128</span>                 <span class="keyword">struct</span> page *page = lru_to_page(pages);</span></span><br><span class="line"><span class="params"><span class="number">129</span>                 list_del(&amp;page-&gt;lru);</span></span><br><span class="line"><span class="params"><span class="number">130</span>                 <span class="keyword">if</span> (!add_to_page_cache_lru(page, mapping, page-&gt;index, gfp))</span></span><br><span class="line"><span class="params"><span class="number">131</span>                         mapping-&gt;a_ops-&gt;readpage(filp, page);</span></span><br><span class="line"><span class="params"><span class="number">132</span>                 put_page(page);</span></span><br><span class="line"><span class="params"><span class="number">133</span>         &#125;</span></span><br></pre></td></tr></table></figure>

<p>优先走<code>-&gt;readpages()</code>，如果没有走<code>-&gt;readpage()</code>。</p>
<p>接着看<code>generic_file_buffered_read()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2010</span>                 <span class="keyword">if</span> (PageReadahead(page)) &#123;</span><br><span class="line"><span class="number">2011</span>                         page_cache_async_readahead(mapping,</span><br><span class="line"><span class="number">2012</span>                                         ra, filp, page,</span><br><span class="line"><span class="number">2013</span>                                         index, last_index - index);</span><br><span class="line"><span class="number">2014</span>                 &#125;</span><br><span class="line"><span class="number">2015</span>                 <span class="keyword">if</span> (!PageUptodate(page)) &#123;</span><br><span class="line"><span class="number">2016</span>                         <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_NOWAIT) &#123;</span><br><span class="line"><span class="number">2017</span>                                 put_page(page);</span><br><span class="line"><span class="number">2018</span>                                 <span class="keyword">goto</span> would_block;</span><br><span class="line"><span class="number">2019</span>                         &#125;</span><br><span class="line"><span class="number">2020</span></span><br><span class="line"><span class="number">2021</span>                         <span class="comment">/*</span></span><br><span class="line"><span class="comment">2022                          * See comment in do_read_cache_page on why</span></span><br><span class="line"><span class="comment">2023                          * wait_on_page_locked is used to avoid unnecessarily</span></span><br><span class="line"><span class="comment">2024                          * serialisations and why it&#x27;s safe.</span></span><br><span class="line"><span class="comment">2025                          */</span></span><br><span class="line"><span class="number">2026</span>                         error = wait_on_page_locked_killable(page);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在page cache里找到了这个page，不过是<code>PG_readahead</code>就走个异步读。</p>
<p>要check page是不是最新的(2015行)，为啥, 让我们看<code>do_read_cache_pages()</code>里的<code>wait_on_page_locked</code>, ok，我们看下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2689</span> <span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">do_read_cache_page</span><span class="params">(<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params"><span class="number">2690</span>                                 <span class="type">pgoff_t</span> index,</span></span><br><span class="line"><span class="params"><span class="number">2691</span>                                 <span class="type">int</span> (*filler)(<span class="type">void</span> *, <span class="keyword">struct</span> page *),</span></span><br><span class="line"><span class="params"><span class="number">2692</span>                                 <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params"><span class="number">2693</span>                                 <span class="type">gfp_t</span> gfp)</span></span><br><span class="line">2694 &#123;</span><br><span class="line"><span class="number">2695</span>         <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="number">2696</span>         <span class="type">int</span> err;</span><br><span class="line"><span class="number">2697</span> repeat:</span><br><span class="line"><span class="number">2698</span>         page = find_get_page(mapping, index);</span><br><span class="line"><span class="number">2699</span>         <span class="keyword">if</span> (!page) &#123;</span><br><span class="line"><span class="number">2700</span>                 page = __page_cache_alloc(gfp | __GFP_COLD);</span><br><span class="line"><span class="number">2701</span>                 <span class="keyword">if</span> (!page)</span><br><span class="line"><span class="number">2702</span>                         <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"><span class="number">2703</span>                 err = add_to_page_cache_lru(page, mapping, index, gfp);</span><br><span class="line"><span class="number">2704</span>                 <span class="keyword">if</span> (unlikely(err)) &#123;</span><br><span class="line"><span class="number">2705</span>                         put_page(page);</span><br><span class="line"><span class="number">2706</span>                         <span class="keyword">if</span> (err == -EEXIST)</span><br><span class="line"><span class="number">2707</span>                                 <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="number">2708</span>                         <span class="comment">/* Presumably ENOMEM for radix tree node */</span></span><br><span class="line"><span class="number">2709</span>                         <span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line"><span class="number">2710</span>                 &#125;</span><br><span class="line"><span class="number">2711</span></span><br><span class="line"><span class="number">2712</span> filler:</span><br><span class="line"><span class="number">2713</span>                 err = filler(data, page);</span><br><span class="line"><span class="number">2714</span>                 <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">2715</span>                         put_page(page);</span><br><span class="line"><span class="number">2716</span>                         <span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line"><span class="number">2717</span>                 &#125;</span><br><span class="line"><span class="number">2718</span></span><br><span class="line"><span class="number">2719</span>                 page = wait_on_page_read(page);</span><br><span class="line"><span class="number">2720</span>                 <span class="keyword">if</span> (IS_ERR(page))</span><br><span class="line"><span class="number">2721</span>                         <span class="keyword">return</span> page;</span><br><span class="line"><span class="number">2722</span>                 <span class="keyword">goto</span> out;</span><br><span class="line"><span class="number">2723</span>         &#125;</span><br><span class="line"><span class="number">2724</span>         <span class="keyword">if</span> (PageUptodate(page))</span><br><span class="line"><span class="number">2725</span>                 <span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>

<p>在<code>find_get_page()</code>找到了这个page后，这个page可能被锁：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2727</span>         <span class="comment">/*</span></span><br><span class="line"><span class="comment">2728          * Page is not up to date and may be locked due one of the following</span></span><br><span class="line"><span class="comment">2729          * case a: Page is being filled and the page lock is held</span></span><br><span class="line"><span class="comment">2730          * case b: Read/write error clearing the page uptodate status</span></span><br><span class="line"><span class="comment">2731          * case c: Truncation in progress (page locked)</span></span><br><span class="line"><span class="comment">2732          * case d: Reclaim in progress</span></span><br><span class="line"><span class="comment">2733          *</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">2757          */</span></span><br><span class="line"><span class="number">2758</span>         wait_on_page_locked(page);</span><br><span class="line"><span class="number">2759</span>         <span class="keyword">if</span> (PageUptodate(page))</span><br><span class="line"><span class="number">2760</span>                 <span class="keyword">goto</span> out;</span><br><span class="line"><span class="number">2761</span></span><br><span class="line"><span class="number">2762</span>         <span class="comment">/* Distinguish between all the cases under the safety of the lock */</span></span><br><span class="line"><span class="number">2763</span>         lock_page(page);</span><br><span class="line"><span class="number">2764</span></span><br><span class="line"><span class="number">2765</span>         <span class="comment">/* Case c or d, restart the operation */</span></span><br><span class="line"><span class="number">2766</span>         <span class="keyword">if</span> (!page-&gt;mapping) &#123;</span><br><span class="line"><span class="number">2767</span>                 unlock_page(page);</span><br><span class="line"><span class="number">2768</span>                 put_page(page);</span><br><span class="line"><span class="number">2769</span>                 <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="number">2770</span>         &#125;</span><br><span class="line"><span class="number">2771</span></span><br><span class="line"><span class="number">2772</span>         <span class="comment">/* Someone else locked and filled the page in a very small window */</span></span><br><span class="line"><span class="number">2773</span>         <span class="keyword">if</span> (PageUptodate(page)) &#123;</span><br><span class="line"><span class="number">2774</span>                 unlock_page(page);</span><br><span class="line"><span class="number">2775</span>                 <span class="keyword">goto</span> out;</span><br><span class="line"><span class="number">2776</span>         &#125;</span><br><span class="line"><span class="number">2777</span>         <span class="keyword">goto</span> filler;</span><br><span class="line"><span class="number">2778</span></span><br><span class="line"><span class="number">2779</span> out:</span><br><span class="line"><span class="number">2780</span>         mark_page_accessed(page);</span><br><span class="line"><span class="number">2781</span>         <span class="keyword">return</span> page;</span><br><span class="line"><span class="number">2782</span> &#125;</span><br></pre></td></tr></table></figure>
<p>可见，page的状态有多繁琐。</p>
<p>等待page被解锁：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">516</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">517  * Wait for a page to be unlocked.</span></span><br><span class="line"><span class="comment">518  *</span></span><br><span class="line"><span class="comment">519  * This must be called with the caller &quot;holding&quot; the page,</span></span><br><span class="line"><span class="comment">520  * ie with increased &quot;page-&gt;count&quot; so that the page won&#x27;t</span></span><br><span class="line"><span class="comment">521  * go away during the wait..</span></span><br><span class="line"><span class="comment">522  */</span></span><br><span class="line"><span class="number">523</span> <span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">wait_on_page_locked</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">524 &#123;</span><br><span class="line"><span class="number">525</span>         <span class="keyword">if</span> (PageLocked(page))</span><br><span class="line"><span class="number">526</span>                 wait_on_page_bit(compound_head(page), PG_locked);</span><br><span class="line"><span class="number">527</span> &#125;</span><br></pre></td></tr></table></figure>

<p>ok，so 等待unlock后，pageuptodate走<code>page_ok</code>, cp to user then next page:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2091</span>                 <span class="comment">/*</span></span><br><span class="line"><span class="comment">2092                  * Ok, we have the page, and it&#x27;s up-to-date, so</span></span><br><span class="line"><span class="comment">2093                  * now we can copy it to user space...</span></span><br><span class="line"><span class="comment">2094                  */</span></span><br><span class="line"><span class="number">2095</span></span><br><span class="line"><span class="number">2096</span>                 ret = copy_page_to_iter(page, offset, nr, iter);</span><br><span class="line"><span class="number">2097</span>                 offset += ret;</span><br><span class="line"><span class="number">2098</span>                 index += offset &gt;&gt; PAGE_SHIFT;</span><br><span class="line"><span class="number">2099</span>                 offset &amp;= ~PAGE_MASK;</span><br><span class="line"><span class="number">2100</span>                 prev_offset = offset;</span><br><span class="line"><span class="number">2101</span></span><br><span class="line"><span class="number">2102</span>                 put_page(page);</span><br><span class="line"><span class="number">2103</span>                 written += ret;</span><br><span class="line"><span class="number">2104</span>                 <span class="keyword">if</span> (!iov_iter_count(iter))</span><br><span class="line"><span class="number">2105</span>                         <span class="keyword">goto</span> out;</span><br><span class="line"><span class="number">2106</span>                 <span class="keyword">if</span> (ret &lt; nr) &#123;</span><br><span class="line"><span class="number">2107</span>                         error = -EFAULT;</span><br><span class="line"><span class="number">2108</span>                         <span class="keyword">goto</span> out;</span><br><span class="line"><span class="number">2109</span>                 &#125;</span><br><span class="line"><span class="number">2110</span>                 <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>简单一句话，就是pagecache找不到的就走底层的<code>-&gt;readpage(s)()</code>, 它只负责read disk。</p>
<p>Done。</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>版权声明：</span>本站所有文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明原文链接！</p></div><br><div class="tags"><a href="/tags/vfs"><i class="fa fa-tag">vfs</i></a></div><div class="post-nav"><a class="pre" href="/migrate-typecho-from-aliapp-to-cloudvm.html">从ali云弹性Web托管迁移Typecho到云虚拟主机遇坑说明</a><a class="next" href="/erofs-compacted-index-generation.html">EROFS on-disk compact index 生成分析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/linux-kernel-drm-overview.html">Linux kernel DRM overview</a></li><li class="post-list-item"><a class="post-list-link" href="/upgrade-my-custom-build-server-amd-based.html">我的PC组装升级记</a></li><li class="post-list-item"><a class="post-list-link" href="/convert-typecho-to-hexo.html">I am back!</a></li><li class="post-list-item"><a class="post-list-link" href="/review-freezing-issue-when-drag-icon-after-ohos-adaption.html">OpenHarmony适配后图标拖拽卡屏问题回顾</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-fix-parse-too-complex-in-source-insight.html">Source Insight 自定义解析</a></li><li class="post-list-item"><a class="post-list-link" href="/adapt-ohos-for-mali-g57-on-sprd-t606.html">转：拥抱鸿蒙 - 在展讯T606平台上的探索与实践</a></li><li class="post-list-item"><a class="post-list-link" href="/essential-inventory-of-adaption-for-unisoc-platform-androidt-based.html">展讯平台 OpenHarmony 3.2.2 适配基础盘点</a></li><li class="post-list-item"><a class="post-list-link" href="/porting-openharmony-linux-kernel-to-3rd-party-chip.html">快速移植 OpenHarmony Linux 内核到三方 ARM64 平台</a></li><li class="post-list-item"><a class="post-list-link" href="/openharmony-linux-kernel-overview.html">初识 OpenHarmony Linux Kernel</a></li><li class="post-list-item"><a class="post-list-link" href="/what-android-gki-brings-to-oems.html">What Android GKI Brings to OEMs</a></li></ul></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arm/">arm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dd/">dd</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ebpf/">ebpf</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fs/">fs</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iot/">iot</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mm/">mm</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/msm/">msm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ohos/">ohos</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/perf/">perf</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">security</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/stab/">stab</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">tools</a><span class="category-list-count">20</span></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">TJ的技术博客.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
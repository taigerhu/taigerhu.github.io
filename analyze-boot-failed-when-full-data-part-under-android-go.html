<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Android Go在data分区填近满后不能启动bug分析 | TJ的技术博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android Go在data分区填近满后不能启动bug分析</h1><a id="logo" href="/.">TJ的技术博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 首页</i></a><a href="/archives/"><i class="fa undefined"> 归档</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android Go在data分区填近满后不能启动bug分析</h1><div class="post-meta">2018-08-08</div><div class="post-content"><p>最近遇到一个问题：重启压测十来天后出现大量手机不能启动, Android Go&#x2F;MSM8909，有FWK同事发现空间满了，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/block/mmcblk0p39 5.2G  4.8G  340M  94% /data</span><br></pre></td></tr></table></figure>

<p>原来是我们自定义的logd一直写满了data分区，删除后立即启动正常，为什么data满了会导致起不来，看了下Z的手机，我折腾了下1h都没起来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msm8909go:/ $ <span class="built_in">df</span> -h</span><br><span class="line">Filesystem            Size  Used Avail Use% Mounted on</span><br><span class="line">rootfs                430M  1.6M  428M   1% /</span><br><span class="line">tmpfs                 442M     0  442M   0% /mnt</span><br><span class="line">/dev/block/mmcblk0p34 5.5G  5.2G     0  100% /data      // -&gt; data分区填满</span><br><span class="line">/dev/block/mmcblk0p31 104M  1.0M  100M   2% /cache</span><br><span class="line">msm8909go:/ $ ps -A | grep system_s</span><br><span class="line">system        1709  1517 1018068  46772                     0 R system_server</span><br><span class="line">msm8909go:/ $ <span class="built_in">uptime</span></span><br><span class="line"> 13:22:16 up 1:06,  0 <span class="built_in">users</span>,  load average: 4.61, 4.63, 3.79</span><br><span class="line">msm8909go:/ $ dmesg</span><br><span class="line">dmesg: klogctl: Permission denied</span><br><span class="line">msm8909go:/ $ ps -A | grep zygote</span><br><span class="line">root          1882     1  967528  56388 poll_schedule_timeout 0 S zygote</span><br><span class="line">msm8909go:/ $</span><br><span class="line">msm8909go:/ $ ps -A | grep system_s</span><br><span class="line">system        2073  1882 1011152  38588                     0 R system_server</span><br><span class="line">msm8909go:/ $</span><br></pre></td></tr></table></figure>

<p>system_server一直在重启。</p>
<p>再来看下logcat，发现如下zygote log:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01-06 03:25:49.287  1986  1986 E patchoat: Failed to create symlink at /data/dalvik-cache/arm/system@framework@boot.oat error(28): No space left on device</span><br><span class="line">01-06 03:25:49.288  1986  1986 W patchoat: Current thread not detached in Runtime shutdown</span><br><span class="line">01-06 03:25:48.959  1898  1898 W zygote  : Pruning dalvik cache because of low-memory situation.</span><br><span class="line">01-06 03:25:48.960  1898  1898 W zygote  : Failed to create boot marker.: No such file or directory</span><br><span class="line">01-06 03:25:48.960  1898  1898 W zygote  : Low-memory situation: only 0.17 megabytes available, need at least 50. Preemptively pruning the dalvik cache.</span><br><span class="line">01-06 03:25:48.961  1898  1898 I zygote  : Pruning dalvik-cache since we are relocating an image and will need to recompile</span><br><span class="line">01-06 03:25:48.962  1898  1898 I zygote  : RelocateImage: /system/bin/patchoat --input-image-location=/system/framework/boot.art --output-image-file=/data/dalvik-cache/arm/system@framework@boot.art --instruction-set=arm --base-offset-delta=-6152192</span><br><span class="line">01-06 03:25:49.303  1898  1898 E zygote  : Could not create image space with image file &#x27;/system/framework/boot.art&#x27;. Attempting to fall back to imageless running. Error was: Cannot relocate image /system/framework/boot.art to /data/dalvik-cache/arm/system@framework@boot.art: Failed execv(/system/bin/patchoat --input-image-location=/system/framework/boot.art --output-image-file=/data/dalvik-cache/arm/system@framework@boot.art --instruction-set=arm --base-offset-delta=-6152192) because non-0 exit status</span><br><span class="line">01-06 03:25:49.303  1898  1898 E zygote  : Attempted image: /system/framework/boot.art</span><br></pre></td></tr></table></figure>

<p>能看出来有No space left,  Low-memory situation，这些都是ART虚拟机的东东，让我们先简单了解下ART相关概念和背景:</p>
<p>Google官方解释：</p>
<blockquote>
<p>Android runtime (ART) is the managed runtime used by applications and some system services on Android. ART and its predecessor Dalvik were originally created specifically for the Android project. ART as the runtime executes the Dalvik Executable format and Dex bytecode specification.</p>
<p>ART and Dalvik are compatible runtimes running Dex bytecode, so apps developed for Dalvik should work when running with ART. However, some techniques that work on Dalvik do not work on ART.</p>
<p>ART introduces ahead-of-time (AOT) compilation, which can improve app performance. ART also has tighter install-time verification than Dalvik.</p>
<p>At install time, ART compiles apps using the on-device dex2oat tool. This utility accepts DEX files as input and generates a compiled app executable for the target device. The utility should be able to compile all valid DEX files without difficulty. However, some post-processing tools produce invalid files that may be tolerated by Dalvik but cannot be compiled by ART.</p>
</blockquote>
<p>以前用Dalvik，现在使用ART提高性能，ART向后兼容Dalvik。ART引入了AOT编译技术，使用dex2oat这个工具把DEX文件作为输入，生成相应的可执行文件(ELF格式)。 dex就是Dalvik excutable file， odex就是optimized dex。</p>
<p>再看下wikipedia上对ART和Dalvik的框架对比图：</p>
<p><img src="http://tjtech.me/usr/uploads/2018/08/2962129657.png" alt="ART_view.png"></p>
<p>ok，让我们看代码, path: art&#x2F;runtime&#x2F;gc&#x2F;space&#x2F;image_space.cc:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;ImageSpace&gt; <span class="title">ImageSpace::CreateBootImage</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* image_location,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        <span class="type">const</span> InstructionSet image_isa,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        <span class="type">bool</span> secondary_image,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        std::string* error_msg)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">// Step 0.b: If we&#x27;re the zygote, check for free space, and prune the cache preemptively,</span></span><br><span class="line">  <span class="comment">//           if necessary. While the runtime may be fine (it is pretty tolerant to</span></span><br><span class="line">  <span class="comment">//           out-of-disk-space situations), other parts of the platform are not.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//           The advantage of doing this proactively is that the later steps are simplified,</span></span><br><span class="line">  <span class="comment">//           i.e., we do not need to code retries.</span></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (is_zygote &amp;&amp; dalvik_cache_exists) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!dalvik_cache.<span class="built_in">empty</span>());</span><br><span class="line">    std::string local_error_msg;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CheckSpace</span>(dalvik_cache, &amp;local_error_msg)) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; local_error_msg &lt;&lt; <span class="string">&quot; Preemptively pruning the dalvik cache.&quot;</span>;</span><br><span class="line">      <span class="built_in">PruneDalvikCache</span>(image_isa);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Re-evaluate the image.</span></span><br><span class="line">      found_image = <span class="built_in">FindImageFilenameImpl</span>(image_location,</span><br><span class="line">                                          image_isa,</span><br><span class="line">                                          &amp;has_system,</span><br><span class="line">                                          &amp;system_filename,</span><br><span class="line">                                          &amp;dalvik_cache_exists,</span><br><span class="line">                                          &amp;dalvik_cache,</span><br><span class="line">                                          &amp;is_global_cache,</span><br><span class="line">                                          &amp;has_cache,</span><br><span class="line">                                          &amp;cache_filename);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里boot image是啥意思，稍等下看。</p>
<p>zygote起来后会check space，如果空间过小，就调用PruneDalvikCache把dalvik cache干掉。</p>
<p>先看看check space:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint64_t</span> kLowSpaceValue = <span class="number">50</span> * MB;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint64_t</span> kTmpFsSentinelValue = <span class="number">384</span> * MB;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the free space of the cache partition and make a decision whether to keep the generated</span></span><br><span class="line"><span class="comment">// image. This is to try to mitigate situations where the system might run out of space later.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">CheckSpace</span><span class="params">(<span class="type">const</span> std::string&amp; cache_filename, std::string* error_msg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Using statvfs vs statvfs64 because of b/18207376, and it is enough for all practical purposes.</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">statvfs</span> buf;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> res = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">statvfs</span>(cache_filename.<span class="built_in">c_str</span>(), &amp;buf));</span><br><span class="line">  <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Could not stat. Conservatively tell the system to delete the image.</span></span><br><span class="line">    *error_msg = <span class="string">&quot;Could not stat the filesystem, assuming low-memory situation.&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> fs_overall_size = buf.f_bsize * <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(buf.f_blocks);</span><br><span class="line">  <span class="comment">// Zygote is privileged, but other things are not. Use bavail.</span></span><br><span class="line">  <span class="type">uint64_t</span> fs_free_size = buf.f_bsize * <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(buf.f_bavail);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Take the overall size as an indicator for a tmpfs, which is being used for the decryption</span></span><br><span class="line">  <span class="comment">// environment. We do not want to fail quickening the boot image there, as it is beneficial</span></span><br><span class="line">  <span class="comment">// for time-to-UI.</span></span><br><span class="line">  <span class="keyword">if</span> (fs_overall_size &gt; kTmpFsSentinelValue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fs_free_size &lt; kLowSpaceValue) &#123;</span><br><span class="line">      *error_msg = <span class="built_in">StringPrintf</span>(<span class="string">&quot;Low-memory situation: only %4.2f megabytes available, need at &quot;</span></span><br><span class="line">                                <span class="string">&quot;least %&quot;</span> PRIu64 <span class="string">&quot;.&quot;</span>,</span><br><span class="line">                                <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(fs_free_size) / MB,</span><br><span class="line">                                kLowSpaceValue / MB);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看注释：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Read the free space of the cache partition and make a decision whether to keep the generated</span></span><br><span class="line"><span class="comment">// image. This is to try to mitigate situations where the system might run out of space later.</span></span><br></pre></td></tr></table></figure>

<p>这里cache partition不是说的&#x2F;cache分区，而是说的dalvik cache目录，具体是data分区的&#x2F;data&#x2F;dalvik-cache目录。</p>
<p>剩余空间用的<code>fs_free_size</code>，ART定的最小门限是50MB(kLowSpaceValue)，应该就是data分区的&lt;50MB就认为Low-memory了。</p>
<p>再看了prune dalvik cache做了什么：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// We are relocating or generating the core image. We should get rid of everything. It is all</span></span><br><span class="line"><span class="comment">// out-of-date. We also don&#x27;t really care if this fails since it is just a convenience.</span></span><br><span class="line"><span class="comment">// Adapted from prune_dex_cache(const char* subdir) in frameworks/native/cmds/installd/commands.c</span></span><br><span class="line"><span class="comment">// Note this should only be used during first boot.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PruneDalvikCache</span><span class="params">(InstructionSet isa)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">CHECK_NE</span>(isa, kNone);</span><br><span class="line">  <span class="comment">// Prune the base /data/dalvik-cache.</span></span><br><span class="line">  <span class="comment">// Note: GetDalvikCache may return the empty string if the directory doesn&#x27;t</span></span><br><span class="line">  <span class="comment">// exist. It is safe to pass &quot;&quot; to DeleteDirectoryContents, so this is okay.</span></span><br><span class="line">  impl::<span class="built_in">DeleteDirectoryContents</span>(<span class="built_in">GetDalvikCache</span>(<span class="string">&quot;.&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// Prune /data/dalvik-cache/&lt;isa&gt;.</span></span><br><span class="line">  impl::<span class="built_in">DeleteDirectoryContents</span>(<span class="built_in">GetDalvikCache</span>(<span class="built_in">GetInstructionSetString</span>(isa)), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Be defensive. There should be a runtime created here, but this may be called in a test.</span></span><br><span class="line">  <span class="keyword">if</span> (Runtime::<span class="built_in">Current</span>() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">SetPrunedDalvikCache</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是&#x2F;data&#x2F;dalvik-cache&#x2F;<isa>这个目录删了，正常启动的手机看下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">8909go:/data/dalvik-cache <span class="comment"># du -h</span></span><br><span class="line">269M    ./arm</span><br><span class="line">269M    .</span><br></pre></td></tr></table></figure>

<p>占用了不少啊。</p>
<p>我们再继续看create boot image:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 1: Check if we have an existing and relocated image.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1.a: Have files in system and cache. Then they need to match.</span></span><br><span class="line"><span class="keyword">if</span> (found_image &amp;&amp; has_system &amp;&amp; has_cache) &#123;</span><br><span class="line">  std::string local_error_msg;</span><br><span class="line">  <span class="comment">// Check that the files are matching.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ChecksumsMatch</span>(system_filename.<span class="built_in">c_str</span>(), cache_filename.<span class="built_in">c_str</span>(), &amp;local_error_msg)) &#123;</span><br><span class="line">    std::unique_ptr&lt;ImageSpace&gt; relocated_space =</span><br><span class="line">        ImageSpaceLoader::<span class="built_in">Load</span>(image_location,</span><br><span class="line">                               cache_filename,</span><br><span class="line">                               is_zygote,</span><br><span class="line">                               is_global_cache,</span><br><span class="line">                               <span class="comment">/* validate_oat_file */</span> <span class="literal">false</span>,</span><br><span class="line">                               &amp;local_error_msg);</span><br><span class="line">    <span class="keyword">if</span> (relocated_space != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> relocated_space;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;    </span><br><span class="line">  error_msgs.<span class="built_in">push_back</span>(local_error_msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1.b: Only have a cache file.</span></span><br><span class="line"><span class="keyword">if</span> (found_image &amp;&amp; !has_system &amp;&amp; has_cache) &#123;</span><br><span class="line">  std::string local_error_msg;</span><br><span class="line">  std::unique_ptr&lt;ImageSpace&gt; cache_space =</span><br><span class="line">      ImageSpaceLoader::<span class="built_in">Load</span>(image_location,</span><br><span class="line">                             cache_filename,</span><br><span class="line">                             is_zygote,</span><br><span class="line">                             is_global_cache,</span><br><span class="line">                             <span class="comment">/* validate_oat_file */</span> <span class="literal">true</span>,</span><br><span class="line">                             &amp;local_error_msg);</span><br><span class="line">  <span class="keyword">if</span> (cache_space != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache_space;</span><br><span class="line">  &#125;    </span><br><span class="line">  error_msgs.<span class="built_in">push_back</span>(local_error_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有没有找到image在step 1 FindImageFilenameImpl里：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">FindImageFilenameImpl</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* image_location,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> InstructionSet image_isa,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">bool</span>* has_system,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  std::string* system_filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">bool</span>* dalvik_cache_exists,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  std::string* dalvik_cache,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">bool</span>* is_global_cache,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">bool</span>* has_cache,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  std::string* cache_filename)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(dalvik_cache != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  *has_system = <span class="literal">false</span>;</span><br><span class="line">  *has_cache = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// image_location = /system/framework/boot.art</span></span><br><span class="line">  <span class="comment">// system_image_location = /system/framework/&lt;image_isa&gt;/boot.art</span></span><br><span class="line">  <span class="function">std::string <span class="title">system_image_filename</span><span class="params">(GetSystemImageFilename(image_location, image_isa))</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (OS::<span class="built_in">FileExists</span>(system_image_filename.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">    *system_filename = system_image_filename;</span><br><span class="line">    *has_system = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> have_android_data = <span class="literal">false</span>;</span><br><span class="line">  *dalvik_cache_exists = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">GetDalvikCache</span>(<span class="built_in">GetInstructionSetString</span>(image_isa),</span><br><span class="line">                 <span class="literal">true</span>,</span><br><span class="line">                 dalvik_cache,</span><br><span class="line">                 &amp;have_android_data,</span><br><span class="line">                 dalvik_cache_exists,</span><br><span class="line">                 is_global_cache);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (have_android_data &amp;&amp; *dalvik_cache_exists) &#123;</span><br><span class="line">    <span class="comment">// Always set output location even if it does not exist,</span></span><br><span class="line">    <span class="comment">// so that the caller knows where to create the image.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// image_location = /system/framework/boot.art</span></span><br><span class="line">    <span class="comment">// *image_filename = /data/dalvik-cache/&lt;image_isa&gt;/boot.art</span></span><br><span class="line">    std::string error_msg;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">GetDalvikCacheFilename</span>(image_location,</span><br><span class="line">                                dalvik_cache-&gt;<span class="built_in">c_str</span>(),</span><br><span class="line">                                cache_filename,</span><br><span class="line">                                &amp;error_msg)) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; error_msg;</span><br><span class="line">      <span class="keyword">return</span> *has_system;</span><br><span class="line">    &#125;</span><br><span class="line">    *has_cache = OS::<span class="built_in">FileExists</span>(cache_filename-&gt;<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *has_system || *has_cache;</span><br></pre></td></tr></table></figure>

<p>ok, file in system指的是&#x2F;system&#x2F;framework&#x2F;boot.art，file in cache指的是&#x2F;data&#x2F;dalvik-cache&#x2F;<image_isa>&#x2F;boot.art。</p>
<p>如果都存在且匹配就返回ok了,如果没有匹配，继续step 1.b：只有cache file，load ok也返回ok了,如果只有system有，来看step 2:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 2: We have an existing image in /system.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2.a: We are not required to relocate it. Then we can use it directly.</span></span><br><span class="line"><span class="type">bool</span> relocate = Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">ShouldRelocate</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (found_image &amp;&amp; has_system &amp;&amp; !relocate) &#123;</span><br><span class="line">  std::string local_error_msg;</span><br><span class="line">  std::unique_ptr&lt;ImageSpace&gt; system_space =</span><br><span class="line">      ImageSpaceLoader::<span class="built_in">Load</span>(image_location,</span><br><span class="line">                             system_filename,</span><br><span class="line">                             is_zygote,</span><br><span class="line">                             is_global_cache,</span><br><span class="line">                             <span class="comment">/* validate_oat_file */</span> <span class="literal">false</span>,</span><br><span class="line">                             &amp;local_error_msg);</span><br><span class="line">  <span class="keyword">if</span> (system_space != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> system_space;</span><br><span class="line">  &#125;</span><br><span class="line">  error_msgs.<span class="built_in">push_back</span>(local_error_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不需要relocate，直接load ok就返回ok了,那如果需要呢：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 2.b: We require a relocated image. Then we must patch it. This step fails if this is a</span></span><br><span class="line"><span class="comment">//           secondary image.</span></span><br><span class="line"><span class="keyword">if</span> (found_image &amp;&amp; has_system &amp;&amp; relocate) &#123;</span><br><span class="line">  std::string local_error_msg;</span><br><span class="line">  <span class="keyword">if</span> (!Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">IsImageDex2OatEnabled</span>()) &#123;</span><br><span class="line">    local_error_msg = <span class="string">&quot;Patching disabled.&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondary_image) &#123;</span><br><span class="line">    <span class="comment">// We really want a working image. Prune and restart.</span></span><br><span class="line">    <span class="built_in">PruneDalvikCache</span>(image_isa);</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">ImageCreationAllowed</span>(is_global_cache, image_isa, &amp;local_error_msg)) &#123;</span><br><span class="line">    <span class="type">bool</span> patch_success =</span><br><span class="line">        <span class="built_in">RelocateImage</span>(image_location, cache_filename.<span class="built_in">c_str</span>(), image_isa, &amp;local_error_msg);</span><br><span class="line">    <span class="keyword">if</span> (patch_success) &#123;</span><br><span class="line">      std::unique_ptr&lt;ImageSpace&gt; patched_space =</span><br><span class="line">          ImageSpaceLoader::<span class="built_in">Load</span>(image_location,</span><br><span class="line">                                 cache_filename,</span><br><span class="line">                                 is_zygote,</span><br><span class="line">                                 is_global_cache,</span><br><span class="line">                                 <span class="comment">/* validate_oat_file */</span> <span class="literal">false</span>,</span><br><span class="line">                                 &amp;local_error_msg);</span><br><span class="line">      <span class="keyword">if</span> (patched_space != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> patched_space;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  error_msgs.<span class="built_in">push_back</span>(<span class="built_in">StringPrintf</span>(<span class="string">&quot;Cannot relocate image %s to %s: %s&quot;</span>,</span><br><span class="line">                                    image_location,</span><br><span class="line">                                    cache_filename.<span class="built_in">c_str</span>(),</span><br><span class="line">                                    local_error_msg.<span class="built_in">c_str</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看patch是否disable了，如果patch enable了，看看是不是secondary_image，如果是那么必须删掉dalvik-cache目录重启该进程, 如果是first image那么直接调用RelocateImage进行relocate。</p>
<p>继续看step 3:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 3: We do not have an existing image in /system, so generate an image into the dalvik</span></span><br><span class="line"><span class="comment">//         cache. This step fails if this is a secondary image.</span></span><br><span class="line"><span class="keyword">if</span> (!has_system) &#123;</span><br><span class="line">  std::string local_error_msg;</span><br><span class="line">  <span class="keyword">if</span> (!Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">IsImageDex2OatEnabled</span>()) &#123;</span><br><span class="line">    local_error_msg = <span class="string">&quot;Image compilation disabled.&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondary_image) &#123;</span><br><span class="line">    local_error_msg = <span class="string">&quot;Cannot compile a secondary image.&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">ImageCreationAllowed</span>(is_global_cache, image_isa, &amp;local_error_msg)) &#123;</span><br><span class="line">    <span class="type">bool</span> compilation_success = <span class="built_in">GenerateImage</span>(cache_filename, image_isa, &amp;local_error_msg);</span><br><span class="line">    <span class="keyword">if</span> (compilation_success) &#123;</span><br><span class="line">      std::unique_ptr&lt;ImageSpace&gt; compiled_space =</span><br><span class="line">          ImageSpaceLoader::<span class="built_in">Load</span>(image_location,</span><br><span class="line">                                 cache_filename,</span><br><span class="line">                                 is_zygote,</span><br><span class="line">                                 is_global_cache,</span><br><span class="line">                                 <span class="comment">/* validate_oat_file */</span> <span class="literal">false</span>,</span><br><span class="line">                                 &amp;local_error_msg);</span><br><span class="line">      <span class="keyword">if</span> (compiled_space != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> compiled_space;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  error_msgs.<span class="built_in">push_back</span>(<span class="built_in">StringPrintf</span>(<span class="string">&quot;Cannot compile image to %s: %s&quot;</span>,</span><br><span class="line">                                    cache_filename.<span class="built_in">c_str</span>(),</span><br><span class="line">                                    local_error_msg.<span class="built_in">c_str</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>system下没有boot image就要创建一个到&#x2F;data&#x2F;dalvik-cache下，流程同relocate，同样的secondary image会失败。</p>
<p>ok, create boot image走完。有没有发现secondary image的_exit的流程，会有这种可能：</p>
<p>如果data空间不足50MB，而且在创建boot image的index是!first image，那么会一直死循环，right?</p>
<p>再看下9.0 ART应该是修复了。</p>
<p>还有几个疑问：啥是relocate? 就是为了安全考虑，patchoat就是用来relocate的工具, 具体参考文档里详解。那boot image是什么? 看下stackflow的回答：</p>
<blockquote>
<p>Pre-ART, Android used the Zygote to fork each app process and preload and preinitialize some classes  for optimization purposes. On ART, the set of jar libraries that should be preloaded into each app process is compiled once into the so called boot image. It consists of two files, boot.oat and boot.art. Boot.oat contains the compiled code while boot.art contains a preinitialized heap etc. Both are also generated by dex2oat. This boot image is loaded into each app’s process as an optimization. </p>
</blockquote>
<p>至于什么是secondary image，暂时不明白，由gc&#x2F;heap而来，以后再看。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/platform/">https://developer.android.com/guide/platform/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://source.android.com/devices/tech/dalvik/">https://source.android.com/devices/tech/dalvik/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Android_Runtime">https://en.wikipedia.org/wiki/Android_Runtime</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mssun.me/blog/android-art-runtime-1-background.html">https://mssun.me/blog/android-art-runtime-1-background.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mssun.me/blog/android-art-runtime-2-dex2oat.html">https://mssun.me/blog/android-art-runtime-2-dex2oat.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mssun.me/blog/android-art-runtime-3-compiler.html">https://mssun.me/blog/android-art-runtime-3-compiler.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mssun.me/blog/android-art-runtime-4-patchoat.html">https://mssun.me/blog/android-art-runtime-4-patchoat.html</a></p>
</li>
</ul>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>版权声明：</span>本站所有文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明原文链接！</p></div><br><div class="tags"><a href="/tags/zygote"><i class="fa fa-tag">zygote</i></a><a href="/tags/ART"><i class="fa fa-tag">ART</i></a></div><div class="post-nav"><a class="pre" href="/f2fs-block-reservation-analysis-and-usage-on-android.html">F2FS保留块特性分析及如何在Android上使用</a><a class="next" href="/fix-an-stange-kernel-crash-on-cust-drv.html">Fix a strange kernel crash issue on custom driver</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/kworker-sched-la-stat.html">kworker 调度延迟性能测试和统计</a></li><li class="post-list-item"><a class="post-list-link" href="/implement-erofs-fragment-dedupe.html">转：EROFS 碎片去重实践</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-enable-kasan-in-ubuntu-18-04-for-x86_64.html">How to enable KASAN in Ubuntu 18.04 for X86_64</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-analyze-segmentation-fault-for-non-install-package-in-ubuntu.html">如何分析 Linux user space's segmentation fault</a></li><li class="post-list-item"><a class="post-list-link" href="/prepare-fragment-dedupe-in-erofs.html">EROFS 碎片去重准备</a></li><li class="post-list-item"><a class="post-list-link" href="/good-naming-in-programming.html">优秀代码命名法</a></li><li class="post-list-item"><a class="post-list-link" href="/erofs-compressed-data-deduplication.html">EROFS 压缩去重分析</a></li><li class="post-list-item"><a class="post-list-link" href="/analyze-fscache-cookie-code.html">转：浅析 Linux FS-Cache</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-let-bluetooth-work-under-armbian-kodi-for-rockpi4b-within-metal-case.html">Rockpi4b Armbian Kodi 终于能使用蓝牙了</a></li><li class="post-list-item"><a class="post-list-link" href="/erofs-ztailpacking-explain.html">转：EROFS ztailpacking 特性实现详解</a></li></ul></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arm/">ARM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dd/">Device Driver</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fs/">File System</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iot/">IoT</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/msm/">MSM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mm/">Memory Management</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/perf/">Performance</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">Security</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/stab/">Stability</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">Tools</a><span class="category-list-count">17</span></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">TJ的技术博客.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
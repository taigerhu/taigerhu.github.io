<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>erofs代码分析: on-disk inode layout | TJ的技术博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">erofs代码分析: on-disk inode layout</h1><a id="logo" href="/.">TJ的技术博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 首页</i></a><a href="/archives/"><i class="fa undefined"> 归档</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">erofs代码分析: on-disk inode layout</h1><div class="post-meta">2019-06-26</div><div class="post-content"><p>参考staging erofs，on-disk inode layout相关实现是erofs_fs.h + super.c + inode.c。</p>
<h2 id="data-mappings"><a href="#data-mappings" class="headerlink" title="data mappings"></a>data mappings</h2><p>先看文档介绍：</p>
<blockquote>
<p>- Metadata &amp; data could be mixed by design;</p>
</blockquote>
<blockquote>
<p>Different from other read-only file systems, an EROFS volume is designed to be as simple as possible:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">                              |-&gt; aligned with the block size </span><br><span class="line">_____________________________________________________________ </span><br><span class="line">| |SB| | ... | Metadata | ... | Data | Metadata | ... | Data |</span><br><span class="line">|_|__|_|_____|__________|_____|______|__________|_____|______|</span><br><span class="line">0 +1K</span><br></pre></td></tr></table></figure>
</blockquote>
<p>What is metadata in fs? refer below from wikipedia:</p>
<blockquote>
<p>metadata is data information that provides infor about other data.</p>
</blockquote>
<p>erofs super block放到了1K偏移处。<code>superblock_read()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EROFS_SUPER_OFFSET      1024</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">superblock_read</span><span class="params">(<span class="keyword">struct</span> super_block *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">erofs_sb_info</span> *<span class="title">sbi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">erofs_super_block</span> *<span class="title">layout</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> blkszbits;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	bh = sb_bread(sb, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		errln(<span class="string">&quot;cannot read erofs superblock&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sbi = EROFS_SB(sb);</span><br><span class="line">	layout = (<span class="keyword">struct</span> erofs_super_block *)((u8 *)bh-&gt;b_data</span><br><span class="line">		 + EROFS_SUPER_OFFSET); <span class="comment">// tj: here</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>All data areas should be aligned with the block size, but metadata areas may not. All metadatas can be now observed in two different spaces (views):</p>
<ol>
<li><p>Inode metadata space<br>Each valid inode should be aligned with an inode slot, which is a fixed value (32 bytes) and designed to be kept in line with v1 inode size.</p>
<p>Each inode can be directly found with the following formula:<br>\ \ \ \ \     inode offset &#x3D; meta_blkaddr * block_size + 32 * nid</p>
</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">                            |-&gt; aligned with 8B </span><br><span class="line">                                       |-&gt; followed closely </span><br><span class="line">+ meta_blkaddr blocks                                      |-&gt; another slot </span><br><span class="line"> _____________________________________________________________________ </span><br><span class="line">|  ...   | inode |  xattrs  | extents  | data inline | ... | inode ...</span><br><span class="line">|________|_______|(optional)|(optional)|__(optional)_|_____|__________ </span><br><span class="line">         |-&gt; aligned with the inode slot size</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>Xattrs, extents, data inline are followed by the corresponding inode with proper alignes, and they could be optional for different data mappings, <em>currently</em> there are totally 3 valid data mappings supported:<br>     1) flat file data without data inline (no extent);<br>     2) fixed-output size data compression (must have extents);<br>     3) flat file data with tail-end data inline (no extent);</p>
</blockquote>
<p>三种inode data mapping:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * erofs inode data mapping:</span></span><br><span class="line"><span class="comment"> * 0 - inode plain without inline data A:</span></span><br><span class="line"><span class="comment"> * inode, [xattrs], ... | ... | no-holed data</span></span><br><span class="line"><span class="comment"> * 1 - inode VLE compression B:</span></span><br><span class="line"><span class="comment"> * inode, [xattrs], extents ... | ...</span></span><br><span class="line"><span class="comment"> * 2 - inode plain with inline data C:</span></span><br><span class="line"><span class="comment"> * inode, [xattrs], last_inline_data, ... | ... | no-holed data</span></span><br><span class="line"><span class="comment"> * 3~7 - reserved</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	EROFS_INODE_LAYOUT_PLAIN,</span><br><span class="line">	EROFS_INODE_LAYOUT_COMPRESSION,</span><br><span class="line">	EROFS_INODE_LAYOUT_INLINE,</span><br><span class="line">	EROFS_INODE_LAYOUT_MAX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="read-super-block"><a href="#read-super-block" class="headerlink" title="read super block"></a>read super block</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">erofs_mount() &gt; erofs_fill_super() &gt; erofs_read_super()</span><br></pre></td></tr></table></figure>

<p>mount时会call <code>erofs_read_super()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">erofs_read_super</span><span class="params">(<span class="keyword">struct</span> super_block *sb,</span></span><br><span class="line"><span class="params">			    <span class="type">const</span> <span class="type">char</span> *dev_name,</span></span><br><span class="line"><span class="params">			    <span class="type">void</span> *data, <span class="type">int</span> silent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">erofs_sb_info</span> *<span class="title">sbi</span>;</span></span><br><span class="line">	sb-&gt;s_fs_info = sbi;</span><br><span class="line">...</span><br><span class="line">	err = superblock_read(sb);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_sbread;</span><br></pre></td></tr></table></figure>

<p><code>superblock_read()</code>就是find super block，super block结构赋值来源mkfs.erofs.</p>
<p>接下来在解析mount选项后会获取root inode给<code>-&gt;s_root</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* get the root inode */</span></span><br><span class="line">inode = erofs_iget(sb, ROOT_NID(sbi), <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(inode)) &#123;</span><br><span class="line">	err = PTR_ERR(inode);</span><br><span class="line">	<span class="keyword">goto</span> err_iget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!S_ISDIR(inode-&gt;i_mode)) &#123;</span><br><span class="line">	errln(<span class="string">&quot;rootino(nid %llu) is not a directory(i_mode %o)&quot;</span>,</span><br><span class="line">	      ROOT_NID(sbi), inode-&gt;i_mode);</span><br><span class="line">	err = -EINVAL;</span><br><span class="line">	iput(inode);</span><br><span class="line">	<span class="keyword">goto</span> err_iget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sb-&gt;s_root = d_make_root(inode); <span class="comment">//tj: here</span></span><br><span class="line"><span class="keyword">if</span> (!sb-&gt;s_root) &#123;</span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	<span class="keyword">goto</span> err_iget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果root inode不是目录，那就无效了。</p>
<h2 id="get-inode"><a href="#get-inode" class="headerlink" title="get inode"></a>get inode</h2><p>主要看下<code>erofs_iget()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode *<span class="title function_">erofs_iget</span><span class="params">(<span class="keyword">struct</span> super_block *sb,</span></span><br><span class="line"><span class="params">			 <span class="type">erofs_nid_t</span> nid,</span></span><br><span class="line"><span class="params">			 <span class="type">bool</span> isdir)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> erofs_iget_locked(sb, nid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!inode))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_state &amp; I_NEW) &#123;</span><br><span class="line">		<span class="type">int</span> err;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">erofs_vnode</span> *<span class="title">vi</span> =</span> EROFS_V(inode);</span><br><span class="line"></span><br><span class="line">		vi-&gt;nid = nid;</span><br><span class="line"></span><br><span class="line">		err = fill_inode(inode, isdir);</span><br><span class="line">		<span class="keyword">if</span> (likely(!err))</span><br><span class="line">			unlock_new_inode(inode);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			iget_failed(inode);</span><br><span class="line">			inode = ERR_PTR(err);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先是call <code>erofs_iget_locked()</code>获取，如果没有get到(几率小)就出错了，如果是<code>I_NEW</code>状态，那就生成一个新inode via <code>fill_inode()</code>。</p>
<p>64bits及以上平台用<code>iget_locked()</code>，其他用<code>iget5_locked()</code>，两个vfs接口，not care now，lets check <code>fill_inode()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fill_inode</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">int</span> isdir)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">erofs_sb_info</span> *<span class="title">sbi</span> =</span> EROFS_SB(inode-&gt;i_sb);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">erofs_vnode</span> *<span class="title">vi</span> =</span> EROFS_V(inode);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">erofs_blk_t</span> blkaddr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ofs;</span><br><span class="line"></span><br><span class="line">	trace_erofs_fill_inode(inode, isdir);</span><br><span class="line"></span><br><span class="line">	blkaddr = erofs_blknr(iloc(sbi, vi-&gt;nid));</span><br><span class="line">	ofs = erofs_blkoff(iloc(sbi, vi-&gt;nid));</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u64 <span class="type">erofs_off_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* data type for filesystem-wide blocks number */</span></span><br><span class="line"><span class="keyword">typedef</span> u32 <span class="type">erofs_blk_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> erofs_blknr(addr)       ((addr) / EROFS_BLKSIZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> erofs_blkoff(addr)      ((addr) % EROFS_BLKSIZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> blknr_to_addr(nr)       ((erofs_off_t)(nr) * EROFS_BLKSIZ)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">erofs_off_t</span> <span class="title function_">iloc</span><span class="params">(<span class="keyword">struct</span> erofs_sb_info *sbi, <span class="type">erofs_nid_t</span> nid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> blknr_to_addr(sbi-&gt;meta_blkaddr) + (nid &lt;&lt; sbi-&gt;islotbits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按inode metadata view来，<code>-&gt;meta_blkaddr</code>是block number? <code>iloc()</code>负责找到inode address。</p>
<p>接下来会get inode page, mark to check later.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">page = erofs_get_meta_page(inode-&gt;i_sb, blkaddr, isdir);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(page)) &#123;</span><br><span class="line">	errln(<span class="string">&quot;failed to get inode (nid: %llu) page, err %ld&quot;</span>,</span><br><span class="line">	      vi-&gt;nid, PTR_ERR(page));</span><br><span class="line">	<span class="keyword">return</span> PTR_ERR(page);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">data = page_address(page);</span><br><span class="line"></span><br><span class="line">err = read_inode(inode, data + ofs);</span><br></pre></td></tr></table></figure>

<p><code>read_inode()</code>会读data(来自inode page)的<code>-&gt;i_advise</code>走inode v1 or v2。没有错误会check是否是inline data。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fill_inline_data</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">			    <span class="type">unsigned</span> <span class="type">int</span> m_pofs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">erofs_vnode</span> *<span class="title">vi</span> =</span> EROFS_V(inode);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">erofs_sb_info</span> *<span class="title">sbi</span> =</span> EROFS_I_SB(inode);</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> mode = vi-&gt;datamode;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* fast symlink (following ext4) */</span></span><br><span class="line">	<span class="keyword">if</span> (S_ISLNK(inode-&gt;i_mode) &amp;&amp; inode-&gt;i_size &lt; PAGE_SIZE) &#123;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>fast symlink看条件就是比较小的inode, rt? inline data是for fast symlink? let’s check mkfs.erofs:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mkfs_relocate_sub_inodes</span><span class="params">(<span class="keyword">struct</span> erofs_vnode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">        <span class="keyword">case</span> EROFS_FT_DIR:</span><br><span class="line">        <span class="keyword">case</span> EROFS_FT_SYMLINK:</span><br><span class="line">                unaligned = d-&gt;i_size % EROFS_BLKSIZE;</span><br><span class="line">                nblocks   = d-&gt;i_size / EROFS_BLKSIZE;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (unaligned &gt; erofs_calc_inline_data_size(d) ||</span><br><span class="line">                    (unaligned == <span class="number">0</span> &amp;&amp; nblocks != <span class="number">0</span>)) &#123;</span><br><span class="line">                        d-&gt;i_dmode = EROFS_INODE_LAYOUT_PLAIN;</span><br><span class="line">                        mkfs_rank_inode(d);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (unaligned != <span class="number">0</span>)</span><br><span class="line">                                nblocks++;</span><br><span class="line">                        blkaddr = erofs_alloc_blocks(nblocks);</span><br><span class="line">                        <span class="keyword">if</span> (!blkaddr)</span><br><span class="line">                                <span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">                        d-&gt;i_blkaddr = blkaddr;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        d-&gt;i_dmode        = EROFS_INODE_LAYOUT_INLINE;</span><br><span class="line">                        d-&gt;i_inline_datalen = unaligned;</span><br><span class="line">                        mkfs_rank_inode(d);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (nblocks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                blkaddr = erofs_alloc_blocks(nblocks);</span><br><span class="line">                                <span class="keyword">if</span> (!blkaddr)</span><br><span class="line">                                        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">                                d-&gt;i_blkaddr = blkaddr;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                d-&gt;i_blkaddr = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>EROFS_FT_DIR type的貌似也可以吧。</p>
<p>Done.</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>版权声明：</span>本站所有文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明原文链接！</p></div><br><div class="tags"><a href="/tags/erofs"><i class="fa fa-tag">erofs</i></a></div><div class="post-nav"><a class="pre" href="/how-to-make-and-mount-vendor-image-with-erofs.html">如何制作和挂载erofs格式vendor镜像</a><a class="next" href="/how-to-build-mkfs-erofs-for-arm64.html">How to build mkfs.erofs for ARM64</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/kworker-sched-la-stat.html">kworker 调度延迟性能测试和统计</a></li><li class="post-list-item"><a class="post-list-link" href="/implement-erofs-fragment-dedupe.html">转：EROFS 碎片去重实践</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-enable-kasan-in-ubuntu-18-04-for-x86_64.html">How to enable KASAN in Ubuntu 18.04 for X86_64</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-analyze-segmentation-fault-for-non-install-package-in-ubuntu.html">如何分析 Linux user space's segmentation fault</a></li><li class="post-list-item"><a class="post-list-link" href="/prepare-fragment-dedupe-in-erofs.html">EROFS 碎片去重准备</a></li><li class="post-list-item"><a class="post-list-link" href="/good-naming-in-programming.html">优秀代码命名法</a></li><li class="post-list-item"><a class="post-list-link" href="/erofs-compressed-data-deduplication.html">EROFS 压缩去重分析</a></li><li class="post-list-item"><a class="post-list-link" href="/analyze-fscache-cookie-code.html">转：浅析 Linux FS-Cache</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-let-bluetooth-work-under-armbian-kodi-for-rockpi4b-within-metal-case.html">Rockpi4b Armbian Kodi 终于能使用蓝牙了</a></li><li class="post-list-item"><a class="post-list-link" href="/erofs-ztailpacking-explain.html">转：EROFS ztailpacking 特性实现详解</a></li></ul></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arm/">ARM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dd/">Device Driver</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fs/">File System</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iot/">IoT</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/msm/">MSM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mm/">Memory Management</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/perf/">Performance</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">Security</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/stab/">Stability</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">Tools</a><span class="category-list-count">17</span></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">TJ的技术博客.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
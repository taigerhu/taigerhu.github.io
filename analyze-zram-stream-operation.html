<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>分析ZRAM数据流操作 | TJ的技术博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">分析ZRAM数据流操作</h1><a id="logo" href="/.">TJ的技术博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 首页</i></a><a href="/archives/"><i class="fa undefined"> 归档</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">分析ZRAM数据流操作</h1><div class="post-meta">2017-03-24</div><div class="post-content"><h2 id="ZRAM基本"><a href="#ZRAM基本" class="headerlink" title="ZRAM基本"></a>ZRAM基本</h2><ul>
<li>kernel3.18下代码路径在driver&#x2F;block&#x2F;zram下，主要是三部分：zram块设备驱动zram_drv.c，zram数据流操作zcomp.c以及压缩后台lzo&#x2F;lz4接口</li>
<li>zram sysfs node path: &#x2F;sys&#x2F;block&#x2F;zram0&#x2F;</li>
<li>zram kernel doc: Documentation&#x2F;blockdev&#x2F;zram.txt</li>
</ul>
<h2 id="数据流创建"><a href="#数据流创建" class="headerlink" title="数据流创建"></a>数据流创建</h2><p>在zram驱动中设置sysfs disksize时,会根据sysfs max_comp_streams的配置数创建一个或多个数据流，代码看下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> zcomp *<span class="title function_">zcomp_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *compress, <span class="type">int</span> max_strm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zcomp</span> *<span class="title">comp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zcomp_backend</span> *<span class="title">backend</span>;</span></span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">	backend = find_backend(compress);</span><br><span class="line">	<span class="keyword">if</span> (!backend)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	comp = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> zcomp), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!comp)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	comp-&gt;backend = backend;</span><br><span class="line">	<span class="keyword">if</span> (max_strm &gt; <span class="number">1</span>)</span><br><span class="line">		error = zcomp_strm_multi_create(comp, max_strm);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		error = zcomp_strm_single_create(comp);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br></pre></td></tr></table></figure>

<p>找到backend(lzo&#x2F;lz4)后用zcomp_strm_multi_create创建多个 or 用zcomp_strm_single_create创建单个压缩流。</p>
<p>先来看简单的单压缩流数据。</p>
<h2 id="单数据流操作"><a href="#单数据流操作" class="headerlink" title="单数据流操作"></a>单数据流操作</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm</span> &#123;</span></span><br><span class="line">	<span class="comment">/* compression/decompression buffer */</span></span><br><span class="line">	<span class="type">void</span> *buffer;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The private data of the compression stream, only compression</span></span><br><span class="line"><span class="comment">	 * stream backend can touch this (e.g. compression algorithm</span></span><br><span class="line"><span class="comment">	 * working memory)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> *private;</span><br><span class="line">	<span class="comment">/* used in multi stream backend, protected by backend strm_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * single zcomp_strm backend</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_single</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">strm_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm</span> *<span class="title">zstrm</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用一个互斥锁strm_lock保护这一个数据流访问的串行化，buffer用于存放压缩后的数据，private是压缩backend用到的，压缩backend就是lzo&#x2F;lz4了，看下压缩backend结构定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* static compression backend */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_backend</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*compress)(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *src, <span class="type">unsigned</span> <span class="type">char</span> *dst,</span><br><span class="line">			<span class="type">size_t</span> *dst_len, <span class="type">void</span> *private);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*decompress)(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *src, <span class="type">size_t</span> src_len,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">char</span> *dst);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *(*create)(<span class="type">void</span>);</span><br><span class="line">	<span class="type">void</span> (*destroy)(<span class="type">void</span> *private);</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的create就是给private用的了，也就是申请backend所需要的working memory。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">lzo_create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	ret = kzalloc(LZO1X_MEM_COMPRESS, GFP_NOIO | __GFP_NORETRY |</span><br><span class="line">					__GFP_NOWARN);</span><br><span class="line">	<span class="keyword">if</span> (!ret)</span><br><span class="line">		ret = __vmalloc(LZO1X_MEM_COMPRESS,</span><br><span class="line">				GFP_NOIO | __GFP_NORETRY | __GFP_NOWARN |</span><br><span class="line">				__GFP_ZERO | __GFP_HIGHMEM,</span><br><span class="line">				PAGE_KERNEL);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单压缩流创建时会先分配好这个zstrm并初始化互斥锁strm_lock，当zram block drv在rw时先通过zcomp_strm_single_find拿到zstrm（如果有其他进程占着就等着释放），用完后再用zcomp_strm_single_release解锁这个strm_lock。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">zcomp_strm_single_create</span><span class="params">(<span class="keyword">struct</span> zcomp *comp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_single</span> *<span class="title">zs</span>;</span></span><br><span class="line"></span><br><span class="line">	comp-&gt;destroy = zcomp_strm_single_destroy;</span><br><span class="line">	comp-&gt;strm_find = zcomp_strm_single_find;</span><br><span class="line">	comp-&gt;strm_release = zcomp_strm_single_release;</span><br><span class="line">	comp-&gt;set_max_streams = zcomp_strm_single_set_max_streams;</span><br><span class="line">	zs = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> zcomp_strm_single), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!zs)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	comp-&gt;stream = zs;</span><br><span class="line">	mutex_init(&amp;zs-&gt;strm_lock);         <span class="comment">//互斥锁初始化</span></span><br><span class="line">	zs-&gt;zstrm = zcomp_strm_alloc(comp); <span class="comment">//先分配好这个压缩流</span></span><br><span class="line">	<span class="keyword">if</span> (!zs-&gt;zstrm) &#123;</span><br><span class="line">		kfree(zs);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> zcomp_strm *<span class="title function_">zcomp_strm_single_find</span><span class="params">(<span class="keyword">struct</span> zcomp *comp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_single</span> *<span class="title">zs</span> =</span> comp-&gt;stream;</span><br><span class="line">	mutex_lock(&amp;zs-&gt;strm_lock);</span><br><span class="line">	<span class="keyword">return</span> zs-&gt;zstrm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">zcomp_strm_single_release</span><span class="params">(<span class="keyword">struct</span> zcomp *comp,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> zcomp_strm *zstrm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_single</span> *<span class="title">zs</span> =</span> comp-&gt;stream;</span><br><span class="line">	mutex_unlock(&amp;zs-&gt;strm_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多数据流操作"><a href="#多数据流操作" class="headerlink" title="多数据流操作"></a>多数据流操作</h2><p>引入多压缩流的目的, 内核文档有说明：</p>
<blockquote>
<p>Compression backend may use up to max_comp_streams compression<br>streams, thus allowing up to max_comp_streams concurrent compression<br>operations. By default, compression backend uses single compression<br>stream.</p>
<p>Note:<br>In order to enable compression backend’s multi stream support max_comp_streams<br>must be initially set to desired concurrency level before ZRAM device<br>initialisation. Once the device initialised as a single stream compression<br>backend (max_comp_streams equals to 1), you will see error if you try to change<br>the value of max_comp_streams because single stream compression backend<br>implemented as a special case by lock overhead issue and does not support<br>dynamic max_comp_streams. Only multi stream backend supports dynamic<br>max_comp_streams adjustment.</p>
</blockquote>
<p>这里提到两个点：</p>
<ol>
<li>max_comp_streams是用来增强zram的并发性concurrent，而不是并行性parallel，某国内手机厂家内核说明在此问题上提到了并行，我想是他们理解有错。</li>
<li>当zram使用单压缩流后不能动态修改为多压缩流，只有多压缩流支持运行时修改。</li>
</ol>
<p>来看下上面的第2个问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">zcomp_strm_single_set_max_streams</span><span class="params">(<span class="keyword">struct</span> zcomp *comp, <span class="type">int</span> num_strm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* zcomp_strm_single support only max_comp_streams == 1 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">max_comp_streams_store</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> device_attribute *attr, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">        ...</span><br><span class="line">	down_write(&amp;zram-&gt;init_lock);</span><br><span class="line">	<span class="keyword">if</span> (init_done(zram)) &#123;         <span class="comment">// disksize已配置过</span></span><br><span class="line">		<span class="keyword">if</span> (!zcomp_set_max_streams(zram-&gt;comp, num)) &#123; <span class="comment">// 如果当前是单压缩流模式，不能修改</span></span><br><span class="line">			pr_info(<span class="string">&quot;Cannot change max compression streams\n&quot;</span>);</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	zram-&gt;max_comp_streams = num;</span><br><span class="line">	ret = len;</span><br><span class="line">out:</span><br><span class="line">	up_write(&amp;zram-&gt;init_lock);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* change max_strm limit */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">zcomp_strm_multi_set_max_streams</span><span class="params">(<span class="keyword">struct</span> zcomp *comp, <span class="type">int</span> num_strm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_multi</span> *<span class="title">zs</span> =</span> comp-&gt;stream;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm</span> *<span class="title">zstrm</span>;</span></span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;zs-&gt;strm_lock);</span><br><span class="line">	zs-&gt;max_strm = num_strm;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * if user has lowered the limit and there are idle streams,</span></span><br><span class="line"><span class="comment">	 * immediately free as much streams (and memory) as we can.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (zs-&gt;avail_strm &gt; num_strm &amp;&amp; !list_empty(&amp;zs-&gt;idle_strm)) &#123;</span><br><span class="line">		zstrm = list_entry(zs-&gt;idle_strm.next,</span><br><span class="line">				<span class="keyword">struct</span> zcomp_strm, <span class="built_in">list</span>);</span><br><span class="line">		list_del(&amp;zstrm-&gt;<span class="built_in">list</span>);</span><br><span class="line">		zcomp_strm_free(comp, zstrm);</span><br><span class="line">		zs-&gt;avail_strm--;</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock(&amp;zs-&gt;strm_lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多压缩流在运行中修改时，如果当前可用的avail_strm大于这个新配置，那就把多出来的idle_strm释放掉。</p>
<p>下面看下多压缩流的创建，查找申请，释放。</p>
<h3 id="多压缩流创建"><a href="#多压缩流创建" class="headerlink" title="多压缩流创建"></a>多压缩流创建</h3><p>多压缩流的逻辑就是创建一个list，在使用时从中选择一个idle strm, 如果list为空那就是都被人占着了，要等待释放。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * multi zcomp_strm backend</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_multi</span> &#123;</span></span><br><span class="line">	<span class="comment">/* protect strm list */</span></span><br><span class="line">	<span class="type">spinlock_t</span> strm_lock;</span><br><span class="line">	<span class="comment">/* max possible number of zstrm streams */</span></span><br><span class="line">	<span class="type">int</span> max_strm;</span><br><span class="line">	<span class="comment">/* number of available zstrm streams */</span></span><br><span class="line">	<span class="type">int</span> avail_strm;</span><br><span class="line">	<span class="comment">/* list of available strms */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">idle_strm</span>;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> strm_wait;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">zcomp_strm_multi_create</span><span class="params">(<span class="keyword">struct</span> zcomp *comp, <span class="type">int</span> max_strm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm</span> *<span class="title">zstrm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_multi</span> *<span class="title">zs</span>;</span></span><br><span class="line"></span><br><span class="line">	comp-&gt;destroy = zcomp_strm_multi_destroy;</span><br><span class="line">	comp-&gt;strm_find = zcomp_strm_multi_find;</span><br><span class="line">	comp-&gt;strm_release = zcomp_strm_multi_release;</span><br><span class="line">	comp-&gt;set_max_streams = zcomp_strm_multi_set_max_streams;</span><br><span class="line">	zs = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> zcomp_strm_multi), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!zs)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	comp-&gt;stream = zs;</span><br><span class="line">	spin_lock_init(&amp;zs-&gt;strm_lock);</span><br><span class="line">	INIT_LIST_HEAD(&amp;zs-&gt;idle_strm);</span><br><span class="line">	init_waitqueue_head(&amp;zs-&gt;strm_wait);</span><br><span class="line">	zs-&gt;max_strm = max_strm;</span><br><span class="line">	zs-&gt;avail_strm = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	zstrm = zcomp_strm_alloc(comp);</span><br><span class="line">	<span class="keyword">if</span> (!zstrm) &#123;</span><br><span class="line">		kfree(zs);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	list_add(&amp;zstrm-&gt;<span class="built_in">list</span>, &amp;zs-&gt;idle_strm);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上，多压缩流结构中定义一个list idle_strm，使用单压缩流结构的backend data链入这个list来管理，具体就是zcomp_strm_alloc申请到了一个zstrm后把它list_add idle_strm这个list中。</p>
<p>avail_strm用来计数可用的idle stream。</p>
<p>strm_wait用来处理等待的情况。</p>
<h3 id="多压缩流中查找可用压缩流"><a href="#多压缩流中查找可用压缩流" class="headerlink" title="多压缩流中查找可用压缩流"></a>多压缩流中查找可用压缩流</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> zcomp_strm *<span class="title function_">zcomp_strm_multi_find</span><span class="params">(<span class="keyword">struct</span> zcomp *comp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_multi</span> *<span class="title">zs</span> =</span> comp-&gt;stream;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm</span> *<span class="title">zstrm</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		spin_lock(&amp;zs-&gt;strm_lock);</span><br><span class="line">		<span class="keyword">if</span> (!list_empty(&amp;zs-&gt;idle_strm)) &#123;</span><br><span class="line">			zstrm = list_entry(zs-&gt;idle_strm.next,</span><br><span class="line">					<span class="keyword">struct</span> zcomp_strm, <span class="built_in">list</span>);</span><br><span class="line">			list_del(&amp;zstrm-&gt;<span class="built_in">list</span>);</span><br><span class="line">			spin_unlock(&amp;zs-&gt;strm_lock);</span><br><span class="line">			<span class="keyword">return</span> zstrm;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* zstrm streams limit reached, wait for idle stream */</span></span><br><span class="line">		<span class="keyword">if</span> (zs-&gt;avail_strm &gt;= zs-&gt;max_strm) &#123;</span><br><span class="line">			spin_unlock(&amp;zs-&gt;strm_lock);</span><br><span class="line">			wait_event(zs-&gt;strm_wait, !list_empty(&amp;zs-&gt;idle_strm));</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* allocate new zstrm stream */</span></span><br><span class="line">		zs-&gt;avail_strm++;</span><br><span class="line">		spin_unlock(&amp;zs-&gt;strm_lock);</span><br><span class="line"></span><br><span class="line">		zstrm = zcomp_strm_alloc(comp);</span><br><span class="line">		<span class="keyword">if</span> (!zstrm) &#123;</span><br><span class="line">			spin_lock(&amp;zs-&gt;strm_lock);</span><br><span class="line">			zs-&gt;avail_strm--;</span><br><span class="line">			spin_unlock(&amp;zs-&gt;strm_lock);</span><br><span class="line">			wait_event(zs-&gt;strm_wait, !list_empty(&amp;zs-&gt;idle_strm));</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> zstrm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看可用列表中有没有可用的，如果有就找到了。如果可用列表空了，那就再分配资源，当然前提是资源数不能超过最大压缩数max_strm，如果超过了就等待其他进程释放资源。</p>
<p>ps: 这里可以看到在zcomp_strm_alloc后并没有直接list_add加入可用列表，而是在释放时加入，应该是和上限逻辑有关。</p>
<h3 id="多压缩流释放"><a href="#多压缩流释放" class="headerlink" title="多压缩流释放"></a>多压缩流释放</h3><p>zram block driver在find中找到某个压缩流，使用完后会释放这块资源。具体是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* add stream back to idle list and wake up waiter or free the stream */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">zcomp_strm_multi_release</span><span class="params">(<span class="keyword">struct</span> zcomp *comp, <span class="keyword">struct</span> zcomp_strm *zstrm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zcomp_strm_multi</span> *<span class="title">zs</span> =</span> comp-&gt;stream;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;zs-&gt;strm_lock);</span><br><span class="line">	<span class="keyword">if</span> (zs-&gt;avail_strm &lt;= zs-&gt;max_strm) &#123;</span><br><span class="line">		list_add(&amp;zstrm-&gt;<span class="built_in">list</span>, &amp;zs-&gt;idle_strm);</span><br><span class="line">		spin_unlock(&amp;zs-&gt;strm_lock);</span><br><span class="line">		wake_up(&amp;zs-&gt;strm_wait);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	zs-&gt;avail_strm--;</span><br><span class="line">	spin_unlock(&amp;zs-&gt;strm_lock);</span><br><span class="line">	zcomp_strm_free(comp, zstrm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放时max_strm范围内list_add加入可用列表并唤醒等待该压缩流的进程 or 范围外就释放资源。</p>
<h2 id="ZRAM-callstack"><a href="#ZRAM-callstack" class="headerlink" title="ZRAM callstack"></a>ZRAM callstack</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> [&lt;c010cd84&gt;] (unwind_backtrace) from [&lt;c01099f4&gt;] (show_stack+0x10/0x14)</span><br><span class="line">[   65.015711] [&lt;c01099f4&gt;] (show_stack) from [&lt;c0baeaa4&gt;] (dump_stack+0x78/0x98)</span><br><span class="line">[   65.015721] [&lt;c0baeaa4&gt;] (dump_stack) from [&lt;c052acac&gt;] (zram_make_request+0x12c/0x474)</span><br><span class="line">[   65.015731] [&lt;c052acac&gt;] (zram_make_request) from [&lt;c035278c&gt;] (generic_make_request+0x90/0xc8)</span><br><span class="line">[   65.015741] [&lt;c035278c&gt;] (generic_make_request) from [&lt;c03528d8&gt;] (submit_bio+0x114/0x15c)</span><br><span class="line">[   65.015752] [&lt;c03528d8&gt;] (submit_bio) from [&lt;c0206ce4&gt;] (__swap_writepage+0x260/0x27c)</span><br><span class="line">[   65.015762] [&lt;c0206ce4&gt;] (__swap_writepage) from [&lt;c01e203c&gt;] (shrink_page_list+0x57c/0x9b0)</span><br><span class="line">[   65.015771] [&lt;c01e203c&gt;] (shrink_page_list) from [&lt;c01e2658&gt;] (reclaim_pages_from_list+0xa8/0x108)</span><br><span class="line">[   65.015781] [&lt;c01e2658&gt;] (reclaim_pages_from_list) from [&lt;c0263968&gt;] (reclaim_pte_range+0x11c/0x184)</span><br><span class="line">[   65.015791] [&lt;c0263968&gt;] (reclaim_pte_range) from [&lt;c0203ce8&gt;] (walk_page_range+0x1b8/0x248)</span><br><span class="line">[   65.015801] [&lt;c0203ce8&gt;] (walk_page_range) from [&lt;c026462c&gt;] (reclaim_task_anon+0xb4/0x11c)</span><br><span class="line">[   65.015810] [&lt;c026462c&gt;] (reclaim_task_anon) from [&lt;c0214524&gt;] (swap_fn+0x248/0x4ec)</span><br><span class="line">[   65.015821] [&lt;c0214524&gt;] (swap_fn) from [&lt;c0137434&gt;] (process_one_work+0x254/0x464)</span><br><span class="line">[   65.015830] [&lt;c0137434&gt;] (process_one_work) from [&lt;c013816c&gt;] (worker_thread+0x2b4/0x3f8)</span><br><span class="line">[   65.015839] [&lt;c013816c&gt;] (worker_thread) from [&lt;c013b9b4&gt;] (kthread+0xdc/0xf0)</span><br><span class="line">[   65.015849] [&lt;c013b9b4&gt;] (kthread) from [&lt;c0105f80&gt;] (ret_from_fork+0x14/0x34)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">] CPU: 1 PID: 2737 Comm: ngs.android.pop Tainted: G        W      3.18.31-perf-g5e6acc4-00677-gb0cabe3-dirty #9</span><br><span class="line">[   65.014502] [&lt;c010cd84&gt;] (unwind_backtrace) from [&lt;c01099f4&gt;] (show_stack+0x10/0x14)</span><br><span class="line">[   65.014514] [&lt;c01099f4&gt;] (show_stack) from [&lt;c0baeaa4&gt;] (dump_stack+0x78/0x98)</span><br><span class="line">[   65.014527] [&lt;c0baeaa4&gt;] (dump_stack) from [&lt;c052acac&gt;] (zram_make_request+0x12c/0x474)</span><br><span class="line">[   65.014540] [&lt;c052acac&gt;] (zram_make_request) from [&lt;c035278c&gt;] (generic_make_request+0x90/0xc8)</span><br><span class="line">[   65.014550] [&lt;c035278c&gt;] (generic_make_request) from [&lt;c03528d8&gt;] (submit_bio+0x114/0x15c)</span><br><span class="line">[   65.014561] [&lt;c03528d8&gt;] (submit_bio) from [&lt;c0206e18&gt;] (swap_readpage+0xdc/0xf0)</span><br><span class="line">[   65.014571] [&lt;c0206e18&gt;] (swap_readpage) from [&lt;c0207430&gt;] (read_swap_cache_async+0x154/0x1cc)</span><br><span class="line">[   65.014582] [&lt;c0207430&gt;] (read_swap_cache_async) from [&lt;c0207618&gt;] (swapin_readahead+0x170/0x184)</span><br><span class="line">[   65.014592] [&lt;c0207618&gt;] (swapin_readahead) from [&lt;c01f916c&gt;] (handle_mm_fault+0x490/0x904)</span><br><span class="line">[   65.014603] [&lt;c01f916c&gt;] (handle_mm_fault) from [&lt;c0114590&gt;] (do_page_fault+0x118/0x378)</span><br><span class="line">[   65.014612] [&lt;c0114590&gt;] (do_page_fault) from [&lt;c010030c&gt;] (do_DataAbort+0x34/0x164)</span><br><span class="line">[   65.014620] [&lt;c010030c&gt;] (do_DataAbort) from [&lt;c010a6fc&gt;] (__dabt_usr+0x3c/0x40)</span><br><span class="line">[   65.014625] Exception stack(0xe4895fb0 to 0xe4895ff8)</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>版权声明：</span>本站所有文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明原文链接！</p></div><br><div class="tags"><a href="/tags/Linux Kernel"><i class="fa fa-tag">Linux Kernel</i></a><a href="/tags/zRAM"><i class="fa fa-tag">zRAM</i></a></div><div class="post-nav"><a class="pre" href="/using-adb-in-ubuntu-via-virtualbox-under-win7.html">在Windows VirtualBox虚拟的Ubuntu中使用adb</a><a class="next" href="/analyze-adaptive-lmk.html">分析adaptive lmk特性</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/kworker-sched-la-stat.html">kworker 调度延迟性能测试和统计</a></li><li class="post-list-item"><a class="post-list-link" href="/implement-erofs-fragment-dedupe.html">转：EROFS 碎片去重实践</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-enable-kasan-in-ubuntu-18-04-for-x86_64.html">How to enable KASAN in Ubuntu 18.04 for X86_64</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-analyze-segmentation-fault-for-non-install-package-in-ubuntu.html">如何分析 Linux user space's segmentation fault</a></li><li class="post-list-item"><a class="post-list-link" href="/prepare-fragment-dedupe-in-erofs.html">EROFS 碎片去重准备</a></li><li class="post-list-item"><a class="post-list-link" href="/good-naming-in-programming.html">优秀代码命名法</a></li><li class="post-list-item"><a class="post-list-link" href="/erofs-compressed-data-deduplication.html">EROFS 压缩去重分析</a></li><li class="post-list-item"><a class="post-list-link" href="/analyze-fscache-cookie-code.html">转：浅析 Linux FS-Cache</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-let-bluetooth-work-under-armbian-kodi-for-rockpi4b-within-metal-case.html">Rockpi4b Armbian Kodi 终于能使用蓝牙了</a></li><li class="post-list-item"><a class="post-list-link" href="/erofs-ztailpacking-explain.html">转：EROFS ztailpacking 特性实现详解</a></li></ul></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arm/">ARM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dd/">Device Driver</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fs/">File System</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iot/">IoT</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/msm/">MSM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mm/">Memory Management</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/perf/">Performance</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">Security</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/stab/">Stability</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">Tools</a><span class="category-list-count">17</span></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">TJ的技术博客.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
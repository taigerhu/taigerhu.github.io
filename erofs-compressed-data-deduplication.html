<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>EROFS 压缩去重分析 | TJ的技术博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">EROFS 压缩去重分析</h1><a id="logo" href="/.">TJ的技术博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 首页</i></a><a href="/archives/"><i class="fa undefined"> 归档</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">EROFS 压缩去重分析</h1><div class="post-meta">2022-09-08</div><div class="post-content"><p>EROFS 文件系统刚提交了<a target="_blank" rel="noopener" href="https://lore.kernel.org/linux-erofs/20220906114057.151445-4-ZiyangZhang@linux.alibaba.com/">压缩去重特性</a>提升压缩率，一起来看下。</p>
<h2 id="rolling-hash-基础"><a href="#rolling-hash-基础" class="headerlink" title="rolling hash 基础"></a>rolling hash 基础</h2><p>dedup 用到了 rolling hash，先了解下。</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rolling_hash">wikipedia</a> 的定义是:</p>
<blockquote>
<p>A hash function is any function that can be used to map data of arbitrary size to fixed-size values.</p>
</blockquote>
<blockquote>
<p>A rolling hash (also known as recursive hashing or rolling checksum) is a hash function where the input is hashed in a window that moves through the input.</p>
</blockquote>
<p>举个例子理解下：</p>
<p>字串查找中使用 rolling hash，如查找字串 abcd 中长度为 3 个字符的子串 abc 和 bcd, base 是 10。</p>
<p>子串 abc 的 hash 值：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">H(abc) =&gt; a*(10^2) + b*(10^1) + c*(10^0)</span><br><span class="line">= 97*100 + 98*10 + 99*1 = 10779</span><br></pre></td></tr></table></figure>

<p>子串 bcd 的 hash 值：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">H(bcd) =&gt; b*(10^2) + c*(10^1) + d*(10^0)</span><br><span class="line">= 98*100 + 99*10 + 100*1 = 10890</span><br></pre></td></tr></table></figure>

<p>留意到 abc 和 bcd 有重复的 bc，可以利用之前的 H(abc) 推导出 H(bcd)，也就是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">H(bcd) =&gt; (b*(10^1) + c*(10^0))*10 + d*(10^0)</span><br><span class="line">H(bcd) =&gt; (H(abc) - a*(10^2))*10 + d*(10^0)</span><br><span class="line">= (10779 - 97*100)*10 + 100*1 = 10890</span><br></pre></td></tr></table></figure>

<p>BTW: 为了避免 H() 值太大溢出，有个 mod 运算(by prime number)，这里忽略。</p>
<p>从 input(abc) 到 input(bcd) 的变化就是丢了 a 加了 d，可以把 input 看成一个 window (这里长度是3个字符)，从 abc 到 bcd 可以看作这个 window 在滚动，滚动步长是1个字符。rt?</p>
<p>所以，rolling hash 就是为了在计算字串 hash 值时避免 hashing 整个串, 因为利用之前算得的 old hash 值，所以 new hash 值算的很快。它是基于 hash 做的一种场景优化，rt?</p>
<p>来看 erofs-utils 的实现 rolling_hash.h。</p>
<p>因为 hash value 定义了 long long(8bytes) 型，所以为了防止溢出 <code>PRIME_NUMBER</code> 定义成了最大值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRIME_NUMBER    4294967295LL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADIX           256</span></span><br></pre></td></tr></table></figure>

<p>RADIX 是 256(2^8)，为啥。。。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">erofs_rolling_hash_init</span><span class="params">(u8 *input,</span></span><br><span class="line"><span class="params">                                                <span class="type">int</span> len, <span class="type">bool</span> backwards)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> hash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!backwards) &#123;</span><br><span class="line">                <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">                        hash = (RADIX * hash + input[i]) % PRIME_NUMBER;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (len)</span><br><span class="line">                        hash = (RADIX * hash + input[--len]) % PRIME_NUMBER;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是 H() 的实现加个方向。</p>
<p>rolling hash 的计算：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">erofs_rolling_hash_advance</span><span class="params">(<span class="type">long</span> <span class="type">long</span> old_hash,</span></span><br><span class="line"><span class="params">                                                   <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> RM,</span></span><br><span class="line"><span class="params">                                                   u8 to_remove, u8 to_add)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> hash = old_hash;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> to_remove_val = (to_remove * RM) % PRIME_NUMBER;</span><br><span class="line"></span><br><span class="line">        hash = RADIX * (old_hash - to_remove_val) % PRIME_NUMBER;</span><br><span class="line">        hash = (hash + to_add) % PRIME_NUMBER;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We might get negative value of hash, converting it to positive */</span></span><br><span class="line">        <span class="keyword">if</span> (hash &lt; <span class="number">0</span>)</span><br><span class="line">                hash += PRIME_NUMBER;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是拿上面的例子来说，<code>old_hash</code> 就是 H(abc)，<code>to_remove</code> 和 <code>to_add</code> 相当于 a 和 d。</p>
<p><code>(old_hash - to_remove_val)</code> 就是 <code>H(abc) - a*(10^2)</code>, 所以这个 <code>RM</code> 就是 10^2，也就是针对 input window 的常量是多少，因为用作移除 (remove)，那就是 RM 喽。 所以，RM 的计算是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">erofs_rollinghash_calc_rm</span><span class="params">(<span class="type">int</span> window_size)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> RM = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; window_size - <span class="number">1</span>; ++i)</span><br><span class="line">                RM = (RM * RADIX) % PRIME_NUMBER;</span><br><span class="line">        <span class="keyword">return</span> RM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="red-black-tree-基础"><a href="#red-black-tree-基础" class="headerlink" title="red-black tree 基础"></a>red-black tree 基础</h2><p>除了用到 rolling hash, 压缩去重还用到了红黑树，let’s take a look.</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">wikipedia</a> 相关定义：</p>
<blockquote>
<p>a red-black tree is a kind of self-balancing binary search tree. Each node stores an extra bit representing “color” (“red” or “black”), used to ensure that the tree remains balanced during insertions and deletions.</p>
</blockquote>
<p>红黑树是一种自平衡二叉查找树。</p>
<blockquote>
<p>a self-balancing binary search tree (BST) is any node-based binary search tree that automatically keeps its height (maximal number of levels below the root) small in the face of arbitrary item insertions and deletions.</p>
</blockquote>
<p>平衡二叉查找树就是为了深度(height)不要搞太深了。</p>
<blockquote>
<p>a binary search tree (BST), also called an ordered or sorted binary tree, is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node’s left subtree and less than the ones in its right subtree.</p>
</blockquote>
<p>二叉查找树就是排序的二叉树。</p>
<blockquote>
<p>a binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child.</p>
</blockquote>
<p>二叉树就是一代最多左右两娃。</p>
<p><a target="_blank" rel="noopener" href="http://cslibrary.stanford.edu/110/BinaryTrees.html">stanford公开cs课</a>称 binary trees 有着 <em>优雅</em> 的递归指针结构。(mmm 艺术细胞有了…)</p>
<blockquote>
<p>Binary trees have an elegant recursive pointer structure</p>
</blockquote>
<p>erofs-utils 的实现在 dedupe.c + rb_tree.c里，just read…</p>
<ul>
<li>define the tree node</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>             red;     <span class="comment">// Color red (1), black (0)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">link</span>[2];</span> <span class="comment">// Link left [0] and right [1]</span></span><br><span class="line">    <span class="type">void</span>           *value;   <span class="comment">// User provided, used indirectly via rb_tree_node_cmp_f.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个 node 的值类型是一个 <code>void *</code>，使用者提供，用在下面 <code>-&gt;cmp</code> 这个 callback 函数里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>    *<span class="title">root</span>;</span></span><br><span class="line">    rb_tree_node_cmp_f cmp;</span><br><span class="line">    <span class="type">size_t</span>             size;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>erofs dedup 的 <code>-&gt;cmp</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">z_erofs_dedupe_rbtree_cmp</span><span class="params">(<span class="keyword">struct</span> rb_tree *self,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> rb_node *node_a, <span class="keyword">struct</span> rb_node *node_b)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">z_erofs_dedupe_item</span> *<span class="title">e_a</span> =</span> node_a-&gt;value;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">z_erofs_dedupe_item</span> *<span class="title">e_b</span> =</span> node_b-&gt;value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (e_a-&gt;hash &gt; e_b-&gt;hash) - (e_a-&gt;hash &lt; e_b-&gt;hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>-&gt;value</code> 是一个 dedup item，这个 item 的表征用 <code>hash</code> 来定，也就是前面的 rolling hash。</p>
<ul>
<li>insert the node</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">z_erofs_dedupe_insert</span><span class="params">(<span class="keyword">struct</span> z_erofs_inmem_extent *e,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> *original_data)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">z_erofs_dedupe_item</span> *<span class="title">di</span>;</span></span><br><span class="line">	...</span><br><span class="line">        di-&gt;original_length = e-&gt;length;</span><br><span class="line">        erofs_sha256(original_data, window_size, di-&gt;prefix_sha256);</span><br><span class="line">        di-&gt;hash = erofs_rolling_hash_init(original_data,</span><br><span class="line">                        window_size, <span class="literal">true</span>); <span class="comment">//tj: here</span></span><br><span class="line">        <span class="built_in">memcpy</span>(di-&gt;extra_data, original_data + window_size,</span><br><span class="line">               e-&gt;length - window_size);</span><br><span class="line">        di-&gt;compressed_blkaddr = e-&gt;blkaddr;</span><br><span class="line">        di-&gt;compressed_blks = e-&gt;compressedblks;</span><br><span class="line">        di-&gt;partial = e-&gt;partial;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* with the same rolling hash */</span></span><br><span class="line">        <span class="keyword">if</span> (!rb_tree_insert(dedupe_subtree, di)) <span class="comment">//tj: here</span></span><br><span class="line">                <span class="built_in">free</span>(di);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>向 <code>dedupe_subtree</code> 这个 rb tree 里插入<code>di</code> 这个 node, <code>di-&gt;hash</code> 就是 rolling hash 的初始值。</p>
<ul>
<li>find the node</li>
</ul>
<p>call <code>-&gt;cmp</code> 这个 user 填入的 call back func。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">rb_tree_find</span><span class="params">(<span class="keyword">struct</span> rb_tree *self, <span class="type">void</span> *value)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (self) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">node</span> =</span> &#123; .value = value &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">it</span> =</span> self-&gt;root;</span><br><span class="line">        <span class="type">int</span> cmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (it) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((cmp = self-&gt;cmp(self, it, &amp;node))) &#123; <span class="comment">//tj: here</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// If the tree supports duplicates, they should be</span></span><br><span class="line">                <span class="comment">// chained to the right subtree for this to work</span></span><br><span class="line">                it = it-&gt;link[cmp &lt; <span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = it ? it-&gt;value : <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>erofs dedup 是在 match 里：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">z_erofs_dedupe_match</span><span class="params">(<span class="keyword">struct</span> z_erofs_dedupe_ctx *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">        <span class="comment">/* move backward byte-by-byte */</span></span><br><span class="line">        <span class="keyword">for</span> (; cur &gt;= ctx-&gt;start; --cur) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">z_erofs_dedupe_item</span> *<span class="title">e</span>;</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> extra;</span><br><span class="line">                u8 sha256[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (initial) &#123;</span><br><span class="line">                        <span class="comment">/* initial try */</span></span><br><span class="line">                        e_find.hash = erofs_rolling_hash_init(cur, window_size, <span class="literal">true</span>);</span><br><span class="line">                        initial = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        e_find.hash = erofs_rolling_hash_advance(e_find.hash,</span><br><span class="line">                                rollinghash_rm, cur[window_size], cur[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                e = rb_tree_find(dedupe_tree, &amp;e_find);</span><br><span class="line">                <span class="keyword">if</span> (!e) &#123;</span><br><span class="line">                        e = rb_tree_find(dedupe_subtree, &amp;e_find);</span><br><span class="line">                        <span class="keyword">if</span> (!e)</span><br><span class="line">                                <span class="keyword">continue</span>; <span class="comment">//tj: can not find</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>rolling 窗口区间在<code>cur</code> - <code>ctx-&gt;start</code>。第一次比较用 init 那个值(<code>initial try</code>)，后面的查找用了真正的 rolling hash 计算(<code>..._advance()</code>)。</p>
<p>ok，now 我们来看下 EROFS 是如何进行压缩去重(compressed data deduplication) 的。</p>
<h2 id="erofs-data-deduplication"><a href="#erofs-data-deduplication" class="headerlink" title="erofs data deduplication"></a>erofs data deduplication</h2><p>照例先了解下概念，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_deduplication">wikipedia</a> 定义如下：</p>
<blockquote>
<p>data deduplication is a technique for eliminating duplicate copies of repeating data. Successful implementation of the technique can improve storage utilization, </p>
</blockquote>
<p>就是避免数据重复，减少存储占用。</p>
<p>erofs data dedup 大体的 flow:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vle_compress_one</span><br><span class="line">      |</span><br><span class="line">*z_erofs_compress_dedupe(,,len)* (-&gt; *z_erofs_dedupe_match*)</span><br><span class="line">      |</span><br><span class="line">      | &lt;no dupilcate&gt;</span><br><span class="line">erofs_compress_destsize</span><br><span class="line">      |</span><br><span class="line">   blk_write</span><br><span class="line">      |</span><br><span class="line">*z_erofs_dedupe_insert* (non-inline)</span><br></pre></td></tr></table></figure>

<p>对给定 <code>len</code> 长度源数据，压缩前先尝试 check 是否有重复的 data，如果有重复的(<code>z_erofs_dedupe_match</code>返回0表示match)，就不要写到磁盘了，直接 next round。如果没有重复，那就要写啊，同时记录下(via <code>z_erofs_dedupe_insert()</code>)让后来人比对。</p>
<p>在 match 到后，deduplication 的 data index 会回退到 noncompact，可能是简化逻辑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (z_erofs_dedupe_match(&amp;dctx))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fall back to noncompact indexes for deduplication */</span></span><br><span class="line">inode-&gt;z_advise &amp;= ~Z_EROFS_ADVISE_COMPACTED_2B;</span><br><span class="line">inode-&gt;datalayout = EROFS_INODE_FLAT_COMPRESSION_LEGACY;</span><br></pre></td></tr></table></figure>

<p>那 rolling 是怎么找重复的了？滚动窗口 dedup 初始化时定义为 <code>EROFS_BLKSIZ</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err = z_erofs_dedupe_init(EROFS_BLKSIZ);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">z_erofs_dedupe_match</span><span class="params">(<span class="keyword">struct</span> z_erofs_dedupe_ctx *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">z_erofs_dedupe_item</span> <span class="title">e_find</span>;</span></span><br><span class="line">        u8 *cur;</span><br><span class="line">        <span class="type">bool</span> initial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!dedupe_tree)</span><br><span class="line">                <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;cur &gt; ctx-&gt;end - window_size)</span><br><span class="line">                cur = ctx-&gt;end - window_size;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                cur = ctx-&gt;cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* move backward byte-by-byte */</span></span><br><span class="line">        <span class="keyword">for</span> (; cur &gt;= ctx-&gt;start; --cur) &#123; <span class="comment">//tj: here</span></span><br></pre></td></tr></table></figure>

<p>从 <code>cur</code> 开始向后最小到 <code>ctx-&gt;start</code> 一个个字符滚动 check。<code>ctx-&gt;start</code> 就是接上次 rolling hash 的 end。rt?</p>
<p>如果 cur 往后退了，也就是 dedup 有个 <code>delta</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">delta = ctx-&gt;<span class="built_in">queue</span> + ctx-&gt;head - dctx.cur;</span><br><span class="line"><span class="keyword">if</span> (delta) &#123;</span><br><span class="line">        DBG_BUGON(delta &lt; <span class="number">0</span>);</span><br><span class="line">        DBG_BUGON(!ctx-&gt;e.length);</span><br><span class="line">        ctx-&gt;e.partial = <span class="literal">true</span>;</span><br><span class="line">        ctx-&gt;e.length -= delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时是部分 data dedup 的，有个 advise 申明这种 HEAD lcluster, 在 write index 里:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        type = ctx-&gt;e.raw ? Z_EROFS_VLE_CLUSTER_TYPE_PLAIN :</span><br><span class="line">                Z_EROFS_VLE_CLUSTER_TYPE_HEAD;</span><br><span class="line">        di.di_u.blkaddr = cpu_to_le32(ctx-&gt;e.blkaddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;e.partial) &#123;</span><br><span class="line">                DBG_BUGON(ctx-&gt;e.raw);</span><br><span class="line">                advise |= Z_EROFS_VLE_DI_PARTIAL_REF;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样 zmap 时可以准确找到它，也就是如下提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">erofs-utils: fuse: introduce partial-referenced pclusters</span><br><span class="line"></span><br><span class="line">Due to deduplication for compressed data, pclusters can be partially</span><br><span class="line">referenced with their prefixes.</span><br><span class="line"></span><br><span class="line">Decompression algorithms should know that in advance, otherwise they</span><br><span class="line">will fail out unexpectedly.</span><br></pre></td></tr></table></figure>

<h2 id="refer-doc"><a href="#refer-doc" class="headerlink" title="refer doc"></a>refer doc</h2><ul>
<li><a target="_blank" rel="noopener" href="https://iq.opengenus.org/rolling-hash/">https://iq.opengenus.org/rolling-hash/</a></li>
</ul>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>版权声明：</span>本站所有文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明原文链接！</p></div><br><div class="tags"><a href="/tags/erofs-utils"><i class="fa fa-tag">erofs-utils</i></a><a href="/tags/data-deduplication"><i class="fa fa-tag">data-deduplication</i></a></div><div class="post-nav"><a class="pre" href="/good-naming-in-programming.html">优秀代码命名法</a><a class="next" href="/analyze-fscache-cookie-code.html">转：浅析 Linux FS-Cache</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/upgrade-my-custom-build-server-amd-based.html">我的PC组装升级记</a></li><li class="post-list-item"><a class="post-list-link" href="/convert-typecho-to-hexo.html">I am back!</a></li><li class="post-list-item"><a class="post-list-link" href="/review-freezing-issue-when-drag-icon-after-ohos-adaption.html">OpenHarmony适配后图标拖拽卡屏问题回顾</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-fix-parse-too-complex-in-source-insight.html">Source Insight 自定义解析</a></li><li class="post-list-item"><a class="post-list-link" href="/adapt-ohos-for-mali-g57-on-sprd-t606.html">转：拥抱鸿蒙 - 在展讯T606平台上的探索与实践</a></li><li class="post-list-item"><a class="post-list-link" href="/essential-inventory-of-adaption-for-unisoc-platform-androidt-based.html">展讯平台 OpenHarmony 3.2.2 适配基础盘点</a></li><li class="post-list-item"><a class="post-list-link" href="/porting-openharmony-linux-kernel-to-3rd-party-chip.html">快速移植 OpenHarmony Linux 内核到三方 ARM64 平台</a></li><li class="post-list-item"><a class="post-list-link" href="/openharmony-linux-kernel-overview.html">初识 OpenHarmony Linux Kernel</a></li><li class="post-list-item"><a class="post-list-link" href="/what-android-gki-brings-to-oems.html">What Android GKI Brings to OEMs</a></li><li class="post-list-item"><a class="post-list-link" href="/analyze-erofs-pcluster-mode.html">转：EROFS pcluster 模式分析</a></li></ul></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arm/">arm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dd/">dd</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ebpf/">ebpf</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fs/">fs</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iot/">iot</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mm/">mm</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/msm/">msm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ohos/">ohos</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/perf/">perf</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">security</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/stab/">stab</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">tools</a><span class="category-list-count">20</span></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">TJ的技术博客.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
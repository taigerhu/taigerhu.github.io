<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>内核MMC传输流程Overview | TJ的技术博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">内核MMC传输流程Overview</h1><a id="logo" href="/.">TJ的技术博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 首页</i></a><a href="/archives/"><i class="fa undefined"> 归档</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">内核MMC传输流程Overview</h1><div class="post-meta">2018-01-18</div><div class="post-content"><p>最近看了下mmc读写，起由是Vendor发来eMMC固件升级要求，说如果使用了CMD18 + CMD12，就要升级，因为不知道OEM使用情况，建议都升级。</p>
<p>我们来确认下内核的情况, 内核版本3.18，高通平台。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_READ_DAT_UNTIL_STOP  11   <span class="comment">/* adtc [31:0] dadr        R1  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_STOP_TRANSMISSION    12   <span class="comment">/* ac                      R1b */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_SEND_STATUS          13   <span class="comment">/* ac   [31:16] RCA        R1  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_BUS_TEST_R           14   <span class="comment">/* adtc                    R1  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_GO_INACTIVE_STATE    15   <span class="comment">/* ac   [31:16] RCA            */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_BUS_TEST_W           19   <span class="comment">/* adtc                    R1  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_SPI_READ_OCR         58   <span class="comment">/* spi                  spi_R3 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_SPI_CRC_ON_OFF       59   <span class="comment">/* spi  [0:0] flag      spi_R1 */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* class 2 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_SET_BLOCKLEN         16   <span class="comment">/* ac   [31:0] block len   R1  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_READ_SINGLE_BLOCK    17   <span class="comment">/* adtc [31:0] data addr   R1  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_READ_MULTIPLE_BLOCK  18   <span class="comment">/* adtc [31:0] data addr   R1  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_SEND_TUNING_BLOCK    19   <span class="comment">/* adtc                    R1  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_SEND_TUNING_BLOCK_HS200     21      <span class="comment">/* adtc R1  */</span></span></span><br></pre></td></tr></table></figure>

<p>CMD18就是MMC_READ_MULTIPLE_BLOCK，CMD12就是MMC_STOP_TRANSMISSION。</p>
<p>查下相关代码在mmc_test_prepare_mrq中使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mmc_test_prepare_mrq</span><span class="params">(<span class="keyword">struct</span> mmc_test_card *test,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> mmc_request *mrq, <span class="keyword">struct</span> scatterlist *sg, <span class="type">unsigned</span> sg_len,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> dev_addr, <span class="type">unsigned</span> blocks, <span class="type">unsigned</span> blksz, <span class="type">int</span> write)</span></span><br><span class="line">&#123;</span><br><span class="line">	BUG_ON(!mrq || !mrq-&gt;cmd || !mrq-&gt;data || !mrq-&gt;stop);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (blocks &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		mrq-&gt;cmd-&gt;opcode = write ?</span><br><span class="line">			MMC_WRITE_MULTIPLE_BLOCK : MMC_READ_MULTIPLE_BLOCK;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mrq-&gt;cmd-&gt;opcode = write ?</span><br><span class="line">			MMC_WRITE_BLOCK : MMC_READ_SINGLE_BLOCK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mrq-&gt;cmd-&gt;arg = dev_addr;</span><br><span class="line">	<span class="keyword">if</span> (!mmc_card_blockaddr(test-&gt;card))</span><br><span class="line">		mrq-&gt;cmd-&gt;arg &lt;&lt;= <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">	mrq-&gt;cmd-&gt;flags = MMC_RSP_R1 | MMC_CMD_ADTC;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (blocks == <span class="number">1</span>)</span><br><span class="line">		mrq-&gt;stop = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		mrq-&gt;stop-&gt;opcode = MMC_STOP_TRANSMISSION; <span class="comment">//CMD12</span></span><br><span class="line">		mrq-&gt;stop-&gt;arg = <span class="number">0</span>;</span><br><span class="line">		mrq-&gt;stop-&gt;flags = MMC_RSP_R1B | MMC_CMD_AC;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mrq-&gt;data-&gt;blksz = blksz;</span><br><span class="line">	mrq-&gt;data-&gt;blocks = blocks;</span><br><span class="line">	mrq-&gt;data-&gt;flags = write ? MMC_DATA_WRITE : MMC_DATA_READ;</span><br><span class="line">	mrq-&gt;data-&gt;sg = sg;</span><br><span class="line">	mrq-&gt;data-&gt;sg_len = sg_len;</span><br><span class="line"></span><br><span class="line">	mmc_set_data_timeout(mrq-&gt;data, test-&gt;card);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个具体是在mmc_test里，先看看log情况。</p>
<p>mmc_test默认是模块CONFIG_MMC_TEST&#x3D;m，insmod有如下签名问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insmod: failed to load mmc_test.ko: Required key not available</span><br></pre></td></tr></table></figure>

<p>先略过签名改成y后，如下路径会多出mmc_test目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls /sys/bus/mmc/drivers</span></span><br><span class="line">mmc_test mmcblk</span><br></pre></td></tr></table></figure>

<p>ok,用mmc0会直接Oops，先用mmc1 (SD card)试下,操作步骤是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> mmc1:0001 &gt; /sys/bus/mmc/drivers/mmcblk/unbind</span><br><span class="line"><span class="built_in">echo</span> mmc1:0001 &gt; /sys/bus/mmc/drivers/mmc_test/bind</span><br></pre></td></tr></table></figure>

<p>这时候到如下路径就能看到多出test和testlist两个文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/sys/kernel/debug/mmc1/mmc1:0001 <span class="comment"># ls</span></span><br><span class="line">state status <span class="built_in">test</span> testlist</span><br></pre></td></tr></table></figure>

<p>其中6就是多块读测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 6 &gt; <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>把CONFIG_MMC_DEBUG放开，太多打印了，能看到这项测试的log</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[  137.468637] mmc1: starting CMD18 arg 00000000 flags 00000035</span><br><span class="line">[  137.468644] mmc1:     blksz 512 blocks 16 flags 00000200 tsac 100 ms nsac 0</span><br><span class="line">[  137.468650] mmc1:     CMD12 arg 00000000 flags 0000001d</span><br><span class="line">[  137.468696] sdhci [sdhci_irq()]: *** mmc1 got interrupt: 0x00000001</span><br><span class="line">[  137.469279] sdhci [sdhci_irq()]: *** mmc1 got interrupt: 0x00000002</span><br><span class="line">[  137.469309] sdhci [sdhci_irq()]: *** mmc1 got interrupt: 0x00000003</span><br><span class="line">[  137.469323] mmc1: accumulated busy time is 33456 usec</span><br><span class="line">[  137.469331] mmc1: req done (CMD18): 0: 00000900 00000000 00000000 00000000</span><br><span class="line">[  137.469336] mmc1:     8192 bytes transferred: 0</span><br><span class="line">[  137.469343] mmc1:     (CMD12): 0: 00000b00 00000000 00000000 00000000</span><br></pre></td></tr></table></figure>

<p>ok, 那mmc0到底用了没，放开debug，确是没有发现CMD18 + CMD12的打印，偶尔看了下LK的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Function: mmc sdhci read</span></span><br><span class="line"><span class="comment"> * Arg     : mmc device structure, block address, number of blocks &amp; destination</span></span><br><span class="line"><span class="comment"> * Return  : 0 on Success, non zero on success</span></span><br><span class="line"><span class="comment"> * Flow    : Fill in the command structure &amp; send the command</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmc_sdhci_read</span><span class="params">(<span class="keyword">struct</span> mmc_device *dev, <span class="type">void</span> *dest,</span></span><br><span class="line"><span class="params">                                                <span class="type">uint64_t</span> blk_addr, <span class="type">uint32_t</span> num_blocks)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">uint32_t</span> mmc_ret = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mmc_command</span> <span class="title">cmd</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mmc_card</span> *<span class="title">card</span> =</span> &amp;dev-&gt;card;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">struct</span> mmc_command *)&amp;cmd, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mmc_command));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CMD17/18 Format:</span></span><br><span class="line"><span class="comment">         * [31:0] Data Address</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (num_blocks == <span class="number">1</span>)</span><br><span class="line">                cmd.cmd_index = CMD17_READ_SINGLE_BLOCK;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                cmd.cmd_index = CMD18_READ_MULTIPLE_BLOCK;</span><br><span class="line">        ...</span><br><span class="line">                <span class="comment">/* For multi block read failures send stop command */</span></span><br><span class="line">        <span class="keyword">if</span> (mmc_ret &amp;&amp; num_blocks &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> mmc_stop_command(dev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Response contains 32 bit Card status.</span></span><br><span class="line"><span class="comment">         * Parse the errors &amp; provide relevant information</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> mmc_parse_response(cmd.resp[<span class="number">0</span>]);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常的使用应该在这类读写接口里，kernel的mmc0&#x2F;mmc1读写是怎么样的，从上面的log能看出在mmc_blk_rw_rq_prep中:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mmc_blk_rw_rq_prep</span><span class="params">(<span class="keyword">struct</span> mmc_queue_req *mqrq,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> mmc_card *card,</span></span><br><span class="line"><span class="params">			       <span class="type">int</span> disable_multi,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> mmc_queue *mq)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 readcmd, writecmd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_blk_request</span> *<span class="title">brq</span> =</span> &amp;mqrq-&gt;brq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> mqrq-&gt;req;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_blk_data</span> *<span class="title">md</span> =</span> mq-&gt;data;</span><br><span class="line">	<span class="type">bool</span> do_data_tag;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reliable writes are used to implement Forced Unit Access and</span></span><br><span class="line"><span class="comment">	 * REQ_META accesses, and are supported only on MMCs.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">XXX:</span> this really needs a good explanation of why REQ_META</span></span><br><span class="line"><span class="comment">	 * is treated special.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">bool</span> do_rel_wr = ((req-&gt;cmd_flags &amp; REQ_FUA) ||</span><br><span class="line">			  (req-&gt;cmd_flags &amp; REQ_META)) &amp;&amp;</span><br><span class="line">		(rq_data_dir(req) == WRITE) &amp;&amp;</span><br><span class="line">		(md-&gt;flags &amp; MMC_BLK_REL_WR);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	brq-&gt;cmd.arg = blk_rq_pos(req);</span><br><span class="line">	<span class="keyword">if</span> (!mmc_card_blockaddr(card))</span><br><span class="line">		brq-&gt;cmd.arg &lt;&lt;= <span class="number">9</span>;</span><br><span class="line">	brq-&gt;cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;</span><br><span class="line">	brq-&gt;data.blksz = <span class="number">512</span>;</span><br><span class="line">	brq-&gt;stop.opcode = MMC_STOP_TRANSMISSION; <span class="comment">//stop</span></span><br><span class="line">	brq-&gt;stop.arg = <span class="number">0</span>;</span><br><span class="line">	...</span><br><span class="line">		<span class="keyword">if</span> (brq-&gt;data.blocks &gt; <span class="number">1</span> || do_rel_wr) &#123;</span><br><span class="line">		<span class="comment">/* SPI multiblock writes terminate using a special</span></span><br><span class="line"><span class="comment">		 * token, not a STOP_TRANSMISSION request.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!mmc_host_is_spi(card-&gt;host) ||</span><br><span class="line">		    rq_data_dir(req) == READ)</span><br><span class="line">			brq-&gt;mrq.stop = &amp;brq-&gt;stop; <span class="comment">//stop</span></span><br><span class="line">		readcmd = MMC_READ_MULTIPLE_BLOCK;</span><br><span class="line">		writecmd = MMC_WRITE_MULTIPLE_BLOCK;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		brq-&gt;mrq.stop = <span class="literal">NULL</span>;</span><br><span class="line">		readcmd = MMC_READ_SINGLE_BLOCK;</span><br><span class="line">		writecmd = MMC_WRITE_BLOCK;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>流程调用大概看下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mmc_blk_probe</span><br><span class="line"> |</span><br><span class="line">mmc_blk_alloc/mmc_blk_alloc_part</span><br><span class="line"> |</span><br><span class="line">mmc_blk_alloc_req (md-&gt;queue.issue_fn = mmc_blk_issue_rq) </span><br><span class="line"> |</span><br><span class="line">mmc_blk_issue_rq</span><br><span class="line"> |</span><br><span class="line">mmc_blk_issue_rw_rq</span><br><span class="line"> |</span><br><span class="line">mmc_blk_rw_rq_prep</span><br></pre></td></tr></table></figure>

<p>请求发出主要是通过一个线程 call issue_fn。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mmc_queue_thread</span><span class="params">(<span class="type">void</span> *d)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue</span> *<span class="title">mq</span> =</span> d;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">q</span> =</span> mq-&gt;<span class="built_in">queue</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_card</span> *<span class="title">card</span> =</span> mq-&gt;card;</span><br><span class="line"></span><br><span class="line">	current-&gt;flags |= PF_MEMALLOC;</span><br><span class="line">	<span class="keyword">if</span> (card-&gt;host-&gt;wakeup_on_idle)</span><br><span class="line">		set_wake_up_idle(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	down(&amp;mq-&gt;thread_sem);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue_req</span> *<span class="title">tmp</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> cmd_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		spin_lock_irq(q-&gt;queue_lock);</span><br><span class="line">		set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">		req = blk_fetch_request(q);</span><br><span class="line">		mq-&gt;mqrq_cur-&gt;req = req;</span><br><span class="line">		spin_unlock_irq(q-&gt;queue_lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (req || mq-&gt;mqrq_prev-&gt;req) &#123;</span><br><span class="line">			set_current_state(TASK_RUNNING);</span><br><span class="line">			cmd_flags = req ? req-&gt;cmd_flags : <span class="number">0</span>;</span><br><span class="line">			mq-&gt;issue_fn(mq, req); <span class="comment">// mmc_blk_issue_rq</span></span><br></pre></td></tr></table></figure>

<p>线程的创建是在mmc_init_queue：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mmc_init_queue - initialise a queue structure.</span></span><br><span class="line"><span class="comment"> * @mq: mmc queue</span></span><br><span class="line"><span class="comment"> * @card: mmc card to attach this queue</span></span><br><span class="line"><span class="comment"> * @lock: queue lock</span></span><br><span class="line"><span class="comment"> * @subname: partition subname</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Initialise a MMC card request queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mmc_init_queue</span><span class="params">(<span class="keyword">struct</span> mmc_queue *mq, <span class="keyword">struct</span> mmc_card *card,</span></span><br><span class="line"><span class="params">		   <span class="type">spinlock_t</span> *lock, <span class="type">const</span> <span class="type">char</span> *subname, <span class="type">int</span> area_type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_host</span> *<span class="title">host</span> =</span> card-&gt;host;</span><br><span class="line">	u64 limit = BLK_BOUNCE_HIGH;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue_req</span> *<span class="title">mqrq_cur</span> =</span> &amp;mq-&gt;mqrq[<span class="number">0</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue_req</span> *<span class="title">mqrq_prev</span> =</span> &amp;mq-&gt;mqrq[<span class="number">1</span>];</span><br><span class="line">	...</span><br><span class="line">success:</span><br><span class="line">	sema_init(&amp;mq-&gt;thread_sem, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* hook for pm qos legacy init */</span></span><br><span class="line">	<span class="keyword">if</span> (card-&gt;host-&gt;ops-&gt;init)</span><br><span class="line">		card-&gt;host-&gt;ops-&gt;init(card-&gt;host);</span><br><span class="line"></span><br><span class="line">	mq-&gt;thread = kthread_run(mmc_queue_thread, mq, <span class="string">&quot;mmcqd/%d%s&quot;</span>,</span><br><span class="line">		host-&gt;index, subname ? subname : <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>ps看下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ps | grep mmc</span></span><br><span class="line">root      288   2     0      0     irq_thread 00000000 S irq/145-mmc0</span><br><span class="line">root      290   2     0      0     irq_thread 00000000 S irq/147-mmc1</span><br><span class="line">root      292   2     0      0     mmc_cmdq_t 00000000 D mmc-cmdqd/0</span><br><span class="line">root      293   2     0      0     mmc_queue_ 00000000 S mmcqd/0rpmb</span><br></pre></td></tr></table></figure>

<p>插上SD card，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root      288   2     0      0     irq_thread 00000000 S irq/145-mmc0</span><br><span class="line">root      290   2     0      0     irq_thread 00000000 S irq/147-mmc1</span><br><span class="line">root      291   2     0      0     mmc_cmdq_t 00000000 D mmc-cmdqd/0</span><br><span class="line">root      293   2     0      0     mmc_queue_ 00000000 S mmcqd/0rpmb</span><br><span class="line">root      303   2     0      0     mmc_start_ 00000000 S mmcqd/1</span><br></pre></td></tr></table></figure>

<p>上面创建的线程应该就是mmcqd&#x2F;0rpmb和mmcqd&#x2F;1，mmcqd&#x2F;0rpmb是mmc0的rpmb区分，mmcqd&#x2F;1才是for mmc1(SD card)。</p>
<p>那还有一个线程mmc-cmdqd&#x2F;0是啥，线程创建往上再细看下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mmc_init_queue</span><span class="params">(<span class="keyword">struct</span> mmc_queue *mq, <span class="keyword">struct</span> mmc_card *card,</span></span><br><span class="line"><span class="params">		   <span class="type">spinlock_t</span> *lock, <span class="type">const</span> <span class="type">char</span> *subname, <span class="type">int</span> area_type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_host</span> *<span class="title">host</span> =</span> card-&gt;host;</span><br><span class="line">	u64 limit = BLK_BOUNCE_HIGH;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue_req</span> *<span class="title">mqrq_cur</span> =</span> &amp;mq-&gt;mqrq[<span class="number">0</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_queue_req</span> *<span class="title">mqrq_prev</span> =</span> &amp;mq-&gt;mqrq[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mmc_dev(host)-&gt;dma_mask &amp;&amp; *mmc_dev(host)-&gt;dma_mask)</span><br><span class="line">		limit = (u64)dma_max_pfn(mmc_dev(host)) &lt;&lt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">	mq-&gt;card = card;</span><br><span class="line">	<span class="keyword">if</span> (card-&gt;ext_csd.cmdq_support &amp;&amp;</span><br><span class="line">	    (area_type == MMC_BLK_DATA_AREA_MAIN)) &#123;</span><br><span class="line">		mq-&gt;<span class="built_in">queue</span> = blk_init_queue(mmc_cmdq_dispatch_req, lock);</span><br><span class="line">		<span class="keyword">if</span> (!mq-&gt;<span class="built_in">queue</span>)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		mmc_cmdq_setup_queue(mq, card);</span><br><span class="line">		ret = mmc_cmdq_init(mq, card);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;%s: %d: cmdq: unable to set-up\n&quot;</span>,</span><br><span class="line">			       mmc_hostname(card-&gt;host), ret);</span><br><span class="line">			blk_cleanup_queue(mq-&gt;<span class="built_in">queue</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			sema_init(&amp;mq-&gt;thread_sem, <span class="number">1</span>);</span><br><span class="line">			<span class="comment">/* hook for pm qos cmdq init */</span></span><br><span class="line">			<span class="keyword">if</span> (card-&gt;host-&gt;cmdq_ops-&gt;init)</span><br><span class="line">				card-&gt;host-&gt;cmdq_ops-&gt;init(card-&gt;host);</span><br><span class="line">			mq-&gt;<span class="built_in">queue</span>-&gt;queuedata = mq;</span><br><span class="line">			mq-&gt;thread = kthread_run(mmc_cmdq_thread, mq,</span><br><span class="line">						 <span class="string">&quot;mmc-cmdqd/%d%s&quot;</span>,</span><br><span class="line">						 host-&gt;index,</span><br><span class="line">						 subname ? subname : <span class="string">&quot;&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(mq-&gt;thread)) &#123;</span><br><span class="line">				pr_err(<span class="string">&quot;%s: %d: cmdq: failed to start mmc-cmdqd thread\n&quot;</span>,</span><br><span class="line">						mmc_hostname(card-&gt;host), ret);</span><br><span class="line">				ret = PTR_ERR(mq-&gt;thread);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> ret; <span class="comment">//已经返回了</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mq-&gt;<span class="built_in">queue</span> = blk_init_queue(mmc_request_fn, lock);</span><br><span class="line">	<span class="keyword">if</span> (!mq-&gt;<span class="built_in">queue</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br></pre></td></tr></table></figure>

<p>如果<code>card-&gt;ext_csd.cmdq_support</code>为真，也就是说支持cmdq，如果创建mmc-cmdqd&#x2F;0成功就返回了,ok, cmdq是啥。</p>
<p>看到ext_csd，很显然应该是个硬件特性，再看下开机mmc0&#x2F;mmc1相关log:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[    8.332885] mmc0: SDHCI controller on 7824900.sdhci [7824900.sdhci] using 32-bit ADMA <span class="keyword">in</span> CMDQ mode</span><br><span class="line">...</span><br><span class="line">[    8.504130] mmc1: SDHCI controller on 7864900.sdhci [7864900.sdhci] using 32-bit ADMA <span class="keyword">in</span> legacy mode</span><br></pre></td></tr></table></figure>

<p>看到这里似乎知道了，mmc0用的是CMDQ方式工作，而mmc1仍然使用的是过去的旧方式。</p>
<p>我们再对比看下CMDQ的线程mmc_cmdq_thread，它对应请求是mmc_blk_cmdq_issue_rq&#x2F;mmc_blk_cmdq_rw_prep，所有相关的cmdq的接口都在cmdq_hci.c里。</p>
<p>来看下git log:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 72dfcb7c9f6134282b8077beea420d5f0d736cc9</span><br><span class="line">Author: Venkat Gopalakrishnan &lt;venkatg@codeaurora.org&gt;</span><br><span class="line">Date:   Fri May 29 17:25:46 2015 -0700</span><br><span class="line"></span><br><span class="line">    mmc: cmdq: support for command queue enabled host</span><br><span class="line">    </span><br><span class="line">    This patch adds CMDQ support for command-queue compatible</span><br><span class="line">    hosts.</span><br><span class="line">    </span><br><span class="line">    Command queue is added in eMMC-5.1 specification. This</span><br><span class="line">    enables the controller to process upto 32 requests at</span><br><span class="line">    a time.</span><br><span class="line">    </span><br><span class="line">    Change-Id: I0486495ef57c64bf8427e917daeb184c69b8dc73</span><br><span class="line">    Signed-off-by: Asutosh Das &lt;asutoshd@codeaurora.org&gt;</span><br><span class="line">    Signed-off-by: Sujit Reddy Thumma &lt;sthumma@codeaurora.org&gt;</span><br><span class="line">    Signed-off-by: Konstantin Dorfman &lt;kdorfman@codeaurora.org&gt;</span><br><span class="line">    Signed-off-by: Venkat Gopalakrishnan &lt;venkatg@codeaurora.org&gt;</span><br><span class="line"></span><br><span class="line"> drivers/mmc/host/Kconfig    |  13 ++++</span><br><span class="line"> drivers/mmc/host/Makefile   |   1 +</span><br><span class="line"> drivers/mmc/host/cmdq_hci.c | 656 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> drivers/mmc/host/cmdq_hci.h | 211 ++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> include/linux/mmc/host.h    |  12 ++++</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="code"><pre><span class="line">commit df118e6a7fd85f1f649e2b35aed1d2b18cc29b94</span><br><span class="line">Author: Asutosh Das &lt;asutoshd@codeaurora.org&gt;</span><br><span class="line">Date:   Fri Oct 17 16:36:47 2014 +0530</span><br><span class="line"></span><br><span class="line">    mmc: sdhci: add command queue support to sdhci</span><br><span class="line">    </span><br><span class="line">    Adds command-queue support to SDHCi compliant drivers.</span><br><span class="line">    </span><br><span class="line">    Change-Id: I1efee7f1c86e102364083e9158e4d45c887dd06e</span><br><span class="line">    Signed-off-by: Asutosh Das &lt;asutoshd@codeaurora.org&gt;</span><br><span class="line">    Signed-off-by: Konstantin Dorfman &lt;kdorfman@codeaurora.org&gt;</span><br><span class="line">    Signed-off-by: Venkat Gopalakrishnan &lt;venkatg@codeaurora.org&gt;</span><br><span class="line"></span><br><span class="line"> drivers/mmc/host/sdhci.c  | 142 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++---</span><br><span class="line"> drivers/mmc/host/sdhci.h  |   3 +++</span><br><span class="line"> include/linux/mmc/sdhci.h |   2 ++</span><br><span class="line"> 3 files changed, 144 insertions(+), 3 deletions(-)</span><br><span class="line"></span><br><span class="line">@@ -293,6 +293,8 @@ struct sdhci_host &#123;</span><br><span class="line"> </span><br><span class="line">        u32 auto_cmd_err_sts;</span><br><span class="line">        struct ratelimit_state dbg_dump_rs;</span><br><span class="line">+ struct cmdq_host *cq_host;</span><br><span class="line">+</span><br><span class="line">        unsigned long private[0] ____cacheline_aligned;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> static irqreturn_t sdhci_irq(int irq, void *dev_id)</span><br><span class="line"> &#123;</span><br><span class="line">        irqreturn_t result = IRQ_NONE;</span><br><span class="line">@@ -2948,6 +2963,15 @@ static irqreturn_t sdhci_irq(int irq, void *dev_id)</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        do &#123;</span><br><span class="line">+         if (host-&gt;mmc-&gt;card &amp;&amp; mmc_card_cmdq(host-&gt;mmc-&gt;card) &amp;&amp;</span><br><span class="line">+             !mmc_host_halt(host-&gt;mmc)) &#123;</span><br><span class="line">+                 pr_debug(&quot;*** %s: cmdq intr: 0x%08x\n&quot;,</span><br><span class="line">+                                 mmc_hostname(host-&gt;mmc),</span><br><span class="line">+                                 intmask);</span><br><span class="line">+                 result = sdhci_cmdq_irq(host-&gt;mmc, intmask);</span><br><span class="line">+                 goto out;</span><br><span class="line">+         &#125;</span><br><span class="line">+</span><br><span class="line">                if (intmask &amp; SDHCI_INT_AUTO_CMD_ERR)</span><br><span class="line">                        host-&gt;auto_cmd_err_sts = sdhci_readw(host,</span><br><span class="line">                                        SDHCI_AUTO_CMD_ERR);</span><br><span class="line"></span><br><span class="line">@@ -3918,12 +4042,24 @@ int sdhci_add_host(struct sdhci_host *host)</span><br><span class="line">                sdhci_writel(host, host-&gt;ier, SDHCI_SIGNAL_ENABLE);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">-   pr_info(&quot;%s: SDHCI controller on %s [%s] using %s\n&quot;,</span><br><span class="line">+ if (mmc-&gt;caps2 &amp;  MMC_CAP2_CMD_QUEUE) &#123;</span><br><span class="line">+         bool dma64 = (host-&gt;flags &amp; SDHCI_USE_ADMA_64BIT) ?</span><br><span class="line">+                 true : false;</span><br><span class="line">+         ret = sdhci_cmdq_init(host, mmc, dma64);</span><br><span class="line">+         if (ret)</span><br><span class="line">+                 pr_err(&quot;%s: CMDQ init: failed (%d)\n&quot;,</span><br><span class="line">+                        mmc_hostname(host-&gt;mmc), ret);</span><br><span class="line">+         else</span><br><span class="line">+                 host-&gt;cq_host-&gt;ops = &amp;sdhci_cmdq_ops;</span><br><span class="line">+ &#125;</span><br><span class="line">+ pr_info(&quot;%s: SDHCI controller on %s [%s] using %s in %s mode\n&quot;,</span><br><span class="line">                mmc_hostname(mmc), host-&gt;hw_name, dev_name(mmc_dev(mmc)),</span><br><span class="line">                (host-&gt;flags &amp; SDHCI_USE_ADMA) ?</span><br><span class="line">                ((host-&gt;flags &amp; SDHCI_USE_ADMA_64BIT) ?</span><br><span class="line">                &quot;64-bit ADMA&quot; : &quot;32-bit ADMA&quot;) :</span><br><span class="line">-           ((host-&gt;flags &amp; SDHCI_USE_SDMA) ? &quot;DMA&quot; : &quot;PIO&quot;));</span><br><span class="line">+         ((host-&gt;flags &amp; SDHCI_USE_SDMA) ? &quot;DMA&quot; : &quot;PIO&quot;),</span><br><span class="line">+         ((mmc-&gt;caps2 &amp;  MMC_CAP2_CMD_QUEUE) &amp;&amp; !ret) ?</span><br><span class="line">+         &quot;CMDQ&quot; : &quot;legacy&quot;);</span><br></pre></td></tr></table></figure>

<p>那基本上就是这样了，还有一个地方：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sdhci_finish_data</span><span class="params">(<span class="keyword">struct</span> sdhci_host *host)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Need to send CMD12 if -</span></span><br><span class="line"><span class="comment">	 * a) open-ended multiblock transfer (no CMD23)</span></span><br><span class="line"><span class="comment">	 * b) error in multiblock transfer</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (data-&gt;stop &amp;&amp;</span><br><span class="line">	    (data-&gt;error ||</span><br><span class="line">	     !host-&gt;mrq-&gt;sbc)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The controller needs a reset of internal state machines</span></span><br><span class="line"><span class="comment">		 * upon error conditions.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (data-&gt;error) &#123;</span><br><span class="line">			sdhci_do_reset(host, SDHCI_RESET_CMD);</span><br><span class="line">			sdhci_do_reset(host, SDHCI_RESET_DATA);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sdhci_send_command(host, data-&gt;stop);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br></pre></td></tr></table></figure>

<p>so it should not be for CQ xfer. </p>
<p>btw: 高通总是不正面答复我，给个差评:]</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>版权声明：</span>本站所有文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明原文链接！</p></div><br><div class="tags"><a href="/tags/mmc"><i class="fa fa-tag">mmc</i></a></div><div class="post-nav"><a class="pre" href="/how-to-debug-tf-card-detect-issue.html">TF卡不能检卡问题排查</a><a class="next" href="/msm-serial-console.html">关于高通平台串口调试行为的一点说明</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/kernel-cfi-failure-analysis.html">Kernel CFI failure实例分析</a></li><li class="post-list-item"><a class="post-list-link" href="/linux-kernel-drm-overview.html">Linux kernel DRM overview</a></li><li class="post-list-item"><a class="post-list-link" href="/upgrade-my-custom-build-server-amd-based.html">我的PC组装升级记</a></li><li class="post-list-item"><a class="post-list-link" href="/convert-typecho-to-hexo.html">I am back!</a></li><li class="post-list-item"><a class="post-list-link" href="/review-freezing-issue-when-drag-icon-after-ohos-adaption.html">OpenHarmony适配后图标拖拽卡屏问题回顾</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-fix-parse-too-complex-in-source-insight.html">Source Insight 自定义解析</a></li><li class="post-list-item"><a class="post-list-link" href="/adapt-ohos-for-mali-g57-on-sprd-t606.html">转：拥抱鸿蒙 - 在展讯T606平台上的探索与实践</a></li><li class="post-list-item"><a class="post-list-link" href="/essential-inventory-of-adaption-for-unisoc-platform-androidt-based.html">展讯平台 OpenHarmony 3.2.2 适配基础盘点</a></li><li class="post-list-item"><a class="post-list-link" href="/porting-openharmony-linux-kernel-to-3rd-party-chip.html">快速移植 OpenHarmony Linux 内核到三方 ARM64 平台</a></li><li class="post-list-item"><a class="post-list-link" href="/openharmony-linux-kernel-overview.html">初识 OpenHarmony Linux Kernel</a></li></ul></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arm/">arm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dd/">dd</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ebpf/">ebpf</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fs/">fs</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iot/">iot</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mm/">mm</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/msm/">msm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ohos/">ohos</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/perf/">perf</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">security</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/stab/">stab</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">tools</a><span class="category-list-count">20</span></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">TJ的技术博客.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
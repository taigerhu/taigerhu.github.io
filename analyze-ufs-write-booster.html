<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>UFS Write Booster 分析 | TJ的技术博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">UFS Write Booster 分析</h1><a id="logo" href="/.">TJ的技术博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 首页</i></a><a href="/archives/"><i class="fa undefined"> 归档</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">UFS Write Booster 分析</h1><div class="post-meta">2021-03-10</div><div class="post-content"><p>先来看看JEDEC有关WriteBooster(WB)的描述：</p>
<p>TLC NAND比SLC NAND慢的原因就是TLC里面有更多的programming steps。ok，为了提高性能，那就把TLC NAND的一部分配置成SLC NAND不就行了。rt，WriteBooster特性由此而来，就是把这部分SLC NAND用作WriteBooster Buffer。有个概率图：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+------+                   +---------------------------------------------+</span><br><span class="line">|      | 1.Write data in   |  +--------------+              +---------+  |</span><br><span class="line">|      | WriteBooster mode |  |              |              |         |  |</span><br><span class="line">| Host |-------------------|-&gt;| WriteBooster |   3.Flush    | Normal  |  |</span><br><span class="line">|      |&lt;------------------|--| Buffer       |-------------&gt;| Storage |  |</span><br><span class="line">|      |  2.fast response  |  | (SLC)        |              | (TLC)   |  |</span><br><span class="line">+------+                   |  +--------------+              |         |  |</span><br><span class="line">                           |  Device                        +---------+  |</span><br><span class="line">                           +---------------------------------------------+</span><br></pre></td></tr></table></figure>

<h2 id="Writing-data-to-WriteBooster-Buffer"><a href="#Writing-data-to-WriteBooster-Buffer" class="headerlink" title="Writing data to WriteBooster Buffer"></a>Writing data to WriteBooster Buffer</h2><p>这里有两个WriteBooster mode，一个是LU dedicated buffer mode，一个是shared buffer mode。</p>
<p>bSupportedWriteBoosterBuferTypes暗示了哪一个模式被设备支持。</p>
<p>LU dedicated buffer mode就是指定某个LU为这个WB Buffer。shared buffer mode就是所有的LU共享这个WB Buffer了，不过well-known LUs例外。</p>
<p>注意这个WB Buffer是有生命周期的，你懂的:)</p>
<h2 id="Flushing-WriteBooster-Buffer"><a href="#Flushing-WriteBooster-Buffer" class="headerlink" title="Flushing WriteBooster Buffer"></a>Flushing WriteBooster Buffer</h2><p>当整个WriteBooster buffer被用完了，device就通过WRITEBOOSTER_FLAUSH_NEEDED事件通知Host: need flush( to normal storage)。如果flush有错，那就直接写到normal storage了。</p>
<p>有两个方法flush，一个是flush命令，另一个是在hibernate时。只有当command queue为空时才执行flush。当正在flush时要是有host cmd过来，那就suspend flush，等处理完host cmd后, consume之前suspend的flush。</p>
<h2 id="User-space-configurations"><a href="#User-space-configurations" class="headerlink" title="User space configurations"></a>User space configurations</h2><p>既然有一部分用作WB Buffer，那用户可用空间肯定少了啊，rt，这就是user space reduction。但还有个配置可以保留这个空间，当normal storage都用完了，那就用WB Buffer，此时WB Buffer需要回到normal storage，类似flush操作，性能就会下降。</p>
<h2 id="Linux代码分析"><a href="#Linux代码分析" class="headerlink" title="Linux代码分析"></a>Linux代码分析</h2><p>参考内核5.x, 先看下<code>struct ufs_dev_info</code>，关注WB code。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ufs_dev_info</span> &#123;</span></span><br><span class="line">	<span class="type">bool</span>	f_power_on_wp_en;</span><br><span class="line">	<span class="comment">/* Keeps information if any of the LU is power on write protected */</span></span><br><span class="line">	<span class="type">bool</span>	is_lu_power_on_wp;</span><br><span class="line">	<span class="comment">/* Maximum number of general LU supported by the UFS device */</span></span><br><span class="line">	u8	max_lu_supported;</span><br><span class="line">	u16	wmanufacturerid;</span><br><span class="line">	<span class="comment">/*UFS device Product Name */</span></span><br><span class="line">	u8	*model;</span><br><span class="line">	u16	wspecversion;</span><br><span class="line">	u32	clk_gating_wait_us;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* UFS WB related flags */</span></span><br><span class="line">	<span class="type">bool</span>    wb_enabled;  <span class="comment">//tj: 特性使能</span></span><br><span class="line">	<span class="type">bool</span>    wb_buf_flush_enabled; <span class="comment">//tj: flush操作</span></span><br><span class="line">	u8	wb_dedicated_lu; <span class="comment">//tj: LU dedicated buffer mode</span></span><br><span class="line">	u8      wb_buffer_type;  <span class="comment">//tj: WriteBooster模式</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span>	b_rpm_dev_flush_capable;</span><br><span class="line">	u8	b_presrv_uspc_en; <span class="comment">//tj: 保留用户空间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>获取设备描述符时会check WB，入口是<code>ufshcd_wb_probe()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ufshcd_wb_probe</span><span class="params">(<span class="keyword">struct</span> ufs_hba *hba, u8 *desc_buf)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Probe WB only for UFS-2.2 and UFS-3.1 (and later) devices or</span></span><br><span class="line"><span class="comment">	 * UFS devices with quirk UFS_DEVICE_QUIRK_SUPPORT_EXTENDED_FEATURES</span></span><br><span class="line"><span class="comment">	 * enabled</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(dev_info-&gt;wspecversion &gt;= <span class="number">0x310</span> ||</span><br><span class="line">	      dev_info-&gt;wspecversion == <span class="number">0x220</span> ||</span><br><span class="line">	     (hba-&gt;dev_quirks &amp; UFS_DEVICE_QUIRK_SUPPORT_EXTENDED_FEATURES)))</span><br><span class="line">		<span class="keyword">goto</span> wb_disabled;</span><br></pre></td></tr></table></figure>

<p>UFS-2.2和UFS-3.1(and later)有这个能力。</p>
<p>注意还有个不管标准了，只要有<code>UFS_DEVICE_QUIRK_SUPPORT_EXTENDED_FEATURES</code>这个quirk也行。来看下这个quirk:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Some pre-3.1 UFS devices can support extended features by upgrading</span></span><br><span class="line"><span class="comment"> * the firmware. Enable this quirk to make UFS core driver probe and enable</span></span><br><span class="line"><span class="comment"> * supported features on such devices.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UFS_DEVICE_QUIRK_SUPPORT_EXTENDED_FEATURES (1 &lt;&lt; 10)</span></span><br></pre></td></tr></table></figure>

<p>好家伙，通过升级固件的方式也可以具备WB。So，市面上出现的UFS-3.0 + WriteBooster就是这个喽？</p>
<p>继续看code, WB device支持的条件需要：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ext_ufs_feature = get_unaligned_be32(desc_buf +</span><br><span class="line">				DEVICE_DESC_PARAM_EXT_UFS_FEATURE_SUP);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(ext_ufs_feature &amp; UFS_DEV_WRITE_BOOSTER_SUP))</span><br><span class="line">	<span class="keyword">goto</span> wb_disabled;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEVICE_DESC_PARAM_EXT_UFS_FEATURE_SUP	= <span class="number">0x4F</span>,</span><br></pre></td></tr></table></figure>

<p>继续：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (dev_info-&gt;wb_buffer_type == WB_BUF_MODE_SHARED) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!get_unaligned_be32(desc_buf +</span><br><span class="line">				   DEVICE_DESC_PARAM_WB_SHARED_ALLOC_UNITS))</span><br><span class="line">			<span class="keyword">goto</span> wb_disabled;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (lun = <span class="number">0</span>; lun &lt; UFS_UPIU_MAX_WB_LUN_ID; lun++) &#123;</span><br><span class="line">			d_lu_wb_buf_alloc = <span class="number">0</span>;</span><br><span class="line">			ufshcd_read_unit_desc_param(hba,</span><br><span class="line">					lun,</span><br><span class="line">					UNIT_DESC_PARAM_WB_BUF_ALLOC_UNITS,</span><br><span class="line">					(u8 *)&amp;d_lu_wb_buf_alloc,</span><br><span class="line">					<span class="keyword">sizeof</span>(d_lu_wb_buf_alloc));</span><br><span class="line">			<span class="keyword">if</span> (d_lu_wb_buf_alloc) &#123;</span><br><span class="line">				dev_info-&gt;wb_dedicated_lu = lun;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!d_lu_wb_buf_alloc)</span><br><span class="line">			<span class="keyword">goto</span> wb_disabled;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">wb_disabled:</span><br><span class="line">	hba-&gt;caps &amp;= ~UFSHCD_CAP_WB_EN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共享模式，查看分配大小<code>DEVICE_DESC_PARAM_WB_SHARED_ALLOC_UNITS</code>(dNumSharedWriteBoosterBufferAllocUnits)，如果没分配那就disable WB。</p>
<p>LU专有模式就是从0-7个LU里找看谁分配了WB Buffer就用那个了。</p>
<p>WB特性使能：<code>ufshcd_wb_ctrl()</code>。</p>
<p>两种flush使能: <code>ufshcd_wb_toggle_flush()</code>和<code>ufshcd_wb_toggle_flush_during_h8()</code>。</p>
<p>对于user space reduction，可用buffer大小&lt;10%那就需要flush了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">ufshcd_wb_need_flush</span><span class="params">(<span class="keyword">struct</span> ufs_hba *hba)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (!hba-&gt;dev_info.b_presrv_uspc_en) &#123;</span><br><span class="line">		<span class="keyword">if</span> (avail_buf &lt;= UFS_WB_BUF_REMAIN_PERCENT(<span class="number">10</span>))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>对于 preserve user space，多了个当前WB buffer大小的check:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">ufshcd_wb_presrv_usrspc_keep_vcc_on</span><span class="params">(<span class="keyword">struct</span> ufs_hba *hba,</span></span><br><span class="line"><span class="params">						u32 avail_buf)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (!cur_buf) &#123;</span><br><span class="line">		dev_info(hba-&gt;dev, <span class="string">&quot;dCurWBBuf: %d WB disabled until free-space is available\n&quot;</span>,</span><br><span class="line">			 cur_buf);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Let it continue to flush when available buffer exceeds threshold */</span></span><br><span class="line">	<span class="keyword">if</span> (avail_buf &lt; hba-&gt;vps-&gt;wb_flush_threshold)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前面说过因为perserve，WB buffer大小是可能变化的，当WB buffer全部都回到user space，那就等于没有WB了，也就不需要flush了。</p>
<p>这里可用的buffer门限取决于host侧? 默认是40。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ufs_hba_variant_params</span> <span class="title">ufs_hba_vps</span> =</span> &#123;</span><br><span class="line">	.hba_enable_delay_us		= <span class="number">1000</span>,</span><br><span class="line">	.wb_flush_threshold		= UFS_WB_BUF_REMAIN_PERCENT(<span class="number">40</span>),</span><br></pre></td></tr></table></figure>

<p>mtk改变了flush策略，门限定了80%。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Enable WriteBooster */</span></span><br><span class="line">hba-&gt;caps |= UFSHCD_CAP_WB_EN;</span><br><span class="line">hba-&gt;quirks |= UFSHCI_QUIRK_SKIP_MANUAL_WB_FLUSH_CTRL;</span><br><span class="line">hba-&gt;vps-&gt;wb_flush_threshold = UFS_WB_BUF_REMAIN_PERCENT(<span class="number">80</span>);</span><br></pre></td></tr></table></figure>

<p>也就是说，使用了&gt;20%就要flush了，才这么点？</p>
<h2 id="Refer-doc"><a href="#Refer-doc" class="headerlink" title="Refer doc"></a>Refer doc</h2><p>JEDEC standard UFS version 2.2 (free)</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>版权声明：</span>本站所有文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明原文链接！</p></div><br><div class="tags"><a href="/tags/WriteBooster"><i class="fa fa-tag">WriteBooster</i></a></div><div class="post-nav"><a class="pre" href="/mmc_cmdq_timeout.html">eMMC CMDQ 超时分析</a><a class="next" href="/analyze-schedutil-code.html">schedutil CPUFreq governor 代码分析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/how-to-use-adeb-to-install-bcc-into-android.html">转: 使用 adeb 在 Android 上编译安装 bcc</a></li><li class="post-list-item"><a class="post-list-link" href="/kworker-sched-la-stat.html">kworker 调度延迟性能测试和统计</a></li><li class="post-list-item"><a class="post-list-link" href="/implement-erofs-fragment-dedupe.html">转：EROFS 碎片去重实践</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-enable-kasan-in-ubuntu-18-04-for-x86_64.html">How to enable KASAN in Ubuntu 18.04 for X86_64</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-analyze-segmentation-fault-for-non-install-package-in-ubuntu.html">如何分析 Linux user space's segmentation fault</a></li><li class="post-list-item"><a class="post-list-link" href="/prepare-fragment-dedupe-in-erofs.html">EROFS 碎片去重准备</a></li><li class="post-list-item"><a class="post-list-link" href="/good-naming-in-programming.html">优秀代码命名法</a></li><li class="post-list-item"><a class="post-list-link" href="/erofs-compressed-data-deduplication.html">EROFS 压缩去重分析</a></li><li class="post-list-item"><a class="post-list-link" href="/analyze-fscache-cookie-code.html">转：浅析 Linux FS-Cache</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-let-bluetooth-work-under-armbian-kodi-for-rockpi4b-within-metal-case.html">Rockpi4b Armbian Kodi 终于能使用蓝牙了</a></li></ul></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arm/">ARM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dd/">Device Driver</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fs/">File System</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iot/">IoT</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/msm/">MSM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mm/">Memory Management</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/perf/">Performance</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">Security</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/stab/">Stability</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">Tools</a><span class="category-list-count">18</span></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">TJ的技术博客.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>memcg: understand memory usage | TJ的技术博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">memcg: understand memory usage</h1><a id="logo" href="/.">TJ的技术博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 首页</i></a><a href="/archives/"><i class="fa undefined"> 归档</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">memcg: understand memory usage</h1><div class="post-meta">2018-06-21</div><div class="post-content"><p>Android Go的用户态lmk在探测内存压力时用到了memcg的如下内存使用统计：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MEMCG_MEMORY_USAGE <span class="string">&quot;/dev/memcg/memory.usage_in_bytes&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMCG_MEMORYSW_USAGE <span class="string">&quot;/dev/memcg/memory.memsw.usage_in_bytes&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>memcg是cgroup的一个子系统，那这两个文件是如何统计内存使用的，带着这个疑问来看下, kernel 3.18, msm平台。</p>
<h2 id="How-to-read"><a href="#How-to-read" class="headerlink" title="How to read"></a>How to read</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cftype</span> <span class="title">mem_cgroup_files</span>[] =</span> &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">&quot;usage_in_bytes&quot;</span>,</span><br><span class="line">		.private = MEMFILE_PRIVATE(_MEM, RES_USAGE),</span><br><span class="line">		.read_u64 = mem_cgroup_read_u64,</span><br><span class="line">	&#125;,</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG_SWAP</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> cftype memsw_cgroup_files[] = &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">&quot;memsw.usage_in_bytes&quot;</span>,</span><br><span class="line">		.private = MEMFILE_PRIVATE(_MEMSWAP, RES_USAGE),</span><br><span class="line">		.read_u64 = mem_cgroup_read_u64,</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure>

<p>统一入口<code>mem_cgroup_read_u64</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> u64 <span class="title function_">mem_cgroup_read_u64</span><span class="params">(<span class="keyword">struct</span> cgroup_subsys_state *css,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> cftype *cft)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span> =</span> mem_cgroup_from_css(css);</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">res_type</span> <span class="title">type</span> =</span> MEMFILE_TYPE(cft-&gt;private);</span><br><span class="line">	<span class="type">int</span> name = MEMFILE_ATTR(cft-&gt;private);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">	<span class="keyword">case</span> _MEM:</span><br><span class="line">		<span class="keyword">if</span> (name == RES_USAGE)</span><br><span class="line">			<span class="keyword">return</span> mem_cgroup_usage(memcg, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> res_counter_read_u64(&amp;memcg-&gt;res, name);</span><br><span class="line">	<span class="keyword">case</span> _MEMSWAP:</span><br><span class="line">		<span class="keyword">if</span> (name == RES_USAGE)</span><br><span class="line">			<span class="keyword">return</span> mem_cgroup_usage(memcg, <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">return</span> res_counter_read_u64(&amp;memcg-&gt;memsw, name);</span><br></pre></td></tr></table></figure>

<p>这里<code>usage_in_bytes</code>和<code>memsw.usage_in_bytes</code>都走了<code>mem_cgroup_usage(,boot swap)</code>。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u64 <span class="title function_">mem_cgroup_usage</span><span class="params">(<span class="keyword">struct</span> mem_cgroup *memcg, <span class="type">bool</span> swap)</span></span><br><span class="line">&#123;</span><br><span class="line">	u64 val;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mem_cgroup_is_root(memcg)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!swap)</span><br><span class="line">			<span class="keyword">return</span> res_counter_read_u64(&amp;memcg-&gt;res, RES_USAGE);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> res_counter_read_u64(&amp;memcg-&gt;memsw, RES_USAGE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Transparent hugepages are still accounted for in MEM_CGROUP_STAT_RSS</span></span><br><span class="line"><span class="comment">	 * as well as in MEM_CGROUP_STAT_RSS_HUGE.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	val = mem_cgroup_recursive_stat(memcg, MEM_CGROUP_STAT_CACHE);</span><br><span class="line">	val += mem_cgroup_recursive_stat(memcg, MEM_CGROUP_STAT_RSS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (swap)</span><br><span class="line">		val += mem_cgroup_recursive_stat(memcg, MEM_CGROUP_STAT_SWAP);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> val &lt;&lt; PAGE_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从字面上看，如果是root memcg那就走<code>mem_cgroup_recursive_stat</code>循环统计，如果是non root memcg那就直接call <code>res_counter_read_u64</code>去读<code>res</code>。</p>
<p>res的内核文档设计说明：</p>
<blockquote>
<p>2.1. Design</p>
<p>The core of the design is a counter called the res_counter. The res_counter<br>tracks the current memory usage and limit of the group of processes associated<br>with the controller. Each cgroup has a memory controller specific data<br>structure (mem_cgroup) associated with it. </p>
<p>2.2. Accounting</p>
<pre><code>           +--------------------+
           |  mem_cgroup     |   
           |  (res_counter)     |   
           +--------------------+
            /            ^      \   
           /             |       \   
      +---------------+  |        +---------------+
      | mm_struct     |  |....    | mm_struct     |   
      |               |  |        |               |   
      +---------------+  |        +---------------+
                         |   
                         + --------------+
                                         |   
      +---------------+           +------+--------+
      | page          +----------&gt;  page_cgroup|
      |               |           |               |   
      +---------------+           +---------------+

        (Figure 1: Hierarchy of Accounting)
</code></pre>
<p>Figure 1 shows the important aspects of the controller</p>
<ol>
<li>Accounting happens per cgroup</li>
<li>Each mm_struct knows about which cgroup it belongs to</li>
<li>Each page has a pointer to the page_cgroup, which in turn knows the<br>  cgroup it belongs to</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> <span class="title">css</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * the counter to account for memory usage</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">res_counter</span> <span class="title">res</span>;</span></span><br></pre></td></tr></table></figure>

<p>root memcg的统计用的是<code>struct mem_cgroup_stat_cpu</code>的<code>count</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup_stat_cpu</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> count[MEM_CGROUP_STAT_NSTATS];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> events[MEM_CGROUP_EVENTS_NSTATS];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr_page_events;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> targets[MEM_CGROUP_NTARGETS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * percpu counter.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup_stat_cpu</span> __<span class="title">percpu</span> *<span class="title">stat</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">mem_cgroup_read_stat</span><span class="params">(<span class="keyword">struct</span> mem_cgroup *memcg,</span></span><br><span class="line"><span class="params">				 <span class="keyword">enum</span> mem_cgroup_stat_index idx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(cpu)</span><br><span class="line">		val += per_cpu(memcg-&gt;stat-&gt;count[idx], cpu);</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What is root memcg? 就是初始化时创建的cgroup就是root memory cgroup:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> cgroup_subsys_state * __ref</span><br><span class="line"><span class="title function_">mem_cgroup_css_alloc</span><span class="params">(<span class="keyword">struct</span> cgroup_subsys_state *parent_css)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line">	<span class="type">long</span> error = -ENOMEM;</span><br><span class="line">	<span class="type">int</span> node;</span><br><span class="line"></span><br><span class="line">	memcg = mem_cgroup_alloc();</span><br><span class="line">	<span class="keyword">if</span> (!memcg)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line"></span><br><span class="line">	for_each_node(node)</span><br><span class="line">		<span class="keyword">if</span> (alloc_mem_cgroup_per_zone_info(memcg, node))</span><br><span class="line">			<span class="keyword">goto</span> free_out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* root ? */</span></span><br><span class="line">	<span class="keyword">if</span> (parent_css == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		root_mem_cgroup = memcg;</span><br><span class="line">		res_counter_init(&amp;memcg-&gt;res, <span class="literal">NULL</span>);</span><br><span class="line">		res_counter_init(&amp;memcg-&gt;memsw, <span class="literal">NULL</span>);</span><br><span class="line">		res_counter_init(&amp;memcg-&gt;kmem, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cgroup_init -&gt; cgroup_init_subsys -&gt; mem_cgroup_css_alloc(NULL)</span><br></pre></td></tr></table></figure>

<p>init(system&#x2F;core&#x2F;init&#x2F;init.cpp)会创建non root memcg，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set memcg property based on kernel cmdline argument</span></span><br><span class="line"> <span class="type">bool</span> memcg_enabled = android::base::<span class="built_in">GetBoolProperty</span>(<span class="string">&quot;ro.boot.memcg&quot;</span>,<span class="literal">false</span>);</span><br><span class="line"> <span class="keyword">if</span> (memcg_enabled) &#123;</span><br><span class="line">    <span class="comment">// root memory control cgroup</span></span><br><span class="line">    <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/memcg&quot;</span>, <span class="number">0700</span>);</span><br><span class="line">    <span class="built_in">chown</span>(<span class="string">&quot;/dev/memcg&quot;</span>,AID_ROOT,AID_SYSTEM);</span><br><span class="line">    <span class="built_in">mount</span>(<span class="string">&quot;none&quot;</span>, <span class="string">&quot;/dev/memcg&quot;</span>, <span class="string">&quot;cgroup&quot;</span>, <span class="number">0</span>, <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">    <span class="comment">// app mem cgroups, used by activity manager, lmkd and zygote</span></span><br><span class="line">    <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/memcg/apps/&quot;</span>,<span class="number">0755</span>);</span><br><span class="line">    <span class="built_in">chown</span>(<span class="string">&quot;/dev/memcg/apps/&quot;</span>,AID_SYSTEM,AID_SYSTEM);</span><br><span class="line">    <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/memcg/system&quot;</span>,<span class="number">0550</span>);</span><br><span class="line">    <span class="built_in">chown</span>(<span class="string">&quot;/dev/memcg/system&quot;</span>,AID_SYSTEM,AID_SYSTEM);</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<p>non root的memcg创建：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cgroup_mkdir -&gt; create_css -&gt; mem_cgroup_css_alloc</span><br></pre></td></tr></table></figure>

<p>ok, 那lmkd统计的mem usage其实就是root memcg的统计，root memcg就是把所有memcg的mem_cgroup_stat_cpu的count累加。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">mem_cgroup_recursive_stat</span><span class="params">(<span class="keyword">struct</span> mem_cgroup *memcg,</span></span><br><span class="line"><span class="params">					       <span class="keyword">enum</span> mem_cgroup_stat_index idx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">iter</span>;</span></span><br><span class="line">	<span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Per-cpu values can be negative, use a signed accumulator */</span></span><br><span class="line">	for_each_mem_cgroup_tree(iter, memcg)</span><br><span class="line">		val += mem_cgroup_read_stat(iter, idx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (val &lt; <span class="number">0</span>) <span class="comment">/* race ? */</span></span><br><span class="line">		val = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>memcg使用多少内存统计的是 MEM_CGROUP_STAT_CACHE + MEM_CGROUP_STAT_RSS + MEM_CGROUP_STAT_SWAP。</p>
<p>看下系统cgroups的情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx:/dev/memcg/system <span class="comment"># cat /proc/cgroups</span></span><br><span class="line"><span class="comment">#subsys_name    hierarchy       num_cgroups     enabled</span></span><br><span class="line">cpu     3       1       1</span><br><span class="line">cpuacct 2       2       1</span><br><span class="line">memory  1       128     1</span><br><span class="line">freezer 0       1       1</span><br><span class="line">debug   0       1       1</span><br></pre></td></tr></table></figure>

<p>memory这个cgroup子系统就一个hierarchy，其id是1，这个hierarchy里包含了128个memcg。</p>
<p>了解下hierarchy:</p>
<blockquote>
<ol start="6">
<li>Hierarchy support</li>
</ol>
<p>The memory controller supports a deep hierarchy and hierarchical accounting.<br>The hierarchy is created by creating the appropriate cgroups in the<br>cgroup filesystem. Consider for example, the following cgroup filesystem<br>hierarchy</p>
<pre><code>          root
        /  |   \   
       /   |    \   
      a    b     c   
                 | \ 
                 |  \
                 d   e   
</code></pre>
<p>In the diagram above, with hierarchical accounting enabled, all memory<br>usage of e, is accounted to its ancestors up until the root (i.e, c and root),<br>that has memory.use_hierarchy enabled. If one of the ancestors goes over its<br>limit, the reclaim algorithm reclaims from the tasks in the ancestor and the<br>children of the ancestor.</p>
</blockquote>
<h2 id="How-to-record"><a href="#How-to-record" class="headerlink" title="How to record"></a>How to record</h2><p>主要通过charge&#x2F;uncharge来记录，文档说明：</p>
<blockquote>
<ol>
<li><p>Charge<br>  a page&#x2F;swp_entry may be charged (usage +&#x3D; PAGE_SIZE) at</p>
<pre><code>mem_cgroup_try_charge()
</code></pre>
</li>
<li><p>Uncharge<br>  a page&#x2F;swp_entry may be uncharged (usage -&#x3D; PAGE_SIZE) by</p>
<pre><code>mem_cgroup_uncharge()
  Called when a page&#39;s refcount goes down to 0.

mem_cgroup_uncharge_swap()
  Called when swp_entry&#39;s refcnt goes down to 0. A charge against swap
  disappears.
</code></pre>
</li>
<li><p>charge-commit-cancel<br>Memcg pages are charged in two steps:<br>        mem_cgroup_try_charge()<br>        mem_cgroup_commit_charge() or mem_cgroup_cancel_charge()<br><br>At try_charge(), there are no flags to say “this page is charged”.<br>at this point, usage +&#x3D; PAGE_SIZE.<br><br>At commit(), the page is associated with the memcg.<br><br>At cancel(), simply usage -&#x3D; PAGE_SIZE.</p>
</li>
</ol>
</blockquote>
<p>对root memcg，<code>mem_cgroup_try_charge</code>就不统计res_counter：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">try_charge</span><span class="params">(<span class="keyword">struct</span> mem_cgroup *memcg, <span class="type">gfp_t</span> gfp_mask,</span></span><br><span class="line"><span class="params">		      <span class="type">unsigned</span> <span class="type">int</span> nr_pages)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> batch = max(CHARGE_BATCH, nr_pages);</span><br><span class="line">	<span class="type">int</span> nr_retries = MEM_CGROUP_RECLAIM_RETRIES;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">mem_over_limit</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">res_counter</span> *<span class="title">fail_res</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr_reclaimed;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> size;</span><br><span class="line">	<span class="type">bool</span> may_swap = <span class="literal">true</span>;</span><br><span class="line">	<span class="type">bool</span> drained = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mem_cgroup_is_root(memcg))</span><br><span class="line">		<span class="keyword">goto</span> done; <span class="comment">// tj: if root memcg, not record for res_counter</span></span><br><span class="line">...</span><br><span class="line">done:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cancel charge：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cancel_charge</span><span class="params">(<span class="keyword">struct</span> mem_cgroup *memcg, <span class="type">unsigned</span> <span class="type">int</span> nr_pages)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> bytes = nr_pages * PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mem_cgroup_is_root(memcg))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	res_counter_uncharge(&amp;memcg-&gt;res, bytes);</span><br><span class="line">	<span class="keyword">if</span> (do_swap_account)</span><br><span class="line">		res_counter_uncharge(&amp;memcg-&gt;memsw, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>so non root memcg和root memcg是分开统计的，具体实现后面再看。</p>
<p>那什么时候去统计了，比如增加a page到page cache里时会try charge。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li>kernel3.18&#x2F;Documentation&#x2F;cgroups&#x2F;memory.txt</li>
<li>kernel3.18&#x2F;Documentation&#x2F;cgroups&#x2F;memcg_test.txt</li>
</ul>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>版权声明：</span>本站所有文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明原文链接！</p></div><br><div class="tags"><a href="/tags/memcg"><i class="fa fa-tag">memcg</i></a></div><div class="post-nav"><a class="pre" href="/why-not-free-space-when-deleting-on-sdcardfs.html">SDCardFS: 删除文件后空间未释放问题分析</a><a class="next" href="/analyze-lmk-under-android-go.html">Android Go lowmemorykiller分析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/kworker-sched-la-stat.html">kworker 调度延迟性能测试和统计</a></li><li class="post-list-item"><a class="post-list-link" href="/implement-erofs-fragment-dedupe.html">转：EROFS 碎片去重实践</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-enable-kasan-in-ubuntu-18-04-for-x86_64.html">How to enable KASAN in Ubuntu 18.04 for X86_64</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-analyze-segmentation-fault-for-non-install-package-in-ubuntu.html">如何分析 Linux user space's segmentation fault</a></li><li class="post-list-item"><a class="post-list-link" href="/prepare-fragment-dedupe-in-erofs.html">EROFS 碎片去重准备</a></li><li class="post-list-item"><a class="post-list-link" href="/good-naming-in-programming.html">优秀代码命名法</a></li><li class="post-list-item"><a class="post-list-link" href="/erofs-compressed-data-deduplication.html">EROFS 压缩去重分析</a></li><li class="post-list-item"><a class="post-list-link" href="/analyze-fscache-cookie-code.html">转：浅析 Linux FS-Cache</a></li><li class="post-list-item"><a class="post-list-link" href="/how-to-let-bluetooth-work-under-armbian-kodi-for-rockpi4b-within-metal-case.html">Rockpi4b Armbian Kodi 终于能使用蓝牙了</a></li><li class="post-list-item"><a class="post-list-link" href="/erofs-ztailpacking-explain.html">转：EROFS ztailpacking 特性实现详解</a></li></ul></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arm/">ARM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dd/">Device Driver</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fs/">File System</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iot/">IoT</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/msm/">MSM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mm/">Memory Management</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/perf/">Performance</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">Security</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/stab/">Stability</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">Tools</a><span class="category-list-count">17</span></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">TJ的技术博客.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>